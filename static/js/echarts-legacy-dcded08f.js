System.register([],(function(t,e){"use strict";return{execute:function(){t({i:
/**
             * @param opts.devicePixelRatio Use window.devicePixelRatio by default
             * @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.
             * @param opts.width Use clientWidth of the input `dom` by default.
             *        Can be 'auto' (the same as null/undefined)
             * @param opts.height Use clientHeight of the input `dom` by default.
             *        Can be 'auto' (the same as null/undefined)
             * @param opts.locale Specify the locale.
             * @param opts.useDirtyRect Enable dirty rectangle rendering or not.
             */
function(t,e,n){var i=!(n&&n.ssr);if(i){var r=function(t){return Im[function(t,e){return t.getAttribute?t.getAttribute(e):t[e]}(t,Dm)]}
/**
             * Register theme
             */(t);if(r)return r}var o=new gm(t,e,n);return o.id="ec_"+Cm++,Im[o.id]=o,i&&Do(t,Dm,o.id),hm(o),Ev.trigger("afterinit",o),o},r:Vm});
/*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
/* global Reflect, Promise */var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])},e(t,n)};function n(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function i(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(i.prototype=n.prototype,new i)}var i=function(){this.firefox=!1,this.ie=!1,this.edge=!1,this.newEdge=!1,this.weChat=!1},r=new function(){this.browser=new i,this.node=!1,this.wxa=!1,this.worker=!1,this.svgSupported=!1,this.touchEventsSupported=!1,this.pointerEventsSupported=!1,this.domSupported=!1,this.transformSupported=!1,this.transform3dSupported=!1,this.hasGlobalWindow="undefined"!=typeof window};"object"==typeof wx&&"function"==typeof wx.getSystemInfoSync?(r.wxa=!0,r.touchEventsSupported=!0):"undefined"==typeof document&&"undefined"!=typeof self?r.worker=!0:"undefined"==typeof navigator?(r.node=!0,r.svgSupported=!0):function(t,e){var n=e.browser,i=t.match(/Firefox\/([\d.]+)/),r=t.match(/MSIE\s([\d.]+)/)||t.match(/Trident\/.+?rv:(([\d.]+))/),o=t.match(/Edge?\/([\d.]+)/),a=/micromessenger/i.test(t);i&&(n.firefox=!0,n.version=i[1]),r&&(n.ie=!0,n.version=r[1]),o&&(n.edge=!0,n.version=o[1],n.newEdge=+o[1].split(".")[0]>18),a&&(n.weChat=!0),e.svgSupported="undefined"!=typeof SVGRect,e.touchEventsSupported="ontouchstart"in window&&!n.ie&&!n.edge,e.pointerEventsSupported="onpointerdown"in window&&(n.edge||n.ie&&+n.version>=11),e.domSupported="undefined"!=typeof document;var s=document.documentElement.style;e.transform3dSupported=(n.ie&&"transition"in s||n.edge||"WebKitCSSMatrix"in window&&"m11"in new WebKitCSSMatrix||"MozPerspective"in s)&&!("OTransition"in s),e.transformSupported=e.transform3dSupported||n.ie&&+n.version>=9}(navigator.userAgent,r);const o=r;var a,s,l="sans-serif",u="12px "+l,h=function(t){var e={};if("undefined"==typeof JSON)return e;for(var n=0;n<t.length;n++){var i=String.fromCharCode(n+32),r=(t.charCodeAt(n)-20)/100;e[i]=r}return e}("007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"),c={createCanvas:function(){return"undefined"!=typeof document&&document.createElement("canvas")},measureText:function(t,e){if(!a){var n=c.createCanvas();a=n&&n.getContext("2d")}if(a)return s!==e&&(s=a.font=e||u),a.measureText(t);t=t||"";var i=/(\d+)px/.exec(e=e||u),r=i&&+i[1]||12,o=0;if(e.indexOf("mono")>=0)o=r*t.length;else for(var l=0;l<t.length;l++){var p=h[t[l]];o+=null==p?r:p*r}return{width:o}},loadImage:function(t,e,n){var i=new Image;return i.onload=e,i.onerror=n,i.src=t,i}},p=E(["Function","RegExp","Date","Error","CanvasGradient","CanvasPattern","Image","Canvas"],(function(t,e){return t["[object "+e+"]"]=!0,t}),{}),d=E(["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64"],(function(t,e){return t["[object "+e+"Array]"]=!0,t}),{}),f=Object.prototype.toString,g=Array.prototype,y=g.forEach,v=g.filter,m=g.slice,x=g.map,_=function(){}.constructor,b=_?_.prototype:null,w="__proto__",S=2311;function M(){return S++}function I(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e]}function T(t){if(null==t||"object"!=typeof t)return t;var e=t,n=f.call(t);if("[object Array]"===n){if(!st(t)){e=[];for(var i=0,r=t.length;i<r;i++)e[i]=T(t[i])}}else if(d[n]){if(!st(t)){var o=t.constructor;if(o.from)e=o.from(t);else for(e=new o(t.length),i=0,r=t.length;i<r;i++)e[i]=t[i]}}else if(!p[n]&&!st(t)&&!q(t))for(var a in e={},t)t.hasOwnProperty(a)&&a!==w&&(e[a]=T(t[a]));return e}function C(t,e,n){if(!U(e)||!U(t))return n?T(e):t;for(var i in e)if(e.hasOwnProperty(i)&&i!==w){var r=t[i],o=e[i];!U(o)||!U(r)||G(o)||G(r)||q(o)||q(r)||Z(o)||Z(r)||st(o)||st(r)?!n&&i in t||(t[i]=T(e[i])):C(r,o,n)}return t}function D(t,e){for(var n=t[0],i=1,r=t.length;i<r;i++)n=C(n,t[i],e);return n}function A(t,e){if(Object.assign)Object.assign(t,e);else for(var n in e)e.hasOwnProperty(n)&&n!==w&&(t[n]=e[n]);return t}function k(t,e,n){for(var i=V(e),r=0;r<i.length;r++){var o=i[r];(n?null!=e[o]:null==t[o])&&(t[o]=e[o])}return t}function L(t,e){if(t){if(t.indexOf)return t.indexOf(e);for(var n=0,i=t.length;n<i;n++)if(t[n]===e)return n}return-1}function P(t,e,n){if(t="prototype"in t?t.prototype:t,e="prototype"in e?e.prototype:e,Object.getOwnPropertyNames)for(var i=Object.getOwnPropertyNames(e),r=0;r<i.length;r++){var o=i[r];"constructor"!==o&&(n?null!=e[o]:null==t[o])&&(t[o]=e[o])}else k(t,e,n)}function O(t){return!!t&&"string"!=typeof t&&"number"==typeof t.length}function R(t,e,n){if(t&&e)if(t.forEach&&t.forEach===y)t.forEach(e,n);else if(t.length===+t.length)for(var i=0,r=t.length;i<r;i++)e.call(n,t[i],i,t);else for(var o in t)t.hasOwnProperty(o)&&e.call(n,t[o],o,t)}function N(t,e,n){if(!t)return[];if(!e)return et(t);if(t.map&&t.map===x)return t.map(e,n);for(var i=[],r=0,o=t.length;r<o;r++)i.push(e.call(n,t[r],r,t));return i}function E(t,e,n,i){if(t&&e){for(var r=0,o=t.length;r<o;r++)n=e.call(i,n,t[r],r,t);return n}}function z(t,e,n){if(!t)return[];if(!e)return et(t);if(t.filter&&t.filter===v)return t.filter(e,n);for(var i=[],r=0,o=t.length;r<o;r++)e.call(n,t[r],r,t)&&i.push(t[r]);return i}function V(t){if(!t)return[];if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e}var B=b&&W(b.bind)?b.call.bind(b.bind):function(t,e){for(var n=[],i=2;i<arguments.length;i++)n[i-2]=arguments[i];return function(){return t.apply(e,n.concat(m.call(arguments)))}};function F(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];return function(){return t.apply(this,e.concat(m.call(arguments)))}}function G(t){return Array.isArray?Array.isArray(t):"[object Array]"===f.call(t)}function W(t){return"function"==typeof t}function H(t){return"string"==typeof t}function Y(t){return"[object String]"===f.call(t)}function X(t){return"number"==typeof t}function U(t){var e=typeof t;return"function"===e||!!t&&"object"===e}function Z(t){return!!p[f.call(t)]}function j(t){return!!d[f.call(t)]}function q(t){return"object"==typeof t&&"number"==typeof t.nodeType&&"object"==typeof t.ownerDocument}function K(t){return null!=t.colorStops}function $(t){return t!=t}function J(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];for(var n=0,i=t.length;n<i;n++)if(null!=t[n])return t[n]}function Q(t,e){return null!=t?t:e}function tt(t,e,n){return null!=t?t:null!=e?e:n}function et(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];return m.apply(t,e)}function nt(t){if("number"==typeof t)return[t,t,t,t];var e=t.length;return 2===e?[t[0],t[1],t[0],t[1]]:3===e?[t[0],t[1],t[2],t[1]]:t}function it(t,e){if(!t)throw new Error(e)}function rt(t){return null==t?null:"function"==typeof t.trim?t.trim():t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}var ot="__ec_primitive__";function at(t){t[ot]=!0}function st(t){return t[ot]}var lt=function(){function t(){this.data={}}return t.prototype.delete=function(t){var e=this.has(t);return e&&delete this.data[t],e},t.prototype.has=function(t){return this.data.hasOwnProperty(t)},t.prototype.get=function(t){return this.data[t]},t.prototype.set=function(t,e){return this.data[t]=e,this},t.prototype.keys=function(){return V(this.data)},t.prototype.forEach=function(t){var e=this.data;for(var n in e)e.hasOwnProperty(n)&&t(e[n],n)},t}(),ut="function"==typeof Map,ht=function(){function t(e){var n=G(e);this.data=ut?new Map:new lt;var i=this;function r(t,e){n?i.set(t,e):i.set(e,t)}e instanceof t?e.each(r):e&&R(e,r)}return t.prototype.hasKey=function(t){return this.data.has(t)},t.prototype.get=function(t){return this.data.get(t)},t.prototype.set=function(t,e){return this.data.set(t,e),e},t.prototype.each=function(t,e){this.data.forEach((function(n,i){t.call(e,n,i)}))},t.prototype.keys=function(){var t=this.data.keys();return ut?Array.from(t):t},t.prototype.removeKey=function(t){this.data.delete(t)},t}();function ct(t){return new ht(t)}function pt(t,e){for(var n=new t.constructor(t.length+e.length),i=0;i<t.length;i++)n[i]=t[i];var r=t.length;for(i=0;i<e.length;i++)n[i+r]=e[i];return n}function dt(t,e){var n;if(Object.create)n=Object.create(t);else{var i=function(){};i.prototype=t,n=new i}return e&&A(n,e),n}function ft(t){var e=t.style;e.webkitUserSelect="none",e.userSelect="none",e.webkitTapHighlightColor="rgba(0,0,0,0)",e["-webkit-touch-callout"]="none"}function gt(t,e){return t.hasOwnProperty(e)}function yt(){}var vt=180/Math.PI;function mt(t,e){return null==t&&(t=0),null==e&&(e=0),[t,e]}function xt(t,e){return t[0]=e[0],t[1]=e[1],t}function _t(t){return[t[0],t[1]]}function bt(t,e,n){return t[0]=e,t[1]=n,t}function wt(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t}function St(t,e,n,i){return t[0]=e[0]+n[0]*i,t[1]=e[1]+n[1]*i,t}function Mt(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t}function It(t){return Math.sqrt(function(t){return t[0]*t[0]+t[1]*t[1]}(t))}function Tt(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t}function Ct(t,e){var n=It(e);return 0===n?(t[0]=0,t[1]=0):(t[0]=e[0]/n,t[1]=e[1]/n),t}function Dt(t,e){return Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1]))}var At=Dt,kt=function(t,e){return(t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])};function Lt(t,e,n,i){return t[0]=e[0]+i*(n[0]-e[0]),t[1]=e[1]+i*(n[1]-e[1]),t}function Pt(t,e,n){var i=e[0],r=e[1];return t[0]=n[0]*i+n[2]*r+n[4],t[1]=n[1]*i+n[3]*r+n[5],t}function Ot(t,e,n){return t[0]=Math.min(e[0],n[0]),t[1]=Math.min(e[1],n[1]),t}function Rt(t,e,n){return t[0]=Math.max(e[0],n[0]),t[1]=Math.max(e[1],n[1]),t}var Nt=function(t,e){this.target=t,this.topTarget=e&&e.topTarget},Et=function(){function t(t){this.handler=t,t.on("mousedown",this._dragStart,this),t.on("mousemove",this._drag,this),t.on("mouseup",this._dragEnd,this)}return t.prototype._dragStart=function(t){for(var e=t.target;e&&!e.draggable;)e=e.parent||e.__hostTarget;e&&(this._draggingTarget=e,e.dragging=!0,this._x=t.offsetX,this._y=t.offsetY,this.handler.dispatchToElement(new Nt(e,t),"dragstart",t.event))},t.prototype._drag=function(t){var e=this._draggingTarget;if(e){var n=t.offsetX,i=t.offsetY,r=n-this._x,o=i-this._y;this._x=n,this._y=i,e.drift(r,o,t),this.handler.dispatchToElement(new Nt(e,t),"drag",t.event);var a=this.handler.findHover(n,i,e).target,s=this._dropTarget;this._dropTarget=a,e!==a&&(s&&a!==s&&this.handler.dispatchToElement(new Nt(s,t),"dragleave",t.event),a&&a!==s&&this.handler.dispatchToElement(new Nt(a,t),"dragenter",t.event))}},t.prototype._dragEnd=function(t){var e=this._draggingTarget;e&&(e.dragging=!1),this.handler.dispatchToElement(new Nt(e,t),"dragend",t.event),this._dropTarget&&this.handler.dispatchToElement(new Nt(this._dropTarget,t),"drop",t.event),this._draggingTarget=null,this._dropTarget=null},t}();const zt=Et;var Vt=function(){function t(t){t&&(this._$eventProcessor=t)}return t.prototype.on=function(t,e,n,i){this._$handlers||(this._$handlers={});var r=this._$handlers;if("function"==typeof e&&(i=n,n=e,e=null),!n||!t)return this;var o=this._$eventProcessor;null!=e&&o&&o.normalizeQuery&&(e=o.normalizeQuery(e)),r[t]||(r[t]=[]);for(var a=0;a<r[t].length;a++)if(r[t][a].h===n)return this;var s={h:n,query:e,ctx:i||this,callAtLast:n.zrEventfulCallAtLast},l=r[t].length-1,u=r[t][l];return u&&u.callAtLast?r[t].splice(l,0,s):r[t].push(s),this},t.prototype.isSilent=function(t){var e=this._$handlers;return!e||!e[t]||!e[t].length},t.prototype.off=function(t,e){var n=this._$handlers;if(!n)return this;if(!t)return this._$handlers={},this;if(e){if(n[t]){for(var i=[],r=0,o=n[t].length;r<o;r++)n[t][r].h!==e&&i.push(n[t][r]);n[t]=i}n[t]&&0===n[t].length&&delete n[t]}else delete n[t];return this},t.prototype.trigger=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(!this._$handlers)return this;var i=this._$handlers[t],r=this._$eventProcessor;if(i)for(var o=e.length,a=i.length,s=0;s<a;s++){var l=i[s];if(!r||!r.filter||null==l.query||r.filter(t,l.query))switch(o){case 0:l.h.call(l.ctx);break;case 1:l.h.call(l.ctx,e[0]);break;case 2:l.h.call(l.ctx,e[0],e[1]);break;default:l.h.apply(l.ctx,e)}}return r&&r.afterTrigger&&r.afterTrigger(t),this},t.prototype.triggerWithContext=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(!this._$handlers)return this;var i=this._$handlers[t],r=this._$eventProcessor;if(i)for(var o=e.length,a=e[o-1],s=i.length,l=0;l<s;l++){var u=i[l];if(!r||!r.filter||null==u.query||r.filter(t,u.query))switch(o){case 0:u.h.call(a);break;case 1:u.h.call(a,e[0]);break;case 2:u.h.call(a,e[0],e[1]);break;default:u.h.apply(a,e.slice(1,o-1))}}return r&&r.afterTrigger&&r.afterTrigger(t),this},t}();const Bt=Vt;var Ft=Math.log(2);function Gt(t,e,n,i,r,o){var a=i+"-"+r,s=t.length;if(o.hasOwnProperty(a))return o[a];if(1===e){var l=Math.round(Math.log((1<<s)-1&~r)/Ft);return t[n][l]}for(var u=i|1<<n,h=n+1;i&1<<h;)h++;for(var c=0,p=0,d=0;p<s;p++){var f=1<<p;f&r||(c+=(d%2?-1:1)*t[n][p]*Gt(t,e-1,h,u,r|f,o),d++)}return o[a]=c,c}function Wt(t,e){var n=[[t[0],t[1],1,0,0,0,-e[0]*t[0],-e[0]*t[1]],[0,0,0,t[0],t[1],1,-e[1]*t[0],-e[1]*t[1]],[t[2],t[3],1,0,0,0,-e[2]*t[2],-e[2]*t[3]],[0,0,0,t[2],t[3],1,-e[3]*t[2],-e[3]*t[3]],[t[4],t[5],1,0,0,0,-e[4]*t[4],-e[4]*t[5]],[0,0,0,t[4],t[5],1,-e[5]*t[4],-e[5]*t[5]],[t[6],t[7],1,0,0,0,-e[6]*t[6],-e[6]*t[7]],[0,0,0,t[6],t[7],1,-e[7]*t[6],-e[7]*t[7]]],i={},r=Gt(n,8,0,0,0,i);if(0!==r){for(var o=[],a=0;a<8;a++)for(var s=0;s<8;s++)null==o[s]&&(o[s]=0),o[s]+=((a+s)%2?-1:1)*Gt(n,7,0===a?1:0,1<<a,1<<s,i)/r*e[a];return function(t,e,n){var i=e*o[6]+n*o[7]+1;t[0]=(e*o[0]+n*o[1]+o[2])/i,t[1]=(e*o[3]+n*o[4]+o[5])/i}}}var Ht="___zrEVENTSAVED",Yt=[];function Xt(t,e,n,i,r){if(e.getBoundingClientRect&&o.domSupported&&!Ut(e)){var a=e[Ht]||(e[Ht]={}),s=function(t,e){var n=e.markers;if(n)return n;n=e.markers=[];for(var i=["left","right"],r=["top","bottom"],o=0;o<4;o++){var a=document.createElement("div"),s=o%2,l=(o>>1)%2;a.style.cssText=["position: absolute","visibility: hidden","padding: 0","margin: 0","border-width: 0","user-select: none","width:0","height:0",i[s]+":0",r[l]+":0",i[1-s]+":auto",r[1-l]+":auto",""].join("!important;"),t.appendChild(a),n.push(a)}return n}(e,a),l=function(t,e,n){for(var i=n?"invTrans":"trans",r=e[i],o=e.srcCoords,a=[],s=[],l=!0,u=0;u<4;u++){var h=t[u].getBoundingClientRect(),c=2*u,p=h.left,d=h.top;a.push(p,d),l=l&&o&&p===o[c]&&d===o[c+1],s.push(t[u].offsetLeft,t[u].offsetTop)}return l&&r?r:(e.srcCoords=a,e[i]=n?Wt(s,a):Wt(a,s))}(s,a,r);if(l)return l(t,n,i),!0}return!1}function Ut(t){return"CANVAS"===t.nodeName.toUpperCase()}var Zt=/([&<>"'])/g,jt={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};function qt(t){return null==t?"":(t+"").replace(Zt,(function(t,e){return jt[e]}))}var Kt=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,$t=[],Jt=o.browser.firefox&&+o.browser.version.split(".")[0]<39;function Qt(t,e,n,i){return n=n||{},i?te(t,e,n):Jt&&null!=e.layerX&&e.layerX!==e.offsetX?(n.zrX=e.layerX,n.zrY=e.layerY):null!=e.offsetX?(n.zrX=e.offsetX,n.zrY=e.offsetY):te(t,e,n),n}function te(t,e,n){if(o.domSupported&&t.getBoundingClientRect){var i=e.clientX,r=e.clientY;if(Ut(t)){var a=t.getBoundingClientRect();return n.zrX=i-a.left,void(n.zrY=r-a.top)}if(Xt($t,t,i,r))return n.zrX=$t[0],void(n.zrY=$t[1])}n.zrX=n.zrY=0}function ee(t){return t||window.event}function ne(t,e,n){if(null!=(e=ee(e)).zrX)return e;var i=e.type;if(i&&i.indexOf("touch")>=0){var r="touchend"!==i?e.targetTouches[0]:e.changedTouches[0];r&&Qt(t,r,e,n)}else{Qt(t,e,e,n);var o=function(t){var e=t.wheelDelta;if(e)return e;var n=t.deltaX,i=t.deltaY;return null==n||null==i?e:3*(0!==i?Math.abs(i):Math.abs(n))*(i>0?-1:i<0?1:n>0?-1:1)}(e);e.zrDelta=o?o/120:-(e.detail||0)/3}var a=e.button;return null==e.which&&void 0!==a&&Kt.test(e.type)&&(e.which=1&a?1:2&a?3:4&a?2:0),e}function ie(t,e,n,i){t.addEventListener(e,n,i)}var re=function(t){t.preventDefault(),t.stopPropagation(),t.cancelBubble=!0};function oe(t){return 2===t.which||3===t.which}var ae=function(){function t(){this._track=[]}return t.prototype.recognize=function(t,e,n){return this._doTrack(t,e,n),this._recognize(t)},t.prototype.clear=function(){return this._track.length=0,this},t.prototype._doTrack=function(t,e,n){var i=t.touches;if(i){for(var r={points:[],touches:[],target:e,event:t},o=0,a=i.length;o<a;o++){var s=i[o],l=Qt(n,s,{});r.points.push([l.zrX,l.zrY]),r.touches.push(s)}this._track.push(r)}},t.prototype._recognize=function(t){for(var e in le)if(le.hasOwnProperty(e)){var n=le[e](this._track,t);if(n)return n}},t}();function se(t){var e=t[1][0]-t[0][0],n=t[1][1]-t[0][1];return Math.sqrt(e*e+n*n)}var le={pinch:function(t,e){var n=t.length;if(n){var i,r=(t[n-1]||{}).points,o=(t[n-2]||{}).points||r;if(o&&o.length>1&&r&&r.length>1){var a=se(r)/se(o);!isFinite(a)&&(a=1),e.pinchScale=a;var s=[((i=r)[0][0]+i[1][0])/2,(i[0][1]+i[1][1])/2];return e.pinchX=s[0],e.pinchY=s[1],{type:"pinch",target:t[0].target,event:e}}}}};function ue(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function he(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function ce(t,e,n){var i=e[0]*n[0]+e[2]*n[1],r=e[1]*n[0]+e[3]*n[1],o=e[0]*n[2]+e[2]*n[3],a=e[1]*n[2]+e[3]*n[3],s=e[0]*n[4]+e[2]*n[5]+e[4],l=e[1]*n[4]+e[3]*n[5]+e[5];return t[0]=i,t[1]=r,t[2]=o,t[3]=a,t[4]=s,t[5]=l,t}function pe(t,e,n){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4]+n[0],t[5]=e[5]+n[1],t}function de(t,e,n){var i=e[0],r=e[2],o=e[4],a=e[1],s=e[3],l=e[5],u=Math.sin(n),h=Math.cos(n);return t[0]=i*h+a*u,t[1]=-i*u+a*h,t[2]=r*h+s*u,t[3]=-r*u+h*s,t[4]=h*o+u*l,t[5]=h*l-u*o,t}function fe(t,e,n){var i=n[0],r=n[1];return t[0]=e[0]*i,t[1]=e[1]*r,t[2]=e[2]*i,t[3]=e[3]*r,t[4]=e[4]*i,t[5]=e[5]*r,t}function ge(t,e){var n=e[0],i=e[2],r=e[4],o=e[1],a=e[3],s=e[5],l=n*a-o*i;return l?(l=1/l,t[0]=a*l,t[1]=-o*l,t[2]=-i*l,t[3]=n*l,t[4]=(i*s-a*r)*l,t[5]=(o*r-n*s)*l,t):null}var ye=function(){function t(t,e){this.x=t||0,this.y=e||0}return t.prototype.copy=function(t){return this.x=t.x,this.y=t.y,this},t.prototype.clone=function(){return new t(this.x,this.y)},t.prototype.set=function(t,e){return this.x=t,this.y=e,this},t.prototype.equal=function(t){return t.x===this.x&&t.y===this.y},t.prototype.add=function(t){return this.x+=t.x,this.y+=t.y,this},t.prototype.scale=function(t){this.x*=t,this.y*=t},t.prototype.scaleAndAdd=function(t,e){this.x+=t.x*e,this.y+=t.y*e},t.prototype.sub=function(t){return this.x-=t.x,this.y-=t.y,this},t.prototype.dot=function(t){return this.x*t.x+this.y*t.y},t.prototype.len=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},t.prototype.lenSquare=function(){return this.x*this.x+this.y*this.y},t.prototype.normalize=function(){var t=this.len();return this.x/=t,this.y/=t,this},t.prototype.distance=function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},t.prototype.distanceSquare=function(t){var e=this.x-t.x,n=this.y-t.y;return e*e+n*n},t.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},t.prototype.transform=function(t){if(t){var e=this.x,n=this.y;return this.x=t[0]*e+t[2]*n+t[4],this.y=t[1]*e+t[3]*n+t[5],this}},t.prototype.toArray=function(t){return t[0]=this.x,t[1]=this.y,t},t.prototype.fromArray=function(t){this.x=t[0],this.y=t[1]},t.set=function(t,e,n){t.x=e,t.y=n},t.copy=function(t,e){t.x=e.x,t.y=e.y},t.len=function(t){return Math.sqrt(t.x*t.x+t.y*t.y)},t.lenSquare=function(t){return t.x*t.x+t.y*t.y},t.dot=function(t,e){return t.x*e.x+t.y*e.y},t.add=function(t,e,n){t.x=e.x+n.x,t.y=e.y+n.y},t.sub=function(t,e,n){t.x=e.x-n.x,t.y=e.y-n.y},t.scale=function(t,e,n){t.x=e.x*n,t.y=e.y*n},t.scaleAndAdd=function(t,e,n,i){t.x=e.x+n.x*i,t.y=e.y+n.y*i},t.lerp=function(t,e,n,i){var r=1-i;t.x=r*e.x+i*n.x,t.y=r*e.y+i*n.y},t}();const ve=ye;var me=Math.min,xe=Math.max,_e=new ve,be=new ve,we=new ve,Se=new ve,Me=new ve,Ie=new ve,Te=function(){function t(t,e,n,i){n<0&&(t+=n,n=-n),i<0&&(e+=i,i=-i),this.x=t,this.y=e,this.width=n,this.height=i}return t.prototype.union=function(t){var e=me(t.x,this.x),n=me(t.y,this.y);isFinite(this.x)&&isFinite(this.width)?this.width=xe(t.x+t.width,this.x+this.width)-e:this.width=t.width,isFinite(this.y)&&isFinite(this.height)?this.height=xe(t.y+t.height,this.y+this.height)-n:this.height=t.height,this.x=e,this.y=n},t.prototype.applyTransform=function(e){t.applyTransform(this,this,e)},t.prototype.calculateTransform=function(t){var e=this,n=t.width/e.width,i=t.height/e.height,r=[1,0,0,1,0,0];return pe(r,r,[-e.x,-e.y]),fe(r,r,[n,i]),pe(r,r,[t.x,t.y]),r},t.prototype.intersect=function(e,n){if(!e)return!1;e instanceof t||(e=t.create(e));var i=this,r=i.x,o=i.x+i.width,a=i.y,s=i.y+i.height,l=e.x,u=e.x+e.width,h=e.y,c=e.y+e.height,p=!(o<l||u<r||s<h||c<a);if(n){var d=1/0,f=0,g=Math.abs(o-l),y=Math.abs(u-r),v=Math.abs(s-h),m=Math.abs(c-a),x=Math.min(g,y),_=Math.min(v,m);o<l||u<r?x>f&&(f=x,g<y?ve.set(Ie,-g,0):ve.set(Ie,y,0)):x<d&&(d=x,g<y?ve.set(Me,g,0):ve.set(Me,-y,0)),s<h||c<a?_>f&&(f=_,v<m?ve.set(Ie,0,-v):ve.set(Ie,0,m)):x<d&&(d=x,v<m?ve.set(Me,0,v):ve.set(Me,0,-m))}return n&&ve.copy(n,p?Me:Ie),p},t.prototype.contain=function(t,e){var n=this;return t>=n.x&&t<=n.x+n.width&&e>=n.y&&e<=n.y+n.height},t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},t.prototype.copy=function(e){t.copy(this,e)},t.prototype.plain=function(){return{x:this.x,y:this.y,width:this.width,height:this.height}},t.prototype.isFinite=function(){return isFinite(this.x)&&isFinite(this.y)&&isFinite(this.width)&&isFinite(this.height)},t.prototype.isZero=function(){return 0===this.width||0===this.height},t.create=function(e){return new t(e.x,e.y,e.width,e.height)},t.copy=function(t,e){t.x=e.x,t.y=e.y,t.width=e.width,t.height=e.height},t.applyTransform=function(e,n,i){if(i){if(i[1]<1e-5&&i[1]>-1e-5&&i[2]<1e-5&&i[2]>-1e-5){var r=i[0],o=i[3],a=i[4],s=i[5];return e.x=n.x*r+a,e.y=n.y*o+s,e.width=n.width*r,e.height=n.height*o,e.width<0&&(e.x+=e.width,e.width=-e.width),void(e.height<0&&(e.y+=e.height,e.height=-e.height))}_e.x=we.x=n.x,_e.y=Se.y=n.y,be.x=Se.x=n.x+n.width,be.y=we.y=n.y+n.height,_e.transform(i),Se.transform(i),be.transform(i),we.transform(i),e.x=me(_e.x,be.x,we.x,Se.x),e.y=me(_e.y,be.y,we.y,Se.y);var l=xe(_e.x,be.x,we.x,Se.x),u=xe(_e.y,be.y,we.y,Se.y);e.width=l-e.x,e.height=u-e.y}else e!==n&&t.copy(e,n)},t}();const Ce=Te;var De="silent";function Ae(){re(this.event)}var ke=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.handler=null,e}return n(e,t),e.prototype.dispose=function(){},e.prototype.setCursor=function(){},e}(Bt),Le=function(t,e){this.x=t,this.y=e},Pe=["click","dblclick","mousewheel","mouseout","mouseup","mousedown","mousemove","contextmenu"],Oe=new Ce(0,0,0,0),Re=function(t){function e(e,n,i,r,o){var a=t.call(this)||this;return a._hovered=new Le(0,0),a.storage=e,a.painter=n,a.painterRoot=r,a._pointerSize=o,i=i||new ke,a.proxy=null,a.setHandlerProxy(i),a._draggingMgr=new zt(a),a}return n(e,t),e.prototype.setHandlerProxy=function(t){this.proxy&&this.proxy.dispose(),t&&(R(Pe,(function(e){t.on&&t.on(e,this[e],this)}),this),t.handler=this),this.proxy=t},e.prototype.mousemove=function(t){var e=t.zrX,n=t.zrY,i=ze(this,e,n),r=this._hovered,o=r.target;o&&!o.__zr&&(o=(r=this.findHover(r.x,r.y)).target);var a=this._hovered=i?new Le(e,n):this.findHover(e,n),s=a.target,l=this.proxy;l.setCursor&&l.setCursor(s?s.cursor:"default"),o&&s!==o&&this.dispatchToElement(r,"mouseout",t),this.dispatchToElement(a,"mousemove",t),s&&s!==o&&this.dispatchToElement(a,"mouseover",t)},e.prototype.mouseout=function(t){var e=t.zrEventControl;"only_globalout"!==e&&this.dispatchToElement(this._hovered,"mouseout",t),"no_globalout"!==e&&this.trigger("globalout",{type:"globalout",event:t})},e.prototype.resize=function(){this._hovered=new Le(0,0)},e.prototype.dispatch=function(t,e){var n=this[t];n&&n.call(this,e)},e.prototype.dispose=function(){this.proxy.dispose(),this.storage=null,this.proxy=null,this.painter=null},e.prototype.setCursorStyle=function(t){var e=this.proxy;e.setCursor&&e.setCursor(t)},e.prototype.dispatchToElement=function(t,e,n){var i=(t=t||{}).target;if(!i||!i.silent){for(var r="on"+e,o=function(t,e,n){return{type:t,event:n,target:e.target,topTarget:e.topTarget,cancelBubble:!1,offsetX:n.zrX,offsetY:n.zrY,gestureEvent:n.gestureEvent,pinchX:n.pinchX,pinchY:n.pinchY,pinchScale:n.pinchScale,wheelDelta:n.zrDelta,zrByTouch:n.zrByTouch,which:n.which,stop:Ae}}(e,t,n);i&&(i[r]&&(o.cancelBubble=!!i[r].call(i,o)),i.trigger(e,o),i=i.__hostTarget?i.__hostTarget:i.parent,!o.cancelBubble););o.cancelBubble||(this.trigger(e,o),this.painter&&this.painter.eachOtherLayer&&this.painter.eachOtherLayer((function(t){"function"==typeof t[r]&&t[r].call(t,o),t.trigger&&t.trigger(e,o)})))}},e.prototype.findHover=function(t,e,n){var i=this.storage.getDisplayList(),r=new Le(t,e);if(Ee(i,r,t,e,n),this._pointerSize&&!r.target){for(var o=[],a=this._pointerSize,s=a/2,l=new Ce(t-s,e-s,a,a),u=i.length-1;u>=0;u--){var h=i[u];h===n||h.ignore||h.ignoreCoarsePointer||h.parent&&h.parent.ignoreCoarsePointer||(Oe.copy(h.getBoundingRect()),h.transform&&Oe.applyTransform(h.transform),Oe.intersect(l)&&o.push(h))}if(o.length)for(var c=Math.PI/12,p=2*Math.PI,d=0;d<s;d+=4)for(var f=0;f<p;f+=c)if(Ee(o,r,t+d*Math.cos(f),e+d*Math.sin(f),n),r.target)return r}return r},e.prototype.processGesture=function(t,e){this._gestureMgr||(this._gestureMgr=new ae);var n=this._gestureMgr;"start"===e&&n.clear();var i=n.recognize(t,this.findHover(t.zrX,t.zrY,null).target,this.proxy.dom);if("end"===e&&n.clear(),i){var r=i.type;t.gestureEvent=r;var o=new Le;o.target=i.target,this.dispatchToElement(o,r,i.event)}},e}(Bt);function Ne(t,e,n){if(t[t.rectHover?"rectContain":"contain"](e,n)){for(var i=t,r=void 0,o=!1;i;){if(i.ignoreClip&&(o=!0),!o){var a=i.getClipPath();if(a&&!a.contain(e,n))return!1;i.silent&&(r=!0)}var s=i.__hostTarget;i=s||i.parent}return!r||De}return!1}function Ee(t,e,n,i,r){for(var o=t.length-1;o>=0;o--){var a=t[o],s=void 0;if(a!==r&&!a.ignore&&(s=Ne(a,n,i))&&(!e.topTarget&&(e.topTarget=a),s!==De)){e.target=a;break}}}function ze(t,e,n){var i=t.painter;return e<0||e>i.getWidth()||n<0||n>i.getHeight()}R(["click","mousedown","mouseup","mousewheel","dblclick","contextmenu"],(function(t){Re.prototype[t]=function(e){var n,i,r=e.zrX,o=e.zrY,a=ze(this,r,o);if("mouseup"===t&&a||(i=(n=this.findHover(r,o)).target),"mousedown"===t)this._downEl=i,this._downPoint=[e.zrX,e.zrY],this._upEl=i;else if("mouseup"===t)this._upEl=i;else if("click"===t){if(this._downEl!==this._upEl||!this._downPoint||At(this._downPoint,[e.zrX,e.zrY])>4)return;this._downPoint=null}this.dispatchToElement(n,t,e)}}));const Ve=Re;function Be(t,e,n,i){var r=e+1;if(r===n)return 1;if(i(t[r++],t[e])<0){for(;r<n&&i(t[r],t[r-1])<0;)r++;!function(t,e,n){for(n--;e<n;){var i=t[e];t[e++]=t[n],t[n--]=i}}(t,e,r)}else for(;r<n&&i(t[r],t[r-1])>=0;)r++;return r-e}function Fe(t,e,n,i,r){for(i===e&&i++;i<n;i++){for(var o,a=t[i],s=e,l=i;s<l;)r(a,t[o=s+l>>>1])<0?l=o:s=o+1;var u=i-s;switch(u){case 3:t[s+3]=t[s+2];case 2:t[s+2]=t[s+1];case 1:t[s+1]=t[s];break;default:for(;u>0;)t[s+u]=t[s+u-1],u--}t[s]=a}}function Ge(t,e,n,i,r,o){var a=0,s=0,l=1;if(o(t,e[n+r])>0){for(s=i-r;l<s&&o(t,e[n+r+l])>0;)a=l,(l=1+(l<<1))<=0&&(l=s);l>s&&(l=s),a+=r,l+=r}else{for(s=r+1;l<s&&o(t,e[n+r-l])<=0;)a=l,(l=1+(l<<1))<=0&&(l=s);l>s&&(l=s);var u=a;a=r-l,l=r-u}for(a++;a<l;){var h=a+(l-a>>>1);o(t,e[n+h])>0?a=h+1:l=h}return l}function We(t,e,n,i,r,o){var a=0,s=0,l=1;if(o(t,e[n+r])<0){for(s=r+1;l<s&&o(t,e[n+r-l])<0;)a=l,(l=1+(l<<1))<=0&&(l=s);l>s&&(l=s);var u=a;a=r-l,l=r-u}else{for(s=i-r;l<s&&o(t,e[n+r+l])>=0;)a=l,(l=1+(l<<1))<=0&&(l=s);l>s&&(l=s),a+=r,l+=r}for(a++;a<l;){var h=a+(l-a>>>1);o(t,e[n+h])<0?l=h:a=h+1}return l}function He(t,e){var n,i,r=7,o=0;t.length;var a=[];function s(s){var l=n[s],u=i[s],h=n[s+1],c=i[s+1];i[s]=u+c,s===o-3&&(n[s+1]=n[s+2],i[s+1]=i[s+2]),o--;var p=We(t[h],t,l,u,0,e);l+=p,0!=(u-=p)&&0!==(c=Ge(t[l+u-1],t,h,c,c-1,e))&&(u<=c?function(n,i,o,s){var l=0;for(l=0;l<i;l++)a[l]=t[n+l];var u=0,h=o,c=n;if(t[c++]=t[h++],0!=--s)if(1!==i){for(var p,d,f,g=r;;){p=0,d=0,f=!1;do{if(e(t[h],a[u])<0){if(t[c++]=t[h++],d++,p=0,0==--s){f=!0;break}}else if(t[c++]=a[u++],p++,d=0,1==--i){f=!0;break}}while((p|d)<g);if(f)break;do{if(0!==(p=We(t[h],a,u,i,0,e))){for(l=0;l<p;l++)t[c+l]=a[u+l];if(c+=p,u+=p,(i-=p)<=1){f=!0;break}}if(t[c++]=t[h++],0==--s){f=!0;break}if(0!==(d=Ge(a[u],t,h,s,0,e))){for(l=0;l<d;l++)t[c+l]=t[h+l];if(c+=d,h+=d,0==(s-=d)){f=!0;break}}if(t[c++]=a[u++],1==--i){f=!0;break}g--}while(p>=7||d>=7);if(f)break;g<0&&(g=0),g+=2}if((r=g)<1&&(r=1),1===i){for(l=0;l<s;l++)t[c+l]=t[h+l];t[c+s]=a[u]}else{if(0===i)throw new Error;for(l=0;l<i;l++)t[c+l]=a[u+l]}}else{for(l=0;l<s;l++)t[c+l]=t[h+l];t[c+s]=a[u]}else for(l=0;l<i;l++)t[c+l]=a[u+l]}(l,u,h,c):function(n,i,o,s){var l=0;for(l=0;l<s;l++)a[l]=t[o+l];var u=n+i-1,h=s-1,c=o+s-1,p=0,d=0;if(t[c--]=t[u--],0!=--i)if(1!==s){for(var f=r;;){var g=0,y=0,v=!1;do{if(e(a[h],t[u])<0){if(t[c--]=t[u--],g++,y=0,0==--i){v=!0;break}}else if(t[c--]=a[h--],y++,g=0,1==--s){v=!0;break}}while((g|y)<f);if(v)break;do{if(0!=(g=i-We(a[h],t,n,i,i-1,e))){for(i-=g,d=1+(c-=g),p=1+(u-=g),l=g-1;l>=0;l--)t[d+l]=t[p+l];if(0===i){v=!0;break}}if(t[c--]=a[h--],1==--s){v=!0;break}if(0!=(y=s-Ge(t[u],a,0,s,s-1,e))){for(s-=y,d=1+(c-=y),p=1+(h-=y),l=0;l<y;l++)t[d+l]=a[p+l];if(s<=1){v=!0;break}}if(t[c--]=t[u--],0==--i){v=!0;break}f--}while(g>=7||y>=7);if(v)break;f<0&&(f=0),f+=2}if((r=f)<1&&(r=1),1===s){for(d=1+(c-=i),p=1+(u-=i),l=i-1;l>=0;l--)t[d+l]=t[p+l];t[c]=a[h]}else{if(0===s)throw new Error;for(p=c-(s-1),l=0;l<s;l++)t[p+l]=a[l]}}else{for(d=1+(c-=i),p=1+(u-=i),l=i-1;l>=0;l--)t[d+l]=t[p+l];t[c]=a[h]}else for(p=c-(s-1),l=0;l<s;l++)t[p+l]=a[l]}(l,u,h,c))}return n=[],i=[],{mergeRuns:function(){for(;o>1;){var t=o-2;if(t>=1&&i[t-1]<=i[t]+i[t+1]||t>=2&&i[t-2]<=i[t]+i[t-1])i[t-1]<i[t+1]&&t--;else if(i[t]>i[t+1])break;s(t)}},forceMergeRuns:function(){for(;o>1;){var t=o-2;t>0&&i[t-1]<i[t+1]&&t--,s(t)}},pushRun:function(t,e){n[o]=t,i[o]=e,o+=1}}}function Ye(t,e,n,i){n||(n=0),i||(i=t.length);var r=i-n;if(!(r<2)){var o=0;if(r<32)Fe(t,n,i,n+(o=Be(t,n,i,e)),e);else{var a=He(t,e),s=function(t){for(var e=0;t>=32;)e|=1&t,t>>=1;return t+e}(r);do{if((o=Be(t,n,i,e))<s){var l=r;l>s&&(l=s),Fe(t,n,n+l,n+o,e),o=l}a.pushRun(n,o),a.mergeRuns(),r-=o,n+=o}while(0!==r);a.forceMergeRuns()}}}var Xe=!1;function Ue(){Xe||(Xe=!0)}function Ze(t,e){return t.zlevel===e.zlevel?t.z===e.z?t.z2-e.z2:t.z-e.z:t.zlevel-e.zlevel}var je=function(){function t(){this._roots=[],this._displayList=[],this._displayListLen=0,this.displayableSortFunc=Ze}return t.prototype.traverse=function(t,e){for(var n=0;n<this._roots.length;n++)this._roots[n].traverse(t,e)},t.prototype.getDisplayList=function(t,e){e=e||!1;var n=this._displayList;return!t&&n.length||this.updateDisplayList(e),n},t.prototype.updateDisplayList=function(t){this._displayListLen=0;for(var e=this._roots,n=this._displayList,i=0,r=e.length;i<r;i++)this._updateAndAddDisplayable(e[i],null,t);n.length=this._displayListLen,Ye(n,Ze)},t.prototype._updateAndAddDisplayable=function(t,e,n){if(!t.ignore||n){t.beforeUpdate(),t.update(),t.afterUpdate();var i=t.getClipPath();if(t.ignoreClip)e=null;else if(i){e=e?e.slice():[];for(var r=i,o=t;r;)r.parent=o,r.updateTransform(),e.push(r),o=r,r=r.getClipPath()}if(t.childrenRef){for(var a=t.childrenRef(),s=0;s<a.length;s++){var l=a[s];t.__dirty&&(l.__dirty|=1),this._updateAndAddDisplayable(l,e,n)}t.__dirty=0}else{var u=t;e&&e.length?u.__clipPaths=e:u.__clipPaths&&u.__clipPaths.length>0&&(u.__clipPaths=[]),isNaN(u.z)&&(Ue(),u.z=0),isNaN(u.z2)&&(Ue(),u.z2=0),isNaN(u.zlevel)&&(Ue(),u.zlevel=0),this._displayList[this._displayListLen++]=u}var h=t.getDecalElement&&t.getDecalElement();h&&this._updateAndAddDisplayable(h,e,n);var c=t.getTextGuideLine();c&&this._updateAndAddDisplayable(c,e,n);var p=t.getTextContent();p&&this._updateAndAddDisplayable(p,e,n)}},t.prototype.addRoot=function(t){t.__zr&&t.__zr.storage===this||this._roots.push(t)},t.prototype.delRoot=function(t){if(t instanceof Array)for(var e=0,n=t.length;e<n;e++)this.delRoot(t[e]);else{var i=L(this._roots,t);i>=0&&this._roots.splice(i,1)}},t.prototype.delAllRoots=function(){this._roots=[],this._displayList=[],this._displayListLen=0},t.prototype.getRoots=function(){return this._roots},t.prototype.dispose=function(){this._displayList=null,this._roots=null},t}();const qe=je,Ke=o.hasGlobalWindow&&(window.requestAnimationFrame&&window.requestAnimationFrame.bind(window)||window.msRequestAnimationFrame&&window.msRequestAnimationFrame.bind(window)||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame)||function(t){return setTimeout(t,16)};var $e={linear:function(t){return t},quadraticIn:function(t){return t*t},quadraticOut:function(t){return t*(2-t)},quadraticInOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)},cubicIn:function(t){return t*t*t},cubicOut:function(t){return--t*t*t+1},cubicInOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},quarticIn:function(t){return t*t*t*t},quarticOut:function(t){return 1- --t*t*t*t},quarticInOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},quinticIn:function(t){return t*t*t*t*t},quinticOut:function(t){return--t*t*t*t*t+1},quinticInOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},sinusoidalIn:function(t){return 1-Math.cos(t*Math.PI/2)},sinusoidalOut:function(t){return Math.sin(t*Math.PI/2)},sinusoidalInOut:function(t){return.5*(1-Math.cos(Math.PI*t))},exponentialIn:function(t){return 0===t?0:Math.pow(1024,t-1)},exponentialOut:function(t){return 1===t?1:1-Math.pow(2,-10*t)},exponentialInOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))},circularIn:function(t){return 1-Math.sqrt(1-t*t)},circularOut:function(t){return Math.sqrt(1- --t*t)},circularInOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},elasticIn:function(t){var e,n=.1;return 0===t?0:1===t?1:(!n||n<1?(n=1,e=.1):e=.4*Math.asin(1/n)/(2*Math.PI),-n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/.4))},elasticOut:function(t){var e,n=.1;return 0===t?0:1===t?1:(!n||n<1?(n=1,e=.1):e=.4*Math.asin(1/n)/(2*Math.PI),n*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/.4)+1)},elasticInOut:function(t){var e,n=.1,i=.4;return 0===t?0:1===t?1:(!n||n<1?(n=1,e=.1):e=i*Math.asin(1/n)/(2*Math.PI),(t*=2)<1?n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*-.5:n*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*.5+1)},backIn:function(t){var e=1.70158;return t*t*((e+1)*t-e)},backOut:function(t){var e=1.70158;return--t*t*((e+1)*t+e)+1},backInOut:function(t){var e=2.5949095;return(t*=2)<1?t*t*((e+1)*t-e)*.5:.5*((t-=2)*t*((e+1)*t+e)+2)},bounceIn:function(t){return 1-$e.bounceOut(1-t)},bounceOut:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},bounceInOut:function(t){return t<.5?.5*$e.bounceIn(2*t):.5*$e.bounceOut(2*t-1)+.5}};const Je=$e;var Qe=Math.pow,tn=Math.sqrt,en=1e-8,nn=1e-4,rn=tn(3),on=1/3,an=mt(),sn=mt(),ln=mt();function un(t){return t>-1e-8&&t<en}function hn(t){return t>en||t<-1e-8}function cn(t,e,n,i,r){var o=1-r;return o*o*(o*t+3*r*e)+r*r*(r*i+3*o*n)}function pn(t,e,n,i,r){var o=1-r;return 3*(((e-t)*o+2*(n-e)*r)*o+(i-n)*r*r)}function dn(t,e,n,i,r,o){var a=i+3*(e-n)-t,s=3*(n-2*e+t),l=3*(e-t),u=t-r,h=s*s-3*a*l,c=s*l-9*a*u,p=l*l-3*s*u,d=0;if(un(h)&&un(c))un(s)?o[0]=0:(M=-l/s)>=0&&M<=1&&(o[d++]=M);else{var f=c*c-4*h*p;if(un(f)){var g=c/h,y=-g/2;(M=-s/a+g)>=0&&M<=1&&(o[d++]=M),y>=0&&y<=1&&(o[d++]=y)}else if(f>0){var v=tn(f),m=h*s+1.5*a*(-c+v),x=h*s+1.5*a*(-c-v);(M=(-s-((m=m<0?-Qe(-m,on):Qe(m,on))+(x=x<0?-Qe(-x,on):Qe(x,on))))/(3*a))>=0&&M<=1&&(o[d++]=M)}else{var _=(2*h*s-3*a*c)/(2*tn(h*h*h)),b=Math.acos(_)/3,w=tn(h),S=Math.cos(b),M=(-s-2*w*S)/(3*a),I=(y=(-s+w*(S+rn*Math.sin(b)))/(3*a),(-s+w*(S-rn*Math.sin(b)))/(3*a));M>=0&&M<=1&&(o[d++]=M),y>=0&&y<=1&&(o[d++]=y),I>=0&&I<=1&&(o[d++]=I)}}return d}function fn(t,e,n,i,r){var o=6*n-12*e+6*t,a=9*e+3*i-3*t-9*n,s=3*e-3*t,l=0;if(un(a))hn(o)&&(h=-s/o)>=0&&h<=1&&(r[l++]=h);else{var u=o*o-4*a*s;if(un(u))r[0]=-o/(2*a);else if(u>0){var h,c=tn(u),p=(-o-c)/(2*a);(h=(-o+c)/(2*a))>=0&&h<=1&&(r[l++]=h),p>=0&&p<=1&&(r[l++]=p)}}return l}function gn(t,e,n,i,r,o){var a=(e-t)*r+t,s=(n-e)*r+e,l=(i-n)*r+n,u=(s-a)*r+a,h=(l-s)*r+s,c=(h-u)*r+u;o[0]=t,o[1]=a,o[2]=u,o[3]=c,o[4]=c,o[5]=h,o[6]=l,o[7]=i}function yn(t,e,n,i,r,o,a,s,l,u,h){var c,p,d,f,g,y=.005,v=1/0;an[0]=l,an[1]=u;for(var m=0;m<1;m+=.05)sn[0]=cn(t,n,r,a,m),sn[1]=cn(e,i,o,s,m),(f=kt(an,sn))<v&&(c=m,v=f);v=1/0;for(var x=0;x<32&&!(y<nn);x++)p=c-y,d=c+y,sn[0]=cn(t,n,r,a,p),sn[1]=cn(e,i,o,s,p),f=kt(sn,an),p>=0&&f<v?(c=p,v=f):(ln[0]=cn(t,n,r,a,d),ln[1]=cn(e,i,o,s,d),g=kt(ln,an),d<=1&&g<v?(c=d,v=g):y*=.5);return h&&(h[0]=cn(t,n,r,a,c),h[1]=cn(e,i,o,s,c)),tn(v)}function vn(t,e,n,i,r,o,a,s,l){for(var u=t,h=e,c=0,p=1/l,d=1;d<=l;d++){var f=d*p,g=cn(t,n,r,a,f),y=cn(e,i,o,s,f),v=g-u,m=y-h;c+=Math.sqrt(v*v+m*m),u=g,h=y}return c}function mn(t,e,n,i){var r=1-i;return r*(r*t+2*i*e)+i*i*n}function xn(t,e,n,i){return 2*((1-i)*(e-t)+i*(n-e))}function _n(t,e,n){var i=t+n-2*e;return 0===i?.5:(t-e)/i}function bn(t,e,n,i,r){var o=(e-t)*i+t,a=(n-e)*i+e,s=(a-o)*i+o;r[0]=t,r[1]=o,r[2]=s,r[3]=s,r[4]=a,r[5]=n}function wn(t,e,n,i,r,o,a,s,l){var u,h=.005,c=1/0;an[0]=a,an[1]=s;for(var p=0;p<1;p+=.05)sn[0]=mn(t,n,r,p),sn[1]=mn(e,i,o,p),(y=kt(an,sn))<c&&(u=p,c=y);c=1/0;for(var d=0;d<32&&!(h<nn);d++){var f=u-h,g=u+h;sn[0]=mn(t,n,r,f),sn[1]=mn(e,i,o,f);var y=kt(sn,an);if(f>=0&&y<c)u=f,c=y;else{ln[0]=mn(t,n,r,g),ln[1]=mn(e,i,o,g);var v=kt(ln,an);g<=1&&v<c?(u=g,c=v):h*=.5}}return l&&(l[0]=mn(t,n,r,u),l[1]=mn(e,i,o,u)),tn(c)}function Sn(t,e,n,i,r,o,a){for(var s=t,l=e,u=0,h=1/a,c=1;c<=a;c++){var p=c*h,d=mn(t,n,r,p),f=mn(e,i,o,p),g=d-s,y=f-l;u+=Math.sqrt(g*g+y*y),s=d,l=f}return u}var Mn=/cubic-bezier\(([0-9,\.e ]+)\)/;function In(t){var e=t&&Mn.exec(t);if(e){var n=e[1].split(","),i=+rt(n[0]),r=+rt(n[1]),o=+rt(n[2]),a=+rt(n[3]);if(isNaN(i+r+o+a))return;var s=[];return function(t){return t<=0?0:t>=1?1:dn(0,i,o,1,t,s)&&cn(0,r,a,1,s[0])}}}const Tn=function(){function t(t){this._inited=!1,this._startTime=0,this._pausedTime=0,this._paused=!1,this._life=t.life||1e3,this._delay=t.delay||0,this.loop=t.loop||!1,this.onframe=t.onframe||yt,this.ondestroy=t.ondestroy||yt,this.onrestart=t.onrestart||yt,t.easing&&this.setEasing(t.easing)}return t.prototype.step=function(t,e){if(this._inited||(this._startTime=t+this._delay,this._inited=!0),!this._paused){var n=this._life,i=t-this._startTime-this._pausedTime,r=i/n;r<0&&(r=0),r=Math.min(r,1);var o=this.easingFunc,a=o?o(r):r;if(this.onframe(a),1===r){if(!this.loop)return!0;var s=i%n;this._startTime=t-s,this._pausedTime=0,this.onrestart()}return!1}this._pausedTime+=e},t.prototype.pause=function(){this._paused=!0},t.prototype.resume=function(){this._paused=!1},t.prototype.setEasing=function(t){this.easing=t,this.easingFunc=W(t)?t:Je[t]||In(t)},t}();var Cn=function(t){this.value=t},Dn=function(){function t(){this._len=0}return t.prototype.insert=function(t){var e=new Cn(t);return this.insertEntry(e),e},t.prototype.insertEntry=function(t){this.head?(this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t):this.head=this.tail=t,this._len++},t.prototype.remove=function(t){var e=t.prev,n=t.next;e?e.next=n:this.head=n,n?n.prev=e:this.tail=e,t.next=t.prev=null,this._len--},t.prototype.len=function(){return this._len},t.prototype.clear=function(){this.head=this.tail=null,this._len=0},t}(),An=function(){function t(t){this._list=new Dn,this._maxSize=10,this._map={},this._maxSize=t}return t.prototype.put=function(t,e){var n=this._list,i=this._map,r=null;if(null==i[t]){var o=n.len(),a=this._lastRemovedEntry;if(o>=this._maxSize&&o>0){var s=n.head;n.remove(s),delete i[s.key],r=s.value,this._lastRemovedEntry=s}a?a.value=e:a=new Cn(e),a.key=t,n.insertEntry(a),i[t]=a}return r},t.prototype.get=function(t){var e=this._map[t],n=this._list;if(null!=e)return e!==n.tail&&(n.remove(e),n.insertEntry(e)),e.value},t.prototype.clear=function(){this._list.clear(),this._map={}},t.prototype.len=function(){return this._list.len()},t}();const kn=An;var Ln={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function Pn(t){return(t=Math.round(t))<0?0:t>255?255:t}function On(t){return t<0?0:t>1?1:t}function Rn(t){var e=t;return e.length&&"%"===e.charAt(e.length-1)?Pn(parseFloat(e)/100*255):Pn(parseInt(e,10))}function Nn(t){var e=t;return e.length&&"%"===e.charAt(e.length-1)?On(parseFloat(e)/100):On(parseFloat(e))}function En(t,e,n){return n<0?n+=1:n>1&&(n-=1),6*n<1?t+(e-t)*n*6:2*n<1?e:3*n<2?t+(e-t)*(2/3-n)*6:t}function zn(t,e,n){return t+(e-t)*n}function Vn(t,e,n,i,r){return t[0]=e,t[1]=n,t[2]=i,t[3]=r,t}function Bn(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}var Fn=new kn(20),Gn=null;function Wn(t,e){Gn&&Bn(Gn,e),Gn=Fn.put(t,Gn||e.slice())}function Hn(t,e){if(t){e=e||[];var n=Fn.get(t);if(n)return Bn(e,n);var i=(t+="").replace(/ /g,"").toLowerCase();if(i in Ln)return Bn(e,Ln[i]),Wn(t,e),e;var r,o=i.length;if("#"===i.charAt(0))return 4===o||5===o?(r=parseInt(i.slice(1,4),16))>=0&&r<=4095?(Vn(e,(3840&r)>>4|(3840&r)>>8,240&r|(240&r)>>4,15&r|(15&r)<<4,5===o?parseInt(i.slice(4),16)/15:1),Wn(t,e),e):void Vn(e,0,0,0,1):7===o||9===o?(r=parseInt(i.slice(1,7),16))>=0&&r<=16777215?(Vn(e,(16711680&r)>>16,(65280&r)>>8,255&r,9===o?parseInt(i.slice(7),16)/255:1),Wn(t,e),e):void Vn(e,0,0,0,1):void 0;var a=i.indexOf("("),s=i.indexOf(")");if(-1!==a&&s+1===o){var l=i.substr(0,a),u=i.substr(a+1,s-(a+1)).split(","),h=1;switch(l){case"rgba":if(4!==u.length)return 3===u.length?Vn(e,+u[0],+u[1],+u[2],1):Vn(e,0,0,0,1);h=Nn(u.pop());case"rgb":return u.length>=3?(Vn(e,Rn(u[0]),Rn(u[1]),Rn(u[2]),3===u.length?h:Nn(u[3])),Wn(t,e),e):void Vn(e,0,0,0,1);case"hsla":return 4!==u.length?void Vn(e,0,0,0,1):(u[3]=Nn(u[3]),Yn(u,e),Wn(t,e),e);case"hsl":return 3!==u.length?void Vn(e,0,0,0,1):(Yn(u,e),Wn(t,e),e);default:return}}Vn(e,0,0,0,1)}}function Yn(t,e){var n=(parseFloat(t[0])%360+360)%360/360,i=Nn(t[1]),r=Nn(t[2]),o=r<=.5?r*(i+1):r+i-r*i,a=2*r-o;return Vn(e=e||[],Pn(255*En(a,o,n+1/3)),Pn(255*En(a,o,n)),Pn(255*En(a,o,n-1/3)),1),4===t.length&&(e[3]=t[3]),e}function Xn(t,e){var n=Hn(t);if(n){for(var i=0;i<3;i++)n[i]=e<0?n[i]*(1-e)|0:(255-n[i])*e+n[i]|0,n[i]>255?n[i]=255:n[i]<0&&(n[i]=0);return qn(n,4===n.length?"rgba":"rgb")}}function Un(t,e,n){if(e&&e.length&&t>=0&&t<=1){n=n||[];var i=t*(e.length-1),r=Math.floor(i),o=Math.ceil(i),a=e[r],s=e[o],l=i-r;return n[0]=Pn(zn(a[0],s[0],l)),n[1]=Pn(zn(a[1],s[1],l)),n[2]=Pn(zn(a[2],s[2],l)),n[3]=On(zn(a[3],s[3],l)),n}}function Zn(t,e,n,i){var r=Hn(t);if(t)return r=function(t){if(t){var e,n,i=t[0]/255,r=t[1]/255,o=t[2]/255,a=Math.min(i,r,o),s=Math.max(i,r,o),l=s-a,u=(s+a)/2;if(0===l)e=0,n=0;else{n=u<.5?l/(s+a):l/(2-s-a);var h=((s-i)/6+l/2)/l,c=((s-r)/6+l/2)/l,p=((s-o)/6+l/2)/l;i===s?e=p-c:r===s?e=1/3+h-p:o===s&&(e=2/3+c-h),e<0&&(e+=1),e>1&&(e-=1)}var d=[360*e,n,u];return null!=t[3]&&d.push(t[3]),d}}(r),null!=e&&(r[0]=function(t){return(t=Math.round(t))<0?0:t>360?360:t}(e)),null!=n&&(r[1]=Nn(n)),null!=i&&(r[2]=Nn(i)),qn(Yn(r),"rgba")}function jn(t,e){var n=Hn(t);if(n&&null!=e)return n[3]=On(e),qn(n,"rgba")}function qn(t,e){if(t&&t.length){var n=t[0]+","+t[1]+","+t[2];return"rgba"!==e&&"hsva"!==e&&"hsla"!==e||(n+=","+t[3]),e+"("+n+")"}}function Kn(t,e){var n=Hn(t);return n?(.299*n[0]+.587*n[1]+.114*n[2])*n[3]/255+(1-n[3])*e:0}var $n=Math.round;function Jn(t){var e;if(t&&"transparent"!==t){if("string"==typeof t&&t.indexOf("rgba")>-1){var n=Hn(t);n&&(t="rgb("+n[0]+","+n[1]+","+n[2]+")",e=n[3])}}else t="none";return{color:t,opacity:null==e?1:e}}var Qn=1e-4;function ti(t){return t<Qn&&t>-1e-4}function ei(t){return $n(1e3*t)/1e3}function ni(t){return $n(1e4*t)/1e4}var ii={left:"start",right:"end",center:"middle",middle:"middle"};function ri(t){return t&&!!t.image}function oi(t){return ri(t)||function(t){return t&&!!t.svgElement}(t)}function ai(t){return"linear"===t.type}function si(t){return"radial"===t.type}function li(t){return t&&("linear"===t.type||"radial"===t.type)}function ui(t){return"url(#"+t+")"}function hi(t){var e=t.getGlobalScale(),n=Math.max(e[0],e[1]);return Math.max(Math.ceil(Math.log(n)/Math.log(10)),1)}function ci(t){var e=t.x||0,n=t.y||0,i=(t.rotation||0)*vt,r=Q(t.scaleX,1),o=Q(t.scaleY,1),a=t.skewX||0,s=t.skewY||0,l=[];return(e||n)&&l.push("translate("+e+"px,"+n+"px)"),i&&l.push("rotate("+i+")"),1===r&&1===o||l.push("scale("+r+","+o+")"),(a||s)&&l.push("skew("+$n(a*vt)+"deg, "+$n(s*vt)+"deg)"),l.join(" ")}var pi=o.hasGlobalWindow&&W(window.btoa)?function(t){return window.btoa(unescape(encodeURIComponent(t)))}:"undefined"!=typeof Buffer?function(t){return Buffer.from(t).toString("base64")}:function(t){return null},di=Array.prototype.slice;function fi(t,e,n){return(e-t)*n+t}function gi(t,e,n,i){for(var r=e.length,o=0;o<r;o++)t[o]=fi(e[o],n[o],i);return t}function yi(t,e,n,i){for(var r=e.length,o=0;o<r;o++)t[o]=e[o]+n[o]*i;return t}function vi(t,e,n,i){for(var r=e.length,o=r&&e[0].length,a=0;a<r;a++){t[a]||(t[a]=[]);for(var s=0;s<o;s++)t[a][s]=e[a][s]+n[a][s]*i}return t}function mi(t,e){for(var n=t.length,i=e.length,r=n>i?e:t,o=Math.min(n,i),a=r[o-1]||{color:[0,0,0,0],offset:0},s=o;s<Math.max(n,i);s++)r.push({offset:a.offset,color:a.color.slice()})}function xi(t,e,n){var i=t,r=e;if(i.push&&r.push){var o=i.length,a=r.length;if(o!==a)if(o>a)i.length=a;else for(var s=o;s<a;s++)i.push(1===n?r[s]:di.call(r[s]));var l=i[0]&&i[0].length;for(s=0;s<i.length;s++)if(1===n)isNaN(i[s])&&(i[s]=r[s]);else for(var u=0;u<l;u++)isNaN(i[s][u])&&(i[s][u]=r[s][u])}}function _i(t){if(O(t)){var e=t.length;if(O(t[0])){for(var n=[],i=0;i<e;i++)n.push(di.call(t[i]));return n}return di.call(t)}return t}function bi(t){return t[0]=Math.floor(t[0])||0,t[1]=Math.floor(t[1])||0,t[2]=Math.floor(t[2])||0,t[3]=null==t[3]?1:t[3],"rgba("+t.join(",")+")"}function wi(t){return 4===t||5===t}function Si(t){return 1===t||2===t}var Mi=[0,0,0,0],Ii=function(){function t(t){this.keyframes=[],this.discrete=!1,this._invalid=!1,this._needsSort=!1,this._lastFr=0,this._lastFrP=0,this.propName=t}return t.prototype.isFinished=function(){return this._finished},t.prototype.setFinished=function(){this._finished=!0,this._additiveTrack&&this._additiveTrack.setFinished()},t.prototype.needsAnimate=function(){return this.keyframes.length>=1},t.prototype.getAdditiveTrack=function(){return this._additiveTrack},t.prototype.addKeyframe=function(t,e,n){this._needsSort=!0;var i=this.keyframes,r=i.length,o=!1,a=6,s=e;if(O(e)){var l=function(t){return O(t&&t[0])?2:1}(e);a=l,(1===l&&!X(e[0])||2===l&&!X(e[0][0]))&&(o=!0)}else if(X(e)&&!$(e))a=0;else if(H(e))if(isNaN(+e)){var u=Hn(e);u&&(s=u,a=3)}else a=0;else if(K(e)){var h=A({},s);h.colorStops=N(e.colorStops,(function(t){return{offset:t.offset,color:Hn(t.color)}})),ai(e)?a=4:si(e)&&(a=5),s=h}0===r?this.valType=a:a===this.valType&&6!==a||(o=!0),this.discrete=this.discrete||o;var c={time:t,value:s,rawValue:e,percent:0};return n&&(c.easing=n,c.easingFunc=W(n)?n:Je[n]||In(n)),i.push(c),c},t.prototype.prepare=function(t,e){var n=this.keyframes;this._needsSort&&n.sort((function(t,e){return t.time-e.time}));for(var i=this.valType,r=n.length,o=n[r-1],a=this.discrete,s=Si(i),l=wi(i),u=0;u<r;u++){var h=n[u],c=h.value,p=o.value;h.percent=h.time/t,a||(s&&u!==r-1?xi(c,p,i):l&&mi(c.colorStops,p.colorStops))}if(!a&&5!==i&&e&&this.needsAnimate()&&e.needsAnimate()&&i===e.valType&&!e._finished){this._additiveTrack=e;var d=n[0].value;for(u=0;u<r;u++)0===i?n[u].additiveValue=n[u].value-d:3===i?n[u].additiveValue=yi([],n[u].value,d,-1):Si(i)&&(n[u].additiveValue=1===i?yi([],n[u].value,d,-1):vi([],n[u].value,d,-1))}},t.prototype.step=function(t,e){if(!this._finished){this._additiveTrack&&this._additiveTrack._finished&&(this._additiveTrack=null);var n,i,r,o=null!=this._additiveTrack,a=o?"additiveValue":"value",s=this.valType,l=this.keyframes,u=l.length,h=this.propName,c=3===s,p=this._lastFr,d=Math.min;if(1===u)i=r=l[0];else{if(e<0)n=0;else if(e<this._lastFrP){for(n=d(p+1,u-1);n>=0&&!(l[n].percent<=e);n--);n=d(n,u-2)}else{for(n=p;n<u&&!(l[n].percent>e);n++);n=d(n-1,u-2)}r=l[n+1],i=l[n]}if(i&&r){this._lastFr=n,this._lastFrP=e;var f=r.percent-i.percent,g=0===f?1:d((e-i.percent)/f,1);r.easingFunc&&(g=r.easingFunc(g));var y=o?this._additiveValue:c?Mi:t[h];if(!Si(s)&&!c||y||(y=this._additiveValue=[]),this.discrete)t[h]=g<1?i.rawValue:r.rawValue;else if(Si(s))1===s?gi(y,i[a],r[a],g):function(t,e,n,i){for(var r=e.length,o=r&&e[0].length,a=0;a<r;a++){t[a]||(t[a]=[]);for(var s=0;s<o;s++)t[a][s]=fi(e[a][s],n[a][s],i)}}(y,i[a],r[a],g);else if(wi(s)){var v=i[a],m=r[a],x=4===s;t[h]={type:x?"linear":"radial",x:fi(v.x,m.x,g),y:fi(v.y,m.y,g),colorStops:N(v.colorStops,(function(t,e){var n=m.colorStops[e];return{offset:fi(t.offset,n.offset,g),color:bi(gi([],t.color,n.color,g))}})),global:m.global},x?(t[h].x2=fi(v.x2,m.x2,g),t[h].y2=fi(v.y2,m.y2,g)):t[h].r=fi(v.r,m.r,g)}else if(c)gi(y,i[a],r[a],g),o||(t[h]=bi(y));else{var _=fi(i[a],r[a],g);o?this._additiveValue=_:t[h]=_}o&&this._addToTarget(t)}}},t.prototype._addToTarget=function(t){var e=this.valType,n=this.propName,i=this._additiveValue;0===e?t[n]=t[n]+i:3===e?(Hn(t[n],Mi),yi(Mi,Mi,i,1),t[n]=bi(Mi)):1===e?yi(t[n],t[n],i,1):2===e&&vi(t[n],t[n],i,1)},t}(),Ti=function(){function t(t,e,n,i){this._tracks={},this._trackKeys=[],this._maxTime=0,this._started=0,this._clip=null,this._target=t,this._loop=e,e&&i?I("Can' use additive animation on looped animation."):(this._additiveAnimators=i,this._allowDiscrete=n)}return t.prototype.getMaxTime=function(){return this._maxTime},t.prototype.getDelay=function(){return this._delay},t.prototype.getLoop=function(){return this._loop},t.prototype.getTarget=function(){return this._target},t.prototype.changeTarget=function(t){this._target=t},t.prototype.when=function(t,e,n){return this.whenWithKeys(t,e,V(e),n)},t.prototype.whenWithKeys=function(t,e,n,i){for(var r=this._tracks,o=0;o<n.length;o++){var a=n[o],s=r[a];if(!s){s=r[a]=new Ii(a);var l=void 0,u=this._getAdditiveTrack(a);if(u){var h=u.keyframes,c=h[h.length-1];l=c&&c.value,3===u.valType&&l&&(l=bi(l))}else l=this._target[a];if(null==l)continue;t>0&&s.addKeyframe(0,_i(l),i),this._trackKeys.push(a)}s.addKeyframe(t,_i(e[a]),i)}return this._maxTime=Math.max(this._maxTime,t),this},t.prototype.pause=function(){this._clip.pause(),this._paused=!0},t.prototype.resume=function(){this._clip.resume(),this._paused=!1},t.prototype.isPaused=function(){return!!this._paused},t.prototype.duration=function(t){return this._maxTime=t,this._force=!0,this},t.prototype._doneCallback=function(){this._setTracksFinished(),this._clip=null;var t=this._doneCbs;if(t)for(var e=t.length,n=0;n<e;n++)t[n].call(this)},t.prototype._abortedCallback=function(){this._setTracksFinished();var t=this.animation,e=this._abortedCbs;if(t&&t.removeClip(this._clip),this._clip=null,e)for(var n=0;n<e.length;n++)e[n].call(this)},t.prototype._setTracksFinished=function(){for(var t=this._tracks,e=this._trackKeys,n=0;n<e.length;n++)t[e[n]].setFinished()},t.prototype._getAdditiveTrack=function(t){var e,n=this._additiveAnimators;if(n)for(var i=0;i<n.length;i++){var r=n[i].getTrack(t);r&&(e=r)}return e},t.prototype.start=function(t){if(!(this._started>0)){this._started=1;for(var e=this,n=[],i=this._maxTime||0,r=0;r<this._trackKeys.length;r++){var o=this._trackKeys[r],a=this._tracks[o],s=this._getAdditiveTrack(o),l=a.keyframes,u=l.length;if(a.prepare(i,s),a.needsAnimate())if(!this._allowDiscrete&&a.discrete){var h=l[u-1];h&&(e._target[a.propName]=h.rawValue),a.setFinished()}else n.push(a)}if(n.length||this._force){var c=new Tn({life:i,loop:this._loop,delay:this._delay||0,onframe:function(t){e._started=2;var i=e._additiveAnimators;if(i){for(var r=!1,o=0;o<i.length;o++)if(i[o]._clip){r=!0;break}r||(e._additiveAnimators=null)}for(o=0;o<n.length;o++)n[o].step(e._target,t);var a=e._onframeCbs;if(a)for(o=0;o<a.length;o++)a[o](e._target,t)},ondestroy:function(){e._doneCallback()}});this._clip=c,this.animation&&this.animation.addClip(c),t&&c.setEasing(t)}else this._doneCallback();return this}},t.prototype.stop=function(t){if(this._clip){var e=this._clip;t&&e.onframe(1),this._abortedCallback()}},t.prototype.delay=function(t){return this._delay=t,this},t.prototype.during=function(t){return t&&(this._onframeCbs||(this._onframeCbs=[]),this._onframeCbs.push(t)),this},t.prototype.done=function(t){return t&&(this._doneCbs||(this._doneCbs=[]),this._doneCbs.push(t)),this},t.prototype.aborted=function(t){return t&&(this._abortedCbs||(this._abortedCbs=[]),this._abortedCbs.push(t)),this},t.prototype.getClip=function(){return this._clip},t.prototype.getTrack=function(t){return this._tracks[t]},t.prototype.getTracks=function(){var t=this;return N(this._trackKeys,(function(e){return t._tracks[e]}))},t.prototype.stopTracks=function(t,e){if(!t.length||!this._clip)return!0;for(var n=this._tracks,i=this._trackKeys,r=0;r<t.length;r++){var o=n[t[r]];o&&!o.isFinished()&&(e?o.step(this._target,1):1===this._started&&o.step(this._target,0),o.setFinished())}var a=!0;for(r=0;r<i.length;r++)if(!n[i[r]].isFinished()){a=!1;break}return a&&this._abortedCallback(),a},t.prototype.saveTo=function(t,e,n){if(t){e=e||this._trackKeys;for(var i=0;i<e.length;i++){var r=e[i],o=this._tracks[r];if(o&&!o.isFinished()){var a=o.keyframes,s=a[n?0:a.length-1];s&&(t[r]=_i(s.rawValue))}}}},t.prototype.__changeFinalValue=function(t,e){e=e||V(t);for(var n=0;n<e.length;n++){var i=e[n],r=this._tracks[i];if(r){var o=r.keyframes;if(o.length>1){var a=o.pop();r.addKeyframe(a.time,t[i]),r.prepare(this._maxTime,r.getAdditiveTrack())}}}},t}();const Ci=Ti;function Di(){return(new Date).getTime()}var Ai=function(t){function e(e){var n=t.call(this)||this;return n._running=!1,n._time=0,n._pausedTime=0,n._pauseStart=0,n._paused=!1,e=e||{},n.stage=e.stage||{},n}return n(e,t),e.prototype.addClip=function(t){t.animation&&this.removeClip(t),this._head?(this._tail.next=t,t.prev=this._tail,t.next=null,this._tail=t):this._head=this._tail=t,t.animation=this},e.prototype.addAnimator=function(t){t.animation=this;var e=t.getClip();e&&this.addClip(e)},e.prototype.removeClip=function(t){if(t.animation){var e=t.prev,n=t.next;e?e.next=n:this._head=n,n?n.prev=e:this._tail=e,t.next=t.prev=t.animation=null}},e.prototype.removeAnimator=function(t){var e=t.getClip();e&&this.removeClip(e),t.animation=null},e.prototype.update=function(t){for(var e=Di()-this._pausedTime,n=e-this._time,i=this._head;i;){var r=i.next;i.step(e,n)?(i.ondestroy(),this.removeClip(i),i=r):i=r}this._time=e,t||(this.trigger("frame",n),this.stage.update&&this.stage.update())},e.prototype._startLoop=function(){var t=this;this._running=!0,Ke((function e(){t._running&&(Ke(e),!t._paused&&t.update())}))},e.prototype.start=function(){this._running||(this._time=Di(),this._pausedTime=0,this._startLoop())},e.prototype.stop=function(){this._running=!1},e.prototype.pause=function(){this._paused||(this._pauseStart=Di(),this._paused=!0)},e.prototype.resume=function(){this._paused&&(this._pausedTime+=Di()-this._pauseStart,this._paused=!1)},e.prototype.clear=function(){for(var t=this._head;t;){var e=t.next;t.prev=t.next=t.animation=null,t=e}this._head=this._tail=null},e.prototype.isFinished=function(){return null==this._head},e.prototype.animate=function(t,e){e=e||{},this.start();var n=new Ci(t,e.loop);return this.addAnimator(n),n},e}(Bt);const ki=Ai;var Li,Pi,Oi=o.domSupported,Ri=(Pi={pointerdown:1,pointerup:1,pointermove:1,pointerout:1},{mouse:Li=["click","dblclick","mousewheel","wheel","mouseout","mouseup","mousedown","mousemove","contextmenu"],touch:["touchstart","touchend","touchmove"],pointer:N(Li,(function(t){var e=t.replace("mouse","pointer");return Pi.hasOwnProperty(e)?e:t}))}),Ni=["mousemove","mouseup"],Ei=["pointermove","pointerup"],zi=!1;function Vi(t){var e=t.pointerType;return"pen"===e||"touch"===e}function Bi(t){t&&(t.zrByTouch=!0)}function Fi(t,e){for(var n=e,i=!1;n&&9!==n.nodeType&&!(i=n.domBelongToZr||n!==e&&n===t.painterRoot);)n=n.parentNode;return i}var Gi=function(t,e){this.stopPropagation=yt,this.stopImmediatePropagation=yt,this.preventDefault=yt,this.type=e.type,this.target=this.currentTarget=t.dom,this.pointerType=e.pointerType,this.clientX=e.clientX,this.clientY=e.clientY},Wi={mousedown:function(t){t=ne(this.dom,t),this.__mayPointerCapture=[t.zrX,t.zrY],this.trigger("mousedown",t)},mousemove:function(t){t=ne(this.dom,t);var e=this.__mayPointerCapture;!e||t.zrX===e[0]&&t.zrY===e[1]||this.__togglePointerCapture(!0),this.trigger("mousemove",t)},mouseup:function(t){t=ne(this.dom,t),this.__togglePointerCapture(!1),this.trigger("mouseup",t)},mouseout:function(t){Fi(this,(t=ne(this.dom,t)).toElement||t.relatedTarget)||(this.__pointerCapturing&&(t.zrEventControl="no_globalout"),this.trigger("mouseout",t))},wheel:function(t){zi=!0,t=ne(this.dom,t),this.trigger("mousewheel",t)},mousewheel:function(t){zi||(t=ne(this.dom,t),this.trigger("mousewheel",t))},touchstart:function(t){Bi(t=ne(this.dom,t)),this.__lastTouchMoment=new Date,this.handler.processGesture(t,"start"),Wi.mousemove.call(this,t),Wi.mousedown.call(this,t)},touchmove:function(t){Bi(t=ne(this.dom,t)),this.handler.processGesture(t,"change"),Wi.mousemove.call(this,t)},touchend:function(t){Bi(t=ne(this.dom,t)),this.handler.processGesture(t,"end"),Wi.mouseup.call(this,t),+new Date-+this.__lastTouchMoment<300&&Wi.click.call(this,t)},pointerdown:function(t){Wi.mousedown.call(this,t)},pointermove:function(t){Vi(t)||Wi.mousemove.call(this,t)},pointerup:function(t){Wi.mouseup.call(this,t)},pointerout:function(t){Vi(t)||Wi.mouseout.call(this,t)}};R(["click","dblclick","contextmenu"],(function(t){Wi[t]=function(e){e=ne(this.dom,e),this.trigger(t,e)}}));var Hi={pointermove:function(t){Vi(t)||Hi.mousemove.call(this,t)},pointerup:function(t){Hi.mouseup.call(this,t)},mousemove:function(t){this.trigger("mousemove",t)},mouseup:function(t){var e=this.__pointerCapturing;this.__togglePointerCapture(!1),this.trigger("mouseup",t),e&&(t.zrEventControl="only_globalout",this.trigger("mouseout",t))}};function Yi(t,e){var n=e.domHandlers;o.pointerEventsSupported?R(Ri.pointer,(function(i){Ui(e,i,(function(e){n[i].call(t,e)}))})):(o.touchEventsSupported&&R(Ri.touch,(function(i){Ui(e,i,(function(r){n[i].call(t,r),function(t){t.touching=!0,null!=t.touchTimer&&(clearTimeout(t.touchTimer),t.touchTimer=null),t.touchTimer=setTimeout((function(){t.touching=!1,t.touchTimer=null}),700)}(e)}))})),R(Ri.mouse,(function(i){Ui(e,i,(function(r){r=ee(r),e.touching||n[i].call(t,r)}))})))}function Xi(t,e){function n(n){Ui(e,n,(function(i){i=ee(i),Fi(t,i.target)||(i=function(t,e){return ne(t.dom,new Gi(t,e),!0)}(t,i),e.domHandlers[n].call(t,i))}),{capture:!0})}o.pointerEventsSupported?R(Ei,n):o.touchEventsSupported||R(Ni,n)}function Ui(t,e,n,i){t.mounted[e]=n,t.listenerOpts[e]=i,ie(t.domTarget,e,n,i)}function Zi(t){var e,n,i,r,o=t.mounted;for(var a in o)o.hasOwnProperty(a)&&(e=t.domTarget,n=a,i=o[a],r=t.listenerOpts[a],e.removeEventListener(n,i,r));t.mounted={}}var ji=function(t,e){this.mounted={},this.listenerOpts={},this.touching=!1,this.domTarget=t,this.domHandlers=e};const qi=function(t){function e(e,n){var i=t.call(this)||this;return i.__pointerCapturing=!1,i.dom=e,i.painterRoot=n,i._localHandlerScope=new ji(e,Wi),Oi&&(i._globalHandlerScope=new ji(document,Hi)),Yi(i,i._localHandlerScope),i}return n(e,t),e.prototype.dispose=function(){Zi(this._localHandlerScope),Oi&&Zi(this._globalHandlerScope)},e.prototype.setCursor=function(t){this.dom.style&&(this.dom.style.cursor=t||"default")},e.prototype.__togglePointerCapture=function(t){if(this.__mayPointerCapture=null,Oi&&+this.__pointerCapturing^+t){this.__pointerCapturing=t;var e=this._globalHandlerScope;t?Xi(this,e):Zi(e)}},e}(Bt);var Ki=1;o.hasGlobalWindow&&(Ki=Math.max(window.devicePixelRatio||window.screen&&window.screen.deviceXDPI/window.screen.logicalXDPI||1,1));var $i=Ki,Ji="#333",Qi="#ccc",tr=ue,er=5e-5;function nr(t){return t>er||t<-5e-5}var ir=[],rr=[],or=[1,0,0,1,0,0],ar=Math.abs,sr=function(){function t(){}return t.prototype.getLocalTransform=function(e){return t.getLocalTransform(this,e)},t.prototype.setPosition=function(t){this.x=t[0],this.y=t[1]},t.prototype.setScale=function(t){this.scaleX=t[0],this.scaleY=t[1]},t.prototype.setSkew=function(t){this.skewX=t[0],this.skewY=t[1]},t.prototype.setOrigin=function(t){this.originX=t[0],this.originY=t[1]},t.prototype.needLocalTransform=function(){return nr(this.rotation)||nr(this.x)||nr(this.y)||nr(this.scaleX-1)||nr(this.scaleY-1)||nr(this.skewX)||nr(this.skewY)},t.prototype.updateTransform=function(){var t=this.parent&&this.parent.transform,e=this.needLocalTransform(),n=this.transform;e||t?(n=n||[1,0,0,1,0,0],e?this.getLocalTransform(n):tr(n),t&&(e?ce(n,t,n):he(n,t)),this.transform=n,this._resolveGlobalScaleRatio(n)):n&&tr(n)},t.prototype._resolveGlobalScaleRatio=function(t){var e=this.globalScaleRatio;if(null!=e&&1!==e){this.getGlobalScale(ir);var n=ir[0]<0?-1:1,i=ir[1]<0?-1:1,r=((ir[0]-n)*e+n)/ir[0]||0,o=((ir[1]-i)*e+i)/ir[1]||0;t[0]*=r,t[1]*=r,t[2]*=o,t[3]*=o}this.invTransform=this.invTransform||[1,0,0,1,0,0],ge(this.invTransform,t)},t.prototype.getComputedTransform=function(){for(var t=this,e=[];t;)e.push(t),t=t.parent;for(;t=e.pop();)t.updateTransform();return this.transform},t.prototype.setLocalTransform=function(t){if(t){var e=t[0]*t[0]+t[1]*t[1],n=t[2]*t[2]+t[3]*t[3],i=Math.atan2(t[1],t[0]),r=Math.PI/2+i-Math.atan2(t[3],t[2]);n=Math.sqrt(n)*Math.cos(r),e=Math.sqrt(e),this.skewX=r,this.skewY=0,this.rotation=-i,this.x=+t[4],this.y=+t[5],this.scaleX=e,this.scaleY=n,this.originX=0,this.originY=0}},t.prototype.decomposeTransform=function(){if(this.transform){var t=this.parent,e=this.transform;t&&t.transform&&(ce(rr,t.invTransform,e),e=rr);var n=this.originX,i=this.originY;(n||i)&&(or[4]=n,or[5]=i,ce(rr,e,or),rr[4]-=n,rr[5]-=i,e=rr),this.setLocalTransform(e)}},t.prototype.getGlobalScale=function(t){var e=this.transform;return t=t||[],e?(t[0]=Math.sqrt(e[0]*e[0]+e[1]*e[1]),t[1]=Math.sqrt(e[2]*e[2]+e[3]*e[3]),e[0]<0&&(t[0]=-t[0]),e[3]<0&&(t[1]=-t[1]),t):(t[0]=1,t[1]=1,t)},t.prototype.transformCoordToLocal=function(t,e){var n=[t,e],i=this.invTransform;return i&&Pt(n,n,i),n},t.prototype.transformCoordToGlobal=function(t,e){var n=[t,e],i=this.transform;return i&&Pt(n,n,i),n},t.prototype.getLineScale=function(){var t=this.transform;return t&&ar(t[0]-1)>1e-10&&ar(t[3]-1)>1e-10?Math.sqrt(ar(t[0]*t[3]-t[2]*t[1])):1},t.prototype.copyTransform=function(t){ur(this,t)},t.getLocalTransform=function(t,e){e=e||[];var n=t.originX||0,i=t.originY||0,r=t.scaleX,o=t.scaleY,a=t.anchorX,s=t.anchorY,l=t.rotation||0,u=t.x,h=t.y,c=t.skewX?Math.tan(t.skewX):0,p=t.skewY?Math.tan(-t.skewY):0;if(n||i||a||s){var d=n+a,f=i+s;e[4]=-d*r-c*f*o,e[5]=-f*o-p*d*r}else e[4]=e[5]=0;return e[0]=r,e[3]=o,e[1]=p*r,e[2]=c*o,l&&de(e,e,l),e[4]+=n+u,e[5]+=i+h,e},t.initDefaultProps=function(){var e=t.prototype;e.scaleX=e.scaleY=e.globalScaleRatio=1,e.x=e.y=e.originX=e.originY=e.skewX=e.skewY=e.rotation=e.anchorX=e.anchorY=0}(),t}(),lr=["x","y","originX","originY","anchorX","anchorY","rotation","scaleX","scaleY","skewX","skewY"];function ur(t,e){for(var n=0;n<lr.length;n++){var i=lr[n];t[i]=e[i]}}var hr={};function cr(t,e){var n=hr[e=e||u];n||(n=hr[e]=new kn(500));var i=n.get(t);return null==i&&(i=c.measureText(t,e).width,n.put(t,i)),i}function pr(t,e,n,i){var r=cr(t,e),o=yr(e),a=fr(0,r,n),s=gr(0,o,i);return new Ce(a,s,r,o)}function dr(t,e,n,i){var r=((t||"")+"").split("\n");if(1===r.length)return pr(r[0],e,n,i);for(var o=new Ce(0,0,0,0),a=0;a<r.length;a++){var s=pr(r[a],e,n,i);0===a?o.copy(s):o.union(s)}return o}function fr(t,e,n){return"right"===n?t-=e:"center"===n&&(t-=e/2),t}function gr(t,e,n){return"middle"===n?t-=e/2:"bottom"===n&&(t-=e),t}function yr(t){return cr("",t)}function vr(t,e){return"string"==typeof t?t.lastIndexOf("%")>=0?parseFloat(t)/100*e:parseFloat(t):t}function mr(t,e,n){var i=e.position||"inside",r=null!=e.distance?e.distance:5,o=n.height,a=n.width,s=o/2,l=n.x,u=n.y,h="left",c="top";if(i instanceof Array)l+=vr(i[0],n.width),u+=vr(i[1],n.height),h=null,c=null;else switch(i){case"left":l-=r,u+=s,h="right",c="middle";break;case"right":l+=r+a,u+=s,c="middle";break;case"top":l+=a/2,u-=r,h="center",c="bottom";break;case"bottom":l+=a/2,u+=o+r,h="center";break;case"inside":l+=a/2,u+=s,h="center",c="middle";break;case"insideLeft":l+=r,u+=s,c="middle";break;case"insideRight":l+=a-r,u+=s,h="right",c="middle";break;case"insideTop":l+=a/2,u+=r,h="center";break;case"insideBottom":l+=a/2,u+=o-r,h="center",c="bottom";break;case"insideTopLeft":l+=r,u+=r;break;case"insideTopRight":l+=a-r,u+=r,h="right";break;case"insideBottomLeft":l+=r,u+=o-r,c="bottom";break;case"insideBottomRight":l+=a-r,u+=o-r,h="right",c="bottom"}return(t=t||{}).x=l,t.y=u,t.align=h,t.verticalAlign=c,t}var xr="__zr_normal__",_r=lr.concat(["ignore"]),br=E(lr,(function(t,e){return t[e]=!0,t}),{ignore:!1}),wr={},Sr=new Ce(0,0,0,0),Mr=function(){function t(t){this.id=M(),this.animators=[],this.currentStates=[],this.states={},this._init(t)}return t.prototype._init=function(t){this.attr(t)},t.prototype.drift=function(t,e,n){switch(this.draggable){case"horizontal":e=0;break;case"vertical":t=0}var i=this.transform;i||(i=this.transform=[1,0,0,1,0,0]),i[4]+=t,i[5]+=e,this.decomposeTransform(),this.markRedraw()},t.prototype.beforeUpdate=function(){},t.prototype.afterUpdate=function(){},t.prototype.update=function(){this.updateTransform(),this.__dirty&&this.updateInnerText()},t.prototype.updateInnerText=function(t){var e=this._textContent;if(e&&(!e.ignore||t)){this.textConfig||(this.textConfig={});var n=this.textConfig,i=n.local,r=e.innerTransformable,o=void 0,a=void 0,s=!1;r.parent=i?this:null;var l=!1;if(r.copyTransform(e),null!=n.position){var u=Sr;n.layoutRect?u.copy(n.layoutRect):u.copy(this.getBoundingRect()),i||u.applyTransform(this.transform),this.calculateTextPosition?this.calculateTextPosition(wr,n,u):mr(wr,n,u),r.x=wr.x,r.y=wr.y,o=wr.align,a=wr.verticalAlign;var h=n.origin;if(h&&null!=n.rotation){var c=void 0,p=void 0;"center"===h?(c=.5*u.width,p=.5*u.height):(c=vr(h[0],u.width),p=vr(h[1],u.height)),l=!0,r.originX=-r.x+c+(i?0:u.x),r.originY=-r.y+p+(i?0:u.y)}}null!=n.rotation&&(r.rotation=n.rotation);var d=n.offset;d&&(r.x+=d[0],r.y+=d[1],l||(r.originX=-d[0],r.originY=-d[1]));var f=null==n.inside?"string"==typeof n.position&&n.position.indexOf("inside")>=0:n.inside,g=this._innerTextDefaultStyle||(this._innerTextDefaultStyle={}),y=void 0,v=void 0,m=void 0;f&&this.canBeInsideText()?(y=n.insideFill,v=n.insideStroke,null!=y&&"auto"!==y||(y=this.getInsideTextFill()),null!=v&&"auto"!==v||(v=this.getInsideTextStroke(y),m=!0)):(y=n.outsideFill,v=n.outsideStroke,null!=y&&"auto"!==y||(y=this.getOutsideFill()),null!=v&&"auto"!==v||(v=this.getOutsideStroke(y),m=!0)),(y=y||"#000")===g.fill&&v===g.stroke&&m===g.autoStroke&&o===g.align&&a===g.verticalAlign||(s=!0,g.fill=y,g.stroke=v,g.autoStroke=m,g.align=o,g.verticalAlign=a,e.setDefaultTextStyle(g)),e.__dirty|=1,s&&e.dirtyStyle(!0)}},t.prototype.canBeInsideText=function(){return!0},t.prototype.getInsideTextFill=function(){return"#fff"},t.prototype.getInsideTextStroke=function(t){return"#000"},t.prototype.getOutsideFill=function(){return this.__zr&&this.__zr.isDarkMode()?Qi:Ji},t.prototype.getOutsideStroke=function(t){var e=this.__zr&&this.__zr.getBackgroundColor(),n="string"==typeof e&&Hn(e);n||(n=[255,255,255,1]);for(var i=n[3],r=this.__zr.isDarkMode(),o=0;o<3;o++)n[o]=n[o]*i+(r?0:255)*(1-i);return n[3]=1,qn(n,"rgba")},t.prototype.traverse=function(t,e){},t.prototype.attrKV=function(t,e){"textConfig"===t?this.setTextConfig(e):"textContent"===t?this.setTextContent(e):"clipPath"===t?this.setClipPath(e):"extra"===t?(this.extra=this.extra||{},A(this.extra,e)):this[t]=e},t.prototype.hide=function(){this.ignore=!0,this.markRedraw()},t.prototype.show=function(){this.ignore=!1,this.markRedraw()},t.prototype.attr=function(t,e){if("string"==typeof t)this.attrKV(t,e);else if(U(t))for(var n=V(t),i=0;i<n.length;i++){var r=n[i];this.attrKV(r,t[r])}return this.markRedraw(),this},t.prototype.saveCurrentToNormalState=function(t){this._innerSaveToNormal(t);for(var e=this._normalState,n=0;n<this.animators.length;n++){var i=this.animators[n],r=i.__fromStateTransition;if(!(i.getLoop()||r&&r!==xr)){var o=i.targetName,a=o?e[o]:e;i.saveTo(a)}}},t.prototype._innerSaveToNormal=function(t){var e=this._normalState;e||(e=this._normalState={}),t.textConfig&&!e.textConfig&&(e.textConfig=this.textConfig),this._savePrimaryToNormal(t,e,_r)},t.prototype._savePrimaryToNormal=function(t,e,n){for(var i=0;i<n.length;i++){var r=n[i];null==t[r]||r in e||(e[r]=this[r])}},t.prototype.hasState=function(){return this.currentStates.length>0},t.prototype.getState=function(t){return this.states[t]},t.prototype.ensureState=function(t){var e=this.states;return e[t]||(e[t]={}),e[t]},t.prototype.clearStates=function(t){this.useState(xr,!1,t)},t.prototype.useState=function(t,e,n,i){var r=t===xr;if(this.hasState()||!r){var o=this.currentStates,a=this.stateTransition;if(!(L(o,t)>=0)||!e&&1!==o.length){var s;if(this.stateProxy&&!r&&(s=this.stateProxy(t)),s||(s=this.states&&this.states[t]),s||r){r||this.saveCurrentToNormalState(s);var l=!!(s&&s.hoverLayer||i);l&&this._toggleHoverLayerFlag(!0),this._applyStateObj(t,s,this._normalState,e,!n&&!this.__inHover&&a&&a.duration>0,a);var u=this._textContent,h=this._textGuide;return u&&u.useState(t,e,n,l),h&&h.useState(t,e,n,l),r?(this.currentStates=[],this._normalState={}):e?this.currentStates.push(t):this.currentStates=[t],this._updateAnimationTargets(),this.markRedraw(),!l&&this.__inHover&&(this._toggleHoverLayerFlag(!1),this.__dirty&=-2),s}I("State "+t+" not exists.")}}},t.prototype.useStates=function(t,e,n){if(t.length){var i=[],r=this.currentStates,o=t.length,a=o===r.length;if(a)for(var s=0;s<o;s++)if(t[s]!==r[s]){a=!1;break}if(a)return;for(s=0;s<o;s++){var l=t[s],u=void 0;this.stateProxy&&(u=this.stateProxy(l,t)),u||(u=this.states[l]),u&&i.push(u)}var h=i[o-1],c=!!(h&&h.hoverLayer||n);c&&this._toggleHoverLayerFlag(!0);var p=this._mergeStates(i),d=this.stateTransition;this.saveCurrentToNormalState(p),this._applyStateObj(t.join(","),p,this._normalState,!1,!e&&!this.__inHover&&d&&d.duration>0,d);var f=this._textContent,g=this._textGuide;f&&f.useStates(t,e,c),g&&g.useStates(t,e,c),this._updateAnimationTargets(),this.currentStates=t.slice(),this.markRedraw(),!c&&this.__inHover&&(this._toggleHoverLayerFlag(!1),this.__dirty&=-2)}else this.clearStates()},t.prototype._updateAnimationTargets=function(){for(var t=0;t<this.animators.length;t++){var e=this.animators[t];e.targetName&&e.changeTarget(this[e.targetName])}},t.prototype.removeState=function(t){var e=L(this.currentStates,t);if(e>=0){var n=this.currentStates.slice();n.splice(e,1),this.useStates(n)}},t.prototype.replaceState=function(t,e,n){var i=this.currentStates.slice(),r=L(i,t),o=L(i,e)>=0;r>=0?o?i.splice(r,1):i[r]=e:n&&!o&&i.push(e),this.useStates(i)},t.prototype.toggleState=function(t,e){e?this.useState(t,!0):this.removeState(t)},t.prototype._mergeStates=function(t){for(var e,n={},i=0;i<t.length;i++){var r=t[i];A(n,r),r.textConfig&&A(e=e||{},r.textConfig)}return e&&(n.textConfig=e),n},t.prototype._applyStateObj=function(t,e,n,i,r,o){var a=!(e&&i);e&&e.textConfig?(this.textConfig=A({},i?this.textConfig:n.textConfig),A(this.textConfig,e.textConfig)):a&&n.textConfig&&(this.textConfig=n.textConfig);for(var s={},l=!1,u=0;u<_r.length;u++){var h=_r[u],c=r&&br[h];e&&null!=e[h]?c?(l=!0,s[h]=e[h]):this[h]=e[h]:a&&null!=n[h]&&(c?(l=!0,s[h]=n[h]):this[h]=n[h])}if(!r)for(u=0;u<this.animators.length;u++){var p=this.animators[u],d=p.targetName;p.getLoop()||p.__changeFinalValue(d?(e||n)[d]:e||n)}l&&this._transitionState(t,s,o)},t.prototype._attachComponent=function(t){if((!t.__zr||t.__hostTarget)&&t!==this){var e=this.__zr;e&&t.addSelfToZr(e),t.__zr=e,t.__hostTarget=this}},t.prototype._detachComponent=function(t){t.__zr&&t.removeSelfFromZr(t.__zr),t.__zr=null,t.__hostTarget=null},t.prototype.getClipPath=function(){return this._clipPath},t.prototype.setClipPath=function(t){this._clipPath&&this._clipPath!==t&&this.removeClipPath(),this._attachComponent(t),this._clipPath=t,this.markRedraw()},t.prototype.removeClipPath=function(){var t=this._clipPath;t&&(this._detachComponent(t),this._clipPath=null,this.markRedraw())},t.prototype.getTextContent=function(){return this._textContent},t.prototype.setTextContent=function(t){var e=this._textContent;e!==t&&(e&&e!==t&&this.removeTextContent(),t.innerTransformable=new sr,this._attachComponent(t),this._textContent=t,this.markRedraw())},t.prototype.setTextConfig=function(t){this.textConfig||(this.textConfig={}),A(this.textConfig,t),this.markRedraw()},t.prototype.removeTextConfig=function(){this.textConfig=null,this.markRedraw()},t.prototype.removeTextContent=function(){var t=this._textContent;t&&(t.innerTransformable=null,this._detachComponent(t),this._textContent=null,this._innerTextDefaultStyle=null,this.markRedraw())},t.prototype.getTextGuideLine=function(){return this._textGuide},t.prototype.setTextGuideLine=function(t){this._textGuide&&this._textGuide!==t&&this.removeTextGuideLine(),this._attachComponent(t),this._textGuide=t,this.markRedraw()},t.prototype.removeTextGuideLine=function(){var t=this._textGuide;t&&(this._detachComponent(t),this._textGuide=null,this.markRedraw())},t.prototype.markRedraw=function(){this.__dirty|=1;var t=this.__zr;t&&(this.__inHover?t.refreshHover():t.refresh()),this.__hostTarget&&this.__hostTarget.markRedraw()},t.prototype.dirty=function(){this.markRedraw()},t.prototype._toggleHoverLayerFlag=function(t){this.__inHover=t;var e=this._textContent,n=this._textGuide;e&&(e.__inHover=t),n&&(n.__inHover=t)},t.prototype.addSelfToZr=function(t){if(this.__zr!==t){this.__zr=t;var e=this.animators;if(e)for(var n=0;n<e.length;n++)t.animation.addAnimator(e[n]);this._clipPath&&this._clipPath.addSelfToZr(t),this._textContent&&this._textContent.addSelfToZr(t),this._textGuide&&this._textGuide.addSelfToZr(t)}},t.prototype.removeSelfFromZr=function(t){if(this.__zr){this.__zr=null;var e=this.animators;if(e)for(var n=0;n<e.length;n++)t.animation.removeAnimator(e[n]);this._clipPath&&this._clipPath.removeSelfFromZr(t),this._textContent&&this._textContent.removeSelfFromZr(t),this._textGuide&&this._textGuide.removeSelfFromZr(t)}},t.prototype.animate=function(t,e,n){var i=t?this[t]:this,r=new Ci(i,e,n);return t&&(r.targetName=t),this.addAnimator(r,t),r},t.prototype.addAnimator=function(t,e){var n=this.__zr,i=this;t.during((function(){i.updateDuringAnimation(e)})).done((function(){var e=i.animators,n=L(e,t);n>=0&&e.splice(n,1)})),this.animators.push(t),n&&n.animation.addAnimator(t),n&&n.wakeUp()},t.prototype.updateDuringAnimation=function(t){this.markRedraw()},t.prototype.stopAnimation=function(t,e){for(var n=this.animators,i=n.length,r=[],o=0;o<i;o++){var a=n[o];t&&t!==a.scope?r.push(a):a.stop(e)}return this.animators=r,this},t.prototype.animateTo=function(t,e,n){Ir(this,t,e,n)},t.prototype.animateFrom=function(t,e,n){Ir(this,t,e,n,!0)},t.prototype._transitionState=function(t,e,n,i){for(var r=Ir(this,e,n,i),o=0;o<r.length;o++)r[o].__fromStateTransition=t},t.prototype.getBoundingRect=function(){return null},t.prototype.getPaintRect=function(){return null},t.initDefaultProps=function(){var e=t.prototype;function n(t,n,i,r){function o(t,e){Object.defineProperty(e,0,{get:function(){return t[i]},set:function(e){t[i]=e}}),Object.defineProperty(e,1,{get:function(){return t[r]},set:function(e){t[r]=e}})}Object.defineProperty(e,t,{get:function(){return this[n]||o(this,this[n]=[]),this[n]},set:function(t){this[i]=t[0],this[r]=t[1],this[n]=t,o(this,t)}})}e.type="element",e.name="",e.ignore=e.silent=e.isGroup=e.draggable=e.dragging=e.ignoreClip=e.__inHover=!1,e.__dirty=1,Object.defineProperty&&(n("position","_legacyPos","x","y"),n("scale","_legacyScale","scaleX","scaleY"),n("origin","_legacyOrigin","originX","originY"))}(),t}();function Ir(t,e,n,i,r){var o=[];Dr(t,"",t,e,n=n||{},i,o,r);var a=o.length,s=!1,l=n.done,u=n.aborted,h=function(){s=!0,--a<=0&&(s?l&&l():u&&u())},c=function(){--a<=0&&(s?l&&l():u&&u())};a||l&&l(),o.length>0&&n.during&&o[0].during((function(t,e){n.during(e)}));for(var p=0;p<o.length;p++){var d=o[p];h&&d.done(h),c&&d.aborted(c),n.force&&d.duration(n.duration),d.start(n.easing)}return o}function Tr(t,e,n){for(var i=0;i<n;i++)t[i]=e[i]}function Cr(t,e,n){if(O(e[n]))if(O(t[n])||(t[n]=[]),j(e[n])){var i=e[n].length;t[n].length!==i&&(t[n]=new e[n].constructor(i),Tr(t[n],e[n],i))}else{var r=e[n],o=t[n],a=r.length;if(O(r[0]))for(var s=r[0].length,l=0;l<a;l++)o[l]?Tr(o[l],r[l],s):o[l]=Array.prototype.slice.call(r[l]);else Tr(o,r,a);o.length=r.length}else t[n]=e[n]}function Dr(t,e,n,i,r,o,a,s){for(var l=V(i),u=r.duration,h=r.delay,c=r.additive,p=r.setToFinal,d=!U(o),f=t.animators,g=[],y=0;y<l.length;y++){var v=l[y],m=i[v];if(null!=m&&null!=n[v]&&(d||o[v]))if(!U(m)||O(m)||K(m))g.push(v);else{if(e){s||(n[v]=m,t.updateDuringAnimation(e));continue}Dr(t,v,n[v],m,r,o&&o[v],a,s)}else s||(n[v]=m,t.updateDuringAnimation(e),g.push(v))}var x=g.length;if(!c&&x)for(var _=0;_<f.length;_++)if((w=f[_]).targetName===e&&w.stopTracks(g)){var b=L(f,w);f.splice(b,1)}if(r.force||(g=z(g,(function(t){return e=i[t],r=n[t],!(e===r||O(e)&&O(r)&&function(t,e){var n=t.length;if(n!==e.length)return!1;for(var i=0;i<n;i++)if(t[i]!==e[i])return!1;return!0}(e,r));var e,r})),x=g.length),x>0||r.force&&!a.length){var w,S=void 0,M=void 0,I=void 0;if(s)for(M={},p&&(S={}),_=0;_<x;_++)M[v=g[_]]=n[v],p?S[v]=i[v]:n[v]=i[v];else if(p)for(I={},_=0;_<x;_++)I[v=g[_]]=_i(n[v]),Cr(n,i,v);(w=new Ci(n,!1,!1,c?z(f,(function(t){return t.targetName===e})):null)).targetName=e,r.scope&&(w.scope=r.scope),p&&S&&w.whenWithKeys(0,S,g),I&&w.whenWithKeys(0,I,g),w.whenWithKeys(null==u?500:u,s?M:i,g).delay(h||0),t.addAnimator(w,e),a.push(w)}}P(Mr,Bt),P(Mr,sr);const Ar=Mr;var kr=function(t){function e(e){var n=t.call(this)||this;return n.isGroup=!0,n._children=[],n.attr(e),n}return n(e,t),e.prototype.childrenRef=function(){return this._children},e.prototype.children=function(){return this._children.slice()},e.prototype.childAt=function(t){return this._children[t]},e.prototype.childOfName=function(t){for(var e=this._children,n=0;n<e.length;n++)if(e[n].name===t)return e[n]},e.prototype.childCount=function(){return this._children.length},e.prototype.add=function(t){return t&&t!==this&&t.parent!==this&&(this._children.push(t),this._doAdd(t)),this},e.prototype.addBefore=function(t,e){if(t&&t!==this&&t.parent!==this&&e&&e.parent===this){var n=this._children,i=n.indexOf(e);i>=0&&(n.splice(i,0,t),this._doAdd(t))}return this},e.prototype.replace=function(t,e){var n=L(this._children,t);return n>=0&&this.replaceAt(e,n),this},e.prototype.replaceAt=function(t,e){var n=this._children,i=n[e];if(t&&t!==this&&t.parent!==this&&t!==i){n[e]=t,i.parent=null;var r=this.__zr;r&&i.removeSelfFromZr(r),this._doAdd(t)}return this},e.prototype._doAdd=function(t){t.parent&&t.parent.remove(t),t.parent=this;var e=this.__zr;e&&e!==t.__zr&&t.addSelfToZr(e),e&&e.refresh()},e.prototype.remove=function(t){var e=this.__zr,n=this._children,i=L(n,t);return i<0||(n.splice(i,1),t.parent=null,e&&t.removeSelfFromZr(e),e&&e.refresh()),this},e.prototype.removeAll=function(){for(var t=this._children,e=this.__zr,n=0;n<t.length;n++){var i=t[n];e&&i.removeSelfFromZr(e),i.parent=null}return t.length=0,this},e.prototype.eachChild=function(t,e){for(var n=this._children,i=0;i<n.length;i++){var r=n[i];t.call(e,r,i)}return this},e.prototype.traverse=function(t,e){for(var n=0;n<this._children.length;n++){var i=this._children[n],r=t.call(e,i);i.isGroup&&!r&&i.traverse(t,e)}return this},e.prototype.addSelfToZr=function(e){t.prototype.addSelfToZr.call(this,e);for(var n=0;n<this._children.length;n++)this._children[n].addSelfToZr(e)},e.prototype.removeSelfFromZr=function(e){t.prototype.removeSelfFromZr.call(this,e);for(var n=0;n<this._children.length;n++)this._children[n].removeSelfFromZr(e)},e.prototype.getBoundingRect=function(t){for(var e=new Ce(0,0,0,0),n=t||this._children,i=[],r=null,o=0;o<n.length;o++){var a=n[o];if(!a.ignore&&!a.invisible){var s=a.getBoundingRect(),l=a.getLocalTransform(i);l?(Ce.applyTransform(e,s,l),(r=r||e.clone()).union(e)):(r=r||s.clone()).union(s)}}return r||e},e}(Ar);kr.prototype.type="group";const Lr=kr;
/*!
            * ZRender, a high performance 2d drawing library.
            *
            * Copyright (c) 2013, Baidu Inc.
            * All rights reserved.
            *
            * LICENSE
            * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
            */var Pr={},Or={},Rr=function(){function t(t,e,n){var i=this;this._sleepAfterStill=10,this._stillFrameAccum=0,this._needsRefresh=!0,this._needsRefreshHover=!0,this._darkMode=!1,n=n||{},this.dom=e,this.id=t;var r=new qe,a=n.renderer||"canvas";Pr[a]||(a=V(Pr)[0]),n.useDirtyRect=null!=n.useDirtyRect&&n.useDirtyRect;var s=new Pr[a](e,r,n,t),l=n.ssr||s.ssrOnly;this.storage=r,this.painter=s;var u,h=o.node||o.worker||l?null:new qi(s.getViewportRoot(),s.root),c=n.useCoarsePointer;(null==c||"auto"===c?o.touchEventsSupported:!!c)&&(u=Q(n.pointerSize,44)),this.handler=new Ve(r,s,h,s.root,u),this.animation=new ki({stage:{update:l?null:function(){return i._flush(!0)}}}),l||this.animation.start()}return t.prototype.add=function(t){t&&(this.storage.addRoot(t),t.addSelfToZr(this),this.refresh())},t.prototype.remove=function(t){t&&(this.storage.delRoot(t),t.removeSelfFromZr(this),this.refresh())},t.prototype.configLayer=function(t,e){this.painter.configLayer&&this.painter.configLayer(t,e),this.refresh()},t.prototype.setBackgroundColor=function(t){this.painter.setBackgroundColor&&this.painter.setBackgroundColor(t),this.refresh(),this._backgroundColor=t,this._darkMode=function(t){if(!t)return!1;if("string"==typeof t)return Kn(t,1)<.4;if(t.colorStops){for(var e=t.colorStops,n=0,i=e.length,r=0;r<i;r++)n+=Kn(e[r].color,1);return(n/=i)<.4}return!1}(t)},t.prototype.getBackgroundColor=function(){return this._backgroundColor},t.prototype.setDarkMode=function(t){this._darkMode=t},t.prototype.isDarkMode=function(){return this._darkMode},t.prototype.refreshImmediately=function(t){t||this.animation.update(!0),this._needsRefresh=!1,this.painter.refresh(),this._needsRefresh=!1},t.prototype.refresh=function(){this._needsRefresh=!0,this.animation.start()},t.prototype.flush=function(){this._flush(!1)},t.prototype._flush=function(t){var e,n=Di();this._needsRefresh&&(e=!0,this.refreshImmediately(t)),this._needsRefreshHover&&(e=!0,this.refreshHoverImmediately());var i=Di();e?(this._stillFrameAccum=0,this.trigger("rendered",{elapsedTime:i-n})):this._sleepAfterStill>0&&(this._stillFrameAccum++,this._stillFrameAccum>this._sleepAfterStill&&this.animation.stop())},t.prototype.setSleepAfterStill=function(t){this._sleepAfterStill=t},t.prototype.wakeUp=function(){this.animation.start(),this._stillFrameAccum=0},t.prototype.refreshHover=function(){this._needsRefreshHover=!0},t.prototype.refreshHoverImmediately=function(){this._needsRefreshHover=!1,this.painter.refreshHover&&"canvas"===this.painter.getType()&&this.painter.refreshHover()},t.prototype.resize=function(t){t=t||{},this.painter.resize(t.width,t.height),this.handler.resize()},t.prototype.clearAnimation=function(){this.animation.clear()},t.prototype.getWidth=function(){return this.painter.getWidth()},t.prototype.getHeight=function(){return this.painter.getHeight()},t.prototype.setCursorStyle=function(t){this.handler.setCursorStyle(t)},t.prototype.findHover=function(t,e){return this.handler.findHover(t,e)},t.prototype.on=function(t,e,n){return this.handler.on(t,e,n),this},t.prototype.off=function(t,e){this.handler.off(t,e)},t.prototype.trigger=function(t,e){this.handler.trigger(t,e)},t.prototype.clear=function(){for(var t=this.storage.getRoots(),e=0;e<t.length;e++)t[e]instanceof Lr&&t[e].removeSelfFromZr(this);this.storage.delAllRoots(),this.painter.clear()},t.prototype.dispose=function(){var t;this.animation.stop(),this.clear(),this.storage.dispose(),this.painter.dispose(),this.handler.dispose(),this.animation=this.storage=this.painter=this.handler=null,t=this.id,delete Or[t]},t}();function Nr(t,e){var n=new Rr(M(),t,e);return Or[n.id]=n,n}var Er=1e-4;// Although chrome already enlarge this number to 100 for `toFixed`, but
// we sill follow the spec for compatibility.
/**
             * Linear mapping a value from domain to range
             * @param  val
             * @param  domain Domain extent domain[0] can be bigger than domain[1]
             * @param  range  Range extent range[0] can be bigger than range[1]
             * @param  clamp Default to be false
             */
function zr(t,e,n,i){var r=e[0],o=e[1],a=n[0],s=n[1],l=o-r,u=s-a;if(0===l)return 0===u?a:(a+s)/2;// Avoid accuracy problem in edge, such as
// 146.39 - 62.83 === 83.55999999999999.
// See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
// It is a little verbose for efficiency considering this method
// is a hotspot.
if(i)if(l>0){if(t<=r)return a;if(t>=o)return s}else{if(t>=r)return a;if(t<=o)return s}else{if(t===r)return a;if(t===o)return s}return(t-r)/l*u+a}
/**
             * Convert a percent string to absolute number.
             * Returns NaN if percent is not a valid string or number
             */function Vr(t,e){switch(t){case"center":case"middle":t="50%";break;case"left":case"top":t="0%";break;case"right":case"bottom":t="100%"}return H(t)?(n=t,n.replace(/^\s+|\s+$/g,"")).match(/%$/)?parseFloat(t)/100*e:parseFloat(t):null==t?NaN:+t;var n}function Br(t,e,n){return null==e&&(e=10),// Avoid range error
e=Math.min(Math.max(0,e),20),// PENDING: 1.005.toFixed(2) is '1.00' rather than '1.01'
t=(+t).toFixed(e),n?t:+t}
/**
             * Inplacd asc sort arr.
             * The input arr will be modified.
             */function Fr(t){return t.sort((function(t,e){return t-e})),t}
/**
             * Get precision.
             */function Gr(t){if(t=+t,isNaN(t))return 0;// It is much faster than methods converting number to string as follows
//      let tmp = val.toString();
//      return tmp.length - 1 - tmp.indexOf('.');
// especially when precision is low
// Notice:
// (1) If the loop count is over about 20, it is slower than `getPrecisionSafe`.
//     (see https://jsbench.me/2vkpcekkvw/1)
// (2) If the val is less than for example 1e-15, the result may be incorrect.
//     (see test/ut/spec/util/number.test.ts `getPrecision_equal_random`)
if(t>1e-14)for(var e=1,n=0;n<15;n++,e*=10)if(Math.round(t*e)/e===t)return n;
/**
             * Get precision with slow but safe method
             */return function(t){// toLowerCase for: '3.4E-12'
var e=t.toString().toLowerCase(),n=e.indexOf("e"),i=n>0?+e.slice(n+1):0,r=n>0?n:e.length,o=e.indexOf("."),a=o<0?0:r-1-o;// Consider scientific notation: '3.4e-12' '3.4e+12'
return Math.max(0,a-i)}
/**
             * Minimal dicernible data precisioin according to a single pixel.
             */(t)}function Wr(t,e){var n=Math.log,i=Math.LN10,r=Math.floor(n(t[1]-t[0])/i),o=Math.round(n(Math.abs(e[1]-e[0]))/i),a=Math.min(Math.max(-r+o,0),20);return isFinite(a)?a:20}
/**
             * Get a data of given precision, assuring the sum of percentages
             * in valueList is 1.
             * The largest remainder method is used.
             * https://en.wikipedia.org/wiki/Largest_remainder_method
             *
             * @param valueList a list of all data
             * @param precision integer number showing digits of precision
             * @return {Array<number>}
             */
/**
             * Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004
             * See <http://0.30000000000000004.com/>
             */
function Hr(t,e){var n=Math.max(Gr(t),Gr(e)),i=t+e;// const multiplier = Math.pow(10, maxPrecision);
// return (Math.round(val0 * multiplier) + Math.round(val1 * multiplier)) / multiplier;
// // PENDING: support more?
return n>20?i:Br(i,n)}// Number.MAX_SAFE_INTEGER, ie do not support.
var Yr=9007199254740991;
/**
             * To 0 - 2 * PI, considering negative radian.
             */function Xr(t){var e=2*Math.PI;return(t%e+e)%e}
/**
             * @param {type} radian
             * @return {boolean}
             */function Ur(t){return t>-1e-4&&t<Er}// eslint-disable-next-line
var Zr=/^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;// jshint ignore:line
/**
             * @param value valid type: number | string | Date, otherwise return `new Date(NaN)`
             *   These values can be accepted:
             *   + An instance of Date, represent a time in its own time zone.
             *   + Or string in a subset of ISO 8601, only including:
             *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
             *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
             *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
             *     all of which will be treated as local time if time zone is not specified
             *     (see <https://momentjs.com/>).
             *   + Or other string format, including (all of which will be treated as local time):
             *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
             *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
             *   + a timestamp, which represent a time in UTC.
             * @return date Never be null/undefined. If invalid, return `new Date(NaN)`.
             */function jr(t){if(t instanceof Date)return t;if(H(t)){// Different browsers parse date in different way, so we parse it manually.
// Some other issues:
// new Date('1970-01-01') is UTC,
// new Date('1970/01/01') and new Date('1970-1-01') is local.
// See issue #3623
var e=Zr.exec(t);if(!e)// return Invalid Date.
return new Date(NaN);// Use local time when no timezone offset is specified.
if(e[8]){var n=+e[4]||0;return"Z"!==e[8].toUpperCase()&&(n-=+e[8].slice(0,3)),new Date(Date.UTC(+e[1],+(e[2]||1)-1,+e[3]||1,n,+(e[5]||0),+e[6]||0,e[7]?+e[7].substring(0,3):0))}// match[n] can only be string or undefined.
// But take care of '12' + 1 => '121'.
return new Date(+e[1],+(e[2]||1)-1,+e[3]||1,+e[4]||0,+(e[5]||0),+e[6]||0,e[7]?+e[7].substring(0,3):0)}return null==t?new Date(NaN):new Date(Math.round(t))}
/**
             * Quantity of a number. e.g. 0.1, 1, 10, 100
             *
             * @param val
             * @return
             */
/**
             * Exponent of the quantity of a number
             * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
             *
             * @param val non-negative value
             * @return
             */
function qr(t){if(0===t)return 0;var e=Math.floor(Math.log(t)/Math.LN10);
/**
               * exp is expected to be the rounded-down result of the base-10 log of val.
               * But due to the precision loss with Math.log(val), we need to restore it
               * using 10^exp to make sure we can get val back from exp. #11249
               */return t/Math.pow(10,e)>=10&&e++,e}
/**
             * find a nice number approximately equal to x. Round the number if round = true,
             * take ceiling if round = false. The primary observation is that the nicest
             * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
             *
             * See "Nice Numbers for Graph Labels" of Graphic Gems.
             *
             * @param  val Non-negative value.
             * @param  round
             * @return Niced number
             */function Kr(t,e){var n=qr(t),i=Math.pow(10,n),r=t/i;// Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
// 20 is the uppper bound of toFixed.
return t=(e?r<1.5?1:r<2.5?2:r<4?3:r<7?5:10:r<1?1:r<2?2:r<3?3:r<5?5:10)*i,n>=-20?+t.toFixed(n<0?-n:0):t}
/**
             * This code was copied from "d3.js"
             * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
             * See the license statement at the head of this file.
             * @param ascArr
             */function $r(t,e){var n=(t.length-1)*e+1,i=Math.floor(n),r=+t[i-1],o=n-i;return o?r+o*(t[i]-r):r}
/**
             * Order intervals asc, and split them when overlap.
             * expect(numberUtil.reformIntervals([
             *     {interval: [18, 62], close: [1, 1]},
             *     {interval: [-Infinity, -70], close: [0, 0]},
             *     {interval: [-70, -26], close: [1, 1]},
             *     {interval: [-26, 18], close: [1, 1]},
             *     {interval: [62, 150], close: [1, 1]},
             *     {interval: [106, 150], close: [1, 1]},
             *     {interval: [150, Infinity], close: [0, 0]}
             * ])).toEqual([
             *     {interval: [-Infinity, -70], close: [0, 0]},
             *     {interval: [-70, -26], close: [1, 1]},
             *     {interval: [-26, 18], close: [0, 1]},
             *     {interval: [18, 62], close: [0, 1]},
             *     {interval: [62, 150], close: [0, 1]},
             *     {interval: [150, Infinity], close: [0, 0]}
             * ]);
             * @param list, where `close` mean open or close
             *        of the interval, and Infinity can be used.
             * @return The origin list, which has been reformed.
             */function Jr(t){t.sort((function(t,e){return s(t,e,0)?-1:1}));for(var e=-1/0,n=1,i=0;i<t.length;){for(var r=t[i].interval,o=t[i].close,a=0;a<2;a++)r[a]<=e&&(r[a]=e,o[a]=a?1:1-n),e=r[a],n=o[a];r[0]===r[1]&&o[0]*o[1]!=1?t.splice(i,1):i++}return t;function s(t,e,n){return t.interval[n]<e.interval[n]||t.interval[n]===e.interval[n]&&(t.close[n]-e.close[n]==(n?-1:1)||!n&&s(t,e,1))}}
/**
             * [Numeric is defined as]:
             *     `parseFloat(val) == val`
             * For example:
             * numeric:
             *     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,
             *     and they rounded by white-spaces or line-terminal like ' -123 \n ' (see es spec)
             * not-numeric:
             *     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',
             *     empty string, string with only white-spaces or line-terminal (see es spec),
             *     0x12, '0x12', '-0x12', 012, '012', '-012',
             *     non-string, ...
             *
             * @test See full test cases in `test/ut/spec/util/number.js`.
             * @return Must be a typeof number. If not numeric, return NaN.
             */function Qr(t){var e=parseFloat(t);return e==t&&(0!==e||!H(t)||t.indexOf("x")<=0)?e:NaN}
/**
             * Definition of "numeric": see `numericToNumber`.
             */function to(t){return!isNaN(Qr(t))}
/**
             * Use random base to prevent users hard code depending on
             * this auto generated marker id.
             * @return An positive integer.
             */function eo(){return Math.round(9*Math.random())}
/**
             * Get the greatest common divisor.
             *
             * @param {number} a one number
             * @param {number} b the other number
             */function no(t,e){return 0===e?t:no(e,t%e)}
/**
             * Get the least common multiple.
             *
             * @param {number} a one number
             * @param {number} b the other number
             */function io(t,e){return null==t?e:null==e?t:t*e/no(t,e)}
/**
             * @throws Error
             */
function ro(t){throw new Error(t)}function oo(t,e,n){return(e-t)*n+t}
/**
             * Make the name displayable. But we should
             * make sure it is not duplicated with user
             * specified name, so use '\0';
             */"undefined"!=typeof console&&console.warn&&console.log;var ao="series\0",so="\0_ec_\0";
/**
             * If value is not array, then translate it to array.
             * @param  {*} value
             * @return {Array} [value] or value
             */
function lo(t){return t instanceof Array?t:null==t?[]:[t]}
/**
             * Sync default option between normal and emphasis like `position` and `show`
             * In case some one will write code like
             *     label: {
             *          show: false,
             *          position: 'outside',
             *          fontSize: 18
             *     },
             *     emphasis: {
             *          label: { show: true }
             *     }
             */function uo(t,e,n){// Caution: performance sensitive.
if(t){t[e]=t[e]||{},t.emphasis=t.emphasis||{},t.emphasis[e]=t.emphasis[e]||{};// Default emphasis option from normal
for(var i=0,r=n.length;i<r;i++){var o=n[i];!t.emphasis[e].hasOwnProperty(o)&&t[e].hasOwnProperty(o)&&(t.emphasis[e][o]=t[e][o])}}}var ho=["fontStyle","fontWeight","fontSize","fontFamily","rich","tag","color","textBorderColor","textBorderWidth","width","height","lineHeight","align","verticalAlign","baseline","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","backgroundColor","borderColor","borderWidth","borderRadius","padding"];// modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);
/**
             * The method does not ensure performance.
             * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
             * This helper method retrieves value from data.
             */function co(t){return!U(t)||G(t)||t instanceof Date?t:t.value}
/**
             * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
             * This helper method determine if dataItem has extra option besides value
             */function po(t){return U(t)&&!(t instanceof Array);// // markLine data can be array
// && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}
/**
             * Mapping to existings for merge.
             *
             * Mode "normalMege":
             *     The mapping result (merge result) will keep the order of the existing
             *     component, rather than the order of new option. Because we should ensure
             *     some specified index reference (like xAxisIndex) keep work.
             *     And in most cases, "merge option" is used to update partial option but not
             *     be expected to change the order.
             *
             * Mode "replaceMege":
             *     (1) Only the id mapped components will be merged.
             *     (2) Other existing components (except internal components) will be removed.
             *     (3) Other new options will be used to create new component.
             *     (4) The index of the existing components will not be modified.
             *     That means their might be "hole" after the removal.
             *     The new components are created first at those available index.
             *
             * Mode "replaceAll":
             *     This mode try to support that reproduce an echarts instance from another
             *     echarts instance (via `getOption`) in some simple cases.
             *     In this scenario, the `result` index are exactly the consistent with the `newCmptOptions`,
             *     which ensures the component index referring (like `xAxisIndex: ?`) corrent. That is,
             *     the "hole" in `newCmptOptions` will also be kept.
             *     On the contrary, other modes try best to eliminate holes.
             *     PENDING: This is an experimental mode yet.
             *
             * @return See the comment of <MappingResult>.
             */function fo(t,e,n){var i="normalMerge"===n,r="replaceMerge"===n,o="replaceAll"===n;t=t||[],e=(e||[]).slice();var a=ct();// Validate id and name on user input option.
R(e,(function(t,n){U(t)||(e[n]=null)}));var s,l,u=function(t,e,n){var i=[];if("replaceAll"===n)return i;// Do not use native `map` to in case that the array `existings`
// contains elided items, which will be omitted.
for(var r=0;r<t.length;r++){var o=t[r];// Because of replaceMerge, `existing` may be null/undefined.
o&&null!=o.id&&e.set(o.id,r),// For non-internal-componnets:
//     Mode "normalMerge": all existings kept.
//     Mode "replaceMerge": all existing removed unless mapped by id.
// For internal-components:
//     go with "replaceMerge" approach in both mode.
i.push({existing:"replaceMerge"===n||xo(o)?null:o,newOption:null,keyInfo:null,brandNew:null})}return i}(t,a,n);// The array `result` MUST NOT contain elided items, otherwise the
// forEach will omit those items and result in incorrect result.
return(i||r)&&function(t,e,n,i){// Mapping by id if specified.
R(i,(function(r,o){if(r&&null!=r.id){var a=yo(r.id),s=n.get(a);if(null!=s){var l=t[s];it(!l.newOption,'Duplicated option on id "'+a+'".'),l.newOption=r,// In both mode, if id matched, new option will be merged to
// the existings rather than creating new component model.
l.existing=e[s],i[o]=null}}}))}(u,t,a,e),i&&function(t,e){// Mapping by name if specified.
R(e,(function(n,i){if(n&&null!=n.name)for(var r=0;r<t.length;r++){var o=t[r].existing;if(!t[r].newOption&&o&&(null==o.id||null==n.id)&&!xo(n)&&!xo(o)&&go("name",o,n))return t[r].newOption=n,void(e[i]=null)}}))}(u,e),i||r?function(t,e,n){R(e,(function(e){if(e){for(// Find the first place that not mapped by id and not internal component (consider the "hole").
var i,r=0;// Be `!resultItem` only when `nextIdx >= result.length`.
(i=t[r])&&(// (1) Existing models that already have id should be able to mapped to. Because
// after mapping performed, model will always be assigned with an id if user not given.
// After that all models have id.
// (2) If new option has id, it can only set to a hole or append to the last. It should
// not be merged to the existings with different id. Because id should not be overwritten.
// (3) Name can be overwritten, because axis use name as 'show label text'.
i.newOption||xo(i.existing)||// In mode "replaceMerge", here no not-mapped-non-internal-existing.
i.existing&&null!=e.id&&!go("id",e,i.existing));)r++;i?(i.newOption=e,i.brandNew=n):t.push({newOption:e,brandNew:n,existing:null,keyInfo:null}),r++}}))}(u,e,r):o&&function(t,e){R(e,(function(e){// The feature "reproduce" requires "hole" will also reproduced
// in case that component index referring are broken.
t.push({newOption:e,brandNew:!0,existing:null,keyInfo:null})}))}
/**
             * Make id and name for mapping result (result of mappingToExists)
             * into `keyInfo` field.
             */(u,e),s=u,l=ct(),R(s,(function(t){var e=t.existing;e&&l.set(e.id,t)})),R(s,(function(t){var e=t.newOption;// Force ensure id not duplicated.
it(!e||null==e.id||!l.get(e.id)||l.get(e.id)===t,"id duplicates: "+(e&&e.id)),e&&null!=e.id&&l.set(e.id,t),!t.keyInfo&&(t.keyInfo={})})),// Make name and id.
R(s,(function(t,e){var n=t.existing,i=t.newOption,r=t.keyInfo;if(U(i)){if(// Name can be overwritten. Consider case: axis.name = '20km'.
// But id generated by name will not be changed, which affect
// only in that case: setOption with 'not merge mode' and view
// instance will be recreated, which can be accepted.
r.name=null!=i.name?yo(i.name):n?n.name:ao+e,n)r.id=yo(n.id);else if(null!=i.id)r.id=yo(i.id);else{// Consider this situatoin:
//  optionA: [{name: 'a'}, {name: 'a'}, {..}]
//  optionB [{..}, {name: 'a'}, {name: 'a'}]
// Series with the same name between optionA and optionB
// should be mapped.
var o=0;do{r.id="\0"+r.name+"\0"+o++}while(l.get(r.id))}l.set(r.id,t)}})),u}function go(t,e,n){var i=vo(e[t],null),r=vo(n[t],null);// See `MappingExistingItem`. `id` and `name` trade string equals to number.
return null!=i&&null!=r&&i===r}
/**
             * @return return null if not exist.
             */function yo(t){return vo(t,"")}function vo(t,e){return null==t?e:H(t)?t:X(t)||Y(t)?t+"":e}function mo(t){var e=t.name;// Is specified when `indexOf` get -1 or > 0.
return!(!e||!e.indexOf(ao))}
/**
             * @public
             * @param {Object} cmptOption
             * @return {boolean}
             */function xo(t){return t&&null!=t.id&&0===yo(t.id).indexOf(so)}
/**
             * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name
             *                         each of which can be Array or primary type.
             * @return dataIndex If not found, return undefined/null.
             */
function _o(t,e){return null!=e.dataIndexInside?e.dataIndexInside:null!=e.dataIndex?G(e.dataIndex)?N(e.dataIndex,(function(e){return t.indexOfRawIndex(e)})):t.indexOfRawIndex(e.dataIndex):null!=e.name?G(e.name)?N(e.name,(function(e){return t.indexOfName(e)})):t.indexOfName(e.name):void 0}
/**
             * Enable property storage to any host object.
             * Notice: Serialization is not supported.
             *
             * For example:
             * let inner = zrUitl.makeInner();
             *
             * function some1(hostObj) {
             *      inner(hostObj).someProperty = 1212;
             *      ...
             * }
             * function some2() {
             *      let fields = inner(this);
             *      fields.someProperty1 = 1212;
             *      fields.someProperty2 = 'xx';
             *      ...
             * }
             *
             * @return {Function}
             */function bo(){var t="__ec_inner_"+wo++;return function(e){return e[t]||(e[t]={})}}var wo=eo();
/**
             * The same behavior as `component.getReferringComponents`.
             */function So(t,e,n){var i=Mo(e,n),r=i.mainTypeSpecified,o=i.queryOptionMap,a=i.others,s=n?n.defaultMainType:null;return!r&&s&&o.set(s,{}),o.each((function(e,i){var r=Co(t,i,e,{useDefault:s===i,enableAll:!n||null==n.enableAll||n.enableAll,enableNone:!n||null==n.enableNone||n.enableNone});a[i+"Models"]=r.models,a[i+"Model"]=r.models[0]})),a}function Mo(t,e){var n;if(H(t)){var i={};i[t+"Index"]=0,n=i}else n=t;var r=ct(),o={},a=!1;return R(n,(function(t,n){// Exclude 'dataIndex' and other illgal keys.
if("dataIndex"!==n&&"dataIndexInside"!==n){var i=n.match(/^(\w+)(Index|Id|Name)$/)||[],s=i[1],l=(i[2]||"").toLowerCase();!s||!l||e&&e.includeMainTypes&&L(e.includeMainTypes,s)<0||(a=a||!!s,(r.get(s)||r.set(s,{}))[l]=t)}else o[n]=t})),{mainTypeSpecified:a,queryOptionMap:r,others:o}}var Io={useDefault:!0,enableAll:!1,enableNone:!1},To={useDefault:!1,enableAll:!0,enableNone:!0};function Co(t,e,n,i){i=i||Io;var r=n.index,o=n.id,a=n.name,s={models:null,specified:null!=r||null!=o||null!=a};if(!s.specified){// Use the first as default if `useDefault`.
var l=void 0;return s.models=i.useDefault&&(l=t.getComponent(e))?[l]:[],s}return"none"===r||!1===r?(it(i.enableNone,'`"none"` or `false` is not a valid value on index option.'),s.models=[],s):(// `queryComponents` will return all components if
// both all of index/id/name are null/undefined.
"all"===r&&(it(i.enableAll,'`"all"` is not a valid value on index option.'),r=o=a=null),s.models=t.queryComponents({mainType:e,index:r,id:o,name:a}),s)}function Do(t,e,n){t.setAttribute?t.setAttribute(e,n):t[e]=n}
/**
             * Group a list by key.
             */
function Ao(t,e){var n=ct(),i=[];return R(t,(function(t){var r=e(t);(n.get(r)||(i.push(r),n.set(r,[]))).push(t)})),{keys:i,buckets:n}}
/**
             * Interpolate raw values of a series with percent
             *
             * @param data         data
             * @param labelModel   label model of the text element
             * @param sourceValue  start value. May be null/undefined when init.
             * @param targetValue  end value
             * @param percent      0~1 percentage; 0 uses start value while 1 uses end value
             * @return             interpolated values
             *                     If `sourceValue` and `targetValue` are `number`, return `number`.
             *                     If `sourceValue` and `targetValue` are `string`, return `string`.
             *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.
             *                     Other cases do not supported.
             */function ko(t,e,n,i,r){var o=null==e||"auto"===e;if(null==i)return i;if(X(i))return Br(f=oo(n||0,i,r),o?Math.max(Gr(n||0),Gr(i)):e);if(H(i))return r<1?n:i;for(var a=[],s=n,l=i,u=Math.max(s?s.length:0,l.length),h=0;h<u;++h){var c=t.getDimensionInfo(h);// Don't interpolate ordinal dims
if(c&&"ordinal"===c.type)// In init, there is no `sourceValue`, but should better not to get undefined result.
a[h]=(r<1&&s?s:l)[h];else{var p=s&&s[h]?s[h]:0,d=l[h],f=oo(p,d,r);a[h]=Br(f,o?Math.max(Gr(p),Gr(d)):e)}}return a}var Lo="___EC__COMPONENT__CONTAINER___",Po="___EC__EXTENDED_CLASS___";
/**
             * Notice, parseClassType('') should returns {main: '', sub: ''}
             * @public
             */
function Oo(t){var e={main:"",sub:""};if(t){var n=t.split(".");e.main=n[0]||"",e.sub=n[1]||""}return e}
/**
             * @public
             */
/**
             * Implements `ExtendableConstructor` for `rootClz`.
             *
             * @usage
             * ```ts
             * class Xxx {}
             * type XxxConstructor = typeof Xxx & ExtendableConstructor
             * enableClassExtend(Xxx as XxxConstructor);
             * ```
             */
function Ro(t,e){t.$constructor=t,// FIXME: not necessary?
t.extend=function(t){var e,i,r=this;return W(i=r)&&/^class\s/.test(Function.prototype.toString.call(i))?e=/** @class */function(t){function e(){return t.apply(this,arguments)||this}return n(e,t),e}(r):(// For backward compat, we both support ts class inheritance and this
// "extend" approach.
// The constructor should keep the same behavior as ts class inheritance:
// If this constructor/$constructor is not declared, auto invoke the super
// constructor.
// If this constructor/$constructor is declared, it is responsible for
// calling the super constructor.
e=function(){(t.$constructor||r).apply(this,arguments)},function(t,e){var n=t.prototype;function i(){}for(var r in i.prototype=e.prototype,t.prototype=new i,n)n.hasOwnProperty(r)&&(t.prototype[r]=n[r]);t.prototype.constructor=t,t.superClass=e}(e,this)),A(e.prototype,t),e[Po]=!0,e.extend=this.extend,e.superCall=zo,e.superApply=Vo,e.superClass=r,e}}
/**
             * A work around to both support ts extend and this extend mechanism.
             * on sub-class.
             * @usage
             * ```ts
             * class Component { ... }
             * classUtil.enableClassExtend(Component);
             * classUtil.enableClassManagement(Component, {registerWhenExtend: true});
             *
             * class Series extends Component { ... }
             * // Without calling `markExtend`, `registerWhenExtend` will not work.
             * Component.markExtend(Series);
             * ```
             */
function No(t,e){t.extend=e.extend}// A random offset.
var Eo=Math.round(10*Math.random());
/**
             * Implements `CheckableConstructor` for `target`.
             * Can not use instanceof, consider different scope by
             * cross domain or es module import in ec extensions.
             * Mount a method "isInstance()" to Clz.
             *
             * @usage
             * ```ts
             * class Xxx {}
             * type XxxConstructor = typeof Xxx & CheckableConstructor;
             * enableClassCheck(Xxx as XxxConstructor)
             * ```
             */ // superCall should have class info, which can not be fetched from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, does not override method f,
// then when method of class C is called, dead loop occurred.
function zo(t,e){for(var n=[],i=2;i<arguments.length;i++)n[i-2]=arguments[i];return this.superClass.prototype[e].apply(t,n)}function Vo(t,e,n){return this.superClass.prototype[e].apply(t,n)}
/**
             * Implements `ClassManager` for `target`
             *
             * @usage
             * ```ts
             * class Xxx {}
             * type XxxConstructor = typeof Xxx & ClassManager
             * enableClassManagement(Xxx as XxxConstructor);
             * ```
             */function Bo(t){
/**
               * Component model classes
               * key: componentType,
               * value:
               *     componentClass, when componentType is 'a'
               *     or Object.<subKey, componentClass>, when componentType is 'a.b'
               */
var e={};t.registerClass=function(t){// `type` should not be a "instance member".
// If using TS class, should better declared as `static type = 'series.pie'`.
// otherwise users have to mount `type` on prototype manually.
// For backward compat and enable instance visit type via `this.type`,
// we still support fetch `type` from prototype.
var n,i=t.type||t.prototype.type;if(i){it(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n=i),'componentType "'+n+'" illegal'),// If only static type declared, we assign it to prototype mandatorily.
t.prototype.type=i;var r=Oo(i);if(r.sub){if(r.sub!==Lo){var o=function(t){var n=e[t.main];return n&&n[Lo]||((n=e[t.main]={})[Lo]=!0),n}(r);o[r.sub]=t}}else e[r.main]=t}return t},t.getClass=function(t,n,i){var r=e[t];if(r&&r[Lo]&&(r=n?r[n]:null),i&&!r)throw new Error(n?"Component "+t+"."+(n||"")+" is used but not imported.":t+".type should be specified.");return r},t.getClassesByMainType=function(t){var n=Oo(t),i=[],r=e[n.main];return r&&r[Lo]?R(r,(function(t,e){e!==Lo&&i.push(t)})):i.push(r),i},t.hasClass=function(t){// Just consider componentType.main.
var n=Oo(t);return!!e[n.main]},
/**
               * @return Like ['aa', 'bb'], but can not be ['aa.xx']
               */
t.getAllClassMainTypes=function(){var t=[];return R(e,(function(e,n){t.push(n)})),t},
/**
               * If a main type is container and has sub types
               */
t.hasSubTypes=function(t){var n=Oo(t),i=e[n.main];return i&&i[Lo]}}// /**
//  * @param {string|Array.<string>} properties
//  */
// export function setReadOnly(obj, properties) {
// FIXME It seems broken in IE8 simulation of IE11
// if (!zrUtil.isArray(properties)) {
//     properties = properties != null ? [properties] : [];
// }
// zrUtil.each(properties, function (prop) {
//     let value = obj[prop];
//     Object.defineProperty
//         && Object.defineProperty(obj, prop, {
//             value: value, writable: false
//         });
//     zrUtil.isArray(obj[prop])
//         && Object.freeze
//         && Object.freeze(obj[prop]);
// });
// }
function Fo(t,e){// Normalize
for(var n=0;n<t.length;n++)t[n][1]||(t[n][1]=t[n][0]);return e=e||!1,function(n,i,r){for(var o={},a=0;a<t.length;a++){var s=t[a][1];if(!(i&&L(i,s)>=0||r&&L(r,s)<0)){var l=n.getShallow(s,e);null!=l&&(o[t[a][0]]=l)}}// TODO Text or image?
return o}}var Go=Fo([["fill","color"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["opacity"],["shadowColor"]]),Wo=/** @class */function(){function t(){}return t.prototype.getAreaStyle=function(t,e){return Go(this,t,e)},t}(),Ho=new kn(50);function Yo(t){if("string"==typeof t){var e=Ho.get(t);return e&&e.image}return t}function Xo(t,e,n,i,r){if(t){if("string"==typeof t){if(e&&e.__zrImageSrc===t||!n)return e;var o=Ho.get(t),a={hostEl:n,cb:i,cbPayload:r};return o?!Zo(e=o.image)&&o.pending.push(a):((e=c.loadImage(t,Uo,Uo)).__zrImageSrc=t,Ho.put(t,e.__cachedImgObj={image:e,pending:[a]})),e}return t}return e}function Uo(){var t=this.__cachedImgObj;this.onload=this.onerror=this.__cachedImgObj=null;for(var e=0;e<t.pending.length;e++){var n=t.pending[e],i=n.cb;i&&i(this,n.cbPayload),n.hostEl.dirty()}t.pending.length=0}function Zo(t){return t&&t.width&&t.height}var jo=/\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;function qo(t,e,n,i,r){if(!e)return"";var o=(t+"").split("\n");r=Ko(e,n,i,r);for(var a=0,s=o.length;a<s;a++)o[a]=$o(o[a],r);return o.join("\n")}function Ko(t,e,n,i){var r=A({},i=i||{});r.font=e,n=Q(n,"..."),r.maxIterations=Q(i.maxIterations,2);var o=r.minChar=Q(i.minChar,0);r.cnCharWidth=cr("",e);var a=r.ascCharWidth=cr("a",e);r.placeholder=Q(i.placeholder,"");for(var s=t=Math.max(0,t-1),l=0;l<o&&s>=a;l++)s-=a;var u=cr(n,e);return u>s&&(n="",u=0),s=t-u,r.ellipsis=n,r.ellipsisWidth=u,r.contentWidth=s,r.containerWidth=t,r}function $o(t,e){var n=e.containerWidth,i=e.font,r=e.contentWidth;if(!n)return"";var o=cr(t,i);if(o<=n)return t;for(var a=0;;a++){if(o<=r||a>=e.maxIterations){t+=e.ellipsis;break}var s=0===a?Jo(t,r,e.ascCharWidth,e.cnCharWidth):o>0?Math.floor(t.length*r/o):0;o=cr(t=t.substr(0,s),i)}return""===t&&(t=e.placeholder),t}function Jo(t,e,n,i){for(var r=0,o=0,a=t.length;o<a&&r<e;o++){var s=t.charCodeAt(o);r+=0<=s&&s<=127?n:i}return o}var Qo=function(){},ta=function(t){this.tokens=[],t&&(this.tokens=t)},ea=function(){this.width=0,this.height=0,this.contentWidth=0,this.contentHeight=0,this.outerWidth=0,this.outerHeight=0,this.lines=[]};function na(t,e,n,i,r){var o,a,s=""===e,l=r&&n.rich[r]||{},u=t.lines,h=l.font||n.font,c=!1;if(i){var p=l.padding,d=p?p[1]+p[3]:0;if(null!=l.width&&"auto"!==l.width){var f=vr(l.width,i.width)+d;u.length>0&&f+i.accumWidth>i.width&&(o=e.split("\n"),c=!0),i.accumWidth=f}else{var g=oa(e,h,i.width,i.breakAll,i.accumWidth);i.accumWidth=g.accumWidth+d,a=g.linesWidths,o=g.lines}}else o=e.split("\n");for(var y=0;y<o.length;y++){var v=o[y],m=new Qo;if(m.styleName=r,m.text=v,m.isLineHolder=!v&&!s,"number"==typeof l.width?m.width=l.width:m.width=a?a[y]:cr(v,h),y||c)u.push(new ta([m]));else{var x=(u[u.length-1]||(u[0]=new ta)).tokens,_=x.length;1===_&&x[0].isLineHolder?x[0]=m:(v||!_||s)&&x.push(m)}}}var ia=E(",&?/;] ".split(""),(function(t,e){return t[e]=!0,t}),{});function ra(t){return!function(t){var e=t.charCodeAt(0);return e>=33&&e<=383}(t)||!!ia[t]}function oa(t,e,n,i,r){for(var o=[],a=[],s="",l="",u=0,h=0,c=0;c<t.length;c++){var p=t.charAt(c);if("\n"!==p){var d=cr(p,e),f=!i&&!ra(p);(o.length?h+d>n:r+h+d>n)?h?(s||l)&&(f?(s||(s=l,l="",h=u=0),o.push(s),a.push(h-u),l+=p,s="",h=u+=d):(l&&(s+=l,l="",u=0),o.push(s),a.push(h),s=p,h=d)):f?(o.push(l),a.push(u),l=p,u=d):(o.push(p),a.push(d)):(h+=d,f?(l+=p,u+=d):(l&&(s+=l,l="",u=0),s+=p))}else l&&(s+=l,h+=u),o.push(s),a.push(h),s="",l="",u=0,h=0}return o.length||s||(s=t,l="",u=0),l&&(s+=l),s&&(o.push(s),a.push(h)),1===o.length&&(h+=r),{accumWidth:h,lines:o,linesWidths:a}}var aa="__zr_style_"+Math.round(10*Math.random()),sa={shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,shadowColor:"#000",opacity:1,blend:"source-over"},la={style:{shadowBlur:!0,shadowOffsetX:!0,shadowOffsetY:!0,shadowColor:!0,opacity:!0}};sa[aa]=!0;var ua=["z","z2","invisible"],ha=["invisible"],ca=function(t){function e(e){return t.call(this,e)||this}var i;return n(e,t),e.prototype._init=function(e){for(var n=V(e),i=0;i<n.length;i++){var r=n[i];"style"===r?this.useStyle(e[r]):t.prototype.attrKV.call(this,r,e[r])}this.style||this.useStyle({})},e.prototype.beforeBrush=function(){},e.prototype.afterBrush=function(){},e.prototype.innerBeforeBrush=function(){},e.prototype.innerAfterBrush=function(){},e.prototype.shouldBePainted=function(t,e,n,i){var r,o,a,s=this.transform;if(this.ignore||this.invisible||0===this.style.opacity||this.culling&&(r=this,o=t,a=e,pa.copy(r.getBoundingRect()),r.transform&&pa.applyTransform(r.transform),da.width=o,da.height=a,!pa.intersect(da))||s&&!s[0]&&!s[3])return!1;if(n&&this.__clipPaths)for(var l=0;l<this.__clipPaths.length;++l)if(this.__clipPaths[l].isZeroArea())return!1;if(i&&this.parent)for(var u=this.parent;u;){if(u.ignore)return!1;u=u.parent}return!0},e.prototype.contain=function(t,e){return this.rectContain(t,e)},e.prototype.traverse=function(t,e){t.call(e,this)},e.prototype.rectContain=function(t,e){var n=this.transformCoordToLocal(t,e);return this.getBoundingRect().contain(n[0],n[1])},e.prototype.getPaintRect=function(){var t=this._paintRect;if(!this._paintRect||this.__dirty){var e=this.transform,n=this.getBoundingRect(),i=this.style,r=i.shadowBlur||0,o=i.shadowOffsetX||0,a=i.shadowOffsetY||0;t=this._paintRect||(this._paintRect=new Ce(0,0,0,0)),e?Ce.applyTransform(t,n,e):t.copy(n),(r||o||a)&&(t.width+=2*r+Math.abs(o),t.height+=2*r+Math.abs(a),t.x=Math.min(t.x,t.x+o-r),t.y=Math.min(t.y,t.y+a-r));var s=this.dirtyRectTolerance;t.isZero()||(t.x=Math.floor(t.x-s),t.y=Math.floor(t.y-s),t.width=Math.ceil(t.width+1+2*s),t.height=Math.ceil(t.height+1+2*s))}return t},e.prototype.setPrevPaintRect=function(t){t?(this._prevPaintRect=this._prevPaintRect||new Ce(0,0,0,0),this._prevPaintRect.copy(t)):this._prevPaintRect=null},e.prototype.getPrevPaintRect=function(){return this._prevPaintRect},e.prototype.animateStyle=function(t){return this.animate("style",t)},e.prototype.updateDuringAnimation=function(t){"style"===t?this.dirtyStyle():this.markRedraw()},e.prototype.attrKV=function(e,n){"style"!==e?t.prototype.attrKV.call(this,e,n):this.style?this.setStyle(n):this.useStyle(n)},e.prototype.setStyle=function(t,e){return"string"==typeof t?this.style[t]=e:A(this.style,t),this.dirtyStyle(),this},e.prototype.dirtyStyle=function(t){t||this.markRedraw(),this.__dirty|=2,this._rect&&(this._rect=null)},e.prototype.dirty=function(){this.dirtyStyle()},e.prototype.styleChanged=function(){return!!(2&this.__dirty)},e.prototype.styleUpdated=function(){this.__dirty&=-3},e.prototype.createStyle=function(t){return dt(sa,t)},e.prototype.useStyle=function(t){t[aa]||(t=this.createStyle(t)),this.__inHover?this.__hoverStyle=t:this.style=t,this.dirtyStyle()},e.prototype.isStyleObject=function(t){return t[aa]},e.prototype._innerSaveToNormal=function(e){t.prototype._innerSaveToNormal.call(this,e);var n=this._normalState;e.style&&!n.style&&(n.style=this._mergeStyle(this.createStyle(),this.style)),this._savePrimaryToNormal(e,n,ua)},e.prototype._applyStateObj=function(e,n,i,r,o,a){t.prototype._applyStateObj.call(this,e,n,i,r,o,a);var s,l=!(n&&r);if(n&&n.style?o?r?s=n.style:(s=this._mergeStyle(this.createStyle(),i.style),this._mergeStyle(s,n.style)):(s=this._mergeStyle(this.createStyle(),r?this.style:i.style),this._mergeStyle(s,n.style)):l&&(s=i.style),s)if(o){var u=this.style;if(this.style=this.createStyle(l?{}:u),l)for(var h=V(u),c=0;c<h.length;c++)(d=h[c])in s&&(s[d]=s[d],this.style[d]=u[d]);var p=V(s);for(c=0;c<p.length;c++){var d=p[c];this.style[d]=this.style[d]}this._transitionState(e,{style:s},a,this.getAnimationStyleProps())}else this.useStyle(s);var f=this.__inHover?ha:ua;for(c=0;c<f.length;c++)d=f[c],n&&null!=n[d]?this[d]=n[d]:l&&null!=i[d]&&(this[d]=i[d])},e.prototype._mergeStates=function(e){for(var n,i=t.prototype._mergeStates.call(this,e),r=0;r<e.length;r++){var o=e[r];o.style&&(n=n||{},this._mergeStyle(n,o.style))}return n&&(i.style=n),i},e.prototype._mergeStyle=function(t,e){return A(t,e),t},e.prototype.getAnimationStyleProps=function(){return la},e.initDefaultProps=((i=e.prototype).type="displayable",i.invisible=!1,i.z=0,i.z2=0,i.zlevel=0,i.culling=!1,i.cursor="pointer",i.rectHover=!1,i.incremental=!1,i._rect=null,i.dirtyRectTolerance=0,void(i.__dirty=3)),e}(Ar),pa=new Ce(0,0,0,0),da=new Ce(0,0,0,0);const fa=ca;var ga=Math.min,ya=Math.max,va=Math.sin,ma=Math.cos,xa=2*Math.PI,_a=mt(),ba=mt(),wa=mt();function Sa(t,e,n){if(0!==t.length){for(var i=t[0],r=i[0],o=i[0],a=i[1],s=i[1],l=1;l<t.length;l++)i=t[l],r=ga(r,i[0]),o=ya(o,i[0]),a=ga(a,i[1]),s=ya(s,i[1]);e[0]=r,e[1]=a,n[0]=o,n[1]=s}}function Ma(t,e,n,i,r,o){r[0]=ga(t,n),r[1]=ga(e,i),o[0]=ya(t,n),o[1]=ya(e,i)}var Ia=[],Ta=[];function Ca(t,e,n,i,r,o,a,s,l,u){var h=fn,c=cn,p=h(t,n,r,a,Ia);l[0]=1/0,l[1]=1/0,u[0]=-1/0,u[1]=-1/0;for(var d=0;d<p;d++){var f=c(t,n,r,a,Ia[d]);l[0]=ga(f,l[0]),u[0]=ya(f,u[0])}for(p=h(e,i,o,s,Ta),d=0;d<p;d++){var g=c(e,i,o,s,Ta[d]);l[1]=ga(g,l[1]),u[1]=ya(g,u[1])}l[0]=ga(t,l[0]),u[0]=ya(t,u[0]),l[0]=ga(a,l[0]),u[0]=ya(a,u[0]),l[1]=ga(e,l[1]),u[1]=ya(e,u[1]),l[1]=ga(s,l[1]),u[1]=ya(s,u[1])}function Da(t,e,n,i,r,o,a,s){var l=_n,u=mn,h=ya(ga(l(t,n,r),1),0),c=ya(ga(l(e,i,o),1),0),p=u(t,n,r,h),d=u(e,i,o,c);a[0]=ga(t,r,p),a[1]=ga(e,o,d),s[0]=ya(t,r,p),s[1]=ya(e,o,d)}function Aa(t,e,n,i,r,o,a,s,l){var u=Ot,h=Rt,c=Math.abs(r-o);if(c%xa<1e-4&&c>1e-4)return s[0]=t-n,s[1]=e-i,l[0]=t+n,void(l[1]=e+i);if(_a[0]=ma(r)*n+t,_a[1]=va(r)*i+e,ba[0]=ma(o)*n+t,ba[1]=va(o)*i+e,u(s,_a,ba),h(l,_a,ba),(r%=xa)<0&&(r+=xa),(o%=xa)<0&&(o+=xa),r>o&&!a?o+=xa:r<o&&a&&(r+=xa),a){var p=o;o=r,r=p}for(var d=0;d<o;d+=Math.PI/2)d>r&&(wa[0]=ma(d)*n+t,wa[1]=va(d)*i+e,u(s,wa,s),h(l,wa,l))}var ka={M:1,L:2,C:3,Q:4,A:5,Z:6,R:7},La=[],Pa=[],Oa=[],Ra=[],Na=[],Ea=[],za=Math.min,Va=Math.max,Ba=Math.cos,Fa=Math.sin,Ga=Math.abs,Wa=Math.PI,Ha=2*Wa,Ya="undefined"!=typeof Float32Array,Xa=[];function Ua(t){return Math.round(t/Wa*1e8)/1e8%2*Wa}function Za(t,e){var n=Ua(t[0]);n<0&&(n+=Ha);var i=n-t[0],r=t[1];r+=i,!e&&r-n>=Ha?r=n+Ha:e&&n-r>=Ha?r=n-Ha:!e&&n>r?r=n+(Ha-Ua(n-r)):e&&n<r&&(r=n-(Ha-Ua(r-n))),t[0]=n,t[1]=r}var ja=function(){function t(t){this.dpr=1,this._xi=0,this._yi=0,this._x0=0,this._y0=0,this._len=0,t&&(this._saveData=!1),this._saveData&&(this.data=[])}return t.prototype.increaseVersion=function(){this._version++},t.prototype.getVersion=function(){return this._version},t.prototype.setScale=function(t,e,n){(n=n||0)>0&&(this._ux=Ga(n/$i/t)||0,this._uy=Ga(n/$i/e)||0)},t.prototype.setDPR=function(t){this.dpr=t},t.prototype.setContext=function(t){this._ctx=t},t.prototype.getContext=function(){return this._ctx},t.prototype.beginPath=function(){return this._ctx&&this._ctx.beginPath(),this.reset(),this},t.prototype.reset=function(){this._saveData&&(this._len=0),this._pathSegLen&&(this._pathSegLen=null,this._pathLen=0),this._version++},t.prototype.moveTo=function(t,e){return this._drawPendingPt(),this.addData(ka.M,t,e),this._ctx&&this._ctx.moveTo(t,e),this._x0=t,this._y0=e,this._xi=t,this._yi=e,this},t.prototype.lineTo=function(t,e){var n=Ga(t-this._xi),i=Ga(e-this._yi),r=n>this._ux||i>this._uy;if(this.addData(ka.L,t,e),this._ctx&&r&&this._ctx.lineTo(t,e),r)this._xi=t,this._yi=e,this._pendingPtDist=0;else{var o=n*n+i*i;o>this._pendingPtDist&&(this._pendingPtX=t,this._pendingPtY=e,this._pendingPtDist=o)}return this},t.prototype.bezierCurveTo=function(t,e,n,i,r,o){return this._drawPendingPt(),this.addData(ka.C,t,e,n,i,r,o),this._ctx&&this._ctx.bezierCurveTo(t,e,n,i,r,o),this._xi=r,this._yi=o,this},t.prototype.quadraticCurveTo=function(t,e,n,i){return this._drawPendingPt(),this.addData(ka.Q,t,e,n,i),this._ctx&&this._ctx.quadraticCurveTo(t,e,n,i),this._xi=n,this._yi=i,this},t.prototype.arc=function(t,e,n,i,r,o){this._drawPendingPt(),Xa[0]=i,Xa[1]=r,Za(Xa,o),i=Xa[0];var a=(r=Xa[1])-i;return this.addData(ka.A,t,e,n,n,i,a,0,o?0:1),this._ctx&&this._ctx.arc(t,e,n,i,r,o),this._xi=Ba(r)*n+t,this._yi=Fa(r)*n+e,this},t.prototype.arcTo=function(t,e,n,i,r){return this._drawPendingPt(),this._ctx&&this._ctx.arcTo(t,e,n,i,r),this},t.prototype.rect=function(t,e,n,i){return this._drawPendingPt(),this._ctx&&this._ctx.rect(t,e,n,i),this.addData(ka.R,t,e,n,i),this},t.prototype.closePath=function(){this._drawPendingPt(),this.addData(ka.Z);var t=this._ctx,e=this._x0,n=this._y0;return t&&t.closePath(),this._xi=e,this._yi=n,this},t.prototype.fill=function(t){t&&t.fill(),this.toStatic()},t.prototype.stroke=function(t){t&&t.stroke(),this.toStatic()},t.prototype.len=function(){return this._len},t.prototype.setData=function(t){var e=t.length;this.data&&this.data.length===e||!Ya||(this.data=new Float32Array(e));for(var n=0;n<e;n++)this.data[n]=t[n];this._len=e},t.prototype.appendPath=function(t){t instanceof Array||(t=[t]);for(var e=t.length,n=0,i=this._len,r=0;r<e;r++)n+=t[r].len();for(Ya&&this.data instanceof Float32Array&&(this.data=new Float32Array(i+n)),r=0;r<e;r++)for(var o=t[r].data,a=0;a<o.length;a++)this.data[i++]=o[a];this._len=i},t.prototype.addData=function(t,e,n,i,r,o,a,s,l){if(this._saveData){var u=this.data;this._len+arguments.length>u.length&&(this._expandData(),u=this.data);for(var h=0;h<arguments.length;h++)u[this._len++]=arguments[h]}},t.prototype._drawPendingPt=function(){this._pendingPtDist>0&&(this._ctx&&this._ctx.lineTo(this._pendingPtX,this._pendingPtY),this._pendingPtDist=0)},t.prototype._expandData=function(){if(!(this.data instanceof Array)){for(var t=[],e=0;e<this._len;e++)t[e]=this.data[e];this.data=t}},t.prototype.toStatic=function(){if(this._saveData){this._drawPendingPt();var t=this.data;t instanceof Array&&(t.length=this._len,Ya&&this._len>11&&(this.data=new Float32Array(t)))}},t.prototype.getBoundingRect=function(){Oa[0]=Oa[1]=Na[0]=Na[1]=Number.MAX_VALUE,Ra[0]=Ra[1]=Ea[0]=Ea[1]=-Number.MAX_VALUE;var t,e=this.data,n=0,i=0,r=0,o=0;for(t=0;t<this._len;){var a=e[t++],s=1===t;switch(s&&(r=n=e[t],o=i=e[t+1]),a){case ka.M:n=r=e[t++],i=o=e[t++],Na[0]=r,Na[1]=o,Ea[0]=r,Ea[1]=o;break;case ka.L:Ma(n,i,e[t],e[t+1],Na,Ea),n=e[t++],i=e[t++];break;case ka.C:Ca(n,i,e[t++],e[t++],e[t++],e[t++],e[t],e[t+1],Na,Ea),n=e[t++],i=e[t++];break;case ka.Q:Da(n,i,e[t++],e[t++],e[t],e[t+1],Na,Ea),n=e[t++],i=e[t++];break;case ka.A:var l=e[t++],u=e[t++],h=e[t++],c=e[t++],p=e[t++],d=e[t++]+p;t+=1;var f=!e[t++];s&&(r=Ba(p)*h+l,o=Fa(p)*c+u),Aa(l,u,h,c,p,d,f,Na,Ea),n=Ba(d)*h+l,i=Fa(d)*c+u;break;case ka.R:Ma(r=n=e[t++],o=i=e[t++],r+e[t++],o+e[t++],Na,Ea);break;case ka.Z:n=r,i=o}Ot(Oa,Oa,Na),Rt(Ra,Ra,Ea)}return 0===t&&(Oa[0]=Oa[1]=Ra[0]=Ra[1]=0),new Ce(Oa[0],Oa[1],Ra[0]-Oa[0],Ra[1]-Oa[1])},t.prototype._calculateLength=function(){var t=this.data,e=this._len,n=this._ux,i=this._uy,r=0,o=0,a=0,s=0;this._pathSegLen||(this._pathSegLen=[]);for(var l=this._pathSegLen,u=0,h=0,c=0;c<e;){var p=t[c++],d=1===c;d&&(a=r=t[c],s=o=t[c+1]);var f=-1;switch(p){case ka.M:r=a=t[c++],o=s=t[c++];break;case ka.L:var g=t[c++],y=(x=t[c++])-o;(Ga(A=g-r)>n||Ga(y)>i||c===e-1)&&(f=Math.sqrt(A*A+y*y),r=g,o=x);break;case ka.C:var v=t[c++],m=t[c++],x=(g=t[c++],t[c++]),_=t[c++],b=t[c++];f=vn(r,o,v,m,g,x,_,b,10),r=_,o=b;break;case ka.Q:f=Sn(r,o,v=t[c++],m=t[c++],g=t[c++],x=t[c++],10),r=g,o=x;break;case ka.A:var w=t[c++],S=t[c++],M=t[c++],I=t[c++],T=t[c++],C=t[c++],D=C+T;c+=1,t[c++],d&&(a=Ba(T)*M+w,s=Fa(T)*I+S),f=Va(M,I)*za(Ha,Math.abs(C)),r=Ba(D)*M+w,o=Fa(D)*I+S;break;case ka.R:a=r=t[c++],s=o=t[c++],f=2*t[c++]+2*t[c++];break;case ka.Z:var A=a-r;y=s-o,f=Math.sqrt(A*A+y*y),r=a,o=s}f>=0&&(l[h++]=f,u+=f)}return this._pathLen=u,u},t.prototype.rebuildPath=function(t,e){var n,i,r,o,a,s,l,u,h,c,p=this.data,d=this._ux,f=this._uy,g=this._len,y=e<1,v=0,m=0,x=0;if(!y||(this._pathSegLen||this._calculateLength(),l=this._pathSegLen,u=e*this._pathLen))t:for(var _=0;_<g;){var b=p[_++],w=1===_;switch(w&&(n=r=p[_],i=o=p[_+1]),b!==ka.L&&x>0&&(t.lineTo(h,c),x=0),b){case ka.M:n=r=p[_++],i=o=p[_++],t.moveTo(r,o);break;case ka.L:a=p[_++],s=p[_++];var S=Ga(a-r),M=Ga(s-o);if(S>d||M>f){if(y){if(v+(j=l[m++])>u){var I=(u-v)/j;t.lineTo(r*(1-I)+a*I,o*(1-I)+s*I);break t}v+=j}t.lineTo(a,s),r=a,o=s,x=0}else{var T=S*S+M*M;T>x&&(h=a,c=s,x=T)}break;case ka.C:var C=p[_++],D=p[_++],A=p[_++],k=p[_++],L=p[_++],P=p[_++];if(y){if(v+(j=l[m++])>u){gn(r,C,A,L,I=(u-v)/j,La),gn(o,D,k,P,I,Pa),t.bezierCurveTo(La[1],Pa[1],La[2],Pa[2],La[3],Pa[3]);break t}v+=j}t.bezierCurveTo(C,D,A,k,L,P),r=L,o=P;break;case ka.Q:if(C=p[_++],D=p[_++],A=p[_++],k=p[_++],y){if(v+(j=l[m++])>u){bn(r,C,A,I=(u-v)/j,La),bn(o,D,k,I,Pa),t.quadraticCurveTo(La[1],Pa[1],La[2],Pa[2]);break t}v+=j}t.quadraticCurveTo(C,D,A,k),r=A,o=k;break;case ka.A:var O=p[_++],R=p[_++],N=p[_++],E=p[_++],z=p[_++],V=p[_++],B=p[_++],F=!p[_++],G=N>E?N:E,W=Ga(N-E)>.001,H=z+V,Y=!1;if(y&&(v+(j=l[m++])>u&&(H=z+V*(u-v)/j,Y=!0),v+=j),W&&t.ellipse?t.ellipse(O,R,N,E,B,z,H,F):t.arc(O,R,G,z,H,F),Y)break t;w&&(n=Ba(z)*N+O,i=Fa(z)*E+R),r=Ba(H)*N+O,o=Fa(H)*E+R;break;case ka.R:n=r=p[_],i=o=p[_+1],a=p[_++],s=p[_++];var X=p[_++],U=p[_++];if(y){if(v+(j=l[m++])>u){var Z=u-v;t.moveTo(a,s),t.lineTo(a+za(Z,X),s),(Z-=X)>0&&t.lineTo(a+X,s+za(Z,U)),(Z-=U)>0&&t.lineTo(a+Va(X-Z,0),s+U),(Z-=X)>0&&t.lineTo(a,s+Va(U-Z,0));break t}v+=j}t.rect(a,s,X,U);break;case ka.Z:if(y){var j;if(v+(j=l[m++])>u){I=(u-v)/j,t.lineTo(r*(1-I)+n*I,o*(1-I)+i*I);break t}v+=j}t.closePath(),r=n,o=i}}},t.prototype.clone=function(){var e=new t,n=this.data;return e.data=n.slice?n.slice():Array.prototype.slice.call(n),e._len=this._len,e},t.CMD=ka,t.initDefaultProps=function(){var e=t.prototype;e._saveData=!0,e._ux=0,e._uy=0,e._pendingPtDist=0,e._version=0}(),t}();const qa=ja;function Ka(t,e,n,i,r,o,a){if(0===r)return!1;var s=r,l=0;if(a>e+s&&a>i+s||a<e-s&&a<i-s||o>t+s&&o>n+s||o<t-s&&o<n-s)return!1;if(t===n)return Math.abs(o-t)<=s/2;var u=(l=(e-i)/(t-n))*o-a+(t*i-n*e)/(t-n);return u*u/(l*l+1)<=s/2*s/2}function $a(t,e,n,i,r,o,a,s,l,u,h){if(0===l)return!1;var c=l;return!(h>e+c&&h>i+c&&h>o+c&&h>s+c||h<e-c&&h<i-c&&h<o-c&&h<s-c||u>t+c&&u>n+c&&u>r+c&&u>a+c||u<t-c&&u<n-c&&u<r-c&&u<a-c)&&yn(t,e,n,i,r,o,a,s,u,h,null)<=c/2}function Ja(t,e,n,i,r,o,a,s,l){if(0===a)return!1;var u=a;return!(l>e+u&&l>i+u&&l>o+u||l<e-u&&l<i-u&&l<o-u||s>t+u&&s>n+u&&s>r+u||s<t-u&&s<n-u&&s<r-u)&&wn(t,e,n,i,r,o,s,l,null)<=u/2}var Qa=2*Math.PI;function ts(t){return(t%=Qa)<0&&(t+=Qa),t}var es=2*Math.PI;function ns(t,e,n,i,r,o,a,s,l){if(0===a)return!1;var u=a;s-=t,l-=e;var h=Math.sqrt(s*s+l*l);if(h-u>n||h+u<n)return!1;if(Math.abs(i-r)%es<1e-4)return!0;if(o){var c=i;i=ts(r),r=ts(c)}else i=ts(i),r=ts(r);i>r&&(r+=es);var p=Math.atan2(l,s);return p<0&&(p+=es),p>=i&&p<=r||p+es>=i&&p+es<=r}function is(t,e,n,i,r,o){if(o>e&&o>i||o<e&&o<i)return 0;if(i===e)return 0;var a=(o-e)/(i-e),s=i<e?1:-1;1!==a&&0!==a||(s=i<e?.5:-.5);var l=a*(n-t)+t;return l===r?1/0:l>r?s:0}var rs=qa.CMD,os=2*Math.PI,as=[-1,-1,-1],ss=[-1,-1];function ls(t,e,n,i,r,o,a,s,l,u){if(u>e&&u>i&&u>o&&u>s||u<e&&u<i&&u<o&&u<s)return 0;var h,c=dn(e,i,o,s,u,as);if(0===c)return 0;for(var p=0,d=-1,f=void 0,g=void 0,y=0;y<c;y++){var v=as[y],m=0===v||1===v?.5:1;cn(t,n,r,a,v)<l||(d<0&&(d=fn(e,i,o,s,ss),ss[1]<ss[0]&&d>1&&(h=void 0,h=ss[0],ss[0]=ss[1],ss[1]=h),f=cn(e,i,o,s,ss[0]),d>1&&(g=cn(e,i,o,s,ss[1]))),2===d?v<ss[0]?p+=f<e?m:-m:v<ss[1]?p+=g<f?m:-m:p+=s<g?m:-m:v<ss[0]?p+=f<e?m:-m:p+=s<f?m:-m)}return p}function us(t,e,n,i,r,o,a,s){if(s>e&&s>i&&s>o||s<e&&s<i&&s<o)return 0;var l=function(t,e,n,i,r){var o=t-2*e+n,a=2*(e-t),s=t-i,l=0;if(un(o))hn(a)&&(h=-s/a)>=0&&h<=1&&(r[l++]=h);else{var u=a*a-4*o*s;if(un(u))(h=-a/(2*o))>=0&&h<=1&&(r[l++]=h);else if(u>0){var h,c=tn(u),p=(-a-c)/(2*o);(h=(-a+c)/(2*o))>=0&&h<=1&&(r[l++]=h),p>=0&&p<=1&&(r[l++]=p)}}return l}(e,i,o,s,as);if(0===l)return 0;var u=_n(e,i,o);if(u>=0&&u<=1){for(var h=0,c=mn(e,i,o,u),p=0;p<l;p++){var d=0===as[p]||1===as[p]?.5:1;mn(t,n,r,as[p])<a||(as[p]<u?h+=c<e?d:-d:h+=o<c?d:-d)}return h}return d=0===as[0]||1===as[0]?.5:1,mn(t,n,r,as[0])<a?0:o<e?d:-d}function hs(t,e,n,i,r,o,a,s){if((s-=e)>n||s<-n)return 0;var l=Math.sqrt(n*n-s*s);as[0]=-l,as[1]=l;var u=Math.abs(i-r);if(u<1e-4)return 0;if(u>=os-1e-4){i=0,r=os;var h=o?1:-1;return a>=as[0]+t&&a<=as[1]+t?h:0}if(i>r){var c=i;i=r,r=c}i<0&&(i+=os,r+=os);for(var p=0,d=0;d<2;d++){var f=as[d];if(f+t>a){var g=Math.atan2(s,f);h=o?1:-1,g<0&&(g=os+g),(g>=i&&g<=r||g+os>=i&&g+os<=r)&&(g>Math.PI/2&&g<1.5*Math.PI&&(h=-h),p+=h)}}return p}function cs(t,e,n,i,r){for(var o,a,s,l,u=t.data,h=t.len(),c=0,p=0,d=0,f=0,g=0,y=0;y<h;){var v=u[y++],m=1===y;switch(v===rs.M&&y>1&&(n||(c+=is(p,d,f,g,i,r))),m&&(f=p=u[y],g=d=u[y+1]),v){case rs.M:p=f=u[y++],d=g=u[y++];break;case rs.L:if(n){if(Ka(p,d,u[y],u[y+1],e,i,r))return!0}else c+=is(p,d,u[y],u[y+1],i,r)||0;p=u[y++],d=u[y++];break;case rs.C:if(n){if($a(p,d,u[y++],u[y++],u[y++],u[y++],u[y],u[y+1],e,i,r))return!0}else c+=ls(p,d,u[y++],u[y++],u[y++],u[y++],u[y],u[y+1],i,r)||0;p=u[y++],d=u[y++];break;case rs.Q:if(n){if(Ja(p,d,u[y++],u[y++],u[y],u[y+1],e,i,r))return!0}else c+=us(p,d,u[y++],u[y++],u[y],u[y+1],i,r)||0;p=u[y++],d=u[y++];break;case rs.A:var x=u[y++],_=u[y++],b=u[y++],w=u[y++],S=u[y++],M=u[y++];y+=1;var I=!!(1-u[y++]);o=Math.cos(S)*b+x,a=Math.sin(S)*w+_,m?(f=o,g=a):c+=is(p,d,o,a,i,r);var T=(i-x)*w/b+x;if(n){if(ns(x,_,w,S,S+M,I,e,T,r))return!0}else c+=hs(x,_,w,S,S+M,I,T,r);p=Math.cos(S+M)*b+x,d=Math.sin(S+M)*w+_;break;case rs.R:if(f=p=u[y++],g=d=u[y++],o=f+u[y++],a=g+u[y++],n){if(Ka(f,g,o,g,e,i,r)||Ka(o,g,o,a,e,i,r)||Ka(o,a,f,a,e,i,r)||Ka(f,a,f,g,e,i,r))return!0}else c+=is(o,g,o,a,i,r),c+=is(f,a,f,g,i,r);break;case rs.Z:if(n){if(Ka(p,d,f,g,e,i,r))return!0}else c+=is(p,d,f,g,i,r);p=f,d=g}}return n||(s=d,l=g,Math.abs(s-l)<1e-4)||(c+=is(p,d,f,g,i,r)||0),0!==c}var ps=k({fill:"#000",stroke:null,strokePercent:1,fillOpacity:1,strokeOpacity:1,lineDashOffset:0,lineWidth:1,lineCap:"butt",miterLimit:10,strokeNoScale:!1,strokeFirst:!1},sa),ds={style:k({fill:!0,stroke:!0,strokePercent:!0,fillOpacity:!0,strokeOpacity:!0,lineDashOffset:!0,lineWidth:!0,miterLimit:!0},la.style)},fs=lr.concat(["invisible","culling","z","z2","zlevel","parent"]),gs=function(t){function e(e){return t.call(this,e)||this}var i;return n(e,t),e.prototype.update=function(){var n=this;t.prototype.update.call(this);var i=this.style;if(i.decal){var r=this._decalEl=this._decalEl||new e;r.buildPath===e.prototype.buildPath&&(r.buildPath=function(t){n.buildPath(t,n.shape)}),r.silent=!0;var o=r.style;for(var a in i)o[a]!==i[a]&&(o[a]=i[a]);o.fill=i.fill?i.decal:null,o.decal=null,o.shadowColor=null,i.strokeFirst&&(o.stroke=null);for(var s=0;s<fs.length;++s)r[fs[s]]=this[fs[s]];r.__dirty|=1}else this._decalEl&&(this._decalEl=null)},e.prototype.getDecalElement=function(){return this._decalEl},e.prototype._init=function(e){var n=V(e);this.shape=this.getDefaultShape();var i=this.getDefaultStyle();i&&this.useStyle(i);for(var r=0;r<n.length;r++){var o=n[r],a=e[o];"style"===o?this.style?A(this.style,a):this.useStyle(a):"shape"===o?A(this.shape,a):t.prototype.attrKV.call(this,o,a)}this.style||this.useStyle({})},e.prototype.getDefaultStyle=function(){return null},e.prototype.getDefaultShape=function(){return{}},e.prototype.canBeInsideText=function(){return this.hasFill()},e.prototype.getInsideTextFill=function(){var t=this.style.fill;if("none"!==t){if(H(t)){var e=Kn(t,0);return e>.5?Ji:e>.2?"#eee":Qi}if(t)return Qi}return Ji},e.prototype.getInsideTextStroke=function(t){var e=this.style.fill;if(H(e)){var n=this.__zr;if(!(!n||!n.isDarkMode())==Kn(t,0)<.4)return e}},e.prototype.buildPath=function(t,e,n){},e.prototype.pathUpdated=function(){this.__dirty&=-5},e.prototype.getUpdatedPathProxy=function(t){return!this.path&&this.createPathProxy(),this.path.beginPath(),this.buildPath(this.path,this.shape,t),this.path},e.prototype.createPathProxy=function(){this.path=new qa(!1)},e.prototype.hasStroke=function(){var t=this.style,e=t.stroke;return!(null==e||"none"===e||!(t.lineWidth>0))},e.prototype.hasFill=function(){var t=this.style.fill;return null!=t&&"none"!==t},e.prototype.getBoundingRect=function(){var t=this._rect,e=this.style,n=!t;if(n){var i=!1;this.path||(i=!0,this.createPathProxy());var r=this.path;(i||4&this.__dirty)&&(r.beginPath(),this.buildPath(r,this.shape,!1),this.pathUpdated()),t=r.getBoundingRect()}if(this._rect=t,this.hasStroke()&&this.path&&this.path.len()>0){var o=this._rectStroke||(this._rectStroke=t.clone());if(this.__dirty||n){o.copy(t);var a=e.strokeNoScale?this.getLineScale():1,s=e.lineWidth;if(!this.hasFill()){var l=this.strokeContainThreshold;s=Math.max(s,null==l?4:l)}a>1e-10&&(o.width+=s/a,o.height+=s/a,o.x-=s/a/2,o.y-=s/a/2)}return o}return t},e.prototype.contain=function(t,e){var n=this.transformCoordToLocal(t,e),i=this.getBoundingRect(),r=this.style;if(t=n[0],e=n[1],i.contain(t,e)){var o=this.path;if(this.hasStroke()){var a=r.lineWidth,s=r.strokeNoScale?this.getLineScale():1;if(s>1e-10&&(this.hasFill()||(a=Math.max(a,this.strokeContainThreshold)),function(t,e,n,i){return cs(t,e,!0,n,i)}(o,a/s,t,e)))return!0}if(this.hasFill())return function(t,e,n){return cs(t,0,!1,e,n)}(o,t,e)}return!1},e.prototype.dirtyShape=function(){this.__dirty|=4,this._rect&&(this._rect=null),this._decalEl&&this._decalEl.dirtyShape(),this.markRedraw()},e.prototype.dirty=function(){this.dirtyStyle(),this.dirtyShape()},e.prototype.animateShape=function(t){return this.animate("shape",t)},e.prototype.updateDuringAnimation=function(t){"style"===t?this.dirtyStyle():"shape"===t?this.dirtyShape():this.markRedraw()},e.prototype.attrKV=function(e,n){"shape"===e?this.setShape(n):t.prototype.attrKV.call(this,e,n)},e.prototype.setShape=function(t,e){var n=this.shape;return n||(n=this.shape={}),"string"==typeof t?n[t]=e:A(n,t),this.dirtyShape(),this},e.prototype.shapeChanged=function(){return!!(4&this.__dirty)},e.prototype.createStyle=function(t){return dt(ps,t)},e.prototype._innerSaveToNormal=function(e){t.prototype._innerSaveToNormal.call(this,e);var n=this._normalState;e.shape&&!n.shape&&(n.shape=A({},this.shape))},e.prototype._applyStateObj=function(e,n,i,r,o,a){t.prototype._applyStateObj.call(this,e,n,i,r,o,a);var s,l=!(n&&r);if(n&&n.shape?o?r?s=n.shape:(s=A({},i.shape),A(s,n.shape)):(s=A({},r?this.shape:i.shape),A(s,n.shape)):l&&(s=i.shape),s)if(o){this.shape=A({},this.shape);for(var u={},h=V(s),c=0;c<h.length;c++){var p=h[c];"object"==typeof s[p]?this.shape[p]=s[p]:u[p]=s[p]}this._transitionState(e,{shape:u},a)}else this.shape=s,this.dirtyShape()},e.prototype._mergeStates=function(e){for(var n,i=t.prototype._mergeStates.call(this,e),r=0;r<e.length;r++){var o=e[r];o.shape&&(n=n||{},this._mergeStyle(n,o.shape))}return n&&(i.shape=n),i},e.prototype.getAnimationStyleProps=function(){return ds},e.prototype.isZeroArea=function(){return!1},e.extend=function(t){var i=function(e){function i(n){var i=e.call(this,n)||this;return t.init&&t.init.call(i,n),i}return n(i,e),i.prototype.getDefaultStyle=function(){return T(t.style)},i.prototype.getDefaultShape=function(){return T(t.shape)},i}(e);for(var r in t)"function"==typeof t[r]&&(i.prototype[r]=t[r]);return i},e.initDefaultProps=((i=e.prototype).type="path",i.strokeContainThreshold=5,i.segmentIgnoreThreshold=0,i.subPixelOptimize=!1,i.autoBatch=!1,void(i.__dirty=7)),e}(fa);const ys=gs;var vs=k({strokeFirst:!0,font:u,x:0,y:0,textAlign:"left",textBaseline:"top",miterLimit:2},ps),ms=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.hasStroke=function(){var t=this.style,e=t.stroke;return null!=e&&"none"!==e&&t.lineWidth>0},e.prototype.hasFill=function(){var t=this.style.fill;return null!=t&&"none"!==t},e.prototype.createStyle=function(t){return dt(vs,t)},e.prototype.setBoundingRect=function(t){this._rect=t},e.prototype.getBoundingRect=function(){var t=this.style;if(!this._rect){var e=t.text;null!=e?e+="":e="";var n=dr(e,t.font,t.textAlign,t.textBaseline);if(n.x+=t.x||0,n.y+=t.y||0,this.hasStroke()){var i=t.lineWidth;n.x-=i/2,n.y-=i/2,n.width+=i,n.height+=i}this._rect=n}return this._rect},e.initDefaultProps=void(e.prototype.dirtyRectTolerance=10),e}(fa);ms.prototype.type="tspan";const xs=ms;var _s=k({x:0,y:0},sa),bs={style:k({x:!0,y:!0,width:!0,height:!0,sx:!0,sy:!0,sWidth:!0,sHeight:!0},la.style)},ws=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.createStyle=function(t){return dt(_s,t)},e.prototype._getSize=function(t){var e=this.style,n=e[t];if(null!=n)return n;var i,r=(i=e.image)&&"string"!=typeof i&&i.width&&i.height?e.image:this.__image;if(!r)return 0;var o="width"===t?"height":"width",a=e[o];return null==a?r[t]:r[t]/r[o]*a},e.prototype.getWidth=function(){return this._getSize("width")},e.prototype.getHeight=function(){return this._getSize("height")},e.prototype.getAnimationStyleProps=function(){return bs},e.prototype.getBoundingRect=function(){var t=this.style;return this._rect||(this._rect=new Ce(t.x||0,t.y||0,this.getWidth(),this.getHeight())),this._rect},e}(fa);ws.prototype.type="image";const Ss=ws;var Ms=Math.round;function Is(t,e,n){if(e){var i=e.x1,r=e.x2,o=e.y1,a=e.y2;t.x1=i,t.x2=r,t.y1=o,t.y2=a;var s=n&&n.lineWidth;return s?(Ms(2*i)===Ms(2*r)&&(t.x1=t.x2=Cs(i,s,!0)),Ms(2*o)===Ms(2*a)&&(t.y1=t.y2=Cs(o,s,!0)),t):t}}function Ts(t,e,n){if(e){var i=e.x,r=e.y,o=e.width,a=e.height;t.x=i,t.y=r,t.width=o,t.height=a;var s=n&&n.lineWidth;return s?(t.x=Cs(i,s,!0),t.y=Cs(r,s,!0),t.width=Math.max(Cs(i+o,s,!1)-t.x,0===o?0:1),t.height=Math.max(Cs(r+a,s,!1)-t.y,0===a?0:1),t):t}}function Cs(t,e,n){if(!e)return t;var i=Ms(2*t);return(i+Ms(e))%2==0?i/2:(i+(n?1:-1))/2}var Ds=function(){this.x=0,this.y=0,this.width=0,this.height=0},As={},ks=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new Ds},e.prototype.buildPath=function(t,e){var n,i,r,o;if(this.subPixelOptimize){var a=Ts(As,e,this.style);n=a.x,i=a.y,r=a.width,o=a.height,a.r=e.r,e=a}else n=e.x,i=e.y,r=e.width,o=e.height;e.r?function(t,e){var n,i,r,o,a,s=e.x,l=e.y,u=e.width,h=e.height,c=e.r;u<0&&(s+=u,u=-u),h<0&&(l+=h,h=-h),"number"==typeof c?n=i=r=o=c:c instanceof Array?1===c.length?n=i=r=o=c[0]:2===c.length?(n=r=c[0],i=o=c[1]):3===c.length?(n=c[0],i=o=c[1],r=c[2]):(n=c[0],i=c[1],r=c[2],o=c[3]):n=i=r=o=0,n+i>u&&(n*=u/(a=n+i),i*=u/a),r+o>u&&(r*=u/(a=r+o),o*=u/a),i+r>h&&(i*=h/(a=i+r),r*=h/a),n+o>h&&(n*=h/(a=n+o),o*=h/a),t.moveTo(s+n,l),t.lineTo(s+u-i,l),0!==i&&t.arc(s+u-i,l+i,i,-Math.PI/2,0),t.lineTo(s+u,l+h-r),0!==r&&t.arc(s+u-r,l+h-r,r,0,Math.PI/2),t.lineTo(s+o,l+h),0!==o&&t.arc(s+o,l+h-o,o,Math.PI/2,Math.PI),t.lineTo(s,l+n),0!==n&&t.arc(s+n,l+n,n,Math.PI,1.5*Math.PI)}(t,e):t.rect(n,i,r,o)},e.prototype.isZeroArea=function(){return!this.shape.width||!this.shape.height},e}(ys);ks.prototype.type="rect";const Ls=ks;var Ps={fill:"#000"},Os={style:k({fill:!0,stroke:!0,fillOpacity:!0,strokeOpacity:!0,lineWidth:!0,fontSize:!0,lineHeight:!0,width:!0,height:!0,textShadowColor:!0,textShadowBlur:!0,textShadowOffsetX:!0,textShadowOffsetY:!0,backgroundColor:!0,padding:!0,borderColor:!0,borderWidth:!0,borderRadius:!0},la.style)},Rs=function(t){function e(e){var n=t.call(this)||this;return n.type="text",n._children=[],n._defaultStyle=Ps,n.attr(e),n}return n(e,t),e.prototype.childrenRef=function(){return this._children},e.prototype.update=function(){t.prototype.update.call(this),this.styleChanged()&&this._updateSubTexts();for(var e=0;e<this._children.length;e++){var n=this._children[e];n.zlevel=this.zlevel,n.z=this.z,n.z2=this.z2,n.culling=this.culling,n.cursor=this.cursor,n.invisible=this.invisible}},e.prototype.updateTransform=function(){var e=this.innerTransformable;e?(e.updateTransform(),e.transform&&(this.transform=e.transform)):t.prototype.updateTransform.call(this)},e.prototype.getLocalTransform=function(e){var n=this.innerTransformable;return n?n.getLocalTransform(e):t.prototype.getLocalTransform.call(this,e)},e.prototype.getComputedTransform=function(){return this.__hostTarget&&(this.__hostTarget.getComputedTransform(),this.__hostTarget.updateInnerText(!0)),t.prototype.getComputedTransform.call(this)},e.prototype._updateSubTexts=function(){var t;this._childCursor=0,Gs(t=this.style),R(t.rich,Gs),this.style.rich?this._updateRichTexts():this._updatePlainTexts(),this._children.length=this._childCursor,this.styleUpdated()},e.prototype.addSelfToZr=function(e){t.prototype.addSelfToZr.call(this,e);for(var n=0;n<this._children.length;n++)this._children[n].__zr=e},e.prototype.removeSelfFromZr=function(e){t.prototype.removeSelfFromZr.call(this,e);for(var n=0;n<this._children.length;n++)this._children[n].__zr=null},e.prototype.getBoundingRect=function(){if(this.styleChanged()&&this._updateSubTexts(),!this._rect){for(var t=new Ce(0,0,0,0),e=this._children,n=[],i=null,r=0;r<e.length;r++){var o=e[r],a=o.getBoundingRect(),s=o.getLocalTransform(n);s?(t.copy(a),t.applyTransform(s),(i=i||t.clone()).union(t)):(i=i||a.clone()).union(a)}this._rect=i||t}return this._rect},e.prototype.setDefaultTextStyle=function(t){this._defaultStyle=t||Ps},e.prototype.setTextContent=function(t){},e.prototype._mergeStyle=function(t,e){if(!e)return t;var n=e.rich,i=t.rich||n&&{};return A(t,e),n&&i?(this._mergeRich(i,n),t.rich=i):i&&(t.rich=i),t},e.prototype._mergeRich=function(t,e){for(var n=V(e),i=0;i<n.length;i++){var r=n[i];t[r]=t[r]||{},A(t[r],e[r])}},e.prototype.getAnimationStyleProps=function(){return Os},e.prototype._getOrCreateChild=function(t){var e=this._children[this._childCursor];return e&&e instanceof t||(e=new t),this._children[this._childCursor++]=e,e.__zr=this.__zr,e.parent=this,e},e.prototype._updatePlainTexts=function(){var t=this.style,e=t.font||u,n=t.padding,i=function(t,e){null!=t&&(t+="");var n,i=e.overflow,r=e.padding,o=e.font,a="truncate"===i,s=yr(o),l=Q(e.lineHeight,s),u=!!e.backgroundColor,h="truncate"===e.lineOverflow,c=e.width,p=(n=null==c||"break"!==i&&"breakAll"!==i?t?t.split("\n"):[]:t?oa(t,e.font,c,"breakAll"===i,0).lines:[]).length*l,d=Q(e.height,p);if(p>d&&h){var f=Math.floor(d/l);n=n.slice(0,f)}if(t&&a&&null!=c)for(var g=Ko(c,o,e.ellipsis,{minChar:e.truncateMinChar,placeholder:e.placeholder}),y=0;y<n.length;y++)n[y]=$o(n[y],g);var v=d,m=0;for(y=0;y<n.length;y++)m=Math.max(cr(n[y],o),m);null==c&&(c=m);var x=m;return r&&(v+=r[0]+r[2],x+=r[1]+r[3],c+=r[1]+r[3]),u&&(x=c),{lines:n,height:d,outerWidth:x,outerHeight:v,lineHeight:l,calculatedLineHeight:s,contentWidth:m,contentHeight:p,width:c}}(Xs(t),t),r=Us(t),o=!!t.backgroundColor,a=i.outerHeight,s=i.outerWidth,l=i.contentWidth,h=i.lines,c=i.lineHeight,p=this._defaultStyle,d=t.x||0,f=t.y||0,g=t.align||p.align||"left",y=t.verticalAlign||p.verticalAlign||"top",v=d,m=gr(f,i.contentHeight,y);if(r||n){var x=fr(d,s,g),_=gr(f,a,y);r&&this._renderBackground(t,t,x,_,s,a)}m+=c/2,n&&(v=Ys(d,g,n),"top"===y?m+=n[0]:"bottom"===y&&(m-=n[2]));for(var b=0,w=!1,S=(Hs("fill"in t?t.fill:(w=!0,p.fill))),M=(Ws("stroke"in t?t.stroke:o||p.autoStroke&&!w?null:(b=2,p.stroke))),I=t.textShadowBlur>0,T=null!=t.width&&("truncate"===t.overflow||"break"===t.overflow||"breakAll"===t.overflow),C=i.calculatedLineHeight,D=0;D<h.length;D++){var A=this._getOrCreateChild(xs),k=A.createStyle();A.useStyle(k),k.text=h[D],k.x=v,k.y=m,g&&(k.textAlign=g),k.textBaseline="middle",k.opacity=t.opacity,k.strokeFirst=!0,I&&(k.shadowBlur=t.textShadowBlur||0,k.shadowColor=t.textShadowColor||"transparent",k.shadowOffsetX=t.textShadowOffsetX||0,k.shadowOffsetY=t.textShadowOffsetY||0),k.stroke=M,k.fill=S,M&&(k.lineWidth=t.lineWidth||b,k.lineDash=t.lineDash,k.lineDashOffset=t.lineDashOffset||0),k.font=e,Bs(k,t),m+=c,T&&A.setBoundingRect(new Ce(fr(k.x,t.width,k.textAlign),gr(k.y,C,k.textBaseline),l,C))}},e.prototype._updateRichTexts=function(){var t=this.style,e=function(t,e){var n=new ea;if(null!=t&&(t+=""),!t)return n;for(var i,r=e.width,o=e.height,a=e.overflow,s="break"!==a&&"breakAll"!==a||null==r?null:{width:r,accumWidth:0,breakAll:"breakAll"===a},l=jo.lastIndex=0;null!=(i=jo.exec(t));){var u=i.index;u>l&&na(n,t.substring(l,u),e,s),na(n,i[2],e,s,i[1]),l=jo.lastIndex}l<t.length&&na(n,t.substring(l,t.length),e,s);var h=[],c=0,p=0,d=e.padding,f="truncate"===a,g="truncate"===e.lineOverflow;function y(t,e,n){t.width=e,t.lineHeight=n,c+=n,p=Math.max(p,e)}t:for(var v=0;v<n.lines.length;v++){for(var m=n.lines[v],x=0,_=0,b=0;b<m.tokens.length;b++){var w=(P=m.tokens[b]).styleName&&e.rich[P.styleName]||{},S=P.textPadding=w.padding,M=S?S[1]+S[3]:0,I=P.font=w.font||e.font;P.contentHeight=yr(I);var T=Q(w.height,P.contentHeight);if(P.innerHeight=T,S&&(T+=S[0]+S[2]),P.height=T,P.lineHeight=tt(w.lineHeight,e.lineHeight,T),P.align=w&&w.align||e.align,P.verticalAlign=w&&w.verticalAlign||"middle",g&&null!=o&&c+P.lineHeight>o){b>0?(m.tokens=m.tokens.slice(0,b),y(m,_,x),n.lines=n.lines.slice(0,v+1)):n.lines=n.lines.slice(0,v);break t}var C=w.width,D=null==C||"auto"===C;if("string"==typeof C&&"%"===C.charAt(C.length-1))P.percentWidth=C,h.push(P),P.contentWidth=cr(P.text,I);else{if(D){var A=w.backgroundColor,k=A&&A.image;k&&Zo(k=Yo(k))&&(P.width=Math.max(P.width,k.width*T/k.height))}var L=f&&null!=r?r-_:null;null!=L&&L<P.width?!D||L<M?(P.text="",P.width=P.contentWidth=0):(P.text=qo(P.text,L-M,I,e.ellipsis,{minChar:e.truncateMinChar}),P.width=P.contentWidth=cr(P.text,I)):P.contentWidth=cr(P.text,I)}P.width+=M,_+=P.width,w&&(x=Math.max(x,P.lineHeight))}y(m,_,x)}for(n.outerWidth=n.width=Q(r,p),n.outerHeight=n.height=Q(o,c),n.contentHeight=c,n.contentWidth=p,d&&(n.outerWidth+=d[1]+d[3],n.outerHeight+=d[0]+d[2]),v=0;v<h.length;v++){var P,O=(P=h[v]).percentWidth;P.width=parseInt(O,10)/100*n.width}return n}(Xs(t),t),n=e.width,i=e.outerWidth,r=e.outerHeight,o=t.padding,a=t.x||0,s=t.y||0,l=this._defaultStyle,u=t.align||l.align,h=t.verticalAlign||l.verticalAlign,c=fr(a,i,u),p=gr(s,r,h),d=c,f=p;o&&(d+=o[3],f+=o[0]);var g=d+n;Us(t)&&this._renderBackground(t,t,c,p,i,r);for(var y=!!t.backgroundColor,v=0;v<e.lines.length;v++){for(var m=e.lines[v],x=m.tokens,_=x.length,b=m.lineHeight,w=m.width,S=0,M=d,I=g,T=_-1,C=void 0;S<_&&(!(C=x[S]).align||"left"===C.align);)this._placeToken(C,t,b,f,M,"left",y),w-=C.width,M+=C.width,S++;for(;T>=0&&"right"===(C=x[T]).align;)this._placeToken(C,t,b,f,I,"right",y),w-=C.width,I-=C.width,T--;for(M+=(n-(M-d)-(g-I)-w)/2;S<=T;)C=x[S],this._placeToken(C,t,b,f,M+C.width/2,"center",y),M+=C.width,S++;f+=b}},e.prototype._placeToken=function(t,e,n,i,r,o,a){var s=e.rich[t.styleName]||{};s.text=t.text;var l=t.verticalAlign,h=i+n/2;"top"===l?h=i+t.height/2:"bottom"===l&&(h=i+n-t.height/2),!t.isLineHolder&&Us(s)&&this._renderBackground(s,e,"right"===o?r-t.width:"center"===o?r-t.width/2:r,h-t.height/2,t.width,t.height);var c=!!s.backgroundColor,p=t.textPadding;p&&(r=Ys(r,o,p),h-=t.height/2-p[0]-t.innerHeight/2);var d=this._getOrCreateChild(xs),f=d.createStyle();d.useStyle(f);var g=this._defaultStyle,y=!1,v=0,m=Hs("fill"in s?s.fill:"fill"in e?e.fill:(y=!0,g.fill)),x=Ws("stroke"in s?s.stroke:"stroke"in e?e.stroke:c||a||g.autoStroke&&!y?null:(v=2,g.stroke)),_=s.textShadowBlur>0||e.textShadowBlur>0;f.text=t.text,f.x=r,f.y=h,_&&(f.shadowBlur=s.textShadowBlur||e.textShadowBlur||0,f.shadowColor=s.textShadowColor||e.textShadowColor||"transparent",f.shadowOffsetX=s.textShadowOffsetX||e.textShadowOffsetX||0,f.shadowOffsetY=s.textShadowOffsetY||e.textShadowOffsetY||0),f.textAlign=o,f.textBaseline="middle",f.font=t.font||u,f.opacity=tt(s.opacity,e.opacity,1),Bs(f,s),x&&(f.lineWidth=tt(s.lineWidth,e.lineWidth,v),f.lineDash=Q(s.lineDash,e.lineDash),f.lineDashOffset=e.lineDashOffset||0,f.stroke=x),m&&(f.fill=m);var b=t.contentWidth,w=t.contentHeight;d.setBoundingRect(new Ce(fr(f.x,b,f.textAlign),gr(f.y,w,f.textBaseline),b,w))},e.prototype._renderBackground=function(t,e,n,i,r,o){var a,s,l,u=t.backgroundColor,h=t.borderWidth,c=t.borderColor,p=u&&u.image,d=u&&!p,f=t.borderRadius,g=this;if(d||t.lineHeight||h&&c){(a=this._getOrCreateChild(Ls)).useStyle(a.createStyle()),a.style.fill=null;var y=a.shape;y.x=n,y.y=i,y.width=r,y.height=o,y.r=f,a.dirtyShape()}if(d)(l=a.style).fill=u||null,l.fillOpacity=Q(t.fillOpacity,1);else if(p){(s=this._getOrCreateChild(Ss)).onload=function(){g.dirtyStyle()};var v=s.style;v.image=u.image,v.x=n,v.y=i,v.width=r,v.height=o}h&&c&&((l=a.style).lineWidth=h,l.stroke=c,l.strokeOpacity=Q(t.strokeOpacity,1),l.lineDash=t.borderDash,l.lineDashOffset=t.borderDashOffset||0,a.strokeContainThreshold=0,a.hasFill()&&a.hasStroke()&&(l.strokeFirst=!0,l.lineWidth*=2));var m=(a||s).style;m.shadowBlur=t.shadowBlur||0,m.shadowColor=t.shadowColor||"transparent",m.shadowOffsetX=t.shadowOffsetX||0,m.shadowOffsetY=t.shadowOffsetY||0,m.opacity=tt(t.opacity,e.opacity,1)},e.makeFont=function(t){var e="";return Fs(t)&&(e=[t.fontStyle,t.fontWeight,Vs(t.fontSize),t.fontFamily||"sans-serif"].join(" ")),e&&rt(e)||t.textFont||t.font},e}(fa),Ns={left:!0,right:1,center:1},Es={top:1,bottom:1,middle:1},zs=["fontStyle","fontWeight","fontSize","fontFamily"];function Vs(t){return"string"!=typeof t||-1===t.indexOf("px")&&-1===t.indexOf("rem")&&-1===t.indexOf("em")?isNaN(+t)?"12px":t+"px":t}function Bs(t,e){for(var n=0;n<zs.length;n++){var i=zs[n],r=e[i];null!=r&&(t[i]=r)}}function Fs(t){return null!=t.fontSize||t.fontFamily||t.fontWeight}function Gs(t){if(t){t.font=Rs.makeFont(t);var e=t.align;"middle"===e&&(e="center"),t.align=null==e||Ns[e]?e:"left";var n=t.verticalAlign;"center"===n&&(n="middle"),t.verticalAlign=null==n||Es[n]?n:"top",t.padding&&(t.padding=nt(t.padding))}}function Ws(t,e){return null==t||e<=0||"transparent"===t||"none"===t?null:t.image||t.colorStops?"#000":t}function Hs(t){return null==t||"none"===t?null:t.image||t.colorStops?"#000":t}function Ys(t,e,n){return"right"===e?t-n[1]:"center"===e?t+n[3]/2-n[1]/2:t+n[3]}function Xs(t){var e=t.text;return null!=e&&(e+=""),e}function Us(t){return!!(t.backgroundColor||t.lineHeight||t.borderWidth&&t.borderColor)}const Zs=Rs;var js=bo(),qs=function(t,e,n,i){if(i){var r=js(i);// Add data index and series index for indexing the data by element
// Useful in tooltip
r.dataIndex=n,r.dataType=e,r.seriesIndex=t,// TODO: not store dataIndex on children.
"group"===i.type&&i.traverse((function(i){var r=js(i);r.seriesIndex=t,r.dataIndex=n,r.dataType=e}))}},Ks=1,$s={},Js=bo(),Qs=bo(),tl=["emphasis","blur","select"],el=["normal","emphasis","blur","select"],nl=10,il="highlight",rl="downplay",ol="select",al="unselect",sl="toggleSelect";function ll(t){return null!=t&&"none"!==t}// Most lifted color are duplicated.
var ul=new kn(100);function hl(t){if(H(t)){var e=ul.get(t);return e||(e=Xn(t,-.1),ul.put(t,e)),e}// Change nothing.
if(K(t)){var n=A({},t);return n.colorStops=N(t.colorStops,(function(t){return{offset:t.offset,color:Xn(t.color,-.1)}})),n}return t}function cl(t,e,n){t.onHoverStateChange&&(t.hoverState||0)!==n&&t.onHoverStateChange(e),t.hoverState=n}function pl(t){// Only mark the flag.
// States will be applied in the echarts.ts in next frame.
cl(t,"emphasis",2)}function dl(t){// Only mark the flag.
// States will be applied in the echarts.ts in next frame.
2===t.hoverState&&cl(t,"normal",0)}function fl(t){cl(t,"blur",1)}function gl(t){1===t.hoverState&&cl(t,"normal",0)}function yl(t){t.selected=!0}function vl(t){t.selected=!1}function ml(t,e,n){e(t,n)}function xl(t,e,n){ml(t,e,n),t.isGroup&&t.traverse((function(t){ml(t,e,n)}))}function _l(t,e){switch(e){case"emphasis":t.hoverState=2;break;case"normal":t.hoverState=0;break;case"blur":t.hoverState=1;break;case"select":t.selected=!0}}function bl(t,e){var n=this.states[t];if(this.style){if("emphasis"===t)return function(t,e,n,i){var r=n&&L(n,"select")>=0,o=!1;if(t instanceof ys){var a=Js(t),s=r&&a.selectFill||a.normalFill,l=r&&a.selectStroke||a.normalStroke;if(ll(s)||ll(l)){var u=(i=i||{}).style||{};// inherit case
"inherit"===u.fill?(o=!0,i=A({},i),(u=A({},u)).fill=s):!ll(u.fill)&&ll(s)?(o=!0,// Not modify the original value.
i=A({},i),// Already being applied 'emphasis'. DON'T lift color multiple times.
(u=A({},u)).fill=hl(s)):!ll(u.stroke)&&ll(l)&&(o||(i=A({},i),u=A({},u)),u.stroke=hl(l)),i.style=u}}if(i&&null==i.z2){o||(i=A({},i));var h=t.z2EmphasisLift;i.z2=t.z2+(null!=h?h:nl)}return i}(this,0,e,n);if("blur"===t)return function(t,e,n){var i=L(t.currentStates,e)>=0,r=t.style.opacity,o=i?null:function(t,e,n,i){for(var r=t.style,o={},a=0;a<e.length;a++){var s=e[a],l=r[s];o[s]=null==l?i&&i[s]:l}for(a=0;a<t.animators.length;a++){var u=t.animators[a];u.__fromStateTransition&&u.__fromStateTransition.indexOf(n)<0&&"style"===u.targetName&&u.saveTo(o,e)}return o}(t,["opacity"],e,{opacity:1}),a=(n=n||{}).style||{};return null==a.opacity&&(// clone state
n=A({},n),a=A({// Already being applied 'emphasis'. DON'T mul opacity multiple times.
opacity:i?r:.1*o.opacity},a),n.style=a),n}(this,t,n);if("select"===t)return function(t,e,n){// const hasSelect = indexOf(el.currentStates, stateName) >= 0;
if(n&&null==n.z2){n=A({},n);var i=t.z2SelectLift;n.z2=t.z2+(null!=i?i:9)}return n}(this,0,n)}return n}
/**
             * Set hover style (namely "emphasis style") of element.
             * @param el Should not be `zrender/graphic/Group`.
             * @param focus 'self' | 'selfInSeries' | 'series'
             */function wl(t){t.stateProxy=bl;var e=t.getTextContent(),n=t.getTextGuideLine();e&&(e.stateProxy=bl),n&&(n.stateProxy=bl)}function Sl(t,e){!Ll(t,e)&&!t.__highByOuter&&xl(t,pl)}function Ml(t,e){!Ll(t,e)&&!t.__highByOuter&&xl(t,dl)}function Il(t,e){t.__highByOuter|=1<<(e||0),xl(t,pl)}function Tl(t,e){!(t.__highByOuter&=~(1<<(e||0)))&&xl(t,dl)}function Cl(t){xl(t,fl)}function Dl(t){xl(t,gl)}function Al(t){xl(t,yl)}function kl(t){xl(t,vl)}function Ll(t,e){return t.__highDownSilentOnTouch&&e.zrByTouch}function Pl(t){var e=t.getModel(),n=[],i=[];e.eachComponent((function(e,r){var o=Qs(r),a="series"===e,s=a?t.getViewOfSeriesModel(r):t.getViewOfComponentModel(r);!a&&i.push(s),o.isBlured&&(// Leave blur anyway
s.group.traverse((function(t){gl(t)})),a&&n.push(r)),o.isBlured=!1})),R(i,(function(t){t&&t.toggleBlurSeries&&t.toggleBlurSeries(n,!1,e)}))}function Ol(t,e,n,i){var r=i.getModel();function o(t,e){for(var n=0;n<e.length;n++){var i=t.getItemGraphicEl(e[n]);i&&Dl(i)}}if(n=n||"coordinateSystem",null!=t&&e&&"none"!==e){var a=r.getSeriesByIndex(t),s=a.coordinateSystem;s&&s.master&&(s=s.master);var l=[];r.eachSeries((function(t){var r=a===t,u=t.coordinateSystem;// If there is no coordinate system. use sameSeries instead.
if(u&&u.master&&(u=u.master),!(// Not blur other series if blurScope series
"series"===n&&!r||"coordinateSystem"===n&&!(u&&s?u===s:r)||"series"===e&&r)){if(i.getViewOfSeriesModel(t).group.traverse((function(t){fl(t)})),O(e))o(t.getData(),e);else if(U(e))for(var h=V(e),c=0;c<h.length;c++)o(t.getData(h[c]),e[h[c]]);l.push(t),Qs(t).isBlured=!0}})),r.eachComponent((function(t,e){if("series"!==t){var n=i.getViewOfComponentModel(e);n&&n.toggleBlurSeries&&n.toggleBlurSeries(l,!0,r)}}))}}function Rl(t,e,n){if(null!=t&&null!=e){var i=n.getModel().getComponent(t,e);if(i){Qs(i).isBlured=!0;var r=n.getViewOfComponentModel(i);r&&r.focusBlurEnabled&&r.group.traverse((function(t){fl(t)}))}}}function Nl(t,e,n,i){var r={focusSelf:!1,dispatchers:null};if(null==t||"series"===t||null==e||null==n)return r;var o=i.getModel().getComponent(t,e);if(!o)return r;var a=i.getViewOfComponentModel(o);if(!a||!a.findHighDownDispatchers)return r;for(var s,l=a.findHighDownDispatchers(n),u=0// At presnet, the component (like Geo) only blur inside itself.
// So we do not use `blurScope` in component.
;u<l.length;u++)if("self"===js(l[u]).focus){s=!0;break}return{focusSelf:s,dispatchers:l}}function El(t){R(t.getAllData(),(function(e){var n=e.data,i=e.type;n.eachItemGraphicEl((function(e,n){t.isSelected(n,i)?Al(e):kl(e)}))}))}function zl(t){var e=[];return t.eachSeries((function(t){R(t.getAllData(),(function(n){n.data;var i=n.type,r=t.getSelectedDataIndices();if(r.length>0){var o={dataIndex:r,seriesIndex:t.seriesIndex};null!=i&&(o.dataType=i),e.push(o)}}))})),e}
/**
             * Enable the function that mouseover will trigger the emphasis state.
             *
             * NOTE:
             * This function should be used on the element with dataIndex, seriesIndex.
             *
             */function Vl(t,e,n){Yl(t,!0),xl(t,wl),Fl(t,e,n)}function Bl(t,e,n,i){i?function(t){Yl(t,!1)}(t):Vl(t,e,n)}function Fl(t,e,n){var i=js(t);null!=e?(// TODO dataIndex may be set after this function. This check is not useful.
// if (ecData.dataIndex == null) {
//     if (__DEV__) {
//         console.warn('focus can only been set on element with dataIndex');
//     }
// }
// else {
i.focus=e,i.blurScope=n):i.focus&&(i.focus=null)}var Gl=["emphasis","blur","select"],Wl={itemStyle:"getItemStyle",lineStyle:"getLineStyle",areaStyle:"getAreaStyle"};
/**
             * Set emphasis/blur/selected states of element.
             */
function Hl(t,e,n,// default itemStyle
i){n=n||"itemStyle";for(var r=0;r<Gl.length;r++){var o=Gl[r],a=e.getModel([o,n]);// Let it throw error if getterType is not found.
t.ensureState(o).style=i?i(a):a[Wl[n]]()}}
/**
             *
             * Set element as highlight / downplay dispatcher.
             * It will be checked when element received mouseover event or from highlight action.
             * It's in change of all highlight/downplay behavior of it's children.
             *
             * @param el
             * @param el.highDownSilentOnTouch
             *        In touch device, mouseover event will be trigger on touchstart event
             *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
             *        conveniently use hoverStyle when tap on touch screen without additional
             *        code for compatibility.
             *        But if the chart/component has select feature, which usually also use
             *        hoverStyle, there might be conflict between 'select-highlight' and
             *        'hover-highlight' especially when roam is enabled (see geo for example).
             *        In this case, `highDownSilentOnTouch` should be used to disable
             *        hover-highlight on touch device.
             * @param asDispatcher If `false`, do not set as "highDownDispatcher".
             */function Yl(t,e){var n=!1===e,i=t;// Make `highDownSilentOnTouch` and `onStateChange` only work after
// `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.
t.highDownSilentOnTouch&&(i.__highDownSilentOnTouch=t.highDownSilentOnTouch),// Simple optimize, since this method might be
// called for each elements of a group in some cases.
n&&!i.__highDownDispatcher||(// Emphasis, normal can be triggered manually by API or other components like hover link.
// el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent);
// Also keep previous record.
i.__highByOuter=i.__highByOuter||0,i.__highDownDispatcher=!n)}function Xl(t){return!(!t||!t.__highDownDispatcher)}
/**
             * Enable component highlight/downplay features:
             * + hover link (within the same name)
             * + focus blur in component
             */function Ul(t){var e=t.type;return e===ol||e===al||e===sl}function Zl(t){var e=t.type;return e===il||e===rl}var jl=qa.CMD,ql=[[],[],[]],Kl=Math.sqrt,$l=Math.atan2;function Jl(t,e){if(e){var n,i,r,o,a,s,l=t.data,u=t.len(),h=jl.M,c=jl.C,p=jl.L,d=jl.R,f=jl.A,g=jl.Q;for(r=0,o=0;r<u;){switch(n=l[r++],o=r,i=0,n){case h:case p:i=1;break;case c:i=3;break;case g:i=2;break;case f:var y=e[4],v=e[5],m=Kl(e[0]*e[0]+e[1]*e[1]),x=Kl(e[2]*e[2]+e[3]*e[3]),_=$l(-e[1]/x,e[0]/m);l[r]*=m,l[r++]+=y,l[r]*=x,l[r++]+=v,l[r++]*=m,l[r++]*=x,l[r++]+=_,l[r++]+=_,o=r+=2;break;case d:s[0]=l[r++],s[1]=l[r++],Pt(s,s,e),l[o++]=s[0],l[o++]=s[1],s[0]+=l[r++],s[1]+=l[r++],Pt(s,s,e),l[o++]=s[0],l[o++]=s[1]}for(a=0;a<i;a++){var b=ql[a];b[0]=l[r++],b[1]=l[r++],Pt(b,b,e),l[o++]=b[0],l[o++]=b[1]}}t.increaseVersion()}}var Ql=Math.sqrt,tu=Math.sin,eu=Math.cos,nu=Math.PI;function iu(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function ru(t,e){return(t[0]*e[0]+t[1]*e[1])/(iu(t)*iu(e))}function ou(t,e){return(t[0]*e[1]<t[1]*e[0]?-1:1)*Math.acos(ru(t,e))}function au(t,e,n,i,r,o,a,s,l,u,h){var c=l*(nu/180),p=eu(c)*(t-n)/2+tu(c)*(e-i)/2,d=-1*tu(c)*(t-n)/2+eu(c)*(e-i)/2,f=p*p/(a*a)+d*d/(s*s);f>1&&(a*=Ql(f),s*=Ql(f));var g=(r===o?-1:1)*Ql((a*a*(s*s)-a*a*(d*d)-s*s*(p*p))/(a*a*(d*d)+s*s*(p*p)))||0,y=g*a*d/s,v=g*-s*p/a,m=(t+n)/2+eu(c)*y-tu(c)*v,x=(e+i)/2+tu(c)*y+eu(c)*v,_=ou([1,0],[(p-y)/a,(d-v)/s]),b=[(p-y)/a,(d-v)/s],w=[(-1*p-y)/a,(-1*d-v)/s],S=ou(b,w);if(ru(b,w)<=-1&&(S=nu),ru(b,w)>=1&&(S=0),S<0){var M=Math.round(S/nu*1e6)/1e6;S=2*nu+M%2*nu}h.addData(u,m,x,a,s,_,S,c,o)}var su=/([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,lu=/-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g,uu=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.applyTransform=function(t){},e}(ys);function hu(t){return null!=t.setData}function cu(t,e){var n=function(t){var e=new qa;if(!t)return e;var n,i=0,r=0,o=i,a=r,s=qa.CMD,l=t.match(su);if(!l)return e;for(var u=0;u<l.length;u++){for(var h=l[u],c=h.charAt(0),p=void 0,d=h.match(lu)||[],f=d.length,g=0;g<f;g++)d[g]=parseFloat(d[g]);for(var y=0;y<f;){var v=void 0,m=void 0,x=void 0,_=void 0,b=void 0,w=void 0,S=void 0,M=i,I=r,T=void 0,C=void 0;switch(c){case"l":i+=d[y++],r+=d[y++],p=s.L,e.addData(p,i,r);break;case"L":i=d[y++],r=d[y++],p=s.L,e.addData(p,i,r);break;case"m":i+=d[y++],r+=d[y++],p=s.M,e.addData(p,i,r),o=i,a=r,c="l";break;case"M":i=d[y++],r=d[y++],p=s.M,e.addData(p,i,r),o=i,a=r,c="L";break;case"h":i+=d[y++],p=s.L,e.addData(p,i,r);break;case"H":i=d[y++],p=s.L,e.addData(p,i,r);break;case"v":r+=d[y++],p=s.L,e.addData(p,i,r);break;case"V":r=d[y++],p=s.L,e.addData(p,i,r);break;case"C":p=s.C,e.addData(p,d[y++],d[y++],d[y++],d[y++],d[y++],d[y++]),i=d[y-2],r=d[y-1];break;case"c":p=s.C,e.addData(p,d[y++]+i,d[y++]+r,d[y++]+i,d[y++]+r,d[y++]+i,d[y++]+r),i+=d[y-2],r+=d[y-1];break;case"S":v=i,m=r,T=e.len(),C=e.data,n===s.C&&(v+=i-C[T-4],m+=r-C[T-3]),p=s.C,M=d[y++],I=d[y++],i=d[y++],r=d[y++],e.addData(p,v,m,M,I,i,r);break;case"s":v=i,m=r,T=e.len(),C=e.data,n===s.C&&(v+=i-C[T-4],m+=r-C[T-3]),p=s.C,M=i+d[y++],I=r+d[y++],i+=d[y++],r+=d[y++],e.addData(p,v,m,M,I,i,r);break;case"Q":M=d[y++],I=d[y++],i=d[y++],r=d[y++],p=s.Q,e.addData(p,M,I,i,r);break;case"q":M=d[y++]+i,I=d[y++]+r,i+=d[y++],r+=d[y++],p=s.Q,e.addData(p,M,I,i,r);break;case"T":v=i,m=r,T=e.len(),C=e.data,n===s.Q&&(v+=i-C[T-4],m+=r-C[T-3]),i=d[y++],r=d[y++],p=s.Q,e.addData(p,v,m,i,r);break;case"t":v=i,m=r,T=e.len(),C=e.data,n===s.Q&&(v+=i-C[T-4],m+=r-C[T-3]),i+=d[y++],r+=d[y++],p=s.Q,e.addData(p,v,m,i,r);break;case"A":x=d[y++],_=d[y++],b=d[y++],w=d[y++],S=d[y++],au(M=i,I=r,i=d[y++],r=d[y++],w,S,x,_,b,p=s.A,e);break;case"a":x=d[y++],_=d[y++],b=d[y++],w=d[y++],S=d[y++],au(M=i,I=r,i+=d[y++],r+=d[y++],w,S,x,_,b,p=s.A,e)}}"z"!==c&&"Z"!==c||(p=s.Z,e.addData(p),i=o,r=a),n=p}return e.toStatic(),e}(t),i=A({},e);return i.buildPath=function(t){if(hu(t))t.setData(n.data),(e=t.getContext())&&t.rebuildPath(e,1);else{var e=t;n.rebuildPath(e,1)}},i.applyTransform=function(t){Jl(n,t),this.dirtyShape()},i}function pu(t,e){return new uu(cu(t,e))}function du(t,e){e=e||{};var n=new ys;return t.shape&&n.setShape(t.shape),n.setStyle(t.style),e.bakeTransform?Jl(n.path,t.getComputedTransform()):e.toLocal?n.setLocalTransform(t.getComputedTransform()):n.copyTransform(t),n.buildPath=t.buildPath,n.applyTransform=n.applyTransform,n.z=t.z,n.z2=t.z2,n.zlevel=t.zlevel,n}var fu=function(){this.cx=0,this.cy=0,this.r=0},gu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new fu},e.prototype.buildPath=function(t,e){t.moveTo(e.cx+e.r,e.cy),t.arc(e.cx,e.cy,e.r,0,2*Math.PI)},e}(ys);gu.prototype.type="circle";const yu=gu;var vu=function(){this.cx=0,this.cy=0,this.rx=0,this.ry=0},mu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new vu},e.prototype.buildPath=function(t,e){var n=.5522848,i=e.cx,r=e.cy,o=e.rx,a=e.ry,s=o*n,l=a*n;t.moveTo(i-o,r),t.bezierCurveTo(i-o,r-l,i-s,r-a,i,r-a),t.bezierCurveTo(i+s,r-a,i+o,r-l,i+o,r),t.bezierCurveTo(i+o,r+l,i+s,r+a,i,r+a),t.bezierCurveTo(i-s,r+a,i-o,r+l,i-o,r),t.closePath()},e}(ys);mu.prototype.type="ellipse";const xu=mu;var _u=Math.PI,bu=2*_u,wu=Math.sin,Su=Math.cos,Mu=Math.acos,Iu=Math.atan2,Tu=Math.abs,Cu=Math.sqrt,Du=Math.max,Au=Math.min,ku=1e-4;function Lu(t,e,n,i,r,o,a){var s=t-n,l=e-i,u=(a?o:-o)/Cu(s*s+l*l),h=u*l,c=-u*s,p=t+h,d=e+c,f=n+h,g=i+c,y=(p+f)/2,v=(d+g)/2,m=f-p,x=g-d,_=m*m+x*x,b=r-o,w=p*g-f*d,S=(x<0?-1:1)*Cu(Du(0,b*b*_-w*w)),M=(w*x-m*S)/_,I=(-w*m-x*S)/_,T=(w*x+m*S)/_,C=(-w*m+x*S)/_,D=M-y,A=I-v,k=T-y,L=C-v;return D*D+A*A>k*k+L*L&&(M=T,I=C),{cx:M,cy:I,x0:-h,y0:-c,x1:M*(r/b-1),y1:I*(r/b-1)}}function Pu(t,e){var n,i=Du(e.r,0),r=Du(e.r0||0,0),o=i>0;if(o||r>0){if(o||(i=r,r=0),r>i){var a=i;i=r,r=a}var s=e.startAngle,l=e.endAngle;if(!isNaN(s)&&!isNaN(l)){var u=e.cx,h=e.cy,c=!!e.clockwise,p=Tu(l-s),d=p>bu&&p%bu;if(d>ku&&(p=d),i>ku)if(p>bu-ku)t.moveTo(u+i*Su(s),h+i*wu(s)),t.arc(u,h,i,s,l,!c),r>ku&&(t.moveTo(u+r*Su(l),h+r*wu(l)),t.arc(u,h,r,l,s,c));else{var f=void 0,g=void 0,y=void 0,v=void 0,m=void 0,x=void 0,_=void 0,b=void 0,w=void 0,S=void 0,M=void 0,I=void 0,T=void 0,C=void 0,D=void 0,A=void 0,k=i*Su(s),L=i*wu(s),P=r*Su(l),O=r*wu(l),R=p>ku;if(R){var N=e.cornerRadius;N&&(n=function(t){var e;if(G(t)){var n=t.length;if(!n)return t;e=1===n?[t[0],t[0],0,0]:2===n?[t[0],t[0],t[1],t[1]]:3===n?t.concat(t[2]):t}else e=[t,t,t,t];return e}(N),f=n[0],g=n[1],y=n[2],v=n[3]);var E=Tu(i-r)/2;if(m=Au(E,y),x=Au(E,v),_=Au(E,f),b=Au(E,g),M=w=Du(m,x),I=S=Du(_,b),(w>ku||S>ku)&&(T=i*Su(l),C=i*wu(l),D=r*Su(s),A=r*wu(s),p<_u)){var z=function(t,e,n,i,r,o,a,s){var l=n-t,u=i-e,h=a-r,c=s-o,p=c*l-h*u;if(!(p*p<ku))return[t+(p=(h*(e-o)-c*(t-r))/p)*l,e+p*u]}(k,L,D,A,T,C,P,O);if(z){var V=k-z[0],B=L-z[1],F=T-z[0],W=C-z[1],H=1/wu(Mu((V*F+B*W)/(Cu(V*V+B*B)*Cu(F*F+W*W)))/2),Y=Cu(z[0]*z[0]+z[1]*z[1]);M=Au(w,(i-Y)/(H+1)),I=Au(S,(r-Y)/(H-1))}}}if(R)if(M>ku){var X=Au(y,M),U=Au(v,M),Z=Lu(D,A,k,L,i,X,c),j=Lu(T,C,P,O,i,U,c);t.moveTo(u+Z.cx+Z.x0,h+Z.cy+Z.y0),M<w&&X===U?t.arc(u+Z.cx,h+Z.cy,M,Iu(Z.y0,Z.x0),Iu(j.y0,j.x0),!c):(X>0&&t.arc(u+Z.cx,h+Z.cy,X,Iu(Z.y0,Z.x0),Iu(Z.y1,Z.x1),!c),t.arc(u,h,i,Iu(Z.cy+Z.y1,Z.cx+Z.x1),Iu(j.cy+j.y1,j.cx+j.x1),!c),U>0&&t.arc(u+j.cx,h+j.cy,U,Iu(j.y1,j.x1),Iu(j.y0,j.x0),!c))}else t.moveTo(u+k,h+L),t.arc(u,h,i,s,l,!c);else t.moveTo(u+k,h+L);r>ku&&R?I>ku?(X=Au(f,I),Z=Lu(P,O,T,C,r,-(U=Au(g,I)),c),j=Lu(k,L,D,A,r,-X,c),t.lineTo(u+Z.cx+Z.x0,h+Z.cy+Z.y0),I<S&&X===U?t.arc(u+Z.cx,h+Z.cy,I,Iu(Z.y0,Z.x0),Iu(j.y0,j.x0),!c):(U>0&&t.arc(u+Z.cx,h+Z.cy,U,Iu(Z.y0,Z.x0),Iu(Z.y1,Z.x1),!c),t.arc(u,h,r,Iu(Z.cy+Z.y1,Z.cx+Z.x1),Iu(j.cy+j.y1,j.cx+j.x1),c),X>0&&t.arc(u+j.cx,h+j.cy,X,Iu(j.y1,j.x1),Iu(j.y0,j.x0),!c))):(t.lineTo(u+P,h+O),t.arc(u,h,r,l,s,c)):t.lineTo(u+P,h+O)}else t.moveTo(u,h);t.closePath()}}}var Ou=function(){this.cx=0,this.cy=0,this.r0=0,this.r=0,this.startAngle=0,this.endAngle=2*Math.PI,this.clockwise=!0,this.cornerRadius=0},Ru=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new Ou},e.prototype.buildPath=function(t,e){Pu(t,e)},e.prototype.isZeroArea=function(){return this.shape.startAngle===this.shape.endAngle||this.shape.r===this.shape.r0},e}(ys);Ru.prototype.type="sector";const Nu=Ru;var Eu=function(){this.cx=0,this.cy=0,this.r=0,this.r0=0},zu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new Eu},e.prototype.buildPath=function(t,e){var n=e.cx,i=e.cy,r=2*Math.PI;t.moveTo(n+e.r,i),t.arc(n,i,e.r,0,r,!1),t.moveTo(n+e.r0,i),t.arc(n,i,e.r0,0,r,!0)},e}(ys);zu.prototype.type="ring";const Vu=zu;function Bu(t,e,n){var i=e.smooth,r=e.points;if(r&&r.length>=2){if(i){var o=function(t,e,n,i){var r,o,a,s,l=[],u=[],h=[],c=[];if(i){a=[1/0,1/0],s=[-1/0,-1/0];for(var p=0,d=t.length;p<d;p++)Ot(a,a,t[p]),Rt(s,s,t[p]);Ot(a,a,i[0]),Rt(s,s,i[1])}for(p=0,d=t.length;p<d;p++){var f=t[p];if(n)r=t[p?p-1:d-1],o=t[(p+1)%d];else{if(0===p||p===d-1){l.push(_t(t[p]));continue}r=t[p-1],o=t[p+1]}Mt(u,o,r),Tt(u,u,e);var g=Dt(f,r),y=Dt(f,o),v=g+y;0!==v&&(g/=v,y/=v),Tt(h,u,-g),Tt(c,u,y);var m=wt([],f,h),x=wt([],f,c);i&&(Rt(m,m,a),Ot(m,m,s),Rt(x,x,a),Ot(x,x,s)),l.push(m),l.push(x)}return n&&l.push(l.shift()),l}(r,i,n,e.smoothConstraint);t.moveTo(r[0][0],r[0][1]);for(var a=r.length,s=0;s<(n?a:a-1);s++){var l=o[2*s],u=o[2*s+1],h=r[(s+1)%a];t.bezierCurveTo(l[0],l[1],u[0],u[1],h[0],h[1])}}else{t.moveTo(r[0][0],r[0][1]),s=1;for(var c=r.length;s<c;s++)t.lineTo(r[s][0],r[s][1])}n&&t.closePath()}}var Fu=function(){this.points=null,this.smooth=0,this.smoothConstraint=null},Gu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new Fu},e.prototype.buildPath=function(t,e){Bu(t,e,!0)},e}(ys);Gu.prototype.type="polygon";const Wu=Gu;var Hu=function(){this.points=null,this.percent=1,this.smooth=0,this.smoothConstraint=null},Yu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new Hu},e.prototype.buildPath=function(t,e){Bu(t,e,!1)},e}(ys);Yu.prototype.type="polyline";const Xu=Yu;var Uu={},Zu=function(){this.x1=0,this.y1=0,this.x2=0,this.y2=0,this.percent=1},ju=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new Zu},e.prototype.buildPath=function(t,e){var n,i,r,o;if(this.subPixelOptimize){var a=Is(Uu,e,this.style);n=a.x1,i=a.y1,r=a.x2,o=a.y2}else n=e.x1,i=e.y1,r=e.x2,o=e.y2;var s=e.percent;0!==s&&(t.moveTo(n,i),s<1&&(r=n*(1-s)+r*s,o=i*(1-s)+o*s),t.lineTo(r,o))},e.prototype.pointAt=function(t){var e=this.shape;return[e.x1*(1-t)+e.x2*t,e.y1*(1-t)+e.y2*t]},e}(ys);ju.prototype.type="line";const qu=ju;var Ku=[],$u=function(){this.x1=0,this.y1=0,this.x2=0,this.y2=0,this.cpx1=0,this.cpy1=0,this.percent=1};function Ju(t,e,n){var i=t.cpx2,r=t.cpy2;return null!=i||null!=r?[(n?pn:cn)(t.x1,t.cpx1,t.cpx2,t.x2,e),(n?pn:cn)(t.y1,t.cpy1,t.cpy2,t.y2,e)]:[(n?xn:mn)(t.x1,t.cpx1,t.x2,e),(n?xn:mn)(t.y1,t.cpy1,t.y2,e)]}var Qu=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new $u},e.prototype.buildPath=function(t,e){var n=e.x1,i=e.y1,r=e.x2,o=e.y2,a=e.cpx1,s=e.cpy1,l=e.cpx2,u=e.cpy2,h=e.percent;0!==h&&(t.moveTo(n,i),null==l||null==u?(h<1&&(bn(n,a,r,h,Ku),a=Ku[1],r=Ku[2],bn(i,s,o,h,Ku),s=Ku[1],o=Ku[2]),t.quadraticCurveTo(a,s,r,o)):(h<1&&(gn(n,a,l,r,h,Ku),a=Ku[1],l=Ku[2],r=Ku[3],gn(i,s,u,o,h,Ku),s=Ku[1],u=Ku[2],o=Ku[3]),t.bezierCurveTo(a,s,l,u,r,o)))},e.prototype.pointAt=function(t){return Ju(this.shape,t,!1)},e.prototype.tangentAt=function(t){var e=Ju(this.shape,t,!0);return Ct(e,e)},e}(ys);Qu.prototype.type="bezier-curve";const th=Qu;var eh=function(){this.cx=0,this.cy=0,this.r=0,this.startAngle=0,this.endAngle=2*Math.PI,this.clockwise=!0},nh=function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new eh},e.prototype.buildPath=function(t,e){var n=e.cx,i=e.cy,r=Math.max(e.r,0),o=e.startAngle,a=e.endAngle,s=e.clockwise,l=Math.cos(o),u=Math.sin(o);t.moveTo(l*r+n,u*r+i),t.arc(n,i,r,o,a,!s)},e}(ys);nh.prototype.type="arc";const ih=nh;var rh=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="compound",e}return n(e,t),e.prototype._updatePathDirty=function(){for(var t=this.shape.paths,e=this.shapeChanged(),n=0;n<t.length;n++)e=e||t[n].shapeChanged();e&&this.dirtyShape()},e.prototype.beforeBrush=function(){this._updatePathDirty();for(var t=this.shape.paths||[],e=this.getGlobalScale(),n=0;n<t.length;n++)t[n].path||t[n].createPathProxy(),t[n].path.setScale(e[0],e[1],t[n].segmentIgnoreThreshold)},e.prototype.buildPath=function(t,e){for(var n=e.paths||[],i=0;i<n.length;i++)n[i].buildPath(t,n[i].shape,!0)},e.prototype.afterBrush=function(){for(var t=this.shape.paths||[],e=0;e<t.length;e++)t[e].pathUpdated()},e.prototype.getBoundingRect=function(){return this._updatePathDirty.call(this),ys.prototype.getBoundingRect.call(this)},e}(ys);const oh=rh,ah=function(){function t(t){this.colorStops=t||[]}return t.prototype.addColorStop=function(t,e){this.colorStops.push({offset:t,color:e})},t}();var sh=function(t){function e(e,n,i,r,o,a){var s=t.call(this,o)||this;return s.x=null==e?0:e,s.y=null==n?0:n,s.x2=null==i?1:i,s.y2=null==r?0:r,s.type="linear",s.global=a||!1,s}return n(e,t),e}(ah);const lh=t("L",sh);var uh=function(t){function e(e,n,i,r,o){var a=t.call(this,r)||this;return a.x=null==e?.5:e,a.y=null==n?.5:n,a.r=null==i?.5:i,a.type="radial",a.global=o||!1,a}return n(e,t),e}(ah);const hh=t("R",uh);var ch=[0,0],ph=[0,0],dh=new ve,fh=new ve,gh=function(){function t(t,e){this._corners=[],this._axes=[],this._origin=[0,0];for(var n=0;n<4;n++)this._corners[n]=new ve;for(n=0;n<2;n++)this._axes[n]=new ve;t&&this.fromBoundingRect(t,e)}return t.prototype.fromBoundingRect=function(t,e){var n=this._corners,i=this._axes,r=t.x,o=t.y,a=r+t.width,s=o+t.height;if(n[0].set(r,o),n[1].set(a,o),n[2].set(a,s),n[3].set(r,s),e)for(var l=0;l<4;l++)n[l].transform(e);for(ve.sub(i[0],n[1],n[0]),ve.sub(i[1],n[3],n[0]),i[0].normalize(),i[1].normalize(),l=0;l<2;l++)this._origin[l]=i[l].dot(n[0])},t.prototype.intersect=function(t,e){var n=!0,i=!e;return dh.set(1/0,1/0),fh.set(0,0),!this._intersectCheckOneSide(this,t,dh,fh,i,1)&&(n=!1,i)||!this._intersectCheckOneSide(t,this,dh,fh,i,-1)&&(n=!1,i)||i||ve.copy(e,n?dh:fh),n},t.prototype._intersectCheckOneSide=function(t,e,n,i,r,o){for(var a=!0,s=0;s<2;s++){var l=this._axes[s];if(this._getProjMinMaxOnAxis(s,t._corners,ch),this._getProjMinMaxOnAxis(s,e._corners,ph),ch[1]<ph[0]||ch[0]>ph[1]){if(a=!1,r)return a;var u=Math.abs(ph[0]-ch[1]),h=Math.abs(ch[0]-ph[1]);Math.min(u,h)>i.len()&&(u<h?ve.scale(i,l,-u*o):ve.scale(i,l,h*o))}else n&&(u=Math.abs(ph[0]-ch[1]),h=Math.abs(ch[0]-ph[1]),Math.min(u,h)<n.len()&&(u<h?ve.scale(n,l,u*o):ve.scale(n,l,-h*o)))}return a},t.prototype._getProjMinMaxOnAxis=function(t,e,n){for(var i=this._axes[t],r=this._origin,o=e[0].dot(i)+r[t],a=o,s=o,l=1;l<e.length;l++){var u=e[l].dot(i)+r[t];a=Math.min(u,a),s=Math.max(u,s)}n[0]=a,n[1]=s},t}();const yh=gh;var vh=[],mh=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.notClear=!0,e.incremental=!0,e._displayables=[],e._temporaryDisplayables=[],e._cursor=0,e}return n(e,t),e.prototype.traverse=function(t,e){t.call(e,this)},e.prototype.useStyle=function(){this.style={}},e.prototype.getCursor=function(){return this._cursor},e.prototype.innerAfterBrush=function(){this._cursor=this._displayables.length},e.prototype.clearDisplaybles=function(){this._displayables=[],this._temporaryDisplayables=[],this._cursor=0,this.markRedraw(),this.notClear=!1},e.prototype.clearTemporalDisplayables=function(){this._temporaryDisplayables=[]},e.prototype.addDisplayable=function(t,e){e?this._temporaryDisplayables.push(t):this._displayables.push(t),this.markRedraw()},e.prototype.addDisplayables=function(t,e){e=e||!1;for(var n=0;n<t.length;n++)this.addDisplayable(t[n],e)},e.prototype.getDisplayables=function(){return this._displayables},e.prototype.getTemporalDisplayables=function(){return this._temporaryDisplayables},e.prototype.eachPendingDisplayable=function(t){for(var e=this._cursor;e<this._displayables.length;e++)t&&t(this._displayables[e]);for(e=0;e<this._temporaryDisplayables.length;e++)t&&t(this._temporaryDisplayables[e])},e.prototype.update=function(){this.updateTransform();for(var t=this._cursor;t<this._displayables.length;t++)(e=this._displayables[t]).parent=this,e.update(),e.parent=null;for(t=0;t<this._temporaryDisplayables.length;t++){var e;(e=this._temporaryDisplayables[t]).parent=this,e.update(),e.parent=null}},e.prototype.getBoundingRect=function(){if(!this._rect){for(var t=new Ce(1/0,1/0,-1/0,-1/0),e=0;e<this._displayables.length;e++){var n=this._displayables[e],i=n.getBoundingRect().clone();n.needLocalTransform()&&i.applyTransform(n.getLocalTransform(vh)),t.union(i)}this._rect=t}return this._rect},e.prototype.contain=function(t,e){var n=this.transformCoordToLocal(t,e);if(this.getBoundingRect().contain(n[0],n[1]))for(var i=0;i<this._displayables.length;i++)if(this._displayables[i].contain(t,e))return!0;return!1},e}(fa);const xh=mh;var _h=bo();
/**
             * Return null if animation is disabled.
             */function bh(t,e,n,// Extra opts can override the option in animatable model.
i,// TODO It's only for pictorial bar now.
r){var o;// Check if there is global animation configuration from dataZoom/resize can override the config in option.
// If animation is enabled. Will use this animation config in payload.
// If animation is disabled. Just ignore it.
if(e&&e.ecModel){var a=e.ecModel.getUpdatePayload();o=a&&a.animation}var s="update"===t;if(e&&e.isAnimationEnabled()){var l=void 0,u=void 0,h=void 0;return i?(l=Q(i.duration,200),u=Q(i.easing,"cubicOut"),h=0):(l=e.getShallow(s?"animationDurationUpdate":"animationDuration"),u=e.getShallow(s?"animationEasingUpdate":"animationEasing"),h=e.getShallow(s?"animationDelayUpdate":"animationDelay")),// animation from payload has highest priority.
o&&(null!=o.duration&&(l=o.duration),null!=o.easing&&(u=o.easing),null!=o.delay&&(h=o.delay)),W(h)&&(h=h(n,r)),W(l)&&(l=l(n)),{duration:l||0,delay:h,easing:u}}return null}function wh(t,e,n,i,r,o,a){var s,l=!1;W(r)?(a=o,o=r,r=null):U(r)&&(o=r.cb,a=r.during,l=r.isFrom,s=r.removeOpt,r=r.dataIndex);var u="leave"===t;u||// Must stop the remove animation.
e.stopAnimation("leave");var h=bh(t,i,r,u?s||{}:null,i&&i.getAnimationDelayParams?i.getAnimationDelayParams(e,r):null);if(h&&h.duration>0){var c={duration:h.duration,delay:h.delay||0,easing:h.easing,done:o,force:!!o||!!a,// Set to final state in update/init animation.
// So the post processing based on the path shape can be done correctly.
setToFinal:!u,scope:t,during:a};l?e.animateFrom(n,c):e.animateTo(n,c)}else e.stopAnimation(),// If `isFrom`, the props is the "from" props.
!l&&e.attr(n),// Call during at least once.
a&&a(1),o&&o()}
/**
             * Update graphic element properties with or without animation according to the
             * configuration in series.
             *
             * Caution: this method will stop previous animation.
             * So do not use this method to one element twice before
             * animation starts, unless you know what you are doing.
             * @example
             *     graphic.updateProps(el, {
             *         position: [100, 100]
             *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
             *     // Or
             *     graphic.updateProps(el, {
             *         position: [100, 100]
             *     }, seriesModel, function () { console.log('Animation done!'); });
             */function Sh(t,e,// TODO: TYPE AnimatableModel
n,i,r,o){wh("update",t,e,n,i,r,o)}
/**
             * Init graphic element properties with or without animation according to the
             * configuration in series.
             *
             * Caution: this method will stop previous animation.
             * So do not use this method to one element twice before
             * animation starts, unless you know what you are doing.
             */function Mh(t,e,n,i,r,o){wh("enter",t,e,n,i,r,o)}
/**
             * If element is removed.
             * It can determine if element is having remove animation.
             */function Ih(t){if(!t.__zr)return!0;for(var e=0;e<t.animators.length;e++)if("leave"===t.animators[e].scope)return!0;return!1}
/**
             * Remove graphic element
             */function Th(t,e,n,i,r,o){// Don't do remove animation twice.
Ih(t)||wh("leave",t,e,n,i,r,o)}function Ch(t,e,n,i){t.removeTextContent(),t.removeTextGuideLine(),Th(t,{style:{opacity:0}},e,n,i)}function Dh(t,e,n){function i(){t.parent&&t.parent.remove(t)}// Hide label and labelLine first
// TODO Also use fade out animation?
t.isGroup?t.traverse((function(t){t.isGroup||// Can invoke doRemove multiple times.
Ch(t,e,n,i)})):Ch(t,e,n,i)}
/**
             * Save old style for style transition in universalTransition module.
             * It's used when element will be reused in each render.
             * For chart like map, heatmap, which will always create new element.
             * We don't need to save this because universalTransition can get old style from the old element
             */function Ah(t){_h(t).oldStyle=t.style}var kh=Math.max,Lh=Math.min,Ph={},Oh=function(t,e){var i=cu(t,e);return function(t){function e(e){var n=t.call(this,e)||this;return n.applyTransform=i.applyTransform,n.buildPath=i.buildPath,n}return n(e,t),e}(uu)};
/**
             * Register a user defined shape.
             * The shape class can be fetched by `getShapeClass`
             * This method will overwrite the registered shapes, including
             * the registered built-in shapes, if using the same `name`.
             * The shape can be used in `custom series` and
             * `graphic component` by declaring `{type: name}`.
             *
             * @param name
             * @param ShapeClass Can be generated by `extendShape`.
             */
function Rh(t,e){Ph[t]=e}
/**
             * Find shape class registered by `registerShape`. Usually used in
             * fetching user defined shape.
             *
             * [Caution]:
             * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
             * to use user registered shapes.
             * Because the built-in shape (see `getBuiltInShape`) will be registered by
             * `registerShape` by default. That enables users to get both built-in
             * shapes as well as the shapes belonging to themsleves. But users can overwrite
             * the built-in shapes by using names like 'circle', 'rect' via calling
             * `registerShape`. So the echarts inner featrues should not fetch shapes from here
             * in case that it is overwritten by users, except that some features, like
             * `custom series`, `graphic component`, do it deliberately.
             *
             * (2) In the features like `custom series`, `graphic component`, the user input
             * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
             * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
             * are reserved names, that is, if some user registers a shape named `'image'`,
             * the shape will not be used. If we intending to add some more reserved names
             * in feature, that might bring break changes (disable some existing user shape
             * names). But that case probably rarely happens. So we don't make more mechanism
             * to resolve this issue here.
             *
             * @param name
             * @return The shape class. If not found, return nothing.
             */function Nh(t){if(Ph.hasOwnProperty(t))return Ph[t]}
/**
             * Create a path element from path data string
             * @param pathData
             * @param opts
             * @param rect
             * @param layout 'center' or 'cover' default to be cover
             */function Eh(t,e,n,i){var r=pu(t,e);return n&&("center"===i&&(n=Vh(n,r.getBoundingRect())),Fh(r,n)),r}
/**
             * Create a image element from image url
             * @param imageUrl image url
             * @param opts options
             * @param rect constrain rect
             * @param layout 'center' or 'cover'. Default to be 'cover'
             */function zh(t,e,n){var i=new Ss({style:{image:t,x:e.x,y:e.y,width:e.width,height:e.height},onload:function(t){if("center"===n){var r={width:t.width,height:t.height};i.setStyle(Vh(e,r))}}});return i}
/**
             * Get position of centered element in bounding box.
             *
             * @param  rect         element local bounding box
             * @param  boundingRect constraint bounding box
             * @return element position containing x, y, width, and height
             */function Vh(t,e){// Set rect to center, keep width / height ratio.
var n,i=e.width/e.height,r=t.height*i;return n=r<=t.width?t.height:(r=t.width)/i,{x:t.x+t.width/2-r/2,y:t.y+t.height/2-n/2,width:r,height:n}}var Bh=function(t,e){for(var n=[],i=t.length,r=0;r<i;r++){var o=t[r];n.push(o.getUpdatedPathProxy(!0))}var a=new ys(e);return a.createPathProxy(),a.buildPath=function(t){if(hu(t)){t.appendPath(n);var e=t.getContext();e&&t.rebuildPath(e,1)}},a};
/**
             * Resize a path to fit the rect
             * @param path
             * @param rect
             */function Fh(t,e){if(t.applyTransform){var n=t.getBoundingRect().calculateTransform(e);t.applyTransform(n)}}
/**
             * Sub pixel optimize line for canvas
             */function Gh(t,e){return Is(t,t,{lineWidth:e}),t}
/**
             * Sub pixel optimize rect for canvas
             */
/**
             * Sub pixel optimize for canvas
             *
             * @param position Coordinate, such as x, y
             * @param lineWidth Should be nonnegative integer.
             * @param positiveOrNegative Default false (negative).
             * @return Optimized position.
             */
var Wh=Cs;
/**
             * Get transform matrix of target (param target),
             * in coordinate of its ancestor (param ancestor)
             *
             * @param target
             * @param [ancestor]
             */function Hh(t,e){for(var n=ue([]);t&&t!==e;)ce(n,t.getLocalTransform(),n),t=t.parent;return n}
/**
             * Apply transform to an vertex.
             * @param target [x, y]
             * @param transform Can be:
             *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
             *      + {position, rotation, scale}, the same as `zrender/Transformable`.
             * @param invert Whether use invert matrix.
             * @return [x, y]
             */function Yh(t,e,n){return e&&!O(e)&&(e=sr.getLocalTransform(e)),n&&(e=ge([],e)),Pt([],t,e)}
/**
             * @param direction 'left' 'right' 'top' 'bottom'
             * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]
             * @param invert Whether use invert matrix.
             * @return Transformed direction. 'left' 'right' 'top' 'bottom'
             */function Xh(t,e,n){// Pick a base, ensure that transform result will not be (0, 0).
var i=0===e[4]||0===e[5]||0===e[0]?1:Math.abs(2*e[4]/e[0]),r=0===e[4]||0===e[5]||0===e[2]?1:Math.abs(2*e[4]/e[2]),o=["left"===t?-i:"right"===t?i:0,"top"===t?-r:"bottom"===t?r:0];return o=Yh(o,e,n),Math.abs(o[0])>Math.abs(o[1])?o[0]>0?"right":"left":o[1]>0?"bottom":"top"}function Uh(t){return!t.isGroup}
/**
             * Apply group transition animation from g1 to g2.
             * If no animatableModel, no animation.
             */
function Zh(t,e,n){if(t&&e){var i,r=(i={},t.traverse((function(t){Uh(t)&&t.anid&&(i[t.anid]=t)})),i);e.traverse((function(t){if(Uh(t)&&t.anid){var e=r[t.anid];if(e){var i=o(t);t.attr(o(e)),Sh(t,i,n,js(t).dataIndex)}}}))}function o(t){var e={x:t.x,y:t.y,rotation:t.rotation};return function(t){return null!=t.shape}(t)&&(e.shape=A({},t.shape)),e}}function jh(t,e){// FIXME: This way might be incorrect when graphic clipped by a corner
// and when element has a border.
return N(t,(function(t){var n=t[0];n=kh(n,e.x),n=Lh(n,e.x+e.width);var i=t[1];return i=kh(i,e.y),[n,i=Lh(i,e.y+e.height)]}))}
/**
             * Return a new clipped rect. If rect size are negative, return undefined.
             */function qh(t,// Support 'image://' or 'path://' or direct svg path.
e,n){var i=A({rectHover:!0},e),r=i.style={strokeNoScale:!0};if(n=n||{x:-1,y:-1,width:2,height:2},t)return 0===t.indexOf("image://")?(r.image=t.slice(8),k(r,n),new Ss(i)):Eh(t.replace("path://",""),i,n,"center")}
/**
             * Return `true` if the given line (line `a`) and the given polygon
             * are intersect.
             * Note that we do not count colinear as intersect here because no
             * requirement for that. We could do that if required in future.
             */function Kh(t,e,n,i,r){for(var o=0,a=r[r.length-1];o<r.length;o++){var s=r[o];if($h(t,e,n,i,s[0],s[1],a[0],a[1]))return!0;a=s}}
/**
             * Return `true` if the given two lines (line `a` and line `b`)
             * are intersect.
             * Note that we do not count colinear as intersect here because no
             * requirement for that. We could do that if required in future.
             */function $h(t,e,n,i,r,o,a,s){// let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.
var l,u=n-t,h=i-e,c=a-r,p=s-o,d=Jh(c,p,u,h);if((l=d)<=1e-6&&l>=-1e-6)return!1;// `vec_m` and `vec_n` are intersect iff
//     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,
//     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`
//           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.
var f=t-r,g=e-o,y=Jh(f,g,u,h)/d;if(y<0||y>1)return!1;var v=Jh(f,g,c,p)/d;return!(v<0||v>1)}
/**
             * Cross product of 2-dimension vector.
             */function Jh(t,e,n,i){return t*i-n*e}function Qh(t){var e=t.itemTooltipOption,n=t.componentModel,i=t.itemName,r=H(e)?{formatter:e}:e,o=n.mainType,a=n.componentIndex,s={componentType:o,name:i,$vars:["name"]};s[o+"Index"]=a;var l=t.formatterParamsExtra;l&&R(V(l),(function(t){gt(s,t)||(s[t]=l[t],s.$vars.push(t))}));var u=js(t.el);u.componentMainType=o,u.componentIndex=a,u.tooltipConfig={name:i,option:k({content:i,formatterParams:s},r)}}function tc(t,e){var n;// TODO
// Polyfill for fixing zrender group traverse don't visit it's root issue.
t.isGroup&&(n=e(t)),n||t.traverse(e)}function ec(t,e){if(t)if(G(t))for(var n=0;n<t.length;n++)tc(t[n],e);else tc(t,e)}// Register built-in shapes. These shapes might be overwritten
// by users, although we do not recommend that.
Rh("circle",yu),Rh("ellipse",xu),Rh("sector",Nu),Rh("ring",Vu),Rh("polygon",Wu),Rh("polyline",Xu),Rh("rect",Ls),Rh("line",qu),Rh("bezierCurve",th),Rh("arc",ih);const nc=Object.freeze(Object.defineProperty({__proto__:null,updateProps:Sh,initProps:Mh,removeElement:Th,removeElementWithFadeOut:Dh,isElementRemoved:Ih,extendShape:
/**
             * Extend shape with parameters
             */
function(t){return ys.extend(t)},extendPath:
/**
             * Extend path
             */
function(t,e){return Oh(t,e)},registerShape:Rh,getShapeClass:Nh,makePath:Eh,makeImage:zh,mergePath:Bh,resizePath:Fh,subPixelOptimizeLine:Gh,subPixelOptimizeRect:function(t){return Ts(t.shape,t.shape,t.style),t},subPixelOptimize:Wh,getTransform:Hh,applyTransform:Yh,transformDirection:Xh,groupTransition:Zh,clipPointsByRect:jh,clipRectByRect:function(t,e){var n=kh(t.x,e.x),i=Lh(t.x+t.width,e.x+e.width),r=kh(t.y,e.y),o=Lh(t.y+t.height,e.y+e.height);// If the total rect is cliped, nothing, including the border,
// should be painted. So return undefined.
if(i>=n&&o>=r)return{x:n,y:r,width:i-n,height:o-r}},createIcon:qh,linePolygonIntersect:Kh,lineLineIntersect:$h,setTooltipConfig:Qh,traverseElements:ec,Group:Lr,Image:Ss,Text:Zs,Circle:yu,Ellipse:xu,Sector:Nu,Ring:Vu,Polygon:Wu,Polyline:Xu,Rect:Ls,Line:qu,BezierCurve:th,Arc:ih,IncrementalDisplayable:xh,CompoundPath:oh,LinearGradient:lh,RadialGradient:hh,BoundingRect:Ce,OrientedBoundingRect:yh,Point:ve,Path:ys},Symbol.toStringTag,{value:"Module"}));var ic={};function rc(t,e){for(var n=0;n<tl.length;n++){var i=tl[n],r=e[i],o=t.ensureState(i);o.style=o.style||{},o.style.text=r}var a=t.currentStates.slice();t.clearStates(!0),t.setStyle({text:e.normal}),t.useStates(a,!0)}function oc(t,e,n){var i,r=t.labelFetcher,o=t.labelDataIndex,a=t.labelDimIndex,s=e.normal;r&&(i=r.getFormattedLabel(o,"normal",null,a,s&&s.get("formatter"),null!=n?{interpolatedValue:n}:null)),null==i&&(i=W(t.defaultText)?t.defaultText(o,t,n):t.defaultText);for(var l={normal:i},u=0;u<tl.length;u++){var h=tl[u],c=e[h];l[h]=Q(r?r.getFormattedLabel(o,h,null,a,c&&c.get("formatter")):null,i)}return l}function ac(t,e,n,i){n=n||ic;for(var r=t instanceof Zs,o=!1,a=0;a<el.length;a++)if((p=e[el[a]])&&p.getShallow("show")){o=!0;break}var s=r?t:t.getTextContent();if(o){r||(// Reuse the previous
s||(s=new Zs,t.setTextContent(s)),// Use same state proxy
t.stateProxy&&(s.stateProxy=t.stateProxy));var l=oc(n,e),u=e.normal,h=!!u.getShallow("show"),c=lc(u,i&&i.normal,n,!1,!r);for(c.text=l.normal,r||// Always create new
t.setTextConfig(uc(u,n,!1)),a=0;a<tl.length;a++){var p,d=tl[a];if(p=e[d]){var f=s.ensureState(d),g=!!Q(p.getShallow("show"),h);g!==h&&(f.ignore=!g),f.style=lc(p,i&&i[d],n,!0,!r),f.style.text=l[d],r||(t.ensureState(d).textConfig=uc(p,n,!0))}}// PENDING: if there is many requirements that emphasis position
// need to be different from normal position, we might consider
// auto silent is those cases.
s.silent=!!u.getShallow("silent"),// Keep x and y
null!=s.style.x&&(c.x=s.style.x),null!=s.style.y&&(c.y=s.style.y),s.ignore=!h,// Always create new style.
s.useStyle(c),s.dirty(),n.enableTextSetter&&(gc(s).setLabelText=function(t){var i=oc(n,e,t);rc(s,i)})}else s&&(// Not display rich text.
s.ignore=!0);t.dirty()}function sc(t,e){e=e||"label";for(var n={normal:t.getModel(e)},i=0;i<tl.length;i++){var r=tl[i];n[r]=t.getModel([r,e])}return n}
/**
             * Set basic textStyle properties.
             */function lc(t,e,// Fixed style in the code. Can't be set by model.
n,i,r){var o={};// textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
/**
             * The uniform entry of set text style, that is, retrieve style definitions
             * from `model` and set to `textStyle` object.
             *
             * Never in merge mode, but in overwrite mode, that is, all of the text style
             * properties will be set. (Consider the states of normal and emphasis and
             * default value can be adopted, merge would make the logic too complicated
             * to manage.)
             */
return function(t,e,n,i,r){// Consider there will be abnormal when merge hover style to normal style if given default value.
n=n||ic;var o,a=e.ecModel,s=a&&a.option.textStyle,l=// Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             rich: {
//                 // no 'a' here but using parent 'a'.
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }
// TODO TextStyleModel
function(t){for(// Use object to remove duplicated names.
var e;t&&t!==t.ecModel;){var n=(t.option||ic).rich;if(n){e=e||{};for(var i=V(n),r=0;r<i.length;r++)e[i[r]]=1}t=t.parentModel}return e}(e);if(l)for(var u in o={},l)if(l.hasOwnProperty(u)){// Cascade is supported in rich.
var h=e.getModel(["rich",u]);// In rich, never `disableBox`.
// FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,
// the default color `'blue'` will not be adopted if no color declared in `rich`.
// That might confuses users. So probably we should put `textStyleModel` as the
// root ancestor of the `richTextStyle`. But that would be a break change.
dc(o[u]={},h,s,n,i,r,!1,!0)}o&&(t.rich=o);var c=e.get("overflow");c&&(t.overflow=c);var p=e.get("minMargin");null!=p&&(t.margin=p),dc(t,e,s,n,i,r,!0,!1)}(o,t,n,i,r),e&&A(o,e),o}function uc(t,e,n){e=e||{};var i,r={},o=t.getShallow("rotate"),a=Q(t.getShallow("distance"),n?null:5),s=t.getShallow("offset");// 'outside' is not a valid zr textPostion value, but used
// in bar series, and magric type should be considered.
return"outside"===(i=t.getShallow("position")||(n?null:"inside"))&&(i=e.defaultOutsidePosition||"top"),null!=i&&(r.position=i),null!=s&&(r.offset=s),null!=o&&(o*=Math.PI/180,r.rotation=o),null!=a&&(r.distance=a),// fill and auto is determined by the color of path fill if it's not specified by developers.
r.outsideFill="inherit"===t.get("color")?e.inheritColor||null:"auto",r}var hc=["fontStyle","fontWeight","fontSize","fontFamily","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY"],cc=["align","lineHeight","width","height","tag","verticalAlign"],pc=["padding","borderWidth","borderRadius","borderDashOffset","backgroundColor","borderColor","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY"];function dc(t,e,n,i,r,o,a,s){// In merge mode, default value should not be given.
n=!r&&n||ic;var l=i&&i.inheritColor,u=e.getShallow("color"),h=e.getShallow("textBorderColor"),c=Q(e.getShallow("opacity"),n.opacity);"inherit"!==u&&"auto"!==u||(u=l||null),"inherit"!==h&&"auto"!==h||(h=l||null),o||(// Only use default global textStyle.color if text is individual.
// Otherwise it will use the strategy of attached text color because text may be on a path.
u=u||n.color,h=h||n.textBorderColor),null!=u&&(t.fill=u),null!=h&&(t.stroke=h);var p=Q(e.getShallow("textBorderWidth"),n.textBorderWidth);null!=p&&(t.lineWidth=p);var d=Q(e.getShallow("textBorderType"),n.textBorderType);null!=d&&(t.lineDash=d);var f=Q(e.getShallow("textBorderDashOffset"),n.textBorderDashOffset);null!=f&&(t.lineDashOffset=f),r||null!=c||s||(c=i&&i.defaultOpacity),null!=c&&(t.opacity=c),// TODO
r||o||// Set default finally.
null==t.fill&&i.inheritColor&&(t.fill=i.inheritColor);// Do not use `getFont` here, because merge should be supported, where
// part of these properties may be changed in emphasis style, and the
// others should remain their original value got from normal style.
for(var g=0;g<hc.length;g++){var y=hc[g];null!=(m=Q(e.getShallow(y),n[y]))&&(t[y]=m)}for(g=0;g<cc.length;g++)y=cc[g],null!=(m=e.getShallow(y))&&(t[y]=m);if(null==t.verticalAlign){var v=e.getShallow("baseline");null!=v&&(t.verticalAlign=v)}if(!a||!i.disableBox){for(g=0;g<pc.length;g++){var m;y=pc[g],null!=(m=e.getShallow(y))&&(t[y]=m)}var x=e.getShallow("borderType");null!=x&&(t.borderDash=x),"auto"!==t.backgroundColor&&"inherit"!==t.backgroundColor||!l||(t.backgroundColor=l),"auto"!==t.borderColor&&"inherit"!==t.borderColor||!l||(t.borderColor=l)}}function fc(t,e){var n=e&&e.getModel("textStyle");return rt([// FIXME in node-canvas fontWeight is before fontStyle
t.fontStyle||n&&n.getShallow("fontStyle")||"",t.fontWeight||n&&n.getShallow("fontWeight")||"",(t.fontSize||n&&n.getShallow("fontSize")||12)+"px",t.fontFamily||n&&n.getShallow("fontFamily")||"sans-serif"].join(" "))}var gc=bo();function yc(t,e,n,i){if(t){var r=gc(t);r.prevValue=r.value,r.value=n;var o=e.normal;r.valueAnimation=o.get("valueAnimation"),r.valueAnimation&&(r.precision=o.get("precision"),r.defaultInterpolatedText=i,r.statesModels=e)}}function vc(t,e,n,i,r){var o=gc(t);if(o.valueAnimation&&o.prevValue!==o.value){var a=o.defaultInterpolatedText,s=Q(o.interpolatedValue,o.prevValue),l=o.value;// Consider the case that being animating, do not use the `obj.value`,
// Otherwise it will jump to the `obj.value` when this new animation started.
t.percent=0,(null==o.prevValue?Mh:Sh)(t,{// percent is used to prevent animation from being aborted #15916
percent:1},i,e,null,(function(i){var u=ko(n,o.precision,s,l,i);o.interpolatedValue=1===i?null:u;var h=oc({labelDataIndex:e,labelFetcher:r,defaultText:a?a(u):u+""},o.statesModels,u);rc(t,h)}))}}var mc=["textStyle","color"],xc=["fontStyle","fontWeight","fontSize","fontFamily","padding","lineHeight","rich","width","height","overflow"],_c=new Zs,bc=/** @class */function(){function t(){}
/**
               * Get color property or get color from option.textStyle.color
               */
// TODO Callback
return t.prototype.getTextColor=function(t){var e=this.ecModel;return this.getShallow("color")||(!t&&e?e.get(mc):null)},
/**
               * Create font string from fontStyle, fontWeight, fontSize, fontFamily
               * @return {string}
               */
t.prototype.getFont=function(){return fc({fontStyle:this.getShallow("fontStyle"),fontWeight:this.getShallow("fontWeight"),fontSize:this.getShallow("fontSize"),fontFamily:this.getShallow("fontFamily")},this.ecModel)},t.prototype.getTextRect=function(t){for(var e={text:t,verticalAlign:this.getShallow("verticalAlign")||this.getShallow("baseline")},n=0;n<xc.length;n++)e[xc[n]]=this.getShallow(xc[n]);return _c.useStyle(e),_c.update(),_c.getBoundingRect()},t}();const wc=bc;var Sc,Mc,Ic=[["lineWidth","width"],["stroke","color"],["opacity"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"],["lineDash","type"],["lineDashOffset","dashOffset"],["lineCap","cap"],["lineJoin","join"],["miterLimit"]],Tc=Fo(Ic),Cc=/** @class */function(){function t(){}return t.prototype.getLineStyle=function(t){return Tc(this,t)},t}(),Dc=[["fill","color"],["stroke","borderColor"],["lineWidth","borderWidth"],["opacity"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"],["lineDash","borderType"],["lineDashOffset","borderDashOffset"],["lineCap","borderCap"],["lineJoin","borderJoin"],["miterLimit","borderMiterLimit"]],Ac=Fo(Dc),kc=/** @class */function(){function t(){}return t.prototype.getItemStyle=function(t,e){return Ac(this,t,e)},t}(),Lc=/** @class */function(){function t(t,e,n){this.parentModel=e,this.ecModel=n,this.option=t}return t.prototype.init=function(t,e,n){},
/**
               * Merge the input option to me.
               */
t.prototype.mergeOption=function(t,e){C(this.option,t,!0)},// `path` can be 'a.b.c', so the return value type have to be `ModelOption`
// TODO: TYPE strict key check?
// get(path: string | string[], ignoreParent?: boolean): ModelOption;
t.prototype.get=function(t,e){return null==t?this.option:this._doGet(this.parsePath(t),!e&&this.parentModel)},t.prototype.getShallow=function(t,e){var n=this.option,i=null==n?n:n[t];if(null==i&&!e){var r=this.parentModel;r&&(// FIXME:TS do not know how to make it works
i=r.getShallow(t))}return i},// `path` can be 'a.b.c', so the return value type have to be `Model<ModelOption>`
// getModel(path: string | string[], parentModel?: Model): Model;
// TODO 'a.b.c' is deprecated
t.prototype.getModel=function(e,n){var i=null!=e,r=i?this.parsePath(e):null;return new t(i?this._doGet(r):this.option,n=n||this.parentModel&&this.parentModel.getModel(this.resolveParentPath(r)),this.ecModel)},
/**
               * If model has option
               */
t.prototype.isEmpty=function(){return null==this.option},t.prototype.restoreData=function(){},// Pending
t.prototype.clone=function(){return new(0,this.constructor)(T(this.option))},// setReadOnly(properties): void {
// clazzUtil.setReadOnly(this, properties);
// }
// If path is null/undefined, return null/undefined.
t.prototype.parsePath=function(t){return"string"==typeof t?t.split("."):t},// Resolve path for parent. Perhaps useful when parent use a different property.
// Default to be a identity resolver.
// Can be modified to a different resolver.
t.prototype.resolveParentPath=function(t){return t},// FIXME:TS check whether put this method here
t.prototype.isAnimationEnabled=function(){if(!o.node&&this.option){if(null!=this.option.animation)return!!this.option.animation;if(this.parentModel)return this.parentModel.isAnimationEnabled()}},t.prototype._doGet=function(t,e){var n=this.option;if(!t)return n;for(var i=0;i<t.length&&(!t[i]||null!=(// obj could be number/string/... (like 0)
n=n&&"object"==typeof n?n[t[i]]:null));i++);return null==n&&e&&(n=e._doGet(this.resolveParentPath(t),e.parentModel)),n},t}();Ro(Lc),Sc=Lc,Mc=["__\0is_clz",Eo++].join("_"),Sc.prototype[Mc]=!0,Sc.isInstance=function(t){return!(!t||!t[Mc])},P(Lc,Cc),P(Lc,kc),P(Lc,Wo),P(Lc,wc);const Pc=Lc;var Oc=Math.round(10*Math.random());
/**
             * @public
             * @param {string} type
             * @return {string}
             */function Rc(t){// Considering the case of crossing js context,
// use Math.random to make id as unique as possible.
return[t||"",Oc++].join("_")}
/**
             * Implements `SubTypeDefaulterManager` for `target`.
             */function Nc(t,e){// See also `model/Component.ts#getDefaultOption`
return C(C({},t,!0),e,!0)}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * Language: English.
             */var Ec="ZH",zc="EN",Vc=zc,Bc={},Fc={},Gc=o.domSupported&&/* eslint-disable-next-line */(document.documentElement.lang||navigator.language||navigator.browserLanguage).toUpperCase().indexOf(Ec)>-1?Ec:Vc;function Wc(t,e){t=t.toUpperCase(),Fc[t]=new Pc(e),Bc[t]=e}// export function getLocale(locale: string) {
//     return localeStorage[locale];
// }
function Hc(t){return Fc[t]}// Default locale
Wc(zc,{time:{month:["January","February","March","April","May","June","July","August","September","October","November","December"],monthAbbr:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayOfWeek:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayOfWeekAbbr:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]},legend:{selector:{all:"All",inverse:"Inv"}},toolbox:{brush:{title:{rect:"Box Select",polygon:"Lasso Select",lineX:"Horizontally Select",lineY:"Vertically Select",keep:"Keep Selections",clear:"Clear Selections"}},dataView:{title:"Data View",lang:["Data View","Close","Refresh"]},dataZoom:{title:{zoom:"Zoom",back:"Zoom Reset"}},magicType:{title:{line:"Switch to Line Chart",bar:"Switch to Bar Chart",stack:"Stack",tiled:"Tile"}},restore:{title:"Restore"},saveAsImage:{title:"Save as Image",lang:["Right Click to Save Image"]}},series:{typeNames:{pie:"Pie chart",bar:"Bar chart",line:"Line chart",scatter:"Scatter plot",effectScatter:"Ripple scatter plot",radar:"Radar chart",tree:"Tree",treemap:"Treemap",boxplot:"Boxplot",candlestick:"Candlestick",k:"K line chart",heatmap:"Heat map",map:"Map",parallel:"Parallel coordinate map",lines:"Line graph",graph:"Relationship graph",sankey:"Sankey diagram",funnel:"Funnel chart",gauge:"Gauge",pictorialBar:"Pictorial bar",themeRiver:"Theme River Map",sunburst:"Sunburst"}},aria:{general:{withTitle:'This is a chart about "{title}"',withoutTitle:"This is a chart"},series:{single:{prefix:"",withName:" with type {seriesType} named {seriesName}.",withoutName:" with type {seriesType}."},multiple:{prefix:". It consists of {seriesCount} series count.",withName:" The {seriesId} series is a {seriesType} representing {seriesName}.",withoutName:" The {seriesId} series is a {seriesType}.",separator:{middle:"",end:""}}},data:{allData:"The data is as follows: ",partialData:"The first {displayCnt} items are: ",withName:"the data for {name} is {value}",withoutName:"{value}",separator:{middle:", ",end:". "}}}}),Wc(Ec,{time:{month:["","","","","","","","","","","",""],monthAbbr:["1","2","3","4","5","6","7","8","9","10","11","12"],dayOfWeek:["","","","","","",""],dayOfWeekAbbr:["","","","","","",""]},legend:{selector:{all:"",inverse:""}},toolbox:{brush:{title:{rect:"",polygon:"",lineX:"",lineY:"",keep:"",clear:""}},dataView:{title:"",lang:["","",""]},dataZoom:{title:{zoom:"",back:""}},magicType:{title:{line:"",bar:"",stack:"",tiled:""}},restore:{title:""},saveAsImage:{title:"",lang:[""]}},series:{typeNames:{pie:"",bar:"",line:"",scatter:"",effectScatter:"",radar:"",tree:"",treemap:"",boxplot:"",candlestick:"K",k:"K",heatmap:"",map:"",parallel:"",lines:"",graph:"",sankey:"",funnel:"",gauge:"",pictorialBar:"",themeRiver:"",sunburst:""}},aria:{general:{withTitle:"{title}",withoutTitle:""},series:{single:{prefix:"",withName:"{seriesType}{seriesName}",withoutName:"{seriesType}"},multiple:{prefix:"{seriesCount}",withName:"{seriesId}{seriesName}{seriesType}",withoutName:"{seriesId}{seriesType}",separator:{middle:"",end:""}}},data:{allData:"",partialData:"{displayCnt}",withName:"{name}{value}",withoutName:"{value}",separator:{middle:"",end:""}}}});var Yc=1e3,Xc=6e4,Uc=36e5,Zc=864e5,jc=31536e6,qc={year:"{yyyy}",month:"{MMM}",day:"{d}",hour:"{HH}:{mm}",minute:"{HH}:{mm}",second:"{HH}:{mm}:{ss}",millisecond:"{HH}:{mm}:{ss} {SSS}",none:"{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"},Kc="{yyyy}-{MM}-{dd}",$c={year:"{yyyy}",month:"{yyyy}-{MM}",day:Kc,hour:Kc+" "+qc.hour,minute:Kc+" "+qc.minute,second:Kc+" "+qc.second,millisecond:qc.none},Jc=["year","month","day","hour","minute","second","millisecond"],Qc=["year","half-year","quarter","month","week","half-week","day","half-day","quarter-day","hour","minute","second","millisecond"];function tp(t,e){return"0000".substr(0,e-(t+="").length)+t}function ep(t){switch(t){case"half-year":case"quarter":return"month";case"week":case"half-week":return"day";case"half-day":case"quarter-day":return"hour";default:// year, minutes, second, milliseconds
return t}}function np(t){return t===ep(t)}function ip(// Note: The result based on `isUTC` are totally different, which can not be just simply
// substituted by the result without `isUTC`. So we make the param `isUTC` mandatory.
t,e,n,i){var r=jr(t),o=r[ap(n)](),a=r[sp(n)]()+1,s=Math.floor((a-1)/3)+1,l=r[lp(n)](),u=r["get"+(n?"UTC":"")+"Day"](),h=r[up(n)](),c=(h-1)%12+1,p=r[hp(n)](),d=r[cp(n)](),f=r[pp(n)](),g=(i instanceof Pc?i:Hc(i||Gc)||Fc[Vc]).getModel("time"),y=g.get("month"),v=g.get("monthAbbr"),m=g.get("dayOfWeek"),x=g.get("dayOfWeekAbbr");return(e||"").replace(/{yyyy}/g,o+"").replace(/{yy}/g,o%100+"").replace(/{Q}/g,s+"").replace(/{MMMM}/g,y[a-1]).replace(/{MMM}/g,v[a-1]).replace(/{MM}/g,tp(a,2)).replace(/{M}/g,a+"").replace(/{dd}/g,tp(l,2)).replace(/{d}/g,l+"").replace(/{eeee}/g,m[u]).replace(/{ee}/g,x[u]).replace(/{e}/g,u+"").replace(/{HH}/g,tp(h,2)).replace(/{H}/g,h+"").replace(/{hh}/g,tp(c+"",2)).replace(/{h}/g,c+"").replace(/{mm}/g,tp(p,2)).replace(/{m}/g,p+"").replace(/{ss}/g,tp(d,2)).replace(/{s}/g,d+"").replace(/{SSS}/g,tp(f,3)).replace(/{S}/g,f+"")}function rp(t,e){var n=jr(t),i=n[sp(e)]()+1,r=n[lp(e)](),o=n[up(e)](),a=n[hp(e)](),s=n[cp(e)](),l=0===n[pp(e)](),u=l&&0===s,h=u&&0===a,c=h&&0===o,p=c&&1===r;return p&&1===i?"year":p?"month":c?"day":h?"hour":u?"minute":l?"second":"millisecond"}function op(t,e,n){var i=X(t)?jr(t):t;switch(e=e||rp(t,n)){case"year":return i[ap(n)]();case"half-year":return i[sp(n)]()>=6?1:0;case"quarter":return Math.floor((i[sp(n)]()+1)/4);case"month":return i[sp(n)]();case"day":return i[lp(n)]();case"half-day":return i[up(n)]()/24;case"hour":return i[up(n)]();case"minute":return i[hp(n)]();case"second":return i[cp(n)]();case"millisecond":return i[pp(n)]()}}function ap(t){return t?"getUTCFullYear":"getFullYear"}function sp(t){return t?"getUTCMonth":"getMonth"}function lp(t){return t?"getUTCDate":"getDate"}function up(t){return t?"getUTCHours":"getHours"}function hp(t){return t?"getUTCMinutes":"getMinutes"}function cp(t){return t?"getUTCSeconds":"getSeconds"}function pp(t){return t?"getUTCMilliseconds":"getMilliseconds"}function dp(t){return t?"setUTCFullYear":"setFullYear"}function fp(t){return t?"setUTCMonth":"setMonth"}function gp(t){return t?"setUTCDate":"setDate"}function yp(t){return t?"setUTCHours":"setHours"}function vp(t){return t?"setUTCMinutes":"setMinutes"}function mp(t){return t?"setUTCSeconds":"setSeconds"}function xp(t){return t?"setUTCMilliseconds":"setMilliseconds"}
/**
             * Add a comma each three digit.
             */function _p(t){if(!to(t))return H(t)?t:"-";var e=(t+"").split(".");return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,"$1,")+(e.length>1?"."+e[1]:"")}function bp(t,e){return t=(t||"").toLowerCase().replace(/-(.)/g,(function(t,e){return e.toUpperCase()})),e&&t&&(t=t.charAt(0).toUpperCase()+t.slice(1)),t}var wp=nt;
/**
             * Make value user readable for tooltip and label.
             * "User readable":
             *     Try to not print programmer-specific text like NaN, Infinity, null, undefined.
             *     Avoid to display an empty string, which users can not recognize there is
             *     a value and it might look like a bug.
             */function Sp(t,e,n){function i(t){return t&&rt(t)?t:"-"}function r(t){return!(null==t||isNaN(t)||!isFinite(t))}var o="time"===e,a=t instanceof Date;if(o||a){var s=o?jr(t):t;if(!isNaN(+s))return ip(s,"{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}",n);// In other cases, continue to try to display the value in the following code.
if(a)return"-"}if("ordinal"===e)return Y(t)?i(t):X(t)&&r(t)?t+"":"-";// By default.
var l=Qr(t);return r(l)?_p(l):Y(t)?i(t):"boolean"==typeof t?t+"":"-"}var Mp=["a","b","c","d","e","f","g"],Ip=function(t,e){return"{"+t+(null==e?"":e)+"}"};
/**
             * Template formatter
             * @param {Array.<Object>|Object} paramsList
             */
function Tp(t,e,n){G(e)||(e=[e]);var i=e.length;if(!i)return"";for(var r=e[0].$vars||[],o=0;o<r.length;o++){var a=Mp[o];t=t.replace(Ip(a),Ip(a,0))}for(var s=0;s<i;s++)for(var l=0;l<r.length;l++){var u=e[s][r[l]];t=t.replace(Ip(Mp[l],s),n?qt(u):u)}return t}
/**
             * simple Template formatter
             */
/**
             * @return Never be null/undefined.
             */
function Cp(t,e){return e=e||"transparent",H(t)?t:U(t)&&t.colorStops&&(t.colorStops[0]||{}).color||e}
/**
             * open new tab
             * @param link url
             * @param target blank or self
             */function Dp(t,e){/* global window */if("_blank"===e||"blank"===e){var n=window.open();n.opener=null,n.location.href=t}else window.open(t,e)}var Ap=R,kp=["left","right","top","bottom","width","height"],Lp=[["width","left","right"],["height","top","bottom"]];
/**
             * @public
             */function Pp(t,e,n,i,r){var o=0,a=0;null==i&&(i=1/0),null==r&&(r=1/0);var s=0;e.eachChild((function(l,u){var h,c,p=l.getBoundingRect(),d=e.childAt(u+1),f=d&&d.getBoundingRect();if("horizontal"===t){var g=p.width+(f?-f.x+p.x:0);// Wrap when width exceeds maxWidth or meet a `newline` group
// FIXME compare before adding gap?
(h=o+g)>i||l.newline?(o=0,h=g,a+=s+n,s=p.height):// FIXME: consider rect.y is not `0`?
s=Math.max(s,p.height)}else{var y=p.height+(f?-f.y+p.y:0);// Wrap when width exceeds maxHeight or meet a `newline` group
(c=a+y)>r||l.newline?(o+=s+n,a=0,c=y,s=p.width):s=Math.max(s,p.width)}l.newline||(l.x=o,l.y=a,l.markRedraw(),"horizontal"===t?o=h+n:a=c+n)}))}
/**
             * VBox or HBox layouting
             * @param {string} orient
             * @param {module:zrender/graphic/Group} group
             * @param {number} gap
             * @param {number} [width=Infinity]
             * @param {number} [height=Infinity]
             */var Op=Pp;
/**
             * VBox layouting
             * @param {module:zrender/graphic/Group} group
             * @param {number} gap
             * @param {number} [width=Infinity]
             * @param {number} [height=Infinity]
             */
/**
             * Parse position info.
             */
function Rp(t,e,n){n=wp(n||0);var i=e.width,r=e.height,o=Vr(t.left,i),a=Vr(t.top,r),s=Vr(t.right,i),l=Vr(t.bottom,r),u=Vr(t.width,i),h=Vr(t.height,r),c=n[2]+n[0],p=n[1]+n[3],d=t.aspect;// Align left and top
switch(// If width is not specified, calculate width from left and right
isNaN(u)&&(u=i-s-p-o),isNaN(h)&&(h=r-l-c-a),null!=d&&(// If width and height are not given
// 1. Graph should not exceeds the container
// 2. Aspect must be keeped
// 3. Graph should take the space as more as possible
// FIXME
// Margin is not considered, because there is no case that both
// using margin and aspect so far.
isNaN(u)&&isNaN(h)&&(d>i/r?u=.8*i:h=.8*r),// Calculate width or height with given aspect
isNaN(u)&&(u=d*h),isNaN(h)&&(h=u/d)),// If left is not specified, calculate left from right and width
isNaN(o)&&(o=i-s-u-p),isNaN(a)&&(a=r-l-h-c),t.left||t.right){case"center":o=i/2-u/2-n[3];break;case"right":o=i-u-p}switch(t.top||t.bottom){case"middle":case"center":a=r/2-h/2-n[0];break;case"bottom":a=r-h-c}// If something is wrong and left, top, width, height are calculated as NaN
o=o||0,a=a||0,isNaN(u)&&(// Width may be NaN if only one value is given except width
u=i-p-o-(s||0)),isNaN(h)&&(// Height may be NaN if only one value is given except height
h=r-c-a-(l||0));var f=new Ce(o+n[3],a+n[0],u,h);return f.margin=n,f}
/**
             * Position a zr element in viewport
             *  Group position is specified by either
             *  {left, top}, {right, bottom}
             *  If all properties exists, right and bottom will be igonred.
             *
             * Logic:
             *     1. Scale (against origin point in parent coord)
             *     2. Rotate (against origin point in parent coord)
             *     3. Translate (with el.position by this method)
             * So this method only fixes the last step 'Translate', which does not affect
             * scaling and rotating.
             *
             * If be called repeatedly with the same input el, the same result will be gotten.
             *
             * Return true if the layout happened.
             *
             * @param el Should have `getBoundingRect` method.
             * @param positionInfo
             * @param positionInfo.left
             * @param positionInfo.top
             * @param positionInfo.right
             * @param positionInfo.bottom
             * @param positionInfo.width Only for opt.boundingModel: 'raw'
             * @param positionInfo.height Only for opt.boundingModel: 'raw'
             * @param containerRect
             * @param margin
             * @param opt
             * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]
             * @param opt.boundingMode
             *        Specify how to calculate boundingRect when locating.
             *        'all': Position the boundingRect that is transformed and uioned
             *               both itself and its descendants.
             *               This mode simplies confine the elements in the bounding
             *               of their container (e.g., using 'right: 0').
             *        'raw': Position the boundingRect that is not transformed and only itself.
             *               This mode is useful when you want a element can overflow its
             *               container. (Consider a rotated circle needs to be located in a corner.)
             *               In this mode positionInfo.width/height can only be number.
             */function Np(t,e,n,i,r,o){var a,s=!r||!r.hv||r.hv[0],l=!r||!r.hv||r.hv[1],u=r&&r.boundingMode||"all";if((o=o||t).x=t.x,o.y=t.y,!s&&!l)return!1;if("raw"===u)a="group"===t.type?new Ce(0,0,+e.width||0,+e.height||0):t.getBoundingRect();else if(a=t.getBoundingRect(),t.needLocalTransform()){var h=t.getLocalTransform();// Notice: raw rect may be inner object of el,
// which should not be modified.
(a=a.clone()).applyTransform(h)}// The real width and height can not be specified but calculated by the given el.
var c=Rp(k({width:a.width,height:a.height},e),n,i),p=s?c.x-a.x:0,d=l?c.y-a.y:0;// Because 'tranlate' is the last step in transform
// (see zrender/core/Transformable#getLocalTransform),
// we can just only modify el.position to get final result.
return"raw"===u?(o.x=p,o.y=d):(o.x+=p,o.y+=d),o===t&&t.markRedraw(),!0}
/**
             * @param option Contains some of the properties in HV_NAMES.
             * @param hvIdx 0: horizontal; 1: vertical.
             */function Ep(t){var e=t.layoutMode||t.constructor.layoutMode;return U(e)?e:e?{type:e}:null}
/**
             * Consider Case:
             * When default option has {left: 0, width: 100}, and we set {right: 0}
             * through setOption or media query, using normal zrUtil.merge will cause
             * {right: 0} does not take effect.
             *
             * @example
             * ComponentModel.extend({
             *     init: function () {
             *         ...
             *         let inputPositionParams = layout.getLayoutParams(option);
             *         this.mergeOption(inputPositionParams);
             *     },
             *     mergeOption: function (newOption) {
             *         newOption && zrUtil.merge(thisOption, newOption, true);
             *         layout.mergeLayoutParam(thisOption, newOption);
             *     }
             * });
             *
             * @param targetOption
             * @param newOption
             * @param opt
             */function zp(t,e,n){var i=n&&n.ignoreSize;!G(i)&&(i=[i,i]);var r=a(Lp[0],0),o=a(Lp[1],1);function a(n,r){var o={},a=0,u={},h=0;if(Ap(n,(function(e){u[e]=t[e]})),Ap(n,(function(t){// Consider case: newOption.width is null, which is
// set by user for removing width setting.
s(e,t)&&(o[t]=u[t]=e[t]),l(o,t)&&a++,l(u,t)&&h++})),i[r])// Only one of left/right is premitted to exist.
return l(e,n[1])?u[n[2]]=null:l(e,n[2])&&(u[n[1]]=null),u;// Case: newOption: {width: ..., right: ...},
// or targetOption: {right: ...} and newOption: {width: ...},
// There is no conflict when merged only has params count
// little than enoughParamNumber.
if(2!==h&&a){if(a>=2)return o;// Chose another param from targetOption by priority.
for(var c=0;c<n.length;c++){var p=n[c];if(!s(o,p)&&s(t,p)){o[p]=t[p];break}}return o}return u}function s(t,e){return t.hasOwnProperty(e)}function l(t,e){return null!=t[e]&&"auto"!==t[e]}function u(t,e,n){Ap(t,(function(t){e[t]=n[t]}))}u(Lp[0],t,r),u(Lp[1],t,o)}
/**
             * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
             */function Vp(t){return Bp({},t)}
/**
             * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
             * @param {Object} source
             * @return {Object} Result contains those props.
             */function Bp(t,e){return e&&t&&Ap(kp,(function(n){e.hasOwnProperty(n)&&(t[n]=e[n])})),t}F(Pp,"vertical"),
/**
             * HBox layouting
             * @param {module:zrender/graphic/Group} group
             * @param {number} gap
             * @param {number} [width=Infinity]
             * @param {number} [height=Infinity]
             */
F(Pp,"horizontal");var Fp=bo(),Gp=/** @class */function(t){function e(e,n,i){var r=t.call(this,e,n,i)||this;return r.uid=Rc("ec_cpt_model"),r}return n(e,t),e.prototype.init=function(t,e,n){this.mergeDefaultAndTheme(t,n)},e.prototype.mergeDefaultAndTheme=function(t,e){var n=Ep(this),i=n?Vp(t):{};C(t,e.getTheme().get(this.mainType)),C(t,this.getDefaultOption()),n&&zp(t,i,n)},e.prototype.mergeOption=function(t,e){C(this.option,t,!0);var n=Ep(this);n&&zp(this.option,t,n)},
/**
               * Called immediately after `init` or `mergeOption` of this instance called.
               */
e.prototype.optionUpdated=function(t,e){},
/**
               * [How to declare defaultOption]:
               *
               * (A) If using class declaration in typescript (since echarts 5):
               * ```ts
               * import {ComponentOption} from '../model/option.js';
               * export interface XxxOption extends ComponentOption {
               *     aaa: number
               * }
               * export class XxxModel extends Component {
               *     static type = 'xxx';
               *     static defaultOption: XxxOption = {
               *         aaa: 123
               *     }
               * }
               * Component.registerClass(XxxModel);
               * ```
               * ```ts
               * import {inheritDefaultOption} from '../util/component.js';
               * import {XxxModel, XxxOption} from './XxxModel.js';
               * export interface XxxSubOption extends XxxOption {
               *     bbb: number
               * }
               * class XxxSubModel extends XxxModel {
               *     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {
               *         bbb: 456
               *     })
               *     fn() {
               *         let opt = this.getDefaultOption();
               *         // opt is {aaa: 123, bbb: 456}
               *     }
               * }
               * ```
               *
               * (B) If using class extend (previous approach in echarts 3 & 4):
               * ```js
               * let XxxComponent = Component.extend({
               *     defaultOption: {
               *         xx: 123
               *     }
               * })
               * ```
               * ```js
               * let XxxSubComponent = XxxComponent.extend({
               *     defaultOption: {
               *         yy: 456
               *     },
               *     fn: function () {
               *         let opt = this.getDefaultOption();
               *         // opt is {xx: 123, yy: 456}
               *     }
               * })
               * ```
               */
e.prototype.getDefaultOption=function(){var t=this.constructor;// If using class declaration, it is different to travel super class
// in legacy env and auto merge defaultOption. So if using class
// declaration, defaultOption should be merged manually.
if(!function(t){return!(!t||!t[Po])}(t))// When using ts class, defaultOption must be declared as static.
return t.defaultOption;// FIXME: remove this approach?
var e=Fp(this);if(!e.defaultOption){for(var n=[],i=t;i;){var r=i.prototype.defaultOption;r&&n.push(r),i=i.superClass}for(var o={},a=n.length-1;a>=0;a--)o=C(o,n[a],!0);e.defaultOption=o}return e.defaultOption},
/**
               * Notice: always force to input param `useDefault` in case that forget to consider it.
               * The same behavior as `modelUtil.parseFinder`.
               *
               * @param useDefault In many cases like series refer axis and axis refer grid,
               *        If axis index / axis id not specified, use the first target as default.
               *        In other cases like dataZoom refer axis, if not specified, measn no refer.
               */
e.prototype.getReferringComponents=function(t,e){var n=t+"Index",i=t+"Id";return Co(this.ecModel,t,{index:this.get(n,!0),id:this.get(i,!0)},e)},e.prototype.getBoxLayoutParams=function(){// Consider itself having box layout configs.
var t=this;return{left:t.get("left"),top:t.get("top"),right:t.get("right"),bottom:t.get("bottom"),width:t.get("width"),height:t.get("height")}},
/**
               * Get key for zlevel.
               * If developers don't configure zlevel. We will assign zlevel to series based on the key.
               * For example, lines with trail effect and progressive series will in an individual zlevel.
               */
e.prototype.getZLevelKey=function(){return""},e.prototype.setZLevel=function(t){this.option.zlevel=t},e.protoInitialize=function(){var t=e.prototype;t.type="component",t.id="",t.name="",t.mainType="",t.subType="",t.componentIndex=0}(),e}(Pc);No(Gp,Pc),Bo(Gp),function(t){var e={};t.registerSubTypeDefaulter=function(t,n){var i=Oo(t);e[i.main]=n},t.determineSubType=function(n,i){var r=i.type;if(!r){var o=Oo(n).main;t.hasSubTypes(n)&&e[o]&&(r=e[o](i))}return r}}
/**
             * Implements `TopologicalTravelable<any>` for `entity`.
             *
             * Topological travel on Activity Network (Activity On Vertices).
             * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
             * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
             * If there is circular dependencey, Error will be thrown.
             */(Gp),function(t,e){function n(t,e){return t[e]||(t[e]={predecessor:[],successor:[]}),t[e]}
/**
               * @param targetNameList Target Component type list.
               *                       Can be ['aa', 'bb', 'aa.xx']
               * @param fullNameList By which we can build dependency graph.
               * @param callback Params: componentType, dependencies.
               * @param context Scope of callback.
               */
t.topologicalTravel=function(t,i,r,o){if(t.length){var a=function(t){var i={},r=[];return R(t,(function(o){var a=n(i,o),s=function(t,e){var n=[];return R(t,(function(t){L(e,t)>=0&&n.push(t)})),n}(a.originalDeps=e(o),t);a.entryCount=s.length,0===a.entryCount&&r.push(o),R(s,(function(t){L(a.predecessor,t)<0&&a.predecessor.push(t);var e=n(i,t);L(e.successor,t)<0&&e.successor.push(o)}))})),{graph:i,noEntryList:r}}(i),s=a.graph,l=a.noEntryList,u={};for(R(t,(function(t){u[t]=!0}));l.length;){var h=l.pop(),c=s[h],p=!!u[h];p&&(r.call(o,h,c.originalDeps.slice()),delete u[h]),R(c.successor,p?f:d)}R(u,(function(){throw new Error("")}))}function d(t){s[t].entryCount--,0===s[t].entryCount&&l.push(t)}// Consider this case: legend depends on series, and we call
// chart.setOption({series: [...]}), where only series is in option.
// If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
// not be called, but only sereis.mergeOption is called. Thus legend
// have no chance to update its local record about series (like which
// name of series is available in legend).
function f(t){u[t]=!0,d(t)}}}(Gp,(function(t){var e=[];return R(Gp.getClassesByMainType(t),(function(t){e=e.concat(t.dependencies||t.prototype.dependencies||[])})),// Ensure main type.
e=N(e,(function(t){return Oo(t).main})),// Hack dataset for convenience.
"dataset"!==t&&L(e,"dataset")<=0&&e.unshift("dataset"),e}));const Wp=Gp;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var Hp="";// Navigator not exists in node
"undefined"!=typeof navigator&&(/* global navigator */Hp=navigator.platform||"");var Yp="rgba(0, 0, 0, 0.2)";const Xp={darkMode:"auto",// backgroundColor: 'rgba(0,0,0,0)',
colorBy:"series",color:["#5470c6","#91cc75","#fac858","#ee6666","#73c0de","#3ba272","#fc8452","#9a60b4","#ea7ccc"],gradientColor:["#f6efa6","#d88273","#bf444c"],aria:{decal:{decals:[{color:Yp,dashArrayX:[1,0],dashArrayY:[2,5],symbolSize:1,rotation:Math.PI/6},{color:Yp,symbol:"circle",dashArrayX:[[8,8],[0,8,8,0]],dashArrayY:[6,0],symbolSize:.8},{color:Yp,dashArrayX:[1,0],dashArrayY:[4,3],rotation:-Math.PI/4},{color:Yp,dashArrayX:[[6,6],[0,6,6,0]],dashArrayY:[6,0]},{color:Yp,dashArrayX:[[1,0],[1,6]],dashArrayY:[1,0,6,0],rotation:Math.PI/4},{color:Yp,symbol:"triangle",dashArrayX:[[9,9],[0,9,9,0]],dashArrayY:[7,2],symbolSize:.75}]}},// If xAxis and yAxis declared, grid is created by default.
// grid: {},
textStyle:{// color: '#000',
// decoration: 'none',
// PENDING
fontFamily:Hp.match(/^Win/)?"Microsoft YaHei":"sans-serif",// fontFamily: 'Arial, Verdana, sans-serif',
fontSize:12,fontStyle:"normal",fontWeight:"normal"},// http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
// Default is source-over
blendMode:null,stateAnimation:{duration:300,easing:"cubicOut"},animation:"auto",animationDuration:1e3,animationDurationUpdate:500,animationEasing:"cubicInOut",animationEasingUpdate:"cubicInOut",animationThreshold:2e3,// Configuration for progressive/incremental rendering
progressiveThreshold:3e3,progressive:400,// Threshold of if use single hover layer to optimize.
// It is recommended that `hoverLayerThreshold` is equivalent to or less than
// `progressiveThreshold`, otherwise hover will cause restart of progressive,
// which is unexpected.
// see example <echarts/test/heatmap-large.html>.
hoverLayerThreshold:3e3,// See: module:echarts/scale/Time
useUTC:!1};var Up=ct(["tooltip","label","itemName","itemId","itemGroupId","seriesName"]),Zp="original",jp="arrayRows",qp="objectRows",Kp="keyedColumns",$p="typedArray",Jp="unknown",Qp="column",td="row",ed=1,nd=2,id=3,rd=bo();
/**
             * [The strategy of the arrengment of data dimensions for dataset]:
             * "value way": all axes are non-category axes. So series one by one take
             *     several (the number is coordSysDims.length) dimensions from dataset.
             *     The result of data arrengment of data dimensions like:
             *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
             * "category way": at least one axis is category axis. So the the first data
             *     dimension is always mapped to the first category axis and shared by
             *     all of the series. The other data dimensions are taken by series like
             *     "value way" does.
             *     The result of data arrengment of data dimensions like:
             *     | ser_shared_x | ser0_y | ser1_y | ser2_y |
             *
             * @return encode Never be `null/undefined`.
             */
function od(t,e,n){var i={},r=sd(e);// Currently only make default when using dataset, util more reqirements occur.
if(!r||!t)return i;var o,a,s=[],l=[],u=e.ecModel,h=rd(u).datasetMap,c=r.uid+"_"+n.seriesLayoutBy;R(t=t.slice(),(function(e,n){var r=U(e)?e:t[n]={name:e};"ordinal"===r.type&&null==o&&(o=n,a=f(r)),i[r.name]=[]}));var p=h.get(c)||h.set(c,{categoryWayDim:a,valueWayDim:0});// TODO
// Auto detect first time axis and do arrangement.
function d(t,e,n){for(var i=0;i<n;i++)t.push(e+i)}function f(t){var e=t.dimsDef;return e?e.length:1}return R(t,(function(t,e){var n=t.name,r=f(t);// In value way.
if(null==o){var a=p.valueWayDim;d(i[n],a,r),d(l,a,r),p.valueWayDim+=r}// In category way, the first category axis.
else o===e?(d(i[n],0,r),d(s,0,r)):(a=p.categoryWayDim,d(i[n],a,r),d(l,a,r),p.categoryWayDim+=r)})),s.length&&(i.itemName=s),l.length&&(i.seriesName=l),i}
/**
             * Work for data like [{name: ..., value: ...}, ...].
             *
             * @return encode Never be `null/undefined`.
             */function ad(t,e,n){var i={};// Currently only make default when using dataset, util more reqirements occur.
if(!sd(t))return i;var r,o=e.sourceFormat,a=e.dimensionsDefine;o!==qp&&o!==Kp||R(a,(function(t,e){"name"===(U(t)?t.name:t)&&(r=e)}));var s=function(){// 5 is an experience value.
for(var t={},i={},s=[],l=0,u=Math.min(5,n);l<u;l++){var h=ud(e.data,o,e.seriesLayoutBy,a,e.startIndex,l);s.push(h);var c=h===id;// [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,
// and then find a name dim with the priority:
// "BE_ORDINAL.Might|BE_ORDINAL.Must" > "other dim" > "the value dim itself".
if(c&&null==t.v&&l!==r&&(t.v=l),(null==t.n||t.n===t.v||!c&&s[t.n]===id)&&(t.n=l),p(t)&&s[t.n]!==id)return t;// [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),
// find the first BE_ORDINAL.Might as the value dim,
// and then find a name dim with the priority:
// "other dim" > "the value dim itself".
// That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be
// treated as number.
c||(h===nd&&null==i.v&&l!==r&&(i.v=l),null!=i.n&&i.n!==i.v||(i.n=l))}function p(t){return null!=t.v&&null!=t.n}return p(t)?t:p(i)?i:null}();if(s){i.value=[s.v];// `potentialNameDimIndex` has highest priority.
var l=null!=r?r:s.n;// By default, label uses itemName in charts.
// So we don't set encodeLabel here.
i.itemName=[l],i.seriesName=[l]}return i}
/**
             * @return If return null/undefined, indicate that should not use datasetModel.
             */function sd(t){if(!t.get("data",!0))return Co(t.ecModel,"dataset",{index:t.get("datasetIndex",!0),id:t.get("datasetId",!0)},Io).models[0]}
/**
             * @return Always return an array event empty.
             */
/**
             * The rule should not be complex, otherwise user might not
             * be able to known where the data is wrong.
             * The code is ugly, but how to make it neat?
             */
function ld(t,e){return ud(t.data,t.sourceFormat,t.seriesLayoutBy,t.dimensionsDefine,t.startIndex,e)}// dimIndex may be overflow source data.
// return {BE_ORDINAL}
function ud(t,e,n,i,r,o){var a,s,l;// Experience value.
if(j(t))return id;// When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
// always exists in source.
if(i){var u=i[o];U(u)?(s=u.name,l=u.type):H(u)&&(s=u)}if(null!=l)return"ordinal"===l?ed:id;if(e===jp){var h=t;if(n===td){for(var c=h[o],p=0;p<(c||[]).length&&p<5;p++)if(null!=(a=m(c[r+p])))return a}else for(p=0;p<h.length&&p<5;p++){var d=h[r+p];if(d&&null!=(a=m(d[o])))return a}}else if(e===qp){var f=t;if(!s)return id;for(p=0;p<f.length&&p<5;p++)if((y=f[p])&&null!=(a=m(y[s])))return a}else if(e===Kp){if(!s)return id;if(!(c=t[s])||j(c))return id;for(p=0;p<c.length&&p<5;p++)if(null!=(a=m(c[p])))return a}else if(e===Zp){var g=t;for(p=0;p<g.length&&p<5;p++){var y,v=co(y=g[p]);if(!G(v))return id;if(null!=(a=m(v[o])))return a}}function m(t){var e=H(t);// Consider usage convenience, '1', '2' will be treated as "number".
// `isFinit('')` get `true`.
return null!=t&&isFinite(t)&&""!==t?e?nd:id:e&&"-"!==t?ed:void 0}return id}var hd,cd,pd,dd=ct(),fd=bo(),gd=bo(),yd=/** @class */function(){function t(){}return t.prototype.getColorFromPalette=function(t,e,n){var i=lo(this.get("color",!0)),r=this.get("colorLayer",!0);return md(this,fd,i,r,t,e,n)},t.prototype.clearColorPalette=function(){!function(t,e){e(t).paletteIdx=0,e(t).paletteNameMap={}}// Internal method names:
// -----------------------
(this,fd)},t}();function vd(t,e,n,i){var r=lo(t.get(["aria","decal","decals"]));return md(t,gd,r,null,e,n,i)}
/**
             * @param name MUST NOT be null/undefined. Otherwise call this function
             *             twise with the same parameters will get different result.
             * @param scope default this.
             * @return Can be null/undefined
             */
function md(t,e,n,i,r,o,a){var s=e(o=o||t),l=s.paletteIdx||0,u=s.paletteNameMap=s.paletteNameMap||{};// Use `hasOwnProperty` to avoid conflict with Object.prototype.
if(u.hasOwnProperty(r))return u[r];var h=null!=a&&i?function(t,e){// TODO palettes must be in order
for(var n=t.length,i=0;i<n;i++)if(t[i].length>e)return t[i];return t[n-1]}(i,a):n;// In case can't find in layered color palette.
if((h=h||n)&&h.length){var c=h[l];return r&&(u[r]=c),s.paletteIdx=(l+1)%h.length,c}}var xd="\0_ec_inner",_d=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.init=function(t,e,n,i,r,o){i=i||{},this.option=null,// Mark as not initialized.
this._theme=new Pc(i),this._locale=new Pc(r),this._optionManager=o},e.prototype.setOption=function(t,e,n){var i=Sd(e);this._optionManager.setOption(t,n,i),this._resetOption(null,i)},
/**
               * @param type null/undefined: reset all.
               *        'recreate': force recreate all.
               *        'timeline': only reset timeline option
               *        'media': only reset media query option
               * @return Whether option changed.
               */
e.prototype.resetOption=function(t,e){return this._resetOption(t,Sd(e))},e.prototype._resetOption=function(t,e){var n=!1,i=this._optionManager;if(!t||"recreate"===t){var r=i.mountOption("recreate"===t);this.option&&"recreate"!==t?(this.restoreData(),this._mergeOption(r,e)):pd(this,r),n=!0}// By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,
// it should better not have the same props with `MediaUnit['option']`.
// Because either `option2` or `MediaUnit['option']` will be always merged to "current option"
// rather than original "baseOption". If they both override a prop, the result might be
// unexpected when media state changed after `setOption` called.
// If we really need to modify a props in each `MediaUnit['option']`, use the full version
// (`{baseOption, media}`) in `setOption`.
// For `timeline`, the case is the same.
if("timeline"!==t&&"media"!==t||this.restoreData(),!t||"recreate"===t||"timeline"===t){var o=i.getTimelineOption(this);o&&(n=!0,this._mergeOption(o,e))}if(!t||"recreate"===t||"media"===t){var a=i.getMediaOption(this);a.length&&R(a,(function(t){n=!0,this._mergeOption(t,e)}),this)}return n},e.prototype.mergeOption=function(t){this._mergeOption(t,null)},e.prototype._mergeOption=function(t,e){var n=this.option,i=this._componentsMap,r=this._componentsCount,o=[],a=ct(),s=e&&e.replaceMergeMainTypeMap;// `datasetMap` is used to make default encode.
rd(this).datasetMap=ct(),// If no component class, merge directly.
// For example: color, animaiton options, etc.
R(t,(function(t,e){null!=t&&(Wp.hasClass(e)?e&&(o.push(e),a.set(e,!0)):// globalSettingTask.dirty();
n[e]=null==n[e]?T(t):C(n[e],t,!0))})),s&&// If there is a mainType `xxx` in `replaceMerge` but not declared in option,
// we trade it as it is declared in option as `{xxx: []}`. Because:
// (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.
// (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.
s.each((function(t,e){Wp.hasClass(e)&&!a.get(e)&&(o.push(e),a.set(e,!0))})),Wp.topologicalTravel(o,Wp.getAllClassMainTypes(),(function(e){var o=function(t,e,n){var i=dd.get(e);if(!i)return n;var r=i(t);return r?n.concat(r):n}(this,e,lo(t[e])),a=i.get(e),l=// `!oldCmptList` means init. See the comment in `mappingToExists`
a?s&&s.get(e)?"replaceMerge":"normalMerge":"replaceAll",u=fo(a,o,l);// Set mainType and complete subType.
(function(t,e,n){// Set mainType and complete subType.
R(t,(function(t){var i=t.newOption;U(i)&&(t.keyInfo.mainType=e,t.keyInfo.subType=function(t,e,n,i){// tooltip, markline, markpoint may always has no subType
return e.type?e.type:n?n.subType:i.determineSubType(t,e)}
/**
             * A helper for removing duplicate items between batchA and batchB,
             * and in themselves, and categorize by series.
             *
             * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
             * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
             * @return result: [resultBatchA, resultBatchB]
             */(e,i,t.existing,n))}))})(u,e,Wp),// Empty it before the travel, in order to prevent `this._componentsMap`
// from being used in the `init`/`mergeOption`/`optionUpdated` of some
// components, which is probably incorrect logic.
n[e]=null,i.set(e,null),r.set(e,0);var h,c=[],p=[],d=0;R(u,(function(t,n){var i=t.existing,r=t.newOption;if(r){var o="series"===e,a=Wp.getClass(e,t.keyInfo.subType,!o);if(!a)return;// TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.
if("tooltip"===e){if(h)return;h=!0}if(i&&i.constructor===a)i.name=t.keyInfo.name,// componentModel.settingTask && componentModel.settingTask.dirty();
i.mergeOption(r,this),i.optionUpdated(r,!1);else{// PENDING Global as parent ?
var s=A({componentIndex:n},t.keyInfo);// Assign `keyInfo`
A(i=new a(r,this,this,s),s),t.brandNew&&(i.__requireNewView=!0),i.init(r,this,this),// Call optionUpdated after init.
// newCmptOption has been used as componentModel.option
// and may be merged with theme and default, so pass null
// to avoid confusion.
i.optionUpdated(null,!0)}}else i&&(// Consider where is no new option and should be merged using {},
// see removeEdgeAndAdd in topologicalTravel and
// ComponentModel.getAllClassMainTypes.
i.mergeOption({},this),i.optionUpdated({},!1));// If no both `resultItem.exist` and `resultItem.option`,
// either it is in `replaceMerge` and not matched by any id,
// or it has been removed in previous `replaceMerge` and left a "hole" in this component index.
i?(c.push(i.option),p.push(i),d++):(// Always do assign to avoid elided item in array.
c.push(void 0),p.push(void 0))}),this),n[e]=c,i.set(e,p),r.set(e,d),// Backup series for filtering.
"series"===e&&hd(this)}// If no series declared, ensure `_seriesIndices` initialized.
),this),this._seriesIndices||hd(this)},
/**
               * Get option for output (cloned option and inner info removed)
               */
e.prototype.getOption=function(){var t=T(this.option);return R(t,(function(e,n){if(Wp.hasClass(n)){for(var i=lo(e),r=i.length,o=!1,a=r-1// Inner cmpts need to be removed.
// Inner cmpts might not be at last since ec5.0, but still
// compatible for users: if inner cmpt at last, splice the returned array.
;a>=0;a--)// Remove options with inner id.
i[a]&&!xo(i[a])?o=!0:(i[a]=null,!o&&r--);i.length=r,t[n]=i}})),delete t[xd],t},e.prototype.getTheme=function(){return this._theme},e.prototype.getLocaleModel=function(){return this._locale},e.prototype.setUpdatePayload=function(t){this._payload=t},e.prototype.getUpdatePayload=function(){return this._payload},
/**
               * @param idx If not specified, return the first one.
               */
e.prototype.getComponent=function(t,e){var n=this._componentsMap.get(t);if(n){var i=n[e||0];if(i)return i;if(null==e)for(var r=0;r<n.length;r++)if(n[r])return n[r]}},
/**
               * @return Never be null/undefined.
               */
e.prototype.queryComponents=function(t){var e=t.mainType;if(!e)return[];var n,i=t.index,r=t.id,o=t.name,a=this._componentsMap.get(e);return a&&a.length?(null!=i?(n=[],R(lo(i),(function(t){a[t]&&n.push(a[t])}))):n=null!=r?bd("id",r,a):null!=o?bd("name",o,a):z(a,(function(t){return!!t})),wd(n,t)):[]},
/**
               * The interface is different from queryComponents,
               * which is convenient for inner usage.
               *
               * @usage
               * let result = findComponents(
               *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
               * );
               * let result = findComponents(
               *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
               * );
               * let result = findComponents(
               *     {mainType: 'series',
               *     filter: function (model, index) {...}}
               * );
               * // result like [component0, componnet1, ...]
               */
e.prototype.findComponents=function(t){var e,n,i,r,o,a=t.query,s=t.mainType,l=(n=s+"Index",i=s+"Id",r=s+"Name",!(e=a)||null==e[n]&&null==e[i]&&null==e[r]?null:{mainType:s,// subType will be filtered finally.
index:e[n],id:e[i],name:e[r]}),u=l?this.queryComponents(l):z(this._componentsMap.get(s),(function(t){return!!t}));return o=wd(u,t),t.filter?z(o,t.filter):o},e.prototype.eachComponent=function(t,e,n){var i=this._componentsMap;if(W(t)){var r=e,o=t;i.each((function(t,e){for(var n=0;t&&n<t.length;n++){var i=t[n];i&&o.call(r,e,i,i.componentIndex)}}))}else for(var a=H(t)?i.get(t):U(t)?this.findComponents(t):null,s=0;a&&s<a.length;s++){var l=a[s];l&&e.call(n,l,l.componentIndex)}},
/**
               * Get series list before filtered by name.
               */
e.prototype.getSeriesByName=function(t){var e=vo(t,null);return z(this._componentsMap.get("series"),(function(t){return!!t&&null!=e&&t.name===e}))},
/**
               * Get series list before filtered by index.
               */
e.prototype.getSeriesByIndex=function(t){return this._componentsMap.get("series")[t]},
/**
               * Get series list before filtered by type.
               * FIXME: rename to getRawSeriesByType?
               */
e.prototype.getSeriesByType=function(t){return z(this._componentsMap.get("series"),(function(e){return!!e&&e.subType===t}))},
/**
               * Get all series before filtered.
               */
e.prototype.getSeries=function(){return z(this._componentsMap.get("series"),(function(t){return!!t}))},
/**
               * Count series before filtered.
               */
e.prototype.getSeriesCount=function(){return this._componentsCount.get("series")},
/**
               * After filtering, series may be different
               * from raw series.
               */
e.prototype.eachSeries=function(t,e){cd(this),R(this._seriesIndices,(function(n){var i=this._componentsMap.get("series")[n];t.call(e,i,n)}),this)},
/**
               * Iterate raw series before filtered.
               *
               * @param {Function} cb
               * @param {*} context
               */
e.prototype.eachRawSeries=function(t,e){R(this._componentsMap.get("series"),(function(n){n&&t.call(e,n,n.componentIndex)}))},
/**
               * After filtering, series may be different.
               * from raw series.
               */
e.prototype.eachSeriesByType=function(t,e,n){cd(this),R(this._seriesIndices,(function(i){var r=this._componentsMap.get("series")[i];r.subType===t&&e.call(n,r,i)}),this)},
/**
               * Iterate raw series before filtered of given type.
               */
e.prototype.eachRawSeriesByType=function(t,e,n){return R(this.getSeriesByType(t),e,n)},e.prototype.isSeriesFiltered=function(t){return cd(this),null==this._seriesIndicesMap.get(t.componentIndex)},e.prototype.getCurrentSeriesIndices=function(){return(this._seriesIndices||[]).slice()},e.prototype.filterSeries=function(t,e){cd(this);var n=[];R(this._seriesIndices,(function(i){var r=this._componentsMap.get("series")[i];t.call(e,r,i)&&n.push(i)}),this),this._seriesIndices=n,this._seriesIndicesMap=ct(n)},e.prototype.restoreData=function(t){hd(this);var e=this._componentsMap,n=[];e.each((function(t,e){Wp.hasClass(e)&&n.push(e)})),Wp.topologicalTravel(n,Wp.getAllClassMainTypes(),(function(n){R(e.get(n),(function(e){!e||"series"===n&&function(t,e){if(e){var n=e.seriesIndex,i=e.seriesId,r=e.seriesName;return null!=n&&t.componentIndex!==n||null!=i&&t.id!==i||null!=r&&t.name!==r}}(e,t)||e.restoreData()}))}))},e.internalField=(hd=function(t){var e=t._seriesIndices=[];R(t._componentsMap.get("series"),(function(t){// series may have been removed by `replaceMerge`.
t&&e.push(t.componentIndex)})),t._seriesIndicesMap=ct(e)},cd=function(t){},void(pd=function(t,e){// Using OPTION_INNER_KEY to mark that this option cannot be used outside,
// i.e. `chart.setOption(chart.getModel().option);` is forbidden.
t.option={},t.option[xd]=1,// Init with series: [], in case of calling findSeries method
// before series initialized.
t._componentsMap=ct({series:[]}),t._componentsCount=ct();// If user spefied `option.aria`, aria will be enable. This detection should be
// performed before theme and globalDefault merge.
var n=e.aria;U(n)&&null==n.enabled&&(n.enabled=!0),function(t,e){// PENDING
// NOT use `colorLayer` in theme if option has `color`
var n=t.color&&!t.colorLayer;R(e,(function(e,i){"colorLayer"===i&&n||Wp.hasClass(i)||("object"==typeof e?t[i]=t[i]?C(t[i],e,!1):T(e):null==t[i]&&(t[i]=e));// If it is component model mainType, the model handles that merge later.
// otherwise, merge them here.
}))}(e,t._theme.option),// TODO Needs clone when merging to the unexisted property
C(e,Xp,!1),t._mergeOption(e,null)})),e}(Pc);function bd(t,e,n){// Here is a break from echarts4: string and number are
// treated as equal.
if(G(e)){var i=ct();return R(e,(function(t){null!=t&&null!=vo(t,null)&&i.set(t,!0)})),z(n,(function(e){return e&&i.get(e[t])}))}var r=vo(e,null);return z(n,(function(e){return e&&null!=r&&e[t]===r}))}function wd(t,e){// Using hasOwnProperty for restrict. Consider
// subType is undefined in user payload.
return e.hasOwnProperty("subType")?z(t,(function(t){return t&&t.subType===e.subType})):t}function Sd(t){var e=ct();return t&&R(lo(t.replaceMerge),(function(t){e.set(t,!0)})),{replaceMergeMainTypeMap:e}}P(_d,yd);const Md=_d;var Id=["getDom","getZr","getWidth","getHeight","getDevicePixelRatio","dispatchAction","isSSR","isDisposed","on","off","getDataURL","getConnectedDataURL",// 'getModel',
"getOption",// 'getViewOfComponentModel',
// 'getViewOfSeriesModel',
"getId","updateLabelLayout"];const Td=function(t){R(Id,(function(e){this[e]=B(t[e],t)}),this)};var Cd={},Dd=/** @class */function(){function t(){this._coordinateSystems=[]}return t.prototype.create=function(t,e){var n=[];R(Cd,(function(i,r){var o=i.create(t,e);n=n.concat(o||[])})),this._coordinateSystems=n},t.prototype.update=function(t,e){R(this._coordinateSystems,(function(n){n.update&&n.update(t,e)}))},t.prototype.getCoordinateSystems=function(){return this._coordinateSystems.slice()},t.register=function(t,e){Cd[t]=e},t.get=function(t){return Cd[t]},t}();const Ad=Dd;var kd=/^(min|max)?(.+)$/,Ld=/** @class */function(){// timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
function t(t){this._timelineOptions=[],this._mediaList=[],
/**
                 * -1, means default.
                 * empty means no media.
                 */
this._currentMediaIndices=[],this._api=t}return t.prototype.setOption=function(t,e,n){t&&(// That set dat primitive is dangerous if user reuse the data when setOption again.
R(lo(t.series),(function(t){t&&t.data&&j(t.data)&&at(t.data)})),R(lo(t.dataset),(function(t){t&&t.source&&j(t.source)&&at(t.source)}))),// Caution: some series modify option data, if do not clone,
// it should ensure that the repeat modify correctly
// (create a new object when modify itself).
t=T(t);// FIXME
// If some property is set in timeline options or media option but
// not set in baseOption, a warning should be given.
var i=this._optionBackup,r=
/**
             * [RAW_OPTION_PATTERNS]
             * (Note: "series: []" represents all other props in `ECUnitOption`)
             *
             * (1) No prop "baseOption" declared:
             * Root option is used as "baseOption" (except prop "options" and "media").
             * ```js
             * option = {
             *     series: [],
             *     timeline: {},
             *     options: [],
             * };
             * option = {
             *     series: [],
             *     media: {},
             * };
             * option = {
             *     series: [],
             *     timeline: {},
             *     options: [],
             *     media: {},
             * }
             * ```
             *
             * (2) Prop "baseOption" declared:
             * If "baseOption" declared, `ECUnitOption` props can only be declared
             * inside "baseOption" except prop "timeline" (compat ec2).
             * ```js
             * option = {
             *     baseOption: {
             *         timeline: {},
             *         series: [],
             *     },
             *     options: []
             * };
             * option = {
             *     baseOption: {
             *         series: [],
             *     },
             *     media: []
             * };
             * option = {
             *     baseOption: {
             *         timeline: {},
             *         series: [],
             *     },
             *     options: []
             *     media: []
             * };
             * option = {
             *     // ec3 compat ec2: allow (only) `timeline` declared
             *     // outside baseOption. Keep this setting for compat.
             *     timeline: {},
             *     baseOption: {
             *         series: [],
             *     },
             *     options: [],
             *     media: []
             * };
             * ```
             */
function(// `rawOption` May be modified
t,e,n){var i,r,o=[],a=t.baseOption,s=t.timeline,l=t.options,u=t.media,h=!!t.media,c=!!(l||s||a&&a.timeline);function p(t){R(e,(function(e){e(t,n)}))}return a?// For merge option.
(r=a).timeline||(r.timeline=s):((c||h)&&(t.options=t.media=null),r=t),h&&G(u)&&R(u,(function(t){t&&t.option&&(t.query?o.push(t):i||(// Use the first media default.
i=t))})),p(r),R(l,(function(t){return p(t)})),R(o,(function(t){return p(t.option)})),{baseOption:r,timelineOptions:l||[],mediaDefault:i,mediaList:o}}
/**
             * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
             * Support: width, height, aspectRatio
             * Can use max or min as prefix.
             */(t,e,!i);this._newBaseOption=r.baseOption,// For setOption at second time (using merge mode);
i?(// FIXME
// the restore merge solution is essentially incorrect.
// the mapping can not be 100% consistent with ecModel, which probably brings
// potential bug!
// The first merge is delayed, because in most cases, users do not call `setOption` twice.
// let fakeCmptsMap = this._fakeCmptsMap;
// if (!fakeCmptsMap) {
//     fakeCmptsMap = this._fakeCmptsMap = createHashMap();
//     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);
// }
// mergeToBackupOption(
//     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt
// );
// For simplicity, timeline options and media options do not support merge,
// that is, if you `setOption` twice and both has timeline options, the latter
// timeline options will not be merged to the former, but just substitute them.
r.timelineOptions.length&&(i.timelineOptions=r.timelineOptions),r.mediaList.length&&(i.mediaList=r.mediaList),r.mediaDefault&&(i.mediaDefault=r.mediaDefault)):this._optionBackup=r},t.prototype.mountOption=function(t){var e=this._optionBackup;return this._timelineOptions=e.timelineOptions,this._mediaList=e.mediaList,this._mediaDefault=e.mediaDefault,this._currentMediaIndices=[],T(t?e.baseOption:this._newBaseOption)},t.prototype.getTimelineOption=function(t){var e,n=this._timelineOptions;if(n.length){// getTimelineOption can only be called after ecModel inited,
// so we can get currentIndex from timelineModel.
var i=t.getComponent("timeline");i&&(e=T(// FIXME:TS as TimelineModel or quivlant interface
n[i.getCurrentIndex()]))}return e},t.prototype.getMediaOption=function(t){var e,n,i=this._api.getWidth(),r=this._api.getHeight(),o=this._mediaList,a=this._mediaDefault,s=[],l=[];// No media defined.
if(!o.length&&!a)return l;// Multi media may be applied, the latter defined media has higher priority.
for(var u=0,h=o.length;u<h;u++)Pd(o[u].query,i,r)&&s.push(u);// FIXME
// Whether mediaDefault should force users to provide? Otherwise
// the change by media query can not be recorvered.
return!s.length&&a&&(s=[-1]),s.length&&(e=s,n=this._currentMediaIndices,e.join(",")!==n.join(","))&&(l=N(s,(function(t){return T(-1===t?a.option:o[t].option)}))),// Otherwise return nothing.
this._currentMediaIndices=s,l},t}();// Key: mainType
// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;
/**
             * TERM EXPLANATIONS:
             * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.
             */function Pd(t,e,n){var i={width:e,height:n,aspectratio:e/n},r=!0;return R(t,(function(t,e){var n=e.match(kd);if(n&&n[1]&&n[2]){var o=n[1],a=n[2].toLowerCase();(function(t,e,n){return"min"===n?t>=e:"max"===n?t<=e:t===e})(i[a],t,o)||(r=!1)}})),r}
/**
             * Consider case:
             * `chart.setOption(opt1);`
             * Then user do some interaction like dataZoom, dataView changing.
             * `chart.setOption(opt2);`
             * Then user press 'reset button' in toolbox.
             *
             * After doing that all of the interaction effects should be reset, the
             * chart should be the same as the result of invoke
             * `chart.setOption(opt1); chart.setOption(opt2);`.
             *
             * Although it is not able ensure that
             * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
             * `chart.setOption(merge(opt1, opt2));` exactly,
             * this might be the only simple way to implement that feature.
             *
             * MEMO: We've considered some other approaches:
             * 1. Each model handles its self restoration but not uniform treatment.
             *     (Too complex in logic and error-prone)
             * 2. Use a shadow ecModel. (Performance expensive)
             *
             * FIXME: A possible solution:
             * Add a extra level of model for each component model. The inheritance chain would be:
             * ecModel <- componentModel <- componentActionModel <- dataItemModel
             * And all of the actions can only modify the `componentActionModel` rather than
             * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.
             * When "resotre" action triggered, model from `componentActionModel` will be discarded
             * instead of recreating the "ecModel" from the "_optionBackup".
             */
// function mergeToBackupOption(
//     fakeCmptsMap: FakeComponentsMap,
//     // `tarOption` Can be null/undefined, means init
//     tarOption: ECUnitOption,
//     newOption: ECUnitOption,
//     // Can be null/undefined
//     opt: InnerSetOptionOpts
// ): void {
//     newOption = newOption || {} as ECUnitOption;
//     const notInit = !!tarOption;
//     each(newOption, function (newOptsInMainType, mainType) {
//         if (newOptsInMainType == null) {
//             return;
//         }
//         if (!ComponentModel.hasClass(mainType)) {
//             if (tarOption) {
//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);
//             }
//         }
//         else {
//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;
//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];
//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;
//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);
//             const mappingResult = mappingToExists(
//                 oldFakeCmptsInMainType,
//                 normalizeToArray(newOptsInMainType),
//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? 'replaceMerge' : 'normalMerge'
//             );
//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);
//             each(mappingResult, function (resultItem, index) {
//                 // The same logic as `Global.ts#_mergeOption`.
//                 let fakeCmpt = resultItem.existing;
//                 const newOption = resultItem.newOption;
//                 const keyInfo = resultItem.keyInfo;
//                 let fakeCmptOpt;
//                 if (!newOption) {
//                     fakeCmptOpt = oldTarOptsInMainType[index];
//                 }
//                 else {
//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {
//                         fakeCmpt.name = keyInfo.name;
//                         if (notInit) {
//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);
//                         }
//                     }
//                     else {
//                         fakeCmpt = extend({}, keyInfo);
//                         if (notInit) {
//                             fakeCmptOpt = clone(newOption);
//                         }
//                     }
//                 }
//                 if (fakeCmpt) {
//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);
//                     resultFakeCmptsInMainType.push(fakeCmpt);
//                 }
//                 else {
//                     notInit && resultTarOptsInMainType.push(void 0);
//                     resultFakeCmptsInMainType.push(void 0);
//                 }
//             });
//         }
//     });
// }
const Od=Ld;var Rd=R,Nd=U,Ed=["areaStyle","lineStyle","nodeStyle","linkStyle","chordStyle","label","labelLine"];function zd(t){var e=t&&t.itemStyle;if(e)for(var n=0,i=Ed.length;n<i;n++){var r=Ed[n],o=e.normal,a=e.emphasis;o&&o[r]&&(t[r]=t[r]||{},t[r].normal?C(t[r].normal,o[r]):t[r].normal=o[r],o[r]=null),a&&a[r]&&(t[r]=t[r]||{},t[r].emphasis?C(t[r].emphasis,a[r]):t[r].emphasis=a[r],a[r]=null)}}function Vd(t,e,n){if(t&&t[e]&&(t[e].normal||t[e].emphasis)){var i=t[e].normal,r=t[e].emphasis;i&&(n?(t[e].normal=t[e].emphasis=null,k(t[e],i)):t[e]=i),r&&(t.emphasis=t.emphasis||{},t.emphasis[e]=r,// Also compat the case user mix the style and focus together in ec3 style
// for example: { itemStyle: { normal: {}, emphasis: {focus, shadowBlur} } }
r.focus&&(t.emphasis.focus=r.focus),r.blurScope&&(t.emphasis.blurScope=r.blurScope))}}function Bd(t){Vd(t,"itemStyle"),Vd(t,"lineStyle"),Vd(t,"areaStyle"),Vd(t,"label"),Vd(t,"labelLine"),// treemap
Vd(t,"upperLabel"),// graph
Vd(t,"edgeLabel")}function Fd(t,e){// Check whether is not object (string\null\undefined ...)
var n=Nd(t)&&t[e],i=Nd(n)&&n.textStyle;if(i)for(var r=0,o=ho.length;r<o;r++){var a=ho[r];i.hasOwnProperty(a)&&(n[a]=i[a])}}function Gd(t){t&&(Bd(t),Fd(t,"label"),t.emphasis&&Fd(t.emphasis,"label"))}function Wd(t){return G(t)?t:t?[t]:[]}function Hd(t){return(G(t)?t[0]:t)||{}}function Yd(t,e){Rd(Wd(t.series),(function(t){Nd(t)&&function(t){if(Nd(t)){zd(t),Bd(t),Fd(t,"label"),// treemap
Fd(t,"upperLabel"),// graph
Fd(t,"edgeLabel"),t.emphasis&&(Fd(t.emphasis,"label"),// treemap
Fd(t.emphasis,"upperLabel"),// graph
Fd(t.emphasis,"edgeLabel"));var e=t.markPoint;e&&(zd(e),Gd(e));var n=t.markLine;n&&(zd(n),Gd(n));var i=t.markArea;i&&Gd(i);var r=t.data;// Break with ec3: if `setOption` again, there may be no `type` in option,
// then the backward compat based on option type will not be performed.
if("graph"===t.type){r=r||t.nodes;var o=t.links||t.edges;if(o&&!j(o))for(var a=0;a<o.length;a++)Gd(o[a]);R(t.categories,(function(t){Bd(t)}))}if(r&&!j(r))for(a=0;a<r.length;a++)Gd(r[a]);// mark point data
if((e=t.markPoint)&&e.data){var s=e.data;for(a=0;a<s.length;a++)Gd(s[a])}// mark line data
if((n=t.markLine)&&n.data){var l=n.data;for(a=0;a<l.length;a++)G(l[a])?(Gd(l[a][0]),Gd(l[a][1])):Gd(l[a])}// Series
"gauge"===t.type?(Fd(t,"axisLabel"),Fd(t,"title"),Fd(t,"detail")):"treemap"===t.type?(Vd(t.breadcrumb,"itemStyle"),R(t.levels,(function(t){Bd(t)}))):"tree"===t.type&&Bd(t.leaves);// sunburst starts from ec4, so it does not need to compat levels.
}}(t)}));var n=["xAxis","yAxis","radiusAxis","angleAxis","singleAxis","parallelAxis","radar"];e&&n.push("valueAxis","categoryAxis","logAxis","timeAxis"),Rd(n,(function(e){Rd(Wd(t[e]),(function(t){t&&(Fd(t,"axisLabel"),Fd(t.axisPointer,"label"))}))})),Rd(Wd(t.parallel),(function(t){var e=t&&t.parallelAxisDefault;Fd(e,"axisLabel"),Fd(e&&e.axisPointer,"label")})),Rd(Wd(t.calendar),(function(t){Vd(t,"itemStyle"),Fd(t,"dayLabel"),Fd(t,"monthLabel"),Fd(t,"yearLabel")})),// radar.name.textStyle
Rd(Wd(t.radar),(function(t){Fd(t,"name"),// Use axisName instead of name because component has name property
t.name&&null==t.axisName&&(t.axisName=t.name,delete t.name),null!=t.nameGap&&null==t.axisNameGap&&(t.axisNameGap=t.nameGap,delete t.nameGap)})),Rd(Wd(t.geo),(function(t){Nd(t)&&(Gd(t),Rd(Wd(t.regions),(function(t){Gd(t)})))})),Rd(Wd(t.timeline),(function(t){Gd(t),Vd(t,"label"),Vd(t,"itemStyle"),Vd(t,"controlStyle",!0);var e=t.data;G(e)&&R(e,(function(t){U(t)&&(Vd(t,"label"),Vd(t,"itemStyle"))}))})),Rd(Wd(t.toolbox),(function(t){Vd(t,"iconStyle"),Rd(t.feature,(function(t){Vd(t,"iconStyle")}))})),Fd(Hd(t.axisPointer),"label"),Fd(Hd(t.tooltip).axisPointer,"label")}function Xd(t){t&&R(Ud,(function(e){e[0]in t&&!(e[1]in t)&&(t[e[1]]=t[e[0]])}))}var Ud=[["x","left"],["y","top"],["x2","right"],["y2","bottom"]],Zd=["grid","geo","parallel","legend","toolbox","title","visualMap","dataZoom","timeline"],jd=[["borderRadius","barBorderRadius"],["borderColor","barBorderColor"],["borderWidth","barBorderWidth"]];function qd(t){var e=t&&t.itemStyle;if(e)for(var n=0;n<jd.length;n++){var i=jd[n][1],r=jd[n][0];null!=e[i]&&(e[r]=e[i])}}function Kd(t){t&&"edge"===t.alignTo&&null!=t.margin&&null==t.edgeDistance&&(t.edgeDistance=t.margin)}function $d(t){t&&t.downplay&&!t.blur&&(t.blur=t.downplay)}function Jd(t,e){if(t)for(var n=0;n<t.length;n++)e(t[n]),t[n]&&Jd(t[n].children,e)}function Qd(t,e){Yd(t,e),// Make sure series array for model initialization.
t.series=lo(t.series),R(t.series,(function(t){if(U(t)){var e=t.type;if("line"===e)null!=t.clipOverflow&&(t.clip=t.clipOverflow);else if("pie"===e||"gauge"===e){if(null!=t.clockWise&&(t.clockwise=t.clockWise),Kd(t.label),(r=t.data)&&!j(r))for(var n=0;n<r.length;n++)Kd(r[n]);null!=t.hoverOffset&&(t.emphasis=t.emphasis||{},(t.emphasis.scaleSize=null)&&(t.emphasis.scaleSize=t.hoverOffset))}else if("gauge"===e){var i=function(t,e){for(var n=e.split(","),i=t,r=0;r<n.length&&null!=(i=i&&i[n[r]]);r++);return i}(t,"pointer.color");null!=i&&function(t,e,n,i){for(var r,o=e.split(","),a=t,s=0;s<o.length-1;s++)null==a[r=o[s]]&&(a[r]={}),a=a[r];(i||null==a[o[s]])&&(a[o[s]]=n)}(t,"itemStyle.color",i)}else if("bar"===e){var r;if(qd(t),qd(t.backgroundStyle),qd(t.emphasis),(r=t.data)&&!j(r))for(n=0;n<r.length;n++)"object"==typeof r[n]&&(qd(r[n]),qd(r[n]&&r[n].emphasis))}else if("sunburst"===e){var o=t.highlightPolicy;o&&(t.emphasis=t.emphasis||{},t.emphasis.focus||(t.emphasis.focus=o)),$d(t),Jd(t.data,$d)}else"graph"===e||"sankey"===e?function(t){t&&null!=t.focusNodeAdjacency&&(t.emphasis=t.emphasis||{},null==t.emphasis.focus&&(t.emphasis.focus="adjacency"))}(t):"map"===e&&(t.mapType&&!t.map&&(t.map=t.mapType),t.mapLocation&&k(t,t.mapLocation));null!=t.hoverAnimation&&(t.emphasis=t.emphasis||{},t.emphasis&&null==t.emphasis.scale&&(t.emphasis.scale=t.hoverAnimation)),Xd(t)}})),// dataRange has changed to visualMap
t.dataRange&&(t.visualMap=t.dataRange),R(Zd,(function(e){var n=t[e];n&&(G(n)||(n=[n]),R(n,(function(t){Xd(t)})))}))}//     data processing stage is blocked in stream.
//     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
// (2) Only register once when import repeatedly.
//     Should be executed after series is filtered and before stack calculation.
function tf(t){R(t,(function(e,n){var i=[],r=[NaN,NaN],o=[e.stackResultDimension,e.stackedOverDimension],a=e.data,s=e.isStackedByIndex,l=e.seriesModel.get("stackStrategy")||"samesign";// Should not write on raw data, because stack series model list changes
// depending on legend selection.
a.modify(o,(function(o,u,h){var c,p,d=a.get(e.stackedDimension,h);// Consider `connectNulls` of line area, if value is NaN, stackedOver
// should also be NaN, to draw a appropriate belt area.
if(isNaN(d))return r;s?p=a.getRawIndex(h):c=a.get(e.stackedByDimension,h);// If stackOver is NaN, chart view will render point on value start.
for(var f=NaN,g=n-1;g>=0;g--){var y=t[g];// Has been optimized by inverted indices on `stackedByDimension`.
if(s||(p=y.data.rawIndexOf(y.stackedByDimension,c)),p>=0){var v=y.data.getByRawIndex(y.stackResultDimension,p);// Considering positive stack, negative stack and empty data
if("all"===l||"positive"===l&&v>0||"negative"===l&&v<0||"samesign"===l&&d>=0&&v>0||"samesign"===l&&d<=0&&v<0){// The sum has to be very small to be affected by the
// floating arithmetic problem. An incorrect result will probably
// cause axis min/max to be filtered incorrectly.
d=Hr(d,v),f=v;break}}}return i[0]=d,i[1]=f,i}))}))}var ef,nf,rf,of,af,sf=function(t){this.data=t.data||(t.sourceFormat===Kp?{}:[]),this.sourceFormat=t.sourceFormat||Jp,// Visit config
this.seriesLayoutBy=t.seriesLayoutBy||Qp,this.startIndex=t.startIndex||0,this.dimensionsDetectedCount=t.dimensionsDetectedCount,this.metaRawOption=t.metaRawOption;var e=this.dimensionsDefine=t.dimensionsDefine;if(e)for(var n=0;n<e.length;n++){var i=e[n];null==i.type&&ld(this,n)===ed&&(i.type="ordinal")}};function lf(t){return t instanceof sf}
/**
             * Create a source from option.
             * NOTE: Created source is immutable. Don't change any properties in it.
             */function uf(t,e,// can be null. If not provided, auto detect it from `sourceData`.
n){n=n||cf(t);var i=e.seriesLayoutBy,r=
/**
             * Determine the source definitions from data standalone dimensions definitions
             * are not specified.
             */
function(t,e,n,i,// standalone raw dimensions definition, like:
// {
//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]
// }
// in `dataset` or `series`
r){var o,a;// PENDING: Could data be null/undefined here?
// currently, if `dataset.source` not specified, error thrown.
// if `series.data` not specified, nothing rendered without error thrown.
// Should test these cases.
if(!t)return{dimensionsDefine:pf(r),startIndex:a,dimensionsDetectedCount:o};if(e===jp){var s=t;// Rule: Most of the first line are string: it is header.
// Caution: consider a line with 5 string and 1 number,
// it still can not be sure it is a head, because the
// 5 string may be 5 values of category columns.
"auto"===i||null==i?df((function(t){// '-' is regarded as null/undefined.
null!=t&&"-"!==t&&(H(t)?null==a&&(a=1):a=0);// 10 is an experience number, avoid long loop.
}),n,s,10):a=X(i)?i:i?1:0,r||1!==a||(r=[],df((function(t,e){r[e]=null!=t?t+"":""}),n,s,1/0)),o=r?r.length:n===td?s.length:s[0]?s[0].length:null}else if(e===qp)r||(r=function(t){for(var e,n=0;n<t.length&&!(e=t[n++]););// jshint ignore: line
if(e){var i=[];return R(e,(function(t,e){i.push(e)})),i}}// Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
// which is reasonable. But dimension name is duplicated.
// Returns undefined or an array contains only object without null/undefined or string.
(t));else if(e===Kp)r||(r=[],R(t,(function(t,e){r.push(e)})));else if(e===Zp){var l=co(t[0]);o=G(l)&&l.length||1}return{startIndex:a,dimensionsDefine:pf(r),dimensionsDetectedCount:o}}(t,n,i,e.sourceHeader,e.dimensions);return new sf({data:t,sourceFormat:n,seriesLayoutBy:i,dimensionsDefine:r.dimensionsDefine,startIndex:r.startIndex,dimensionsDetectedCount:r.dimensionsDetectedCount,metaRawOption:T(e)})}
/**
             * Wrap original series data for some compatibility cases.
             */function hf(t){return new sf({data:t,sourceFormat:j(t)?$p:Zp})}
/**
             * Clone source but excludes source data.
             */
/**
             * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.
             */
function cf(t){var e=Jp;if(j(t))e=$p;else if(G(t)){// FIXME Whether tolerate null in top level array?
0===t.length&&(e=jp);for(var n=0,i=t.length;n<i;n++){var r=t[n];if(null!=r){if(G(r)){e=jp;break}if(U(r)){e=qp;break}}}}else if(U(t))for(var o in t)if(gt(t,o)&&O(t[o])){e=Kp;break}return e}function pf(t){if(t){var e=ct();return N(t,(function(t,n){// Other fields will be discarded.
var i={name:(t=U(t)?t:{name:t}).name,displayName:t.displayName,type:t.type};// User can set null in dimensions.
// We don't auto specify name, otherwise a given name may
// cause it to be referred unexpectedly.
if(null==i.name)return i;// Also consider number form like 2012.
i.name+="",// User may also specify displayName.
// displayName will always exists except user not
// specified or dim name is not specified or detected.
// (A auto generated dim name will not be used as
// displayName).
null==i.displayName&&(i.displayName=i.name);var r=e.get(i.name);return r?i.name+="-"+r.count++:e.set(i.name,{count:1}),i}))}}function df(t,e,n,i){if(e===td)for(var r=0;r<n.length&&r<i;r++)t(n[r]?n[r][0]:null,r);else{var o=n[0]||[];for(r=0;r<o.length&&r<i;r++)t(o[r],r)}}function ff(t){var e=t.sourceFormat;return e===qp||e===Kp}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * If normal array used, mutable chunk size is supported.
             * If typed array used, chunk size must be fixed.
             */
var gf=/** @class */function(){function t(t,e){// let source: Source;
var n=lf(t)?t:hf(t);// declare source is Source;
this._source=n;var i=this._data=n.data;// Typed array. TODO IE10+?
n.sourceFormat===$p&&(this._offset=0,this._dimSize=e,this._data=i),af(this,i,n)}return t.prototype.getSource=function(){return this._source},t.prototype.count=function(){return 0},t.prototype.getItem=function(t,e){},t.prototype.appendData=function(t){},t.prototype.clean=function(){},t.protoInitialize=function(){// PENDING: To avoid potential incompat (e.g., prototype
// is visited somewhere), still init them on prototype.
var e=t.prototype;e.pure=!1,e.persistent=!0}(),t.internalField=function(){var t;af=function(t,r,o){var a=o.sourceFormat,s=o.seriesLayoutBy,l=o.startIndex,u=o.dimensionsDefine;if(A(t,of[If(a,s)]),a===$p)t.getItem=e,t.count=i,t.fillStorage=n;else{var h=mf(a,s);t.getItem=B(h,null,r,l,u);var c=bf(a,s);t.count=B(c,null,r,l,u)}};var e=function(t,e){t-=this._offset,e=e||[];for(var n=this._data,i=this._dimSize,r=i*t,o=0;o<i;o++)e[o]=n[r+o];return e},n=function(t,e,n,i){for(var r=this._data,o=this._dimSize,a=0;a<o;a++){for(var s=i[a],l=null==s[0]?1/0:s[0],u=null==s[1]?-1/0:s[1],h=e-t,c=n[a],p=0;p<h;p++){// appendData with TypedArray will always do replace in provider.
var d=r[p*o+a];c[t+p]=d,d<l&&(l=d),d>u&&(u=d)}s[0]=l,s[1]=u}},i=function(){return this._data?this._data.length/this._dimSize:0};function r(t){for(var e=0;e<t.length;e++)this._data.push(t[e])}(t={})[jp+"_"+Qp]={pure:!0,appendData:r},t[jp+"_"+td]={pure:!0,appendData:function(){throw new Error('Do not support appendData when set seriesLayoutBy: "row".')}},t[qp]={pure:!0,appendData:r},t[Kp]={pure:!0,appendData:function(t){var e=this._data;R(t,(function(t,n){for(var i=e[n]||(e[n]=[]),r=0;r<(t||[]).length;r++)i.push(t[r])}))}},t[Zp]={appendData:r},t[$p]={persistent:!1,pure:!0,appendData:function(t){this._data=t},// Clean self if data is already used.
clean:function(){// PENDING
this._offset+=this.count(),this._data=null}},of=t}(),t}(),yf=function(t,e,n,i){return t[i]},vf=((ef={})[jp+"_"+Qp]=function(t,e,n,i){return t[i+e]},ef[jp+"_"+td]=function(t,e,n,i,r){i+=e;for(var o=r||[],a=t,s=0;s<a.length;s++){var l=a[s];o[s]=l?l[i]:null}return o},ef[qp]=yf,ef[Kp]=function(t,e,n,i,r){for(var o=r||[],a=0;a<n.length;a++){var s=t[n[a].name];o[a]=s?s[i]:null}return o},ef[Zp]=yf,ef);function mf(t,e){return vf[If(t,e)]}var xf=function(t,e,n){return t.length},_f=((nf={})[jp+"_"+Qp]=function(t,e,n){return Math.max(0,t.length-e)},nf[jp+"_"+td]=function(t,e,n){var i=t[0];return i?Math.max(0,i.length-e):0},nf[qp]=xf,nf[Kp]=function(t,e,n){var i=t[n[0].name];return i?i.length:0},nf[Zp]=xf,nf);function bf(t,e){return _f[If(t,e)]}var wf=function(t,e,n){return t[e]},Sf=((rf={})[jp]=wf,rf[qp]=function(t,e,n){return t[n]},rf[Kp]=wf,rf[Zp]=function(t,e,n){// FIXME: In some case (markpoint in geo (geo-map.html)),
// dataItem is {coord: [...]}
var i=co(t);return i instanceof Array?i[e]:i},rf[$p]=wf,rf);function Mf(t){return Sf[t]}function If(t,e){return t===jp?t+"_"+e:t}// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
// Consider persistent.
// Caution: why use raw value to display on label or tooltip?
// A reason is to avoid format. For example time value we do not know
// how to format is expected. More over, if stack is used, calculated
// value may be 0.91000000001, which have brings trouble to display.
// TODO: consider how to treat null/undefined/NaN when display?
function Tf(t,e,// If dimIndex is null/undefined, return OptionDataItem.
// Otherwise, return OptionDataValue.
n){if(t){// Consider data may be not persistent.
var i=t.getRawDataItem(e);if(null!=i){var r=t.getStore(),o=r.getSource().sourceFormat;if(null!=n){var a=t.getDimensionIndex(n),s=r.getDimensionProperty(a);return Mf(o)(i,a,s)}var l=i;return o===Zp&&(l=co(i)),l}}}var Cf=/\{@(.+?)\}/g,Df=/** @class */function(){function t(){}
/**
               * Get params for formatter
               */return t.prototype.getDataParams=function(t,e){var n=this.getData(e),i=this.getRawValue(t,e),r=n.getRawIndex(t),o=n.getName(t),a=n.getRawDataItem(t),s=n.getItemVisual(t,"style"),l=s&&s[n.getItemVisual(t,"drawType")||"fill"],u=s&&s.stroke,h=this.mainType,c="series"===h,p=n.userOutput&&n.userOutput.get();return{componentType:h,componentSubType:this.subType,componentIndex:this.componentIndex,seriesType:c?this.subType:null,seriesIndex:this.seriesIndex,seriesId:c?this.id:null,seriesName:c?this.name:null,name:o,dataIndex:r,data:a,dataType:e,value:i,color:l,borderColor:u,dimensionNames:p?p.fullDimensions:null,encode:p?p.encode:null,// Param name list for mapping `a`, `b`, `c`, `d`, `e`
$vars:["seriesName","name","value"]}},
/**
               * Format label
               * @param dataIndex
               * @param status 'normal' by default
               * @param dataType
               * @param labelDimIndex Only used in some chart that
               *        use formatter in different dimensions, like radar.
               * @param formatter Formatter given outside.
               * @return return null/undefined if no formatter
               */
t.prototype.getFormattedLabel=function(t,e,n,i,r,o){e=e||"normal";var a=this.getData(n),s=this.getDataParams(t,n);return o&&(s.value=o.interpolatedValue),null!=i&&G(s.value)&&(s.value=s.value[i]),r||(// @ts-ignore
r=a.getItemModel(t).get("normal"===e?["label","formatter"]:[e,"label","formatter"])),W(r)?(s.status=e,s.dimensionIndex=i,r(s)):H(r)?Tp(r,s).replace(Cf,(function(e,n){var i=n.length,r=n;"["===r.charAt(0)&&"]"===r.charAt(i-1)&&(r=+r.slice(1,i-1));var s=Tf(a,t,r);if(o&&G(o.interpolatedValue)){var l=a.getDimensionIndex(r);l>=0&&(s=o.interpolatedValue[l])}return null!=s?s+"":""})):void 0},
/**
               * Get raw value in option
               */
t.prototype.getRawValue=function(t,e){return Tf(this.getData(e),t)},
/**
               * Should be implemented.
               * @param {number} dataIndex
               * @param {boolean} [multipleSeries=false]
               * @param {string} [dataType]
               */
t.prototype.formatTooltip=function(t,e,n){},t}();// but guess little chance has been used outside. Do we need to backward
// compat it?
// type TooltipFormatResultLegacyObject = {
//     // `html` means the markup language text, either in 'html' or 'richText'.
//     // The name `html` is not appropriate because in 'richText' it is not a HTML
//     // string. But still support it for backward compatibility.
//     html: string;
//     markers: Dictionary<ColorString>;
// };
/**
             * For backward compat, normalize the return from `formatTooltip`.
             */
function Af(t){var e,n;// let markers: Dictionary<ColorString>;
return U(t)?t.type&&(n=t):e=t,{text:e,// markers: markers || markersExisting,
frag:n}}
/**
             * @param {Object} define
             * @return See the return of `createTask`.
             */function kf(t){return new Lf(t)}var Lf=/** @class */function(){function t(t){t=t||{},this._reset=t.reset,this._plan=t.plan,this._count=t.count,this._onDirty=t.onDirty,this._dirty=!0}
/**
               * @param step Specified step.
               * @param skip Skip customer perform call.
               * @param modBy Sampling window size.
               * @param modDataCount Sampling count.
               * @return whether unfinished.
               */return t.prototype.perform=function(t){var e,n=this._upstream,i=t&&t.skip;// TODO some refactor.
// Pull data. Must pull data each time, because context.data
// may be updated by Series.setData.
if(this._dirty&&n){var r=this.context;r.data=r.outputData=n.context.outputData}this.__pipeline&&(this.__pipeline.currentTask=this),this._plan&&!i&&(e=this._plan(this.context));// Support sharding by mod, which changes the render sequence and makes the rendered graphic
// elements uniformed distributed when progress, especially when moving or zooming.
var o,a=h(this._modBy),s=this._modDataCount||0,l=h(t&&t.modBy),u=t&&t.modDataCount||0;function h(t){// jshint ignore:line
return!(t>=1)&&(t=1),t}a===l&&s===u||(e="reset"),(this._dirty||"reset"===e)&&(this._dirty=!1,o=this._doReset(i)),this._modBy=l,this._modDataCount=u;var c=t&&t.step;// Note: Stubs, that its host overall task let it has progress, has progress.
// If no progress, pass index from upstream to downstream each time plan called.
if(this._dueEnd=n?n._outputDueEnd:this._count?this._count(this.context):1/0,this._progress){var p=this._dueIndex,d=Math.min(null!=c?this._dueIndex+c:1/0,this._dueEnd);if(!i&&(o||p<d)){var f=this._progress;if(G(f))for(var g=0;g<f.length;g++)this._doProgress(f[g],p,d,l,u);else this._doProgress(f,p,d,l,u)}this._dueIndex=d;// If no `outputDueEnd`, assume that output data and
// input data is the same, so use `dueIndex` as `outputDueEnd`.
var y=null!=this._settedOutputEnd?this._settedOutputEnd:d;this._outputDueEnd=y}else// (1) Some overall task has no progress.
// (2) Stubs, that its host overall task do not let it has progress, has no progress.
// This should always be performed so it can be passed to downstream.
this._dueIndex=this._outputDueEnd=null!=this._settedOutputEnd?this._settedOutputEnd:this._dueEnd;return this.unfinished()},t.prototype.dirty=function(){this._dirty=!0,this._onDirty&&this._onDirty(this.context)},t.prototype._doProgress=function(t,e,n,i,r){Pf.reset(e,n,i,r),this._callingProgress=t,this._callingProgress({start:e,end:n,count:n-e,next:Pf.next},this.context)},t.prototype._doReset=function(t){var e,n;this._dueIndex=this._outputDueEnd=this._dueEnd=0,this._settedOutputEnd=null,!t&&this._reset&&((e=this._reset(this.context))&&e.progress&&(n=e.forceFirstProgress,e=e.progress),// To simplify no progress checking, array must has item.
G(e)&&!e.length&&(e=null)),this._progress=e,this._modBy=this._modDataCount=null;var i=this._downstream;return i&&i.dirty(),n},t.prototype.unfinished=function(){return this._progress&&this._dueIndex<this._dueEnd},
/**
               * @param downTask The downstream task.
               * @return The downstream task.
               */
t.prototype.pipe=function(t){(this._downstream!==t||this._dirty)&&(this._downstream=t,t._upstream=this,t.dirty())},t.prototype.dispose=function(){this._disposed||(this._upstream&&(this._upstream._downstream=null),this._downstream&&(this._downstream._upstream=null),this._dirty=!1,this._disposed=!0)},t.prototype.getUpstream=function(){return this._upstream},t.prototype.getDownstream=function(){return this._downstream},t.prototype.setOutputEnd=function(t){// This only happens in dataTask, dataZoom, map, currently.
// where dataZoom do not set end each time, but only set
// when reset. So we should record the set end, in case
// that the stub of dataZoom perform again and earse the
// set end by upstream.
this._outputDueEnd=this._settedOutputEnd=t},t}(),Pf=function(){var t,e,n,i,r,o={reset:function(l,u,h,c){e=l,t=u,n=h,i=c,r=Math.ceil(i/n),o.next=n>1&&i>0?s:a}};return o;function a(){return e<t?e++:null}function s(){var o=e%r*n+Math.ceil(e/r),a=e>=t?null:o<i?o:e;return e++,a}}();// -----------------------------------------------------------------------------
// For stream debug (Should be commented out after used!)
// @usage: printTask(this, 'begin');
// @usage: printTask(this, null, {someExtraProp});
// @usage: Use `__idxInPipeline` as conditional breakpiont.
// window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {
//     window.ecTaskUID == null && (window.ecTaskUID = 0);
//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
//     let props = [];
//     if (task.__pipeline) {
//         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
//         props.push({text: '__idxInPipeline/total', value: val});
//     } else {
//         let stubCount = 0;
//         task.agentStubMap.each(() => stubCount++);
//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
//     }
//     props.push({text: 'uid', value: task.uidDebug});
//     if (task.__pipeline) {
//         props.push({text: 'pipelineId', value: task.__pipeline.id});
//         task.agent && props.push(
//             {text: 'stubFor', value: task.agent.uidDebug}
//         );
//     }
//     props.push(
//         {text: 'dirty', value: task._dirty},
//         {text: 'dueIndex', value: task._dueIndex},
//         {text: 'dueEnd', value: task._dueEnd},
//         {text: 'outputDueEnd', value: task._outputDueEnd}
//     );
//     if (extra) {
//         Object.keys(extra).forEach(key => {
//             props.push({text: key, value: extra[key]});
//         });
//     }
//     let args = ['color: blue'];
//     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
//         args.push('color: green', 'color: red'),
//         `${item.text}: %c${item.value}`
//     )).join('%c, ');
//     console.log.apply(console, [msg].concat(args));
//     // console.log(this);
// };
// window.printPipeline = function (task: any, prefix: string) {
//     const pipeline = task.__pipeline;
//     let currTask = pipeline.head;
//     while (currTask) {
//         window.printTask(currTask, prefix);
//         currTask = currTask._downstream;
//     }
// };
// window.showChain = function (chainHeadTask) {
//     var chain = [];
//     var task = chainHeadTask;
//     while (task) {
//         chain.push({
//             task: task,
//             up: task._upstream,
//             down: task._downstream,
//             idxInPipeline: task.__idxInPipeline
//         });
//         task = task._downstream;
//     }
//     return chain;
// };
// window.findTaskInChain = function (task, chainHeadTask) {
//     let chain = window.showChain(chainHeadTask);
//     let result = [];
//     for (let i = 0; i < chain.length; i++) {
//         let chainItem = chain[i];
//         if (chainItem.task === task) {
//             result.push(i);
//         }
//     }
//     return result;
// };
// window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {
//     let chainA = window.showChain(chainHeadTaskA);
//     for (let i = 0; i < chainA.length; i++) {
//         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));
//     }
// };
/**
             * Convert raw the value in to inner value in List.
             *
             * [Performance sensitive]
             *
             * [Caution]: this is the key logic of user value parser.
             * For backward compatibility, do not modify it until you have to!
             */
function Of(t,// For high performance, do not omit the second param.
e){// Performance sensitive.
var n=e&&e.type;return"ordinal"===n?t:("time"!==n||X(t)||null==t||"-"===t||(t=+jr(t)),null==t||""===t?NaN:+t)}var Rf=ct({number:function(t){// Do not use `numericToNumber` here. We have `numericToNumber` by default.
// Here the number parser can have loose rule:
// enable to cut suffix: "120px" => 120, "14%" => 14.
return parseFloat(t)},time:function(t){// return timestamp.
return+jr(t)},trim:function(t){return H(t)?rt(t):t}});function Nf(t){return Rf.get(t)}var Ef={lt:function(t,e){return t<e},lte:function(t,e){return t<=e},gt:function(t,e){return t>e},gte:function(t,e){return t>=e}},zf=/** @class */function(){function t(t,e){X(e)||ro(""),this._opFn=Ef[t],this._rvalFloat=Qr(e)}// Performance sensitive.
return t.prototype.evaluate=function(t){// Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.
return X(t)?this._opFn(t,this._rvalFloat):this._opFn(Qr(t),this._rvalFloat)},t}(),Vf=/** @class */function(){
/**
               * @param order by default: 'asc'
               * @param incomparable by default: Always on the tail.
               *        That is, if 'asc' => 'max', if 'desc' => 'min'
               *        See the definition of "incomparable" in [SORT_COMPARISON_RULE].
               */
function t(t,e){var n="desc"===t;this._resultLT=n?1:-1,null==e&&(e=n?"min":"max"),this._incomparable="min"===e?-1/0:1/0}// See [SORT_COMPARISON_RULE].
// Performance sensitive.
return t.prototype.evaluate=function(t,e){// Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.
var n=X(t)?t:Qr(t),i=X(e)?e:Qr(e),r=isNaN(n),o=isNaN(i);if(r&&(n=this._incomparable),o&&(i=this._incomparable),r&&o){var a=H(t),s=H(e);a&&(n=s?t:0),s&&(i=a?e:0)}return n<i?this._resultLT:n>i?-this._resultLT:0},t}(),Bf=/** @class */function(){function t(t,e){this._rval=e,this._isEQ=t,this._rvalTypeof=typeof e,this._rvalFloat=Qr(e)}// Performance sensitive.
return t.prototype.evaluate=function(t){var e=t===this._rval;if(!e){var n=typeof t;n===this._rvalTypeof||"number"!==n&&"number"!==this._rvalTypeof||(e=Qr(t)===this._rvalFloat)}return this._isEQ?e:!e},t}();
/**
             * [FILTER_COMPARISON_RULE]
             * `lt`|`lte`|`gt`|`gte`:
             * + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.
             * `eq`:
             * + If same type, compare with `===`.
             * + If there is one number, convert to number (`numericToNumber`) to compare.
             * + Else return `false`.
             * `ne`:
             * + Not `eq`.
             *
             *
             * [SORT_COMPARISON_RULE]
             * All the values are grouped into three categories:
             * + "numeric" (number and numeric string)
             * + "non-numeric-string" (string that excluding numeric string)
             * + "others"
             * "numeric" vs "numeric": values are ordered by number order.
             * "non-numeric-string" vs "non-numeric-string": values are ordered by ES spec (#sec-abstract-relational-comparison).
             * "others" vs "others": do not change order (always return 0).
             * "numeric" vs "non-numeric-string": "non-numeric-string" is treated as "incomparable".
             * "number" vs "others": "others" is treated as "incomparable".
             * "non-numeric-string" vs "others": "others" is treated as "incomparable".
             * "incomparable" will be seen as -Infinity or Infinity (depends on the settings).
             * MEMO:
             *   Non-numeric string sort makes sense when we need to put the items with the same tag together.
             *   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,
             *   So we treat "numeric-string" sorted by number order rather than string comparison.
             *
             *
             * [CHECK_LIST_OF_THE_RULE_DESIGN]
             * + Do not support string comparison until required. And also need to
             *   avoid the misleading of "2" > "12".
             * + Should avoid the misleading case:
             *   `" 22 " gte "22"` is `true` but `" 22 " eq "22"` is `false`.
             * + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...
             * + Only "numeric" can be converted to comparable number, otherwise converted to NaN.
             *   See `util/number.ts#numericToNumber`.
             *
             * @return If `op` is not `RelationalOperator`, return null;
             */
function Ff(t,e){return"eq"===t||"ne"===t?new Bf("eq"===t,e):gt(Ef,t)?new zf(t,e):null}
/**
             * TODO: disable writable.
             * This structure will be exposed to users.
             */var Gf=/** @class */function(){function t(){}return t.prototype.getRawData=function(){// Only built-in transform available.
throw new Error("not supported")},t.prototype.getRawDataItem=function(t){// Only built-in transform available.
throw new Error("not supported")},t.prototype.cloneRawData=function(){},
/**
               * @return If dimension not found, return null/undefined.
               */
t.prototype.getDimensionInfo=function(t){},
/**
               * dimensions defined if and only if either:
               * (a) dataset.dimensions are declared.
               * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).
               * If dimensions are defined, `dimensionInfoAll` is corresponding to
               * the defined dimensions.
               * Otherwise, `dimensionInfoAll` is determined by data columns.
               * @return Always return an array (even empty array).
               */
t.prototype.cloneAllDimensionInfo=function(){},t.prototype.count=function(){},
/**
               * Only support by dimension index.
               * No need to support by dimension name in transform function,
               * because transform function is not case-specific, no need to use name literally.
               */
t.prototype.retrieveValue=function(t,e){},t.prototype.retrieveValueFromItem=function(t,e){},t.prototype.convertValue=function(t,e){return Of(t,e)},t}();function Wf(t){return jf(t.sourceFormat)||ro(""),t.data}function Hf(t){var e=t.sourceFormat,n=t.data;if(jf(e)||ro(""),e===jp){for(var i=[],r=0,o=n.length;r<o;r++)// Not strictly clone for performance
i.push(n[r].slice());return i}if(e===qp){for(i=[],r=0,o=n.length;r<o;r++)// Not strictly clone for performance
i.push(A({},n[r]));return i}}function Yf(t,e,n){if(null!=n)// Keep the same logic as `List::getDimension` did.
return X(n)||!isNaN(n)&&!gt(e,n)?t[n]:gt(e,n)?e[n]:void 0}function Xf(t){return T(t)}var Uf=ct();function Zf(t,e,n,// If `pipeIndex` is null/undefined, no piped transform.
i){e.length||ro(""),U(t)||ro("");var r=t.type,o=Uf.get(r);o||ro("");// Prepare source
var a=N(e,(function(t){return function(t,e){var n=new Gf,i=t.data,r=n.sourceFormat=t.sourceFormat,o=t.startIndex;t.seriesLayoutBy!==Qp&&ro("");// [MEMO]
// Create a new dimensions structure for exposing.
// Do not expose all dimension info to users directly.
// Because the dimension is probably auto detected from data and not might reliable.
// Should not lead the transformers to think that is reliable and return it.
// See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
var a=[],s={},l=t.dimensionsDefine;if(l)R(l,(function(t,e){var n=t.name,i={index:e,name:n,displayName:t.displayName};a.push(i),// Users probably do not specify dimension name. For simplicity, data transform
// does not generate dimension name.
null!=n&&(gt(s,n)&&ro(""),s[n]=i)}));else for(var u=0;u<t.dimensionsDetectedCount;u++)// Do not generete name or anything others. The consequence process in
// `transform` or `series` probably have there own name generation strategry.
a.push({index:u});// Implement public methods:
var h=mf(r,Qp);e.__isBuiltIn&&(n.getRawDataItem=function(t){return h(i,o,a,t)},n.getRawData=B(Wf,null,t)),n.cloneRawData=B(Hf,null,t);var c=bf(r,Qp);n.count=B(c,null,i,o,a);var p=Mf(r);n.retrieveValue=function(t,e){var n=h(i,o,a,t);return d(n,e)};var d=n.retrieveValueFromItem=function(t,e){if(null!=t){var n=a[e];// When `dimIndex` is `null`, `rawValueGetter` return the whole item.
return n?p(t,e,n.name):void 0}};return n.getDimensionInfo=B(Yf,null,a,s),n.cloneAllDimensionInfo=B(Xf,null,a),n}(t,o)}));return N(lo(o.transform({upstream:a[0],upstreamList:a,config:T(t.config)})),(function(t,n){var i;U(t)||ro(""),t.data||ro(""),jf(cf(t.data))||ro("");var r=e[0];
/**
                 * Intuitively, the end users known the content of the original `dataset.source`,
                 * calucating the transform result in mind.
                 * Suppose the original `dataset.source` is:
                 * ```js
                 * [
                 *     ['product', '2012', '2013', '2014', '2015'],
                 *     ['AAA', 41.1, 30.4, 65.1, 53.3],
                 *     ['BBB', 86.5, 92.1, 85.7, 83.1],
                 *     ['CCC', 24.1, 67.2, 79.5, 86.4]
                 * ]
                 * ```
                 * The dimension info have to be detected from the source data.
                 * Some of the transformers (like filter, sort) will follow the dimension info
                 * of upstream, while others use new dimensions (like aggregate).
                 * Transformer can output a field `dimensions` to define the its own output dimensions.
                 * We also allow transformers to ignore the output `dimensions` field, and
                 * inherit the upstream dimensions definition. It can reduce the burden of handling
                 * dimensions in transformers.
                 *
                 * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
                 */if(r&&0===n&&!t.dimensions){var o=r.startIndex;// We copy the header of upstream to the result, because:
// (1) The returned data always does not contain header line and can not be used
// as dimension-detection. In this case we can not use "detected dimensions" of
// upstream directly, because it might be detected based on different `seriesLayoutBy`.
// (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.
// So the original detected header should be add to the result, otherwise they can not be read.
o&&(t.data=r.data.slice(0,o).concat(t.data)),i={seriesLayoutBy:Qp,sourceHeader:o,dimensions:r.metaRawOption.dimensions}}else i={seriesLayoutBy:Qp,sourceHeader:0,dimensions:t.dimensions};return uf(t.data,i,null)}))}function jf(t){return t===jp||t===qp}var qf,Kf="undefined",$f=typeof Uint32Array===Kf?Array:Uint32Array,Jf=typeof Uint16Array===Kf?Array:Uint16Array,Qf=typeof Int32Array===Kf?Array:Int32Array,tg=typeof Float64Array===Kf?Array:Float64Array,eg={float:tg,int:Qf,// Ordinal data type can be string or int
ordinal:Array,number:Array,time:tg};/* global Float64Array, Int32Array, Uint32Array, Uint16Array */ // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
// different from the Ctor of typed array.
function ng(t){// The possible max value in this._indicies is always this._rawCount despite of filtering.
return t>65535?$f:Jf}function ig(t,e,n,i,r){var o=eg[n||"float"];if(r){var a=t[e],s=a&&a.length;if(s!==i){// The cost of the copy is probably inconsiderable
// within the initial chunkSize.
for(var l=new o(i),u=0;u<s;u++)l[u]=a[u];t[e]=l}}else t[e]=new o(i)}
/**
             * Basically, DataStore API keep immutable.
             */var rg=/** @class */function(){function t(){this._chunks=[],// It will not be calculated util needed.
this._rawExtent=[],this._extent=[],this._count=0,this._rawCount=0,this._calcDimNameToIdx=ct()}
/**
               * Initialize from data
               */return t.prototype.initData=function(t,e,n){this._provider=t,// Clear
this._chunks=[],this._indices=null,this.getRawIndex=this._getRawIdxIdentity;var i=t.getSource(),r=this.defaultDimValueGetter=qf[i.sourceFormat];// Default dim value getter
this._dimValueGetter=n||r,// Reset raw extent.
this._rawExtent=[],ff(i),this._dimensions=N(e,(function(t){return{// Only pick these two props. Not leak other properties like orderMeta.
type:t.type,property:t.property}})),this._initDataFromProvider(0,t.count())},t.prototype.getProvider=function(){return this._provider},
/**
               * Caution: even when a `source` instance owned by a series, the created data store
               * may still be shared by different sereis (the source hash does not use all `source`
               * props, see `sourceManager`). In this case, the `source` props that are not used in
               * hash (like `source.dimensionDefine`) probably only belongs to a certain series and
               * thus should not be fetch here.
               */
t.prototype.getSource=function(){return this._provider.getSource()},
/**
               * @caution Only used in dataStack.
               */
t.prototype.ensureCalculationDimension=function(t,e){var n=this._calcDimNameToIdx,i=this._dimensions,r=n.get(t);if(null!=r){if(i[r].type===e)return r}else r=i.length;return i[r]={type:e},n.set(t,r),this._chunks[r]=new eg[e||"float"](this._rawCount),this._rawExtent[r]=[1/0,-1/0],r},t.prototype.collectOrdinalMeta=function(t,e){var n=this._chunks[t],i=this._dimensions[t],r=this._rawExtent,o=i.ordinalOffset||0,a=n.length;0===o&&(// We need to reset the rawExtent if collect is from start.
// Because this dimension may be guessed as number and calcuating a wrong extent.
r[t]=[1/0,-1/0]);// Parse from previous data offset. len may be changed after appendData
for(var s=r[t],l=o;l<a;l++){var u=n[l]=e.parseAndCollect(n[l]);isNaN(u)||(s[0]=Math.min(u,s[0]),s[1]=Math.max(u,s[1]))}i.ordinalMeta=e,i.ordinalOffset=a,i.type="ordinal"},t.prototype.getOrdinalMeta=function(t){return this._dimensions[t].ordinalMeta},t.prototype.getDimensionProperty=function(t){var e=this._dimensions[t];return e&&e.property},
/**
               * Caution: Can be only called on raw data (before `this._indices` created).
               */
t.prototype.appendData=function(t){var e=this._provider,n=this.count();e.appendData(t);var i=e.count();return e.persistent||(i+=n),n<i&&this._initDataFromProvider(n,i,!0),[n,i]},t.prototype.appendValues=function(t,e){for(var n=this._chunks,i=this._dimensions,r=i.length,o=this._rawExtent,a=this.count(),s=a+Math.max(t.length,e||0),l=0;l<r;l++)ig(n,l,(d=i[l]).type,s,!0);for(var u=[],h=a;h<s;h++)// Store the data by dimensions
for(var c=h-a,p=0;p<r;p++){var d=i[p],f=qf.arrayRows.call(this,t[c]||u,d.property,c,p);n[p][h]=f;var g=o[p];f<g[0]&&(g[0]=f),f>g[1]&&(g[1]=f)}return this._rawCount=this._count=s,{start:a,end:s}},t.prototype._initDataFromProvider=function(t,e,n){for(var i=this._provider,r=this._chunks,o=this._dimensions,a=o.length,s=this._rawExtent,l=N(o,(function(t){return t.property})),u=0;u<a;u++){var h=o[u];s[u]||(s[u]=[1/0,-1/0]),ig(r,u,h.type,e,n)}if(i.fillStorage)i.fillStorage(t,e,r,s);else for(var c=[],p=t;p<e;p++){// NOTICE: Try not to write things into dataItem
c=i.getItem(p,c);// Each data item is value
// [1, 2]
// 2
// Bar chart, line chart which uses category axis
// only gives the 'y' value. 'x' value is the indices of category
// Use a tempValue to normalize the value to be a (x, y) value
// Store the data by dimensions
for(var d=0;d<a;d++){var f=r[d],g=this._dimValueGetter(c,l[d],p,d);// PENDING NULL is empty or zero
f[p]=g;var y=s[d];g<y[0]&&(y[0]=g),g>y[1]&&(y[1]=g)}}!i.persistent&&i.clean&&// Clean unused data if data source is typed array.
i.clean(),this._rawCount=this._count=e,// Reset data extent
this._extent=[]},t.prototype.count=function(){return this._count},
/**
               * Get value. Return NaN if idx is out of range.
               */
t.prototype.get=function(t,e){if(!(e>=0&&e<this._count))return NaN;var n=this._chunks[t];return n?n[this.getRawIndex(e)]:NaN},t.prototype.getValues=function(t,e){var n=[],i=[];if(null==e){e=t,// TODO get all from store?
t=[];// All dimensions
for(var r=0;r<this._dimensions.length;r++)i.push(r)}else i=t;r=0;for(var o=i.length;r<o;r++)n.push(this.get(i[r],e));return n},
/**
               * @param dim concrete dim
               */
t.prototype.getByRawIndex=function(t,e){if(!(e>=0&&e<this._rawCount))return NaN;var n=this._chunks[t];return n?n[e]:NaN},
/**
               * Get sum of data in one dimension
               */
t.prototype.getSum=function(t){var e=0;if(this._chunks[t])for(var n=0,i=this.count();n<i;n++){var r=this.get(t,n);isNaN(r)||(e+=r)}return e},
/**
               * Get median of data in one dimension
               */
t.prototype.getMedian=function(t){var e=[];// map all data of one dimension
this.each([t],(function(t){isNaN(t)||e.push(t)}));// TODO
// Use quick select?
var n=e.sort((function(t,e){return t-e})),i=this.count();// calculate median
return 0===i?0:i%2==1?n[(i-1)/2]:(n[i/2]+n[i/2-1])/2},
/**
               * Retrieve the index with given raw data index.
               */
t.prototype.indexOfRawIndex=function(t){if(t>=this._rawCount||t<0)return-1;if(!this._indices)return t;// Indices are ascending
var e=this._indices,n=e[t];// If rawIndex === dataIndex
if(null!=n&&n<this._count&&n===t)return t;for(var i=0,r=this._count-1;i<=r;){var o=(i+r)/2|0;if(e[o]<t)i=o+1;else{if(!(e[o]>t))return o;r=o-1}}return-1},
/**
               * Retrieve the index of nearest value.
               * @param dim
               * @param value
               * @param [maxDistance=Infinity]
               * @return If and only if multiple indices have
               *         the same value, they are put to the result.
               */
t.prototype.indicesOfNearest=function(t,e,n){var i=this._chunks[t],r=[];if(!i)return r;null==n&&(n=1/0);// Check the test case of `test/ut/spec/data/SeriesData.js`.
for(var o=1/0,a=-1,s=0,l=0,u=this.count();l<u;l++){var h=e-i[this.getRawIndex(l)],c=Math.abs(h);c<=n&&(// When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,
// we'd better not push both of them to `nearestIndices`, otherwise it is easy to
// get more than one item in `nearestIndices` (more specifically, in `tooltip`).
// So we chose the one that `diff >= 0` in this csae.
// But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them
// should be push to `nearestIndices`.
(c<o||c===o&&h>=0&&a<0)&&(o=c,a=h,s=0),h===a&&(r[s++]=l))}return r.length=s,r},t.prototype.getIndices=function(){var t,e=this._indices;if(e){var n=e.constructor,i=this._count;// `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.
if(n===Array){t=new n(i);for(var r=0;r<i;r++)t[r]=e[r]}else t=new n(e.buffer,0,i)}else for(t=new(n=ng(this._rawCount))(this.count()),r=0;r<t.length;r++)t[r]=r;return t},
/**
               * Data filter.
               */
t.prototype.filter=function(t,e){if(!this._count)return this;for(var n=this.clone(),i=n.count(),r=new(ng(n._rawCount))(i),o=[],a=t.length,s=0,l=t[0],u=n._chunks,h=0;h<i;h++){var c=void 0,p=n.getRawIndex(h);// Simple optimization
if(0===a)c=e(h);else if(1===a)c=e(u[l][p],h);else{for(var d=0;d<a;d++)o[d]=u[t[d]][p];o[d]=h,c=e.apply(null,o)}c&&(r[s++]=p)}// Set indices after filtered.
return s<i&&(n._indices=r),n._count=s,// Reset data extent
n._extent=[],n._updateGetRawIdx(),n},
/**
               * Select data in range. (For optimization of filter)
               * (Manually inline code, support 5 million data filtering in data zoom.)
               */
t.prototype.selectRange=function(t){var e=this.clone(),n=e._count;if(!n)return this;var i=V(t),r=i.length;if(!r)return this;var o=e.count(),a=new(ng(e._rawCount))(o),s=0,l=i[0],u=t[l][0],h=t[l][1],c=e._chunks,p=!1;if(!e._indices){// Extreme optimization for common case. About 2x faster in chrome.
var d=0;if(1===r){for(var f=c[i[0]],g=0;g<n;g++)// NaN will not be filtered. Consider the case, in line chart, empty
// value indicates the line should be broken. But for the case like
// scatter plot, a data item with empty value will not be rendered,
// but the axis extent may be effected if some other dim of the data
// item has value. Fortunately it is not a significant negative effect.
((x=f[g])>=u&&x<=h||isNaN(x))&&(a[s++]=d),d++;p=!0}else if(2===r){f=c[i[0]];var y=c[i[1]],v=t[i[1]][0],m=t[i[1]][1];for(g=0;g<n;g++){var x=f[g],_=y[g];// Do not filter NaN, see comment above.
(x>=u&&x<=h||isNaN(x))&&(_>=v&&_<=m||isNaN(_))&&(a[s++]=d),d++}p=!0}}if(!p)if(1===r)for(g=0;g<o;g++){var b=e.getRawIndex(g);// Do not filter NaN, see comment above.
((x=c[i[0]][b])>=u&&x<=h||isNaN(x))&&(a[s++]=b)}else for(g=0;g<o;g++){for(var w=!0,S=(b=e.getRawIndex(g),0);S<r;S++){var M=i[S];// Do not filter NaN, see comment above.
((x=c[M][b])<t[M][0]||x>t[M][1])&&(w=!1)}w&&(a[s++]=e.getRawIndex(g))}// Set indices after filtered.
return s<o&&(e._indices=a),e._count=s,// Reset data extent
e._extent=[],e._updateGetRawIdx(),e},// /**
//  * Data mapping to a plain array
//  */
// mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {
//     const result: any[] = [];
//     this.each(dims, function () {
//         result.push(cb && (cb as MapArrayCb).apply(null, arguments));
//     });
//     return result;
// }
/**
               * Data mapping to a new List with given dimensions
               */
t.prototype.map=function(t,e){// TODO only clone picked chunks.
var n=this.clone(t);return this._updateDims(n,t,e),n},
/**
               * @caution Danger!! Only used in dataStack.
               */
t.prototype.modify=function(t,e){this._updateDims(this,t,e)},t.prototype._updateDims=function(t,e,n){for(var i=t._chunks,r=[],o=e.length,a=t.count(),s=[],l=t._rawExtent,u=0;u<e.length;u++)l[e[u]]=[1/0,-1/0];for(var h=0;h<a;h++){for(var c=t.getRawIndex(h),p=0;p<o;p++)s[p]=i[e[p]][c];s[o]=h;var d=n&&n.apply(null,s);if(null!=d)for(// a number or string (in oridinal dimension)?
"object"!=typeof d&&(r[0]=d,d=r),u=0;u<d.length;u++){var f=e[u],g=d[u],y=l[f],v=i[f];v&&(v[c]=g),g<y[0]&&(y[0]=g),g>y[1]&&(y[1]=g)}}},
/**
               * Large data down sampling using largest-triangle-three-buckets
               * @param {string} valueDimension
               * @param {number} targetCount
               */
t.prototype.lttbDownSample=function(t,e){var n,i,r,o=this.clone([t],!0),a=o._chunks[t],s=this.count(),l=0,u=Math.floor(1/e),h=this.getRawIndex(0),c=new(ng(this._rawCount))(Math.min(2*(Math.ceil(s/u)+2),s));// First frame use the first data.
c[l++]=h;for(var p=1;p<s-1;p+=u){for(var d=Math.min(p+u,s-1),f=Math.min(p+2*u,s),g=(f+d)/2,y=0,v=d;v<f;v++){var m=a[I=this.getRawIndex(v)];isNaN(m)||(y+=m)}y/=f-d;var x=p,_=Math.min(p+u,s),b=p-1,w=a[h];n=-1,r=x;var S=-1,M=0;// Find a point from current frame that construct a triangel with largest area with previous selected point
// And the average of next frame.
for(v=x;v<_;v++){var I;m=a[I=this.getRawIndex(v)],isNaN(m)?(M++,S<0&&(S=I)):(// Calculate triangle area over three buckets
i=Math.abs((b-g)*(m-w)-(b-v)*(y-w)))>n&&(n=i,r=I)}M>0&&M<_-x&&(// Append first NaN point in every bucket.
// It is necessary to ensure the correct order of indices.
c[l++]=Math.min(S,r),r=Math.max(S,r)),c[l++]=r,h=r}// First frame use the last data.
return c[l++]=this.getRawIndex(s-1),o._count=l,o._indices=c,o.getRawIndex=this._getRawIdx,o},
/**
               * Large data down sampling on given dimension
               * @param sampleIndex Sample index for name and id
               */
t.prototype.downSample=function(t,e,n,i){for(var r=this.clone([t],!0),o=r._chunks,a=[],s=Math.floor(1/e),l=o[t],u=this.count(),h=r._rawExtent[t]=[1/0,-1/0],c=new(ng(this._rawCount))(Math.ceil(u/s)),p=0,d=0;d<u;d+=s){// Last frame
s>u-d&&(s=u-d,a.length=s);for(var f=0;f<s;f++){var g=this.getRawIndex(d+f);a[f]=l[g]}var y=n(a),v=this.getRawIndex(Math.min(d+i(a,y)||0,u-1));// Only write value on the filtered data
l[v]=y,y<h[0]&&(h[0]=y),y>h[1]&&(h[1]=y),c[p++]=v}return r._count=p,r._indices=c,r._updateGetRawIdx(),r},
/**
               * Data iteration
               * @param ctx default this
               * @example
               *  list.each('x', function (x, idx) {});
               *  list.each(['x', 'y'], function (x, y, idx) {});
               *  list.each(function (idx) {})
               */
t.prototype.each=function(t,e){if(this._count)for(var n=t.length,i=this._chunks,r=0,o=this.count();r<o;r++){var a=this.getRawIndex(r);// Simple optimization
switch(n){case 0:e(r);break;case 1:e(i[t[0]][a],r);break;case 2:e(i[t[0]][a],i[t[1]][a],r);break;default:for(var s=0,l=[];s<n;s++)l[s]=i[t[s]][a];// Index
l[s]=r,e.apply(null,l)}}},
/**
               * Get extent of data in one dimension
               */
t.prototype.getDataExtent=function(t){// Make sure use concrete dim as cache name.
var e=this._chunks[t],n=[1/0,-1/0];if(!e)return n;// Make more strict checkings to ensure hitting cache.
var i,r=this.count();// Consider the most cases when using data zoom, `getDataExtent`
// happened before filtering. We cache raw extent, which is not
// necessary to be cleared and recalculated when restore data.
if(!this._indices)return this._rawExtent[t].slice();if(i=this._extent[t])return i.slice();for(var o=(i=n)[0],a=i[1],s=0;s<r;s++){var l=e[this.getRawIndex(s)];l<o&&(o=l),l>a&&(a=l)}return i=[o,a],this._extent[t]=i,i},
/**
               * Get raw data item
               */
t.prototype.getRawDataItem=function(t){var e=this.getRawIndex(t);if(this._provider.persistent)return this._provider.getItem(e);for(var n=[],i=this._chunks,r=0;r<i.length;r++)n.push(i[r][e]);return n},
/**
               * Clone shallow.
               *
               * @param clonedDims Determine which dims to clone. Will share the data if not specified.
               */
t.prototype.clone=function(e,n){var i,r,o=new t,a=this._chunks,s=e&&E(e,(function(t,e){return t[e]=!0,t}),{});if(s)for(var l=0;l<a.length;l++)// Not clone if dim is not picked.
o._chunks[l]=s[l]?(i=a[l],r=void 0,(r=i.constructor)===Array?i.slice():new r(i)):a[l];else o._chunks=a;return this._copyCommonProps(o),n||(o._indices=this._cloneIndices()),o._updateGetRawIdx(),o},t.prototype._copyCommonProps=function(t){t._count=this._count,t._rawCount=this._rawCount,t._provider=this._provider,t._dimensions=this._dimensions,t._extent=T(this._extent),t._rawExtent=T(this._rawExtent)},t.prototype._cloneIndices=function(){if(this._indices){var t=this._indices.constructor,e=void 0;if(t===Array){var n=this._indices.length;e=new t(n);for(var i=0;i<n;i++)e[i]=this._indices[i]}else e=new t(this._indices);return e}return null},t.prototype._getRawIdxIdentity=function(t){return t},t.prototype._getRawIdx=function(t){return t<this._count&&t>=0?this._indices[t]:-1},t.prototype._updateGetRawIdx=function(){this.getRawIndex=this._indices?this._getRawIdx:this._getRawIdxIdentity},t.internalField=function(){function t(t,e,n,i){return Of(t[i],this._dimensions[i])}qf={arrayRows:t,objectRows:function(t,e,n,i){return Of(t[e],this._dimensions[i])},keyedColumns:t,original:function(t,e,n,i){// Performance sensitive, do not use modelUtil.getDataItemValue.
// If dataItem is an plain object with no value field, the let `value`
// will be assigned with the object, but it will be tread correctly
// in the `convertValue`.
var r=t&&(null==t.value?t:t.value);return Of(r instanceof Array?r[i]:r,this._dimensions[i])},typedArray:function(t,e,n,i){return t[i]}}}(),t}(),og=/** @class */function(){function t(t){// Cached source. Do not repeat calculating if not dirty.
this._sourceList=[],this._storeList=[],// version sign of each upstream source manager.
this._upstreamSignList=[],this._versionSignBase=0,this._dirty=!0,this._sourceHost=t}
/**
               * Mark dirty.
               */return t.prototype.dirty=function(){this._setLocalSource([],[]),this._storeList=[],this._dirty=!0},t.prototype._setLocalSource=function(t,e){this._sourceList=t,this._upstreamSignList=e,this._versionSignBase++,this._versionSignBase>9e10&&(this._versionSignBase=0)},
/**
               * For detecting whether the upstream source is dirty, so that
               * the local cached source (in `_sourceList`) should be discarded.
               */
t.prototype._getVersionSign=function(){return this._sourceHost.uid+"_"+this._versionSignBase},
/**
               * Always return a source instance. Otherwise throw error.
               */
t.prototype.prepareSource=function(){// For the case that call `setOption` multiple time but no data changed,
// cache the result source to prevent from repeating transform.
this._isDirty()&&(this._createSource(),this._dirty=!1)},t.prototype._createSource=function(){this._setLocalSource([],[]);var t,e,n=this._sourceHost,i=this._getUpstreamSourceManagers(),r=!!i.length;if(sg(n)){var o=n,a=void 0,s=void 0,l=void 0;// Has upstream dataset
if(r){var u=i[0];u.prepareSource(),a=(l=u.getSource()).data,s=l.sourceFormat,e=[u._getVersionSign()]}// Series data is from own.
else s=j(a=o.get("data",!0))?$p:Zp,e=[];// See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.
var h=this._getSourceMetaRawOption()||{},c=l&&l.metaRawOption||{},p=Q(h.seriesLayoutBy,c.seriesLayoutBy)||null,d=Q(h.sourceHeader,c.sourceHeader),f=Q(h.dimensions,c.dimensions);t=p!==c.seriesLayoutBy||!!d!=!!c.sourceHeader||f?[uf(a,{seriesLayoutBy:p,sourceHeader:d,dimensions:f},s)]:[]}else{var g=n;// Has upstream dataset.
if(r){var y=this._applyTransform(i);t=y.sourceList,e=y.upstreamSignList}// Is root dataset.
else t=[uf(g.get("source",!0),this._getSourceMetaRawOption(),null)],e=[]}this._setLocalSource(t,e)},t.prototype._applyTransform=function(t){var e,n=this._sourceHost,i=n.get("transform",!0),r=n.get("fromTransformResult",!0);null!=r&&1!==t.length&&lg("");var o,a=[],s=[];return R(t,(function(t){t.prepareSource();var e=t.getSource(r||0);null==r||e||lg(""),a.push(e),s.push(t._getVersionSign())})),i?e=function(t,e,n){var i=lo(t),r=i.length;r||ro("");for(var o=0,a=r;o<a;o++)e=Zf(i[o],e),// piped transform only support single input, except the fist one.
// piped transform only support single output, except the last one.
o!==a-1&&(e.length=Math.max(e.length,1));return e}(i,a,n.componentIndex):null!=r&&(e=[(o=a[0],new sf({data:o.data,sourceFormat:o.sourceFormat,seriesLayoutBy:o.seriesLayoutBy,dimensionsDefine:T(o.dimensionsDefine),startIndex:o.startIndex,dimensionsDetectedCount:o.dimensionsDetectedCount}))]),{sourceList:e,upstreamSignList:s}},t.prototype._isDirty=function(){if(this._dirty)return!0;// All sourceList is from the some upstream.
for(var t=this._getUpstreamSourceManagers(),e=0;e<t.length;e++){var n=t[e];if(// Consider the case that there is ancestor diry, call it recursively.
// The performance is probably not an issue because usually the chain is not long.
n._isDirty()||this._upstreamSignList[e]!==n._getVersionSign())return!0}},
/**
               * @param sourceIndex By default 0, means "main source".
               *                    In most cases there is only one source.
               */
t.prototype.getSource=function(t){t=t||0;var e=this._sourceList[t];if(!e){// Series may share source instance with dataset.
var n=this._getUpstreamSourceManagers();return n[0]&&n[0].getSource(t)}return e},
/**
               *
               * Get a data store which can be shared across series.
               * Only available for series.
               *
               * @param seriesDimRequest Dimensions that are generated in series.
               *        Should have been sorted by `storeDimIndex` asc.
               */
t.prototype.getSharedDataStore=function(t){var e=t.makeStoreSchema();return this._innerGetDataStore(e.dimensions,t.source,e.hash)},t.prototype._innerGetDataStore=function(t,e,n){// TODO Can use other sourceIndex?
var i=this._storeList,r=i[0];r||(r=i[0]={});var o=r[n];if(!o){var a=this._getUpstreamSourceManagers()[0];sg(this._sourceHost)&&a?o=a._innerGetDataStore(t,e,n):// Always create store from source of series.
(o=new rg).initData(new gf(e,t.length),t),r[n]=o}return o},
/**
               * PENDING: Is it fast enough?
               * If no upstream, return empty array.
               */
t.prototype._getUpstreamSourceManagers=function(){// Always get the relationship from the raw option.
// Do not cache the link of the dependency graph, so that
// there is no need to update them when change happens.
var t=this._sourceHost;if(sg(t)){var e=sd(t);return e?[e.getSourceManager()]:[]}return N(function(t){// Only these attributes declared, we by defualt reference to `datasetIndex: 0`.
// Otherwise, no reference.
return t.get("transform",!0)||t.get("fromTransformResult",!0)?Co(t.ecModel,"dataset",{index:t.get("fromDatasetIndex",!0),id:t.get("fromDatasetId",!0)},Io).models:[]}(t),(function(t){return t.getSourceManager()}))},t.prototype._getSourceMetaRawOption=function(){var t,e,n,i=this._sourceHost;if(sg(i))t=i.get("seriesLayoutBy",!0),e=i.get("sourceHeader",!0),n=i.get("dimensions",!0);else if(!this._getUpstreamSourceManagers().length){var r=i;t=r.get("seriesLayoutBy",!0),e=r.get("sourceHeader",!0),n=r.get("dimensions",!0)}return{seriesLayoutBy:t,sourceHeader:e,dimensions:n}},t}();
/**
             * [REQUIREMENT_MEMO]:
             * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.
             * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and
             * `root-dataset`. Them on `series` has higher priority.
             * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might
             * confuse users: whether those props indicate how to visit the upstream source or visit
             * the transform result source, and some transforms has nothing to do with these props,
             * and some transforms might have multiple upstream.
             * (3) Transforms should specify `metaRawOption` in each output, just like they can be
             * declared in `root-dataset`.
             * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.
             * That is for reducing complexity in transforms.
             * PENDING: Whether to provide transposition transform?
             *
             * [IMPLEMENTAION_MEMO]:
             * "sourceVisitConfig" are calculated from `metaRawOption` and `data`.
             * They will not be calculated until `source` is about to be visited (to prevent from
             * duplicate calcuation). `source` is visited only in series and input to transforms.
             *
             * [DIMENSION_INHERIT_RULE]:
             * By default the dimensions are inherited from ancestors, unless a transform return
             * a new dimensions definition.
             * Consider the case:
             * ```js
             * dataset: [{
             *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]
             * }, {
             *     transform: { type: 'filter', ... }
             * }]
             * dataset: [{
             *     dimension: ['Product', 'Sales', 'Prise'],
             *     source: [ ['Cookies', 321, 44.21], ...]
             * }, {
             *     transform: { type: 'filter', ... }
             * }]
             * ```
             * The two types of option should have the same behavior after transform.
             *
             *
             * [SCENARIO]:
             * (1) Provide source data directly:
             * ```js
             * series: {
             *     encode: {...},
             *     dimensions: [...]
             *     seriesLayoutBy: 'row',
             *     data: [[...]]
             * }
             * ```
             * (2) Series refer to dataset.
             * ```js
             * series: [{
             *     encode: {...}
             *     // Ignore datasetIndex means `datasetIndex: 0`
             *     // and the dimensions defination in dataset is used
             * }, {
             *     encode: {...},
             *     seriesLayoutBy: 'column',
             *     datasetIndex: 1
             * }]
             * ```
             * (3) dataset transform
             * ```js
             * dataset: [{
             *     source: [...]
             * }, {
             *     source: [...]
             * }, {
             *     // By default from 0.
             *     transform: { type: 'filter', config: {...} }
             * }, {
             *     // Piped.
             *     transform: [
             *         { type: 'filter', config: {...} },
             *         { type: 'sort', config: {...} }
             *     ]
             * }, {
             *     id: 'regressionData',
             *     fromDatasetIndex: 1,
             *     // Third-party transform
             *     transform: { type: 'ecStat:regression', config: {...} }
             * }, {
             *     // retrieve the extra result.
             *     id: 'regressionFormula',
             *     fromDatasetId: 'regressionData',
             *     fromTransformResult: 1
             * }]
             * ```
             */ // disable the transform merge, but do not disable transform clone from rawOption.
function ag(t){t.option.transform&&at(t.option.transform)}function sg(t){// Avoid circular dependency with Series.ts
return"series"===t.mainType}function lg(t){throw new Error(t)}var ug="line-height:1";// TODO: more textStyle option
function hg(t,e){var n=t.color||"#6e7079",i=t.fontSize||12,r=t.fontWeight||"400",o=t.color||"#464646",a=t.fontSize||14,s=t.fontWeight||"900";return"html"===e?{// eslint-disable-next-line max-len
nameStyle:"font-size:"+qt(i+"")+"px;color:"+qt(n)+";font-weight:"+qt(r+""),// eslint-disable-next-line max-len
valueStyle:"font-size:"+qt(a+"")+"px;color:"+qt(o)+";font-weight:"+qt(s+"")}:{nameStyle:{fontSize:i,fill:n,fontWeight:r},valueStyle:{fontSize:a,fill:o,fontWeight:s}}}// See `TooltipMarkupLayoutIntent['innerGapLevel']`.
// (value from UI design)
var cg=[0,10,20,30],pg=["","\n","\n\n","\n\n\n"];// eslint-disable-next-line max-len
function dg(t,e){return e.type=t,e}function fg(t){return"section"===t.type}function gg(t){return fg(t)?vg:mg}function yg(t){if(fg(t)){var e=0,n=t.blocks.length,i=n>1||n>0&&!t.noHeader;return R(t.blocks,(function(t){var n=yg(t);// If the some of the sub-blocks have some gaps (like 10px) inside, this block
// should use a larger gap (like 20px) to distinguish those sub-blocks.
n>=e&&(e=n+ +(i&&(// 0 always can not be readable gap level.
!n||fg(t)&&!t.noHeader)))})),e}return 0}function vg(t,e,n,i){var r,o=e.noHeader,a=(r=yg(e),{html:cg[r],richText:pg[r]}),s=[],l=e.blocks||[];it(!l||G(l)),l=l||[];var u=t.orderMode;if(e.sortBlocks&&u){l=l.slice();var h={valueAsc:"asc",valueDesc:"desc"};if(gt(h,u)){var c=new Vf(h[u],null);l.sort((function(t,e){return c.evaluate(t.sortParam,e.sortParam)}))}// FIXME 'seriesDesc' necessary?
else"seriesDesc"===u&&l.reverse()}R(l,(function(n,r){var o=e.valueFormatter,l=gg(n)(// Inherit valueFormatter
o?A(A({},t),{valueFormatter:o}):t,n,r>0?a.html:0,i);null!=l&&s.push(l)}));var p="richText"===t.renderMode?s.join(a.richText):_g(s.join(""),o?n:a.html);if(o)return p;var d=Sp(e.header,"ordinal",t.useUTC),f=hg(i,t.renderMode).nameStyle;return"richText"===t.renderMode?bg(t,d,f)+a.richText+p:_g('<div style="'+f+";"+ug+';">'+qt(d)+"</div>"+p,n)}function mg(t,e,n,i){var r=t.renderMode,o=e.noName,a=e.noValue,s=!e.markerType,l=e.name,u=t.useUTC,h=e.valueFormatter||t.valueFormatter||function(t){return N(t=G(t)?t:[t],(function(t,e){return Sp(t,G(d)?d[e]:d,u)}))};if(!o||!a){var c=s?"":t.markupStyleCreator.makeTooltipMarker(e.markerType,e.markerColor||"#333",r),p=o?"":Sp(l,"ordinal",u),d=e.valueType,f=a?[]:h(e.value),g=!s||!o,y=!s&&o,v=hg(i,r),m=v.nameStyle,x=v.valueStyle;return"richText"===r?(s?"":c)+(o?"":bg(t,p,m))+(a?"":function(t,e,n,i,r){var o=[r],a=i?10:20;// Value has commas inside, so use '  ' as delimiter for multiple values.
return n&&o.push({padding:[0,0,0,a],align:"right"}),t.markupStyleCreator.wrapRichTextStyle(G(e)?e.join("  "):e,o)}(t,f,g,y,x)):_g((s?"":c)+(o?"":function(t,e,n){return'<span style="'+n+";"+(e?"margin-left:2px":"")+'">'+qt(t)+"</span>"}(p,!s,m))+(a?"":function(t,e,n,i){// Do not too close to marker, considering there are multiple values separated by spaces.
var r=n?"10px":"20px",o=e?"float:right;margin-left:"+r:"";return t=G(t)?t:[t],'<span style="'+o+";"+i+'">'+N(t,(function(t){return qt(t)})).join("&nbsp;&nbsp;")+"</span>"}(f,g,y,x)),n)}}
/**
             * @return markupText. null/undefined means no content.
             */function xg(t,e,n,i,r,o){if(t)return gg(t)({useUTC:r,renderMode:n,orderMode:i,markupStyleCreator:e,valueFormatter:t.valueFormatter},t,0,o)}function _g(t,e){return'<div style="margin: '+e+"px 0 0;"+ug+';">'+t+'<div style="clear:both"></div></div>'}function bg(t,e,n){return t.markupStyleCreator.wrapRichTextStyle(e,n)}function wg(t,e){return Cp(t.getData().getItemVisual(e,"style")[t.visualDrawType])}function Sg(t,e){var n=t.get("padding");return null!=n?n:"richText"===e?[8,10]:10}
/**
             * The major feature is generate styles for `renderMode: 'richText'`.
             * But it also serves `renderMode: 'html'` to provide
             * "renderMode-independent" API.
             */var Mg=/** @class */function(){function t(){this.richTextStyles={},// Notice that "generate a style name" usuall happens repeatly when mouse moving and
// displaying a tooltip. So we put the `_nextStyleNameId` as a member of each creator
// rather than static shared by all creators (which will cause it increase to fast).
this._nextStyleNameId=eo()}return t.prototype._generateStyleName=function(){return"__EC_aUTo_"+this._nextStyleNameId++},t.prototype.makeTooltipMarker=function(t,e,n){var i="richText"===n?this._generateStyleName():null,r=function(t,e){var n=H(t)?{color:t,extraCssText:e}:t||{},i=n.color,r=n.type;e=n.extraCssText;var o=n.renderMode||"html";return i?"html"===o?"subItem"===r?'<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:'+qt(i)+";"+(e||"")+'"></span>':'<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:'+qt(i)+";"+(e||"")+'"></span>':{renderMode:o,content:"{"+(n.markerId||"markerX")+"|}  ",style:"subItem"===r?{width:4,height:4,borderRadius:2,backgroundColor:i}:{width:10,height:10,borderRadius:5,backgroundColor:i}}:""}({color:e,type:t,renderMode:n,markerId:i});return H(r)?r:(this.richTextStyles[i]=r.style,r.content)},
/**
               * @usage
               * ```ts
               * const styledText = markupStyleCreator.wrapRichTextStyle([
               *     // The styles will be auto merged.
               *     {
               *         fontSize: 12,
               *         color: 'blue'
               *     },
               *     {
               *         padding: 20
               *     }
               * ]);
               * ```
               */
t.prototype.wrapRichTextStyle=function(t,e){var n={};G(e)?R(e,(function(t){return A(n,t)})):A(n,e);var i=this._generateStyleName();return this.richTextStyles[i]=n,"{"+i+"|"+t+"}"},t}();function Ig(t){var e,n,i,r,o=t.series,a=t.dataIndex,s=t.multipleSeries,l=o.getData(),u=l.mapDimensionsAll("defaultedTooltip"),h=u.length,c=o.getRawValue(a),p=G(c),d=wg(o,a);if(h>1||p&&!h){var f=function(t,e,n,i,r){// check: category-no-encode-has-axis-data in dataset.html
var o=e.getData(),a=E(t,(function(t,e,n){var i=o.getDimensionInfo(n);return t||i&&!1!==i.tooltip&&null!=i.displayName}),!1),s=[],l=[],u=[];function h(t,e){var n=o.getDimensionInfo(e);// If `dimInfo.tooltip` is not set, show tooltip.
n&&!1!==n.otherDims.tooltip&&(a?u.push(dg("nameValue",{markerType:"subItem",markerColor:r,name:n.displayName,value:t,valueType:n.type})):(s.push(t),l.push(n.type)))}return i.length?R(i,(function(t){h(Tf(o,n,t),t)})):R(t,h),{inlineValues:s,inlineValueTypes:l,blocks:u}}(c,o,a,u,d);e=f.inlineValues,n=f.inlineValueTypes,i=f.blocks,// Only support tooltip sort by the first inline value. It's enough in most cases.
r=f.inlineValues[0]}else if(h){var g=l.getDimensionInfo(u[0]);r=e=Tf(l,a,u[0]),n=g.type}else r=e=p?c[0]:c;// Do not show generated series name. It might not be readable.
var y=mo(o),v=y&&o.name||"",m=l.getName(a),x=s?v:m;return dg("section",{header:v,// When series name not specified, do not show a header line with only '-'.
// This case alway happen in tooltip.trigger: 'item'.
noHeader:s||!y,sortParam:r,blocks:[dg("nameValue",{markerType:"item",markerColor:d,// Do not mix display seriesName and itemName in one tooltip,
// which might confuses users.
name:x,// name dimension might be auto assigned, where the name might
// be not readable. So we check trim here.
noName:!rt(x),value:e,valueType:n})].concat(i||[])})}var Tg=bo();function Cg(t,e){return t.getName(e)||t.getId(e)}var Dg="__universalTransitionEnabled",Ag=/** @class */function(t){function e(){// [Caution]: Because this class or desecendants can be used as `XXX.extend(subProto)`,
// the class members must not be initialized in constructor or declaration place.
// Otherwise there is bad case:
//   class A {xxx = 1;}
//   enableClassExtend(A);
//   class B extends A {}
//   var C = B.extend({xxx: 5});
//   var c = new C();
//   console.log(c.xxx); // expect 5 but always 1.
var e=null!==t&&t.apply(this,arguments)||this;// ---------------------------------------
// Props about data selection
// ---------------------------------------
return e._selectedDataIndicesMap={},e}return n(e,t),e.prototype.init=function(t,e,n){this.seriesIndex=this.componentIndex,this.dataTask=kf({count:Lg,reset:Pg}),this.dataTask.context={model:this},this.mergeDefaultAndTheme(t,n),(Tg(this).sourceManager=new og(this)).prepareSource();var i=this.getInitialData(t,n);Rg(i,this),this.dataTask.context.data=i,Tg(this).dataBeforeProcessed=i,// If we reverse the order (make data firstly, and then make
// dataBeforeProcessed by cloneShallow), cloneShallow will
// cause data.graph.data !== data when using
// module:echarts/data/Graph or module:echarts/data/Tree.
// See module:echarts/data/helper/linkSeriesData
// Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
// init or merge stage, because the data can be restored. So we do not `restoreData`
// and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
// Call `seriesModel.getRawData()` instead.
// this.restoreData();
kg(this),this._initSelectedMapFromData(i)},
/**
               * Util for merge default and theme to option
               */
e.prototype.mergeDefaultAndTheme=function(t,e){var n=Ep(this),i=n?Vp(t):{},r=this.subType;Wp.hasClass(r)&&(r+="Series"),C(t,e.getTheme().get(this.subType)),C(t,this.getDefaultOption()),// Default label emphasis `show`
uo(t,"label",["show"]),this.fillDataTextStyle(t.data),n&&zp(t,i,n)},e.prototype.mergeOption=function(t,e){// this.settingTask.dirty();
t=C(this.option,t,!0),this.fillDataTextStyle(t.data);var n=Ep(this);n&&zp(this.option,t,n);var i=Tg(this).sourceManager;i.dirty(),i.prepareSource();var r=this.getInitialData(t,e);Rg(r,this),this.dataTask.dirty(),this.dataTask.context.data=r,Tg(this).dataBeforeProcessed=r,kg(this),this._initSelectedMapFromData(r)},e.prototype.fillDataTextStyle=function(t){// Default data label emphasis `show`
// FIXME Tree structure data ?
// FIXME Performance ?
if(t&&!j(t))for(var e=["show"],n=0;n<t.length;n++)t[n]&&t[n].label&&uo(t[n],"label",e)},
/**
               * Init a data structure from data related option in series
               * Must be overridden.
               */
e.prototype.getInitialData=function(t,e){},
/**
               * Append data to list
               */
e.prototype.appendData=function(t){this.getRawData().appendData(t.data)},
/**
               * Consider some method like `filter`, `map` need make new data,
               * We should make sure that `seriesModel.getData()` get correct
               * data in the stream procedure. So we fetch data from upstream
               * each time `task.perform` called.
               */
e.prototype.getData=function(t){var e=Eg(this);if(e){var n=e.context.data;return null==t?n:n.getLinkedData(t)}// When series is not alive (that may happen when click toolbox
// restore or setOption with not merge mode), series data may
// be still need to judge animation or something when graphic
// elements want to know whether fade out.
return Tg(this).data},e.prototype.getAllData=function(){var t=this.getData();return t&&t.getLinkedDataAll?t.getLinkedDataAll():[{data:t}]},e.prototype.setData=function(t){var e=Eg(this);if(e){var n=e.context;// Consider case: filter, data sample.
// FIXME:TS never used, so comment it
// if (context.data !== data && task.modifyOutputEnd) {
//     task.setOutputEnd(data.count());
// }
n.outputData=t,// Caution: setData should update context.data,
// Because getData may be called multiply in a
// single stage and expect to get the data just
// set. (For example, AxisProxy, x y both call
// getData and setDate sequentially).
// So the context.data should be fetched from
// upstream each time when a stage starts to be
// performed.
e!==this.dataTask&&(n.data=t)}Tg(this).data=t},e.prototype.getEncode=function(){var t=this.get("encode",!0);if(t)return ct(t)},e.prototype.getSourceManager=function(){return Tg(this).sourceManager},e.prototype.getSource=function(){return this.getSourceManager().getSource()},
/**
               * Get data before processed
               */
e.prototype.getRawData=function(){return Tg(this).dataBeforeProcessed},e.prototype.getColorBy=function(){return this.get("colorBy")||"series"},e.prototype.isColorBySeries=function(){return"series"===this.getColorBy()},
/**
               * Get base axis if has coordinate system and has axis.
               * By default use coordSys.getBaseAxis();
               * Can be overridden for some chart.
               * @return {type} description
               */
e.prototype.getBaseAxis=function(){var t=this.coordinateSystem;// @ts-ignore
return t&&t.getBaseAxis&&t.getBaseAxis()},
/**
               * Default tooltip formatter
               *
               * @param dataIndex
               * @param multipleSeries
               * @param dataType
               * @param renderMode valid values: 'html'(by default) and 'richText'.
               *        'html' is used for rendering tooltip in extra DOM form, and the result
               *        string is used as DOM HTML content.
               *        'richText' is used for rendering tooltip in rich text form, for those where
               *        DOM operation is not supported.
               * @return formatted tooltip with `html` and `markers`
               *        Notice: The override method can also return string
               */
e.prototype.formatTooltip=function(t,e,n){return Ig({series:this,dataIndex:t,multipleSeries:e})},e.prototype.isAnimationEnabled=function(){var t=this.ecModel;// Disable animation if using echarts in node but not give ssr flag.
// In ssr mode, renderToString will generate svg with css animation.
if(o.node&&(!t||!t.ssr))return!1;var e=this.getShallow("animation");return e&&this.getData().count()>this.getShallow("animationThreshold")&&(e=!1),!!e},e.prototype.restoreData=function(){this.dataTask.dirty()},e.prototype.getColorFromPalette=function(t,e,n){var i=this.ecModel,r=yd.prototype.getColorFromPalette.call(this,t,e,n);// PENDING
return r||(r=i.getColorFromPalette(t,e,n)),r},
/**
               * Use `data.mapDimensionsAll(coordDim)` instead.
               * @deprecated
               */
e.prototype.coordDimToDataDim=function(t){return this.getRawData().mapDimensionsAll(t)},
/**
               * Get progressive rendering count each step
               */
e.prototype.getProgressive=function(){return this.get("progressive")},
/**
               * Get progressive rendering count each step
               */
e.prototype.getProgressiveThreshold=function(){return this.get("progressiveThreshold")},// PENGING If selectedMode is null ?
e.prototype.select=function(t,e){this._innerSelect(this.getData(e),t)},e.prototype.unselect=function(t,e){var n=this.option.selectedMap;if(n){var i=this.option.selectedMode,r=this.getData(e);if("series"===i||"all"===n)return this.option.selectedMap={},void(this._selectedDataIndicesMap={});for(var o=0;o<t.length;o++){var a=Cg(r,t[o]);n[a]=!1,this._selectedDataIndicesMap[a]=-1}}},e.prototype.toggleSelect=function(t,e){for(var n=[],i=0;i<t.length;i++)n[0]=t[i],this.isSelected(t[i],e)?this.unselect(n,e):this.select(n,e)},e.prototype.getSelectedDataIndices=function(){if("all"===this.option.selectedMap)return[].slice.call(this.getData().getIndices());for(var t=this._selectedDataIndicesMap,e=V(t),n=[],i=0;i<e.length;i++){var r=t[e[i]];r>=0&&n.push(r)}return n},e.prototype.isSelected=function(t,e){var n=this.option.selectedMap;if(!n)return!1;var i=this.getData(e);return("all"===n||n[Cg(i,t)])&&!i.getItemModel(t).get(["select","disabled"])},e.prototype.isUniversalTransitionEnabled=function(){if(this[Dg])return!0;var t=this.option.universalTransition;// Quick reject
return!!t&&(!0===t||t&&t.enabled)},e.prototype._innerSelect=function(t,e){var n,i,r=this.option,o=r.selectedMode,a=e.length;if(o&&a)if("series"===o)r.selectedMap="all";else if("multiple"===o){U(r.selectedMap)||(r.selectedMap={});for(var s=r.selectedMap,l=0;l<a;l++){var u=e[l];// TODO different types of data share same object.
s[c=Cg(t,u)]=!0,this._selectedDataIndicesMap[c]=t.getRawIndex(u)}}else if("single"===o||!0===o){var h=e[a-1],c=Cg(t,h);r.selectedMap=((n={})[c]=!0,n),this._selectedDataIndicesMap=((i={})[c]=t.getRawIndex(h),i)}},e.prototype._initSelectedMapFromData=function(t){// Ignore select info in data if selectedMap exists.
// NOTE It's only for legacy usage. edge data is not supported.
if(!this.option.selectedMap){var e=[];t.hasItemOption&&t.each((function(n){var i=t.getRawDataItem(n);i&&i.selected&&e.push(n)})),e.length>0&&this._innerSelect(t,e)}},// /**
//  * @see {module:echarts/stream/Scheduler}
//  */
// abstract pipeTask: null
e.registerClass=function(t){return Wp.registerClass(t)},e.protoInitialize=function(){var t=e.prototype;t.type="series.__base__",t.seriesIndex=0,t.ignoreStyleOnData=!1,t.hasSymbolVisual=!1,t.defaultSymbol="circle",// Make sure the values can be accessed!
t.visualStyleAccessPath="itemStyle",t.visualDrawType="fill"}(),e}(Wp);
/**
             * MUST be called after `prepareSource` called
             * Here we need to make auto series, especially for auto legend. But we
             * do not modify series.name in option to avoid side effects.
             */
function kg(t){// User specified name has higher priority, otherwise it may cause
// series can not be queried unexpectedly.
var e=t.name;mo(t)||(t.name=function(t){var e=t.getRawData(),n=e.mapDimensionsAll("seriesName"),i=[];return R(n,(function(t){var n=e.getDimensionInfo(t);n.displayName&&i.push(n.displayName)})),i.join(" ")}(t)||e)}function Lg(t){return t.model.getRawData().count()}function Pg(t){var e=t.model;return e.setData(e.getRawData().cloneShallow()),Og}function Og(t,e){// Avoid repead cloneShallow when data just created in reset.
e.outputData&&t.end>e.outputData.count()&&e.model.getRawData().cloneShallow(e.outputData)}// TODO refactor
function Rg(t,e){R(pt(t.CHANGABLE_METHODS,t.DOWNSAMPLE_METHODS),(function(n){t.wrapMethod(n,F(Ng,e))}))}function Ng(t,e){var n=Eg(t);return n&&// Consider case: filter, selectRange
n.setOutputEnd((e||this).count()),e}function Eg(t){var e=(t.ecModel||{}).scheduler,n=e&&e.getPipeline(t.uid);if(n){// When pipline finished, the currrentTask keep the last
// task (renderTask).
var i=n.currentTask;if(i){var r=i.agentStubMap;r&&(i=r.get(t.uid))}return i}}P(Ag,Df),P(Ag,yd),No(Ag,Wp);const zg=Ag;var Vg=/** @class */function(){function t(){this.group=new Lr,this.uid=Rc("viewComponent")}return t.prototype.init=function(t,e){},t.prototype.render=function(t,e,n,i){},t.prototype.dispose=function(t,e){},t.prototype.updateView=function(t,e,n,i){// Do nothing;
},t.prototype.updateLayout=function(t,e,n,i){// Do nothing;
},t.prototype.updateVisual=function(t,e,n,i){// Do nothing;
},
/**
               * Hook for toggle blur target series.
               * Can be used in marker for blur or leave blur the markers
               */
t.prototype.toggleBlurSeries=function(t,e,n){// Do nothing;
},
/**
               * Traverse the new rendered elements.
               *
               * It will traverse the new added element in progressive rendering.
               * And traverse all in normal rendering.
               */
t.prototype.eachRendered=function(t){var e=this.group;e&&e.traverse(t)},t}();Ro(Vg),Bo(Vg);const Bg=Vg;
/**
             * @return {string} If large mode changed, return string 'reset';
             */function Fg(){var t=bo();return function(e){var n=t(e),i=e.pipelineContext,r=!!n.large,o=!!n.progressiveRender,a=n.large=!(!i||!i.large),s=n.progressiveRender=!(!i||!i.progressiveRender);return!(r===a&&o===s)&&"reset"}}var Gg=bo(),Wg=Fg(),Hg=/** @class */function(){function t(){this.group=new Lr,this.uid=Rc("viewChart"),this.renderTask=kf({plan:Ug,reset:Zg}),this.renderTask.context={view:this}}return t.prototype.init=function(t,e){},t.prototype.render=function(t,e,n,i){},
/**
               * Highlight series or specified data item.
               */
t.prototype.highlight=function(t,e,n,i){var r=t.getData(i&&i.dataType);r&&Xg(r,i,"emphasis")},
/**
               * Downplay series or specified data item.
               */
t.prototype.downplay=function(t,e,n,i){var r=t.getData(i&&i.dataType);r&&Xg(r,i,"normal")},
/**
               * Remove self.
               */
t.prototype.remove=function(t,e){this.group.removeAll()},
/**
               * Dispose self.
               */
t.prototype.dispose=function(t,e){},t.prototype.updateView=function(t,e,n,i){this.render(t,e,n,i)},// FIXME never used?
t.prototype.updateLayout=function(t,e,n,i){this.render(t,e,n,i)},// FIXME never used?
t.prototype.updateVisual=function(t,e,n,i){this.render(t,e,n,i)},
/**
               * Traverse the new rendered elements.
               *
               * It will traverse the new added element in progressive rendering.
               * And traverse all in normal rendering.
               */
t.prototype.eachRendered=function(t){ec(this.group,t)},t.markUpdateMethod=function(t,e){Gg(t).updateMethod=e},t.protoInitialize=void(t.prototype.type="chart"),t}();
/**
             * Set state of single element
             */
function Yg(t,e,n){t&&Xl(t)&&("emphasis"===e?Il:Tl)(t,n)}function Xg(t,e,n){var i=_o(t,e),r=e&&null!=e.highlightKey?
/**
             * Support highlight/downplay record on each elements.
             * For the case: hover highlight/downplay (legend, visualMap, ...) and
             * user triggered highlight/downplay should not conflict.
             * Only all of the highlightDigit cleared, return to normal.
             * @param {string} highlightKey
             * @return {number} highlightDigit
             */
function(t){var e=$s[t];return null==e&&Ks<=32&&(e=$s[t]=Ks++),e}(e.highlightKey):null;null!=i?R(lo(i),(function(e){Yg(t.getItemGraphicEl(e),n,r)})):t.eachItemGraphicEl((function(t){Yg(t,n,r)}))}function Ug(t){return Wg(t.model)}function Zg(t){var e=t.model,n=t.ecModel,i=t.api,r=t.payload,o=e.pipelineContext.progressiveRender,a=t.view,s=r&&Gg(r).updateMethod,l=o?"incrementalPrepareRender":s&&a[s]?s:"render";return"render"!==l&&a[l](e,n,i,r),jg[l]}Ro(Hg),Bo(Hg);var jg={incrementalPrepareRender:{progress:function(t,e){e.view.incrementalRender(t,e.model,e.ecModel,e.api,e.payload)}},render:{// Put view.render in `progress` to support appendData. But in this case
// view.render should not be called in reset, otherwise it will be called
// twise. Use `forceFirstProgress` to make sure that view.render is called
// in any cases.
forceFirstProgress:!0,progress:function(t,e){e.view.render(e.model,e.ecModel,e.api,e.payload)}}};const qg=Hg;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var Kg="\0__throttleOriginMethod",$g="\0__throttleRate",Jg="\0__throttleType";
/**
             * @public
             * @param {(Function)} fn
             * @param {number} [delay=0] Unit: ms.
             * @param {boolean} [debounce=false]
             *        true: If call interval less than `delay`, only the last call works.
             *        false: If call interval less than `delay, call works on fixed rate.
             * @return {(Function)} throttled fn.
             */
function Qg(t,e,n){var i,r,o,a,s,l=0,u=0,h=null;function c(){u=(new Date).getTime(),h=null,t.apply(o,a||[])}e=e||0;var p=function(){for(var t=[],p=0;p<arguments.length;p++)t[p]=arguments[p];i=(new Date).getTime(),o=this,a=t;var d=s||e,f=s||n;s=null,r=i-(f?l:u)-d,clearTimeout(h),// Here we should make sure that: the `exec` SHOULD NOT be called later
// than a new call of `cb`, that is, preserving the command order. Consider
// calculating "scale rate" when roaming as an example. When a call of `cb`
// happens, either the `exec` is called dierectly, or the call is delayed.
// But the delayed call should never be later than next call of `cb`. Under
// this assurance, we can simply update view state each time `dispatchAction`
// triggered by user roaming, but not need to add extra code to avoid the
// state being "rolled-back".
f?h=setTimeout(c,d):r>=0?c():h=setTimeout(c,-r),l=i};
/**
               * Clear throttle.
               * @public
               */return p.clear=function(){h&&(clearTimeout(h),h=null)},
/**
               * Enable debounce once.
               */
p.debounceNextCall=function(t){s=t},p}
/**
             * Create throttle method or update throttle rate.
             *
             * @example
             * ComponentView.prototype.render = function () {
             *     ...
             *     throttle.createOrUpdate(
             *         this,
             *         '_dispatchAction',
             *         this.model.get('throttle'),
             *         'fixRate'
             *     );
             * };
             * ComponentView.prototype.remove = function () {
             *     throttle.clear(this, '_dispatchAction');
             * };
             * ComponentView.prototype.dispose = function () {
             *     throttle.clear(this, '_dispatchAction');
             * };
             *
             */function ty(t,e,n,i){var r=t[e];if(r){var o=r[Kg]||r,a=r[Jg];if(r[$g]!==n||a!==i){if(null==n||!i)return t[e]=o;(r=t[e]=Qg(o,n,"debounce"===i))[Kg]=o,r[Jg]=i,r[$g]=n}return r}}
/**
             * Clear throttle. Example see throttle.createOrUpdate.
             */function ey(t,e){var n=t[e];n&&n[Kg]&&(// Clear throttle
n.clear&&n.clear(),t[e]=n[Kg])}var ny=bo(),iy={itemStyle:Fo(Dc,!0),lineStyle:Fo(Ic,!0)},ry={lineStyle:"stroke",itemStyle:"fill"};function oy(t,e){var n=t.visualStyleMapper||iy[e];return n||iy.itemStyle}function ay(t,e){// return defaultColorKey[stylePath] ||
var n=t.visualDrawType||ry[e];return n||"fill"}var sy={createOnAllSeries:!0,performRawSeries:!0,reset:function(t,e){var n=t.getData(),i=t.visualStyleAccessPath||"itemStyle",r=t.getModel(i),o=oy(t,i)(r),a=r.getShallow("decal");a&&(n.setVisual("decal",a),a.dirty=!0);// TODO
var s=ay(t,i),l=o[s],u=W(l)?l:null,h="auto"===o.fill||"auto"===o.stroke;// Get from color palette by default.
if(!o[s]||u||h){// Note: If some series has color specified (e.g., by itemStyle.color), we DO NOT
// make it effect palette. Because some scenarios users need to make some series
// transparent or as background, which should better not effect the palette.
var c=t.getColorFromPalette(// TODO series count changed.
t.name,null,e.getSeriesCount());o[s]||(o[s]=c,n.setVisual("colorFromPalette",!0)),o.fill="auto"===o.fill||W(o.fill)?c:o.fill,o.stroke="auto"===o.stroke||W(o.stroke)?c:o.stroke}// Only visible series has each data be visual encoded
if(n.setVisual("style",o),n.setVisual("drawType",s),!e.isSeriesFiltered(t)&&u)return n.setVisual("colorFromPalette",!1),{dataEach:function(e,n){var i=t.getDataParams(n),r=A({},o);r[s]=u(i),e.setItemVisual(n,"style",r)}}}},ly=new Pc,uy={createOnAllSeries:!0,performRawSeries:!0,reset:function(t,e){if(!t.ignoreStyleOnData&&!e.isSeriesFiltered(t)){var n=t.getData(),i=t.visualStyleAccessPath||"itemStyle",r=oy(t,i),o=n.getVisual("drawType");return{dataEach:n.hasItemOption?function(t,e){// Not use getItemModel for performance considuration
var n=t.getRawDataItem(e);if(n&&n[i]){ly.option=n[i];var a=r(ly);A(t.ensureUniqueItemVisual(e,"style"),a),ly.option.decal&&(t.setItemVisual(e,"decal",ly.option.decal),ly.option.decal.dirty=!0),o in a&&t.setItemVisual(e,"colorFromPalette",!1)}}:null}}}},hy={performRawSeries:!0,overallReset:function(t){// Each type of series uses one scope.
// Pie and funnel are using different scopes.
var e=ct();t.eachSeries((function(t){var n=t.getColorBy();if(!t.isColorBySeries()){var i=t.type+"-"+n,r=e.get(i);r||(r={},e.set(i,r)),ny(t).scope=r}})),t.eachSeries((function(e){if(!e.isColorBySeries()&&!t.isSeriesFiltered(e)){var n=e.getRawData(),i={},r=e.getData(),o=ny(e).scope,a=e.visualStyleAccessPath||"itemStyle",s=ay(e,a);r.each((function(t){var e=r.getRawIndex(t);i[e]=t})),// Iterate on data before filtered. To make sure color from palette can be
// Consistent when toggling legend.
n.each((function(t){var a=i[t];// Get color from palette for each data only when the color is inherited from series color, which is
// also picked from color palette. So following situation is not in the case:
// 1. series.itemStyle.color is set
// 2. color is encoded by visualMap
if(r.getItemVisual(a,"colorFromPalette")){var l=r.ensureUniqueItemVisual(a,"style"),u=n.getName(t)||t+"",h=n.count();l[s]=e.getColorFromPalette(u,o,h)}}))}}))}},cy=Math.PI,py=/** @class */function(){function t(t,e,n,i){// key: handlerUID
this._stageTaskMap=ct(),this.ecInstance=t,this.api=e,// Fix current processors in case that in some rear cases that
// processors might be registered after echarts instance created.
// Register processors incrementally for a echarts instance is
// not supported by this stream architecture.
n=this._dataProcessorHandlers=n.slice(),i=this._visualHandlers=i.slice(),this._allHandlers=n.concat(i)}return t.prototype.restoreData=function(t,e){// TODO: Only restore needed series and components, but not all components.
// Currently `restoreData` of all of the series and component will be called.
// But some independent components like `title`, `legend`, `graphic`, `toolbox`,
// `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
// and some components like coordinate system, axes, dataZoom, visualMap only
// need their target series refresh.
// (1) If we are implementing this feature some day, we should consider these cases:
// if a data processor depends on a component (e.g., dataZoomProcessor depends
// on the settings of `dataZoom`), it should be re-performed if the component
// is modified by `setOption`.
// (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
// it should be re-performed when the result array of `getTargetSeries` changed.
// We use `dependencies` to cover these issues.
// (3) How to update target series when coordinate system related components modified.
// TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
// and this case all of the tasks will be set as dirty.
t.restoreData(e),// Theoretically an overall task not only depends on each of its target series, but also
// depends on all of the series.
// The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
// dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
// that the overall task is set as dirty and to be performed, otherwise it probably cause
// state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
// probably cause state chaos (consider `dataZoomProcessor`).
this._stageTaskMap.each((function(t){var e=t.overallTask;e&&e.dirty()}))},// If seriesModel provided, incremental threshold is check by series data.
t.prototype.getPerformArgs=function(t,e){// For overall task
if(t.__pipeline){var n=this._pipelineMap.get(t.__pipeline.id),i=n.context,r=!e&&n.progressiveEnabled&&(!i||i.progressiveRender)&&t.__idxInPipeline>n.blockIndex?n.step:null,o=i&&i.modDataCount;return{step:r,modBy:null!=o?Math.ceil(o/r):null,modDataCount:o}}},t.prototype.getPipeline=function(t){return this._pipelineMap.get(t)},
/**
               * Current, progressive rendering starts from visual and layout.
               * Always detect render mode in the same stage, avoiding that incorrect
               * detection caused by data filtering.
               * Caution:
               * `updateStreamModes` use `seriesModel.getData()`.
               */
t.prototype.updateStreamModes=function(t,e){var n=this._pipelineMap.get(t.uid),i=t.getData().count(),r=n.progressiveEnabled&&e.incrementalPrepareRender&&i>=n.threshold,o=t.get("large")&&i>=t.get("largeThreshold"),a="mod"===t.get("progressiveChunkMode")?i:null;t.pipelineContext=n.context={progressiveRender:r,modDataCount:a,large:o}},t.prototype.restorePipelines=function(t){var e=this,n=e._pipelineMap=ct();t.eachSeries((function(t){var i=t.getProgressive(),r=t.uid;n.set(r,{id:r,head:null,tail:null,threshold:t.getProgressiveThreshold(),progressiveEnabled:i&&!(t.preventIncremental&&t.preventIncremental()),blockIndex:-1,step:Math.round(i||700),count:0}),e._pipe(t,t.dataTask)}))},t.prototype.prepareStageTasks=function(){var t=this._stageTaskMap,e=this.api.getModel(),n=this.api;R(this._allHandlers,(function(i){var r=t.get(i.uid)||t.set(i.uid,{});it(!(i.reset&&i.overallReset),""),i.reset&&this._createSeriesStageTask(i,r,e,n),i.overallReset&&this._createOverallStageTask(i,r,e,n)}),this)},t.prototype.prepareView=function(t,e,n,i){var r=t.renderTask,o=r.context;o.model=e,o.ecModel=n,o.api=i,r.__block=!t.incrementalPrepareRender,this._pipe(e,r)},t.prototype.performDataProcessorTasks=function(t,e){// If we do not use `block` here, it should be considered when to update modes.
this._performStageTasks(this._dataProcessorHandlers,t,e,{block:!0})},t.prototype.performVisualTasks=function(t,e,n){this._performStageTasks(this._visualHandlers,t,e,n)},t.prototype._performStageTasks=function(t,e,n,i){i=i||{};var r=!1,o=this;function a(t,e){return t.setDirty&&(!t.dirtyMap||t.dirtyMap.get(e.__pipeline.id))}R(t,(function(t,s){if(!i.visualType||i.visualType===t.visualType){var l=o._stageTaskMap.get(t.uid),u=l.seriesTaskMap,h=l.overallTask;if(h){var c,p=h.agentStubMap;p.each((function(t){a(i,t)&&(t.dirty(),c=!0)})),c&&h.dirty(),o.updatePayload(h,n);var d=o.getPerformArgs(h,i.block);// Execute stubs firstly, which may set the overall task dirty,
// then execute the overall task. And stub will call seriesModel.setData,
// which ensures that in the overallTask seriesModel.getData() will not
// return incorrect data.
p.each((function(t){t.perform(d)})),h.perform(d)&&(r=!0)}else u&&u.each((function(s,l){a(i,s)&&s.dirty();var u=o.getPerformArgs(s,i.block);// FIXME
// if intending to declare `performRawSeries` in handlers, only
// stream-independent (specifically, data item independent) operations can be
// performed. Because if a series is filtered, most of the tasks will not
// be performed. A stream-dependent operation probably cause wrong biz logic.
// Perhaps we should not provide a separate callback for this case instead
// of providing the config `performRawSeries`. The stream-dependent operations
// and stream-independent operations should better not be mixed.
u.skip=!t.performRawSeries&&e.isSeriesFiltered(s.context.model),o.updatePayload(s,n),s.perform(u)&&(r=!0)}))}})),this.unfinished=r||this.unfinished},t.prototype.performSeriesTasks=function(t){var e;t.eachSeries((function(t){// Progress to the end for dataInit and dataRestore.
e=t.dataTask.perform()||e})),this.unfinished=e||this.unfinished},t.prototype.plan=function(){// Travel pipelines, check block.
this._pipelineMap.each((function(t){var e=t.tail;do{if(e.__block){t.blockIndex=e.__idxInPipeline;break}e=e.getUpstream()}while(e)}))},t.prototype.updatePayload=function(t,e){"remain"!==e&&(t.context.payload=e)},t.prototype._createSeriesStageTask=function(t,e,n,i){var r=this,o=e.seriesTaskMap,a=e.seriesTaskMap=ct(),s=t.seriesType,l=t.getTargetSeries;function u(e){var s=e.uid,l=a.set(s,o&&o.get(s)||kf({plan:vy,reset:my,count:by}));// Init tasks for each seriesModel only once.
// Reuse original task instance.
l.context={model:e,ecModel:n,api:i,// PENDING: `useClearVisual` not used?
useClearVisual:t.isVisual&&!t.isLayout,plan:t.plan,reset:t.reset,scheduler:r},r._pipe(e,l)}// If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
// to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
// it works but it may cause other irrelevant charts blocked.
t.createOnAllSeries?n.eachRawSeries(u):s?n.eachRawSeriesByType(s,u):l&&l(n,i).each(u)},t.prototype._createOverallStageTask=function(t,e,n,i){var r=this,o=e.overallTask=e.overallTask||kf({reset:dy});o.context={ecModel:n,api:i,overallReset:t.overallReset,scheduler:r};var a=o.agentStubMap,s=o.agentStubMap=ct(),l=t.seriesType,u=t.getTargetSeries,h=!0,c=!1;// The count of stages are totally about only several dozen, so
// do not need to reuse the map.
function p(t){var e=t.uid,n=s.set(e,a&&a.get(e)||(// When the result of `getTargetSeries` changed, the overallTask
// should be set as dirty and re-performed.
c=!0,kf({reset:fy,onDirty:yy})));n.context={model:t,overallProgress:h},n.agent=o,n.__block=h,r._pipe(t,n)}it(!t.createOnAllSeries,""),l?n.eachRawSeriesByType(l,p):u?u(n,i).each(p):(h=!1,R(n.getSeries(),p)),c&&o.dirty()},t.prototype._pipe=function(t,e){var n=t.uid,i=this._pipelineMap.get(n);!i.head&&(i.head=e),i.tail&&i.tail.pipe(e),i.tail=e,e.__idxInPipeline=i.count++,e.__pipeline=i},t.wrapStageHandler=function(t,e){return W(t)&&(t={overallReset:t,seriesType:wy(t)}),t.uid=Rc("stageHandler"),e&&(t.visualType=e),t},t}();function dy(t){t.overallReset(t.ecModel,t.api,t.payload)}function fy(t){return t.overallProgress&&gy}function gy(){this.agent.dirty(),this.getDownstream().dirty()}function yy(){this.agent&&this.agent.dirty()}function vy(t){return t.plan?t.plan(t.model,t.ecModel,t.api,t.payload):null}function my(t){t.useClearVisual&&t.data.clearAllVisual();var e=t.resetDefines=lo(t.reset(t.model,t.ecModel,t.api,t.payload));return e.length>1?N(e,(function(t,e){return _y(e)})):xy}var xy=_y(0);function _y(t){return function(e,n){var i=n.data,r=n.resetDefines[t];if(r&&r.dataEach)for(var o=e.start;o<e.end;o++)r.dataEach(i,o);else r&&r.progress&&r.progress(e,i)}}function by(t){return t.data.count()}
/**
             * Only some legacy stage handlers (usually in echarts extensions) are pure function.
             * To ensure that they can work normally, they should work in block mode, that is,
             * they should not be started util the previous tasks finished. So they cause the
             * progressive rendering disabled. We try to detect the series type, to narrow down
             * the block range to only the series type they concern, but not all series.
             */function wy(t){Sy=null;try{// Assume there is no async when calling `eachSeriesByType`.
t(My,Iy)}catch(ku){}return Sy}var Sy,My={},Iy={};function Ty(t,e){/* eslint-disable */for(var n in e.prototype)// Do not use hasOwnProperty
t[n]=yt;/* eslint-enable */}Ty(My,Md),Ty(Iy,Td),My.eachSeriesByType=My.eachRawSeriesByType=function(t){Sy=t},My.eachComponent=function(t){"series"===t.mainType&&t.subType&&(Sy=t.subType)};const Cy=py;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var Dy=["#37A2DA","#32C5E9","#67E0E3","#9FE6B8","#FFDB5C","#ff9f7f","#fb7293","#E062AE","#E690D1","#e7bcf3","#9d96f5","#8378EA","#96BFFF"];const Ay={color:Dy,colorLayer:[["#37A2DA","#ffd85c","#fd7b5f"],["#37A2DA","#67E0E3","#FFDB5C","#ff9f7f","#E062AE","#9d96f5"],["#37A2DA","#32C5E9","#9FE6B8","#FFDB5C","#ff9f7f","#fb7293","#e7bcf3","#8378EA","#96BFFF"],Dy]};
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var ky="#B9B8CE",Ly="#100C2A",Py=function(){return{axisLine:{lineStyle:{color:ky}},splitLine:{lineStyle:{color:"#484753"}},splitArea:{areaStyle:{color:["rgba(255,255,255,0.02)","rgba(255,255,255,0.05)"]}},minorSplitLine:{lineStyle:{color:"#20203B"}}}},Oy=["#4992ff","#7cffb2","#fddd60","#ff6e76","#58d9f9","#05c091","#ff8a45","#8d48e3","#dd79ff"],Ry={darkMode:!0,color:Oy,backgroundColor:Ly,axisPointer:{lineStyle:{color:"#817f91"},crossStyle:{color:"#817f91"},label:{// TODO Contrast of label backgorundColor
color:"#fff"}},legend:{textStyle:{color:ky}},textStyle:{color:ky},title:{textStyle:{color:"#EEF1FA"},subtextStyle:{color:"#B9B8CE"}},toolbox:{iconStyle:{borderColor:ky}},dataZoom:{borderColor:"#71708A",textStyle:{color:ky},brushStyle:{color:"rgba(135,163,206,0.3)"},handleStyle:{color:"#353450",borderColor:"#C5CBE3"},moveHandleStyle:{color:"#B0B6C3",opacity:.3},fillerColor:"rgba(135,163,206,0.2)",emphasis:{handleStyle:{borderColor:"#91B7F2",color:"#4D587D"},moveHandleStyle:{color:"#636D9A",opacity:.7}},dataBackground:{lineStyle:{color:"#71708A",width:1},areaStyle:{color:"#71708A"}},selectedDataBackground:{lineStyle:{color:"#87A3CE"},areaStyle:{color:"#87A3CE"}}},visualMap:{textStyle:{color:ky}},timeline:{lineStyle:{color:ky},label:{color:ky},controlStyle:{color:ky,borderColor:ky}},calendar:{itemStyle:{color:Ly},dayLabel:{color:ky},monthLabel:{color:ky},yearLabel:{color:ky}},timeAxis:Py(),logAxis:Py(),valueAxis:Py(),categoryAxis:Py(),line:{symbol:"circle"},graph:{color:Oy},gauge:{title:{color:ky},axisLine:{lineStyle:{color:[[1,"rgba(207,212,219,0.2)"]]}},axisLabel:{color:ky},detail:{color:"#EEF1FA"}},candlestick:{itemStyle:{color:"#f64e56",color0:"#54ea92",borderColor:"#f64e56",borderColor0:"#54ea92"}}};Ry.categoryAxis.splitLine.show=!1;const Ny=Ry;
/**
             * Usage of query:
             * `chart.on('click', query, handler);`
             * The `query` can be:
             * + The component type query string, only `mainType` or `mainType.subType`,
             *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
             * + The component query object, like:
             *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
             *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
             * + The data query object, like:
             *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
             * + The other query object (cmponent customized query), like:
             *   `{element: 'some'}` (only available in custom series).
             *
             * Caveat: If a prop in the `query` object is `null/undefined`, it is the
             * same as there is no such prop in the `query` object.
             */var Ey=/** @class */function(){function t(){}return t.prototype.normalizeQuery=function(t){var e={},n={},i={};// `query` is `mainType` or `mainType.subType` of component.
if(H(t)){var r=Oo(t);// `.main` and `.sub` may be ''.
e.mainType=r.main||null,e.subType=r.sub||null}// `query` is an object, convert to {mainType, index, name, id}.
else{// `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,
// can not be used in `compomentModel.filterForExposedEvent`.
var o=["Index","Name","Id"],a={name:1,dataIndex:1,dataType:1};R(t,(function(t,r){for(var s=!1,l=0;l<o.length;l++){var u=o[l],h=r.lastIndexOf(u);if(h>0&&h===r.length-u.length){var c=r.slice(0,h);// Consider `dataIndex`.
"data"!==c&&(e.mainType=c,e[u.toLowerCase()]=t,s=!0)}}a.hasOwnProperty(r)&&(n[r]=t,s=!0),s||(i[r]=t)}))}return{cptQuery:e,dataQuery:n,otherQuery:i}},t.prototype.filter=function(t,e){// They should be assigned before each trigger call.
var n=this.eventInfo;if(!n)return!0;var i=n.targetEl,r=n.packedEvent,o=n.model,a=n.view;// For event like 'globalout'.
if(!o||!a)return!0;var s=e.cptQuery,l=e.dataQuery;return u(s,o,"mainType")&&u(s,o,"subType")&&u(s,o,"index","componentIndex")&&u(s,o,"name")&&u(s,o,"id")&&u(l,r,"name")&&u(l,r,"dataIndex")&&u(l,r,"dataType")&&(!a.filterForExposedEvent||a.filterForExposedEvent(t,e.otherQuery,i,r));function u(t,e,n,i){return null==t[n]||e[i||n]===t[n]}},t.prototype.afterTrigger=function(){// Make sure the eventInfo won't be used in next trigger.
this.eventInfo=null},t}(),zy=["symbol","symbolSize","symbolRotate","symbolOffset"],Vy=zy.concat(["symbolKeepAspect"]),By={createOnAllSeries:!0,// For legend.
performRawSeries:!0,reset:function(t,e){var n=t.getData();if(t.legendIcon&&n.setVisual("legendIcon",t.legendIcon),t.hasSymbolVisual){for(var i={},r={},o=!1,a=0;a<zy.length;a++){var s=zy[a],l=t.get(s);W(l)?(o=!0,r[s]=l):i[s]=l}// Only visible series has each data be visual encoded
if(i.symbol=i.symbol||t.defaultSymbol,n.setVisual(A({legendIcon:t.legendIcon||i.symbol,symbolKeepAspect:t.get("symbolKeepAspect")},i)),!e.isSeriesFiltered(t)){var u=V(r);return{dataEach:o?function(e,n){for(var i=t.getRawValue(n),o=t.getDataParams(n),a=0;a<u.length;a++){var s=u[a];e.setItemVisual(n,s,r[s](i,o))}}:null}}}}},Fy={createOnAllSeries:!0,// For legend.
performRawSeries:!0,reset:function(t,e){if(t.hasSymbolVisual&&!e.isSeriesFiltered(t))return{dataEach:t.getData().hasItemOption?function(t,e){for(var n=t.getItemModel(e),i=0;i<Vy.length;i++){var r=Vy[i],o=n.getShallow(r,!0);null!=o&&t.setItemVisual(e,r,o)}}:null};// Only visible series has each data be visual encoded
}};
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
function Gy(t,e,n){switch(n){case"color":return t.getItemVisual(e,"style")[t.getVisual("drawType")];case"opacity":return t.getItemVisual(e,"style").opacity;case"symbol":case"symbolSize":case"liftZ":return t.getItemVisual(e,n)}}function Wy(t,e){switch(e){case"color":return t.getVisual("style")[t.getVisual("drawType")];case"opacity":return t.getVisual("style").opacity;case"symbol":case"symbolSize":case"liftZ":return t.getVisual(e)}}function Hy(t,e,n,i){switch(n){case"color":t.ensureUniqueItemVisual(e,"style")[t.getVisual("drawType")]=i,// Mark the color has been changed, not from palette anymore
t.setItemVisual(e,"colorFromPalette",!1);break;case"opacity":t.ensureUniqueItemVisual(e,"style").opacity=i;break;case"symbol":case"symbolSize":case"liftZ":t.setItemVisual(e,n,i)}}// Inlucdes: pieSelect, pieUnSelect, pieToggleSelect, mapSelect, mapUnSelect, mapToggleSelect
function Yy(t,e){function n(e,n){var i=[];return e.eachComponent({mainType:"series",subType:t,query:n},(function(t){i.push(t.seriesIndex)})),i}R([[t+"ToggleSelect","toggleSelect"],[t+"Select","select"],[t+"UnSelect","unselect"]],(function(t){e(t[0],(function(e,i,r){e=A({},e),r.dispatchAction(A(e,{type:t[1],seriesIndex:n(i,e)}))}))}))}function Xy(t,e,n,i,r){var o=t+e;n.isSilent(o)||i.eachComponent({mainType:"series",subType:"pie"},(function(t){for(var e=t.seriesIndex,i=t.option.selectedMap,a=r.selected,s=0;s<a.length;s++)if(a[s].seriesIndex===e){var l=t.getData(),u=_o(l,r.fromActionPayload);n.trigger(o,{type:o,seriesId:t.id,name:G(u)?l.getName(u[0]):l.getName(u),selected:H(i)?i:A({},i)})}}))}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
function Uy(t,e,n){for(var i;t&&(!e(t)||(i=t,!n));)t=t.__hostTarget||t.parent;return i}var Zy=Math.round(9*Math.random()),jy="function"==typeof Object.defineProperty,qy=function(){function t(){this._id="__ec_inner_"+Zy++}return t.prototype.get=function(t){return this._guard(t)[this._id]},t.prototype.set=function(t,e){var n=this._guard(t);return jy?Object.defineProperty(n,this._id,{value:e,enumerable:!1,configurable:!0}):n[this._id]=e,this},t.prototype.delete=function(t){return!!this.has(t)&&(delete this._guard(t)[this._id],!0)},t.prototype.has=function(t){return!!this._guard(t)[this._id]},t.prototype._guard=function(t){if(t!==Object(t))throw TypeError("Value of WeakMap is not a non-null object.");return t},t}();const Ky=qy;
/**
             * Triangle shape
             * @inner
             */var $y=ys.extend({type:"triangle",shape:{cx:0,cy:0,width:0,height:0},buildPath:function(t,e){var n=e.cx,i=e.cy,r=e.width/2,o=e.height/2;t.moveTo(n,i-o),t.lineTo(n+r,i+o),t.lineTo(n-r,i+o),t.closePath()}}),Jy=ys.extend({type:"diamond",shape:{cx:0,cy:0,width:0,height:0},buildPath:function(t,e){var n=e.cx,i=e.cy,r=e.width/2,o=e.height/2;t.moveTo(n,i-o),t.lineTo(n+r,i),t.lineTo(n,i+o),t.lineTo(n-r,i),t.closePath()}}),Qy=ys.extend({type:"pin",shape:{// x, y on the cusp
x:0,y:0,width:0,height:0},buildPath:function(t,e){var n=e.x,i=e.y,r=e.width/5*3,o=Math.max(r,e.height),a=r/2,s=a*a/(o-a),l=i-o+a+s,u=Math.asin(s/a),h=Math.cos(u)*a,c=Math.sin(u),p=Math.cos(u),d=.6*a,f=.7*a;t.moveTo(n-h,l+s),t.arc(n,l,a,Math.PI-u,2*Math.PI+u),t.bezierCurveTo(n+h-c*d,l+s+p*d,n,i-f,n,i),t.bezierCurveTo(n,i-f,n-h+c*d,l+s+p*d,n-h,l+s),t.closePath()}}),tv=ys.extend({type:"arrow",shape:{x:0,y:0,width:0,height:0},buildPath:function(t,e){var n=e.height,i=e.width,r=e.x,o=e.y,a=i/3*2;t.moveTo(r,o),t.lineTo(r+a,o+n),t.lineTo(r,o+n/4*3),t.lineTo(r-a,o+n),t.lineTo(r,o),t.closePath()}}),ev={line:function(t,e,n,i,r){r.x1=t,r.y1=e+i/2,r.x2=t+n,r.y2=e+i/2},rect:function(t,e,n,i,r){r.x=t,r.y=e,r.width=n,r.height=i},roundRect:function(t,e,n,i,r){r.x=t,r.y=e,r.width=n,r.height=i,r.r=Math.min(n,i)/4},square:function(t,e,n,i,r){var o=Math.min(n,i);r.x=t,r.y=e,r.width=o,r.height=o},circle:function(t,e,n,i,r){// Put circle in the center of square
r.cx=t+n/2,r.cy=e+i/2,r.r=Math.min(n,i)/2},diamond:function(t,e,n,i,r){r.cx=t+n/2,r.cy=e+i/2,r.width=n,r.height=i},pin:function(t,e,n,i,r){r.x=t+n/2,r.y=e+i/2,r.width=n,r.height=i},arrow:function(t,e,n,i,r){r.x=t+n/2,r.y=e+i/2,r.width=n,r.height=i},triangle:function(t,e,n,i,r){r.cx=t+n/2,r.cy=e+i/2,r.width=n,r.height=i}},nv={};
/**
             * Diamond shape
             * @inner
             */R({line:qu,rect:Ls,roundRect:Ls,square:Ls,circle:yu,diamond:Jy,pin:Qy,arrow:tv,triangle:$y},(function(t,e){nv[e]=new t}));var iv=ys.extend({type:"symbol",shape:{symbolType:"",x:0,y:0,width:0,height:0},calculateTextPosition:function(t,e,n){var i=mr(t,e,n),r=this.shape;return r&&"pin"===r.symbolType&&"inside"===e.position&&(i.y=n.y+.4*n.height),i},buildPath:function(t,e,n){var i=e.symbolType;if("none"!==i){var r=nv[i];r||(r=nv[// Default rect
i="rect"]),ev[i](e.x,e.y,e.width,e.height,r.shape),r.buildPath(t,r.shape,n)}}});// Provide setColor helper method to avoid determine if set the fill or stroke outside
function rv(t,e){if("image"!==this.type){var n=this.style;this.__isEmptyBrush?(n.stroke=t,n.fill=e||"#fff",// TODO Same width with lineStyle in LineView
n.lineWidth=2):"line"===this.shape.symbolType?n.stroke=t:n.fill=t,this.markRedraw()}}
/**
             * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
             */function ov(t,e,n,i,r,o,// whether to keep the ratio of w/h,
a){// TODO Support image object, DynamicImage.
var s,l=0===t.indexOf("empty");return l&&(t=t.substr(5,1).toLowerCase()+t.substr(6)),(s=0===t.indexOf("image://")?zh(t.slice(8),new Ce(e,n,i,r),a?"center":"cover"):0===t.indexOf("path://")?Eh(t.slice(7),{},new Ce(e,n,i,r),a?"center":"cover"):new iv({shape:{symbolType:t,x:e,y:n,width:i,height:r}})).__isEmptyBrush=l,// TODO Should deprecate setColor
s.setColor=rv,o&&s.setColor(o),s}function av(t){return G(t)||(t=[+t,+t]),[t[0]||0,t[1]||0]}function sv(t,e){if(null!=t)return G(t)||(t=[t,t]),[Vr(t[0],e[0])||0,Vr(Q(t[1],t[0]),e[1])||0]}function lv(t){return isFinite(t)}function uv(t,e,n){for(var i="radial"===e.type?function(t,e,n){var i=n.width,r=n.height,o=Math.min(i,r),a=null==e.x?.5:e.x,s=null==e.y?.5:e.y,l=null==e.r?.5:e.r;return e.global||(a=a*i+n.x,s=s*r+n.y,l*=o),a=lv(a)?a:.5,s=lv(s)?s:.5,l=l>=0&&lv(l)?l:.5,t.createRadialGradient(a,s,0,a,s,l)}(t,e,n):function(t,e,n){var i=null==e.x?0:e.x,r=null==e.x2?1:e.x2,o=null==e.y?0:e.y,a=null==e.y2?0:e.y2;return e.global||(i=i*n.width+n.x,r=r*n.width+n.x,o=o*n.height+n.y,a=a*n.height+n.y),i=lv(i)?i:0,r=lv(r)?r:1,o=lv(o)?o:0,a=lv(a)?a:0,t.createLinearGradient(i,o,r,a)}(t,e,n),r=e.colorStops,o=0;o<r.length;o++)i.addColorStop(r[o].offset,r[o].color);return i}function hv(t){return parseInt(t,10)}function cv(t,e,n){var i=["width","height"][e],r=["clientWidth","clientHeight"][e],o=["paddingLeft","paddingTop"][e],a=["paddingRight","paddingBottom"][e];if(null!=n[i]&&"auto"!==n[i])return parseFloat(n[i]);var s=document.defaultView.getComputedStyle(t);return(t[r]||hv(s[i])||hv(t.style[i]))-(hv(s[o])||0)-(hv(s[a])||0)|0}function pv(t){var e,n,i=t.style,r=i.lineDash&&i.lineWidth>0&&(e=i.lineDash,n=i.lineWidth,e&&"solid"!==e&&n>0?"dashed"===e?[4*n,2*n]:"dotted"===e?[n]:X(e)?[e]:G(e)?e:null:null),o=i.lineDashOffset;if(r){var a=i.strokeNoScale&&t.getLineScale?t.getLineScale():1;a&&1!==a&&(r=N(r,(function(t){return t/a})),o/=a)}return[r,o]}var dv=new qa(!0);function fv(t){var e=t.stroke;return!(null==e||"none"===e||!(t.lineWidth>0))}function gv(t){return"string"==typeof t&&"none"!==t}function yv(t){var e=t.fill;return null!=e&&"none"!==e}function vv(t,e){if(null!=e.fillOpacity&&1!==e.fillOpacity){var n=t.globalAlpha;t.globalAlpha=e.fillOpacity*e.opacity,t.fill(),t.globalAlpha=n}else t.fill()}function mv(t,e){if(null!=e.strokeOpacity&&1!==e.strokeOpacity){var n=t.globalAlpha;t.globalAlpha=e.strokeOpacity*e.opacity,t.stroke(),t.globalAlpha=n}else t.stroke()}function xv(t,e,n){var i=Xo(e.image,e.__image,n);if(Zo(i)){var r=t.createPattern(i,e.repeat||"repeat");if("function"==typeof DOMMatrix&&r&&r.setTransform){var o=new DOMMatrix;o.translateSelf(e.x||0,e.y||0),o.rotateSelf(0,0,(e.rotation||0)*vt),o.scaleSelf(e.scaleX||1,e.scaleY||1),r.setTransform(o)}return r}}var _v=["shadowBlur","shadowOffsetX","shadowOffsetY"],bv=[["lineCap","butt"],["lineJoin","miter"],["miterLimit",10]];function wv(t,e,n,i,r){var o=!1;if(!i&&e===(n=n||{}))return!1;if(i||e.opacity!==n.opacity){Iv(t,r),o=!0;var a=Math.max(Math.min(e.opacity,1),0);t.globalAlpha=isNaN(a)?sa.opacity:a}(i||e.blend!==n.blend)&&(o||(Iv(t,r),o=!0),t.globalCompositeOperation=e.blend||sa.blend);for(var s=0;s<_v.length;s++){var l=_v[s];(i||e[l]!==n[l])&&(o||(Iv(t,r),o=!0),t[l]=t.dpr*(e[l]||0))}return(i||e.shadowColor!==n.shadowColor)&&(o||(Iv(t,r),o=!0),t.shadowColor=e.shadowColor||sa.shadowColor),o}function Sv(t,e,n,i,r){var o=Tv(e,r.inHover),a=i?null:n&&Tv(n,r.inHover)||{};if(o===a)return!1;var s=wv(t,o,a,i,r);if((i||o.fill!==a.fill)&&(s||(Iv(t,r),s=!0),gv(o.fill)&&(t.fillStyle=o.fill)),(i||o.stroke!==a.stroke)&&(s||(Iv(t,r),s=!0),gv(o.stroke)&&(t.strokeStyle=o.stroke)),(i||o.opacity!==a.opacity)&&(s||(Iv(t,r),s=!0),t.globalAlpha=null==o.opacity?1:o.opacity),e.hasStroke()){var l=o.lineWidth/(o.strokeNoScale&&e.getLineScale?e.getLineScale():1);t.lineWidth!==l&&(s||(Iv(t,r),s=!0),t.lineWidth=l)}for(var u=0;u<bv.length;u++){var h=bv[u],c=h[0];(i||o[c]!==a[c])&&(s||(Iv(t,r),s=!0),t[c]=o[c]||h[1])}return s}function Mv(t,e){var n=e.transform,i=t.dpr||1;n?t.setTransform(i*n[0],i*n[1],i*n[2],i*n[3],i*n[4],i*n[5]):t.setTransform(i,0,0,i,0,0)}function Iv(t,e){e.batchFill&&t.fill(),e.batchStroke&&t.stroke(),e.batchFill="",e.batchStroke=""}function Tv(t,e){return e&&t.__hoverStyle||t.style}function Cv(t,e){Dv(t,e,{inHover:!1,viewWidth:0,viewHeight:0},!0)}function Dv(t,e,n,i){var r=e.transform;if(!e.shouldBePainted(n.viewWidth,n.viewHeight,!1,!1))return e.__dirty&=-2,void(e.__isRendered=!1);var o=e.__clipPaths,a=n.prevElClipPaths,s=!1,l=!1;if(a&&!function(t,e){if(t===e||!t&&!e)return!1;if(!t||!e||t.length!==e.length)return!0;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!0;return!1}(o,a)||(a&&a.length&&(Iv(t,n),t.restore(),l=s=!0,n.prevElClipPaths=null,n.allClipped=!1,n.prevEl=null),o&&o.length&&(Iv(t,n),t.save(),function(t,e,n){for(var i=!1,r=0;r<t.length;r++){var o=t[r];i=i||o.isZeroArea(),Mv(e,o),e.beginPath(),o.buildPath(e,o.shape),e.clip()}n.allClipped=i}(o,t,n),s=!0),n.prevElClipPaths=o),n.allClipped)e.__isRendered=!1;else{e.beforeBrush&&e.beforeBrush(),e.innerBeforeBrush();var h=n.prevEl;h||(l=s=!0);var c,p,d=e instanceof ys&&e.autoBatch&&function(t){var e=yv(t),n=fv(t);return!(t.lineDash||!(+e^+n)||e&&"string"!=typeof t.fill||n&&"string"!=typeof t.stroke||t.strokePercent<1||t.strokeOpacity<1||t.fillOpacity<1)}(e.style);s||(c=r,p=h.transform,c&&p?c[0]!==p[0]||c[1]!==p[1]||c[2]!==p[2]||c[3]!==p[3]||c[4]!==p[4]||c[5]!==p[5]:c||p)?(Iv(t,n),Mv(t,e)):d||Iv(t,n);var f=Tv(e,n.inHover);e instanceof ys?(1!==n.lastDrawType&&(l=!0,n.lastDrawType=1),Sv(t,e,h,l,n),d&&(n.batchFill||n.batchStroke)||t.beginPath(),function(t,e,n,i){var r,o=fv(n),a=yv(n),s=n.strokePercent,l=s<1,u=!e.path;e.silent&&!l||!u||e.createPathProxy();var h=e.path||dv,c=e.__dirty;if(!i){var p=n.fill,d=n.stroke,f=a&&!!p.colorStops,g=o&&!!d.colorStops,y=a&&!!p.image,v=o&&!!d.image,m=void 0,x=void 0,_=void 0,b=void 0,w=void 0;(f||g)&&(w=e.getBoundingRect()),f&&(m=c?uv(t,p,w):e.__canvasFillGradient,e.__canvasFillGradient=m),g&&(x=c?uv(t,d,w):e.__canvasStrokeGradient,e.__canvasStrokeGradient=x),y&&(_=c||!e.__canvasFillPattern?xv(t,p,e):e.__canvasFillPattern,e.__canvasFillPattern=_),v&&(b=c||!e.__canvasStrokePattern?xv(t,d,e):e.__canvasStrokePattern,e.__canvasStrokePattern=_),f?t.fillStyle=m:y&&(_?t.fillStyle=_:a=!1),g?t.strokeStyle=x:v&&(b?t.strokeStyle=b:o=!1)}var S,M,I=e.getGlobalScale();h.setScale(I[0],I[1],e.segmentIgnoreThreshold),t.setLineDash&&n.lineDash&&(S=(r=pv(e))[0],M=r[1]);var T=!0;(u||4&c)&&(h.setDPR(t.dpr),l?h.setContext(null):(h.setContext(t),T=!1),h.reset(),e.buildPath(h,e.shape,i),h.toStatic(),e.pathUpdated()),T&&h.rebuildPath(t,l?s:1),S&&(t.setLineDash(S),t.lineDashOffset=M),i||(n.strokeFirst?(o&&mv(t,n),a&&vv(t,n)):(a&&vv(t,n),o&&mv(t,n))),S&&t.setLineDash([])}(t,e,f,d),d&&(n.batchFill=f.fill||"",n.batchStroke=f.stroke||"")):e instanceof xs?(3!==n.lastDrawType&&(l=!0,n.lastDrawType=3),Sv(t,e,h,l,n),function(t,e,n){var i,r=n.text;if(null!=r&&(r+=""),r){t.font=n.font||u,t.textAlign=n.textAlign,t.textBaseline=n.textBaseline;var o=void 0,a=void 0;t.setLineDash&&n.lineDash&&(o=(i=pv(e))[0],a=i[1]),o&&(t.setLineDash(o),t.lineDashOffset=a),n.strokeFirst?(fv(n)&&t.strokeText(r,n.x,n.y),yv(n)&&t.fillText(r,n.x,n.y)):(yv(n)&&t.fillText(r,n.x,n.y),fv(n)&&t.strokeText(r,n.x,n.y)),o&&t.setLineDash([])}}(t,e,f)):e instanceof Ss?(2!==n.lastDrawType&&(l=!0,n.lastDrawType=2),function(t,e,n,i,r){wv(t,Tv(e,r.inHover),n&&Tv(n,r.inHover),i,r)}(t,e,h,l,n),function(t,e,n){var i=e.__image=Xo(n.image,e.__image,e,e.onload);if(i&&Zo(i)){var r=n.x||0,o=n.y||0,a=e.getWidth(),s=e.getHeight(),l=i.width/i.height;if(null==a&&null!=s?a=s*l:null==s&&null!=a?s=a/l:null==a&&null==s&&(a=i.width,s=i.height),n.sWidth&&n.sHeight){var u=n.sx||0,h=n.sy||0;t.drawImage(i,u,h,n.sWidth,n.sHeight,r,o,a,s)}else if(n.sx&&n.sy){var c=a-(u=n.sx),p=s-(h=n.sy);t.drawImage(i,u,h,c,p,r,o,a,s)}else t.drawImage(i,r,o,a,s)}}(t,e,f)):e.getTemporalDisplayables&&(4!==n.lastDrawType&&(l=!0,n.lastDrawType=4),function(t,e,n){var i=e.getDisplayables(),r=e.getTemporalDisplayables();t.save();var o,a,s={prevElClipPaths:null,prevEl:null,allClipped:!1,viewWidth:n.viewWidth,viewHeight:n.viewHeight,inHover:n.inHover};for(o=e.getCursor(),a=i.length;o<a;o++)(h=i[o]).beforeBrush&&h.beforeBrush(),h.innerBeforeBrush(),Dv(t,h,s,o===a-1),h.innerAfterBrush(),h.afterBrush&&h.afterBrush(),s.prevEl=h;for(var l=0,u=r.length;l<u;l++){var h;(h=r[l]).beforeBrush&&h.beforeBrush(),h.innerBeforeBrush(),Dv(t,h,s,l===u-1),h.innerAfterBrush(),h.afterBrush&&h.afterBrush(),s.prevEl=h}e.clearTemporalDisplayables(),e.notClear=!0,t.restore()}(t,e,n)),d&&i&&Iv(t,n),e.innerAfterBrush(),e.afterBrush&&e.afterBrush(),n.prevEl=e,e.__dirty=0,e.__isRendered=!0}}var Av=new Ky,kv=new kn(100),Lv=["symbol","symbolSize","symbolKeepAspect","color","backgroundColor","dashArrayX","dashArrayY","maxTileWidth","maxTileHeight"];
/**
             * Create or update pattern image from decal options
             *
             * @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal
             * @return {Pattern} pattern with generated image, null if no decal
             */
function Pv(t,e){if("none"===t)return null;var n=e.getDevicePixelRatio(),i=e.getZr(),r="svg"===i.painter.type;t.dirty&&Av.delete(t);var o=Av.get(t);if(o)return o;var a=k(t,{symbol:"rect",symbolSize:1,symbolKeepAspect:!0,color:"rgba(0, 0, 0, 0.2)",backgroundColor:null,dashArrayX:5,dashArrayY:5,rotation:0,maxTileWidth:512,maxTileHeight:512});"none"===a.backgroundColor&&(a.backgroundColor=null);var s={repeat:"repeat"};return function(t){for(var e,o=[n],s=!0,l=0;l<Lv.length;++l){var u=a[Lv[l]];if(null!=u&&!G(u)&&!H(u)&&!X(u)&&"boolean"!=typeof u){s=!1;break}o.push(u)}if(s){e=o.join(",")+(r?"-svg":"");var h=kv.get(e);h&&(r?t.svgElement=h:t.image=h)}var p,d=Rv(a.dashArrayX),f=
/**
             * Convert dash input into dashArray
             *
             * @param {DecalDashArrayY} dash dash input
             * @return {number[]} normolized dash array
             */
function(t){if(!t||"object"==typeof t&&0===t.length)return[0,0];if(X(t)){var e=Math.ceil(t);return[e,e]}var n=N(t,(function(t){return Math.ceil(t)}));return t.length%2?n.concat(n):n}
/**
             * Get block length of each line. A block is the length of dash line and space.
             * For example, a line with [4, 1] has a dash line of 4 and a space of 1 after
             * that, so the block length of this line is 5.
             *
             * @param {number[][]} dash dash array of X or Y
             * @return {number[]} block length of each line
             */(a.dashArrayY),g=Ov(a.symbol),y=N(d,(function(t){return Nv(t)})),v=Nv(f),m=!r&&c.createCanvas(),x=r&&{tag:"g",attrs:{},key:"dcl",children:[]},_=
/**
                 * Get minimum length that can make a repeatable pattern.
                 *
                 * @return {Object} pattern width and height
                 */
function(){for(
/**
                   * For example, if dash is [[3, 2], [2, 1]] for X, it looks like
                   * |---  ---  ---  ---  --- ...
                   * |-- -- -- -- -- -- -- -- ...
                   * |---  ---  ---  ---  --- ...
                   * |-- -- -- -- -- -- -- -- ...
                   * So the minimum length of X is 15,
                   * which is the least common multiple of `3 + 2` and `2 + 1`
                   * |---  ---  ---  |---  --- ...
                   * |-- -- -- -- -- |-- -- -- ...
                   */
var t=1,e=0,n=y.length;e<n;++e)t=io(t,y[e]);var i=1;for(e=0,n=g.length;e<n;++e)i=io(i,g[e].length);t*=i;var r=v*y.length*g.length;return{width:Math.max(1,Math.min(t,a.maxTileWidth)),height:Math.max(1,Math.min(r,a.maxTileHeight))}}();m&&(m.width=_.width*n,m.height=_.height*n,p=m.getContext("2d")),function(){p&&(p.clearRect(0,0,m.width,m.height),a.backgroundColor&&(p.fillStyle=a.backgroundColor,p.fillRect(0,0,m.width,m.height)));for(var t=0,e=0;e<f.length;++e)t+=f[e];if(!(t<=0))for(var o=-v,s=0,l=0,u=0;o<_.height;){if(s%2==0){for(var h=l/2%g.length,c=0,y=0,b=0;c<2*_.width;){var w=0;for(e=0;e<d[u].length;++e)w+=d[u][e];if(w<=0)// Skip empty line
break;// E.g., [15, 5, 20, 5] draws only for 15 and 20
if(y%2==0){var S=.5*(1-a.symbolSize),M=c+d[u][y]*S,I=o+f[s]*S,T=d[u][y]*a.symbolSize,C=f[s]*a.symbolSize,D=b/2%g[h].length;A(M,I,T,C,g[h][D])}c+=d[u][y],++b,++y===d[u].length&&(y=0)}++u===d.length&&(u=0)}o+=f[s],++l,++s===f.length&&(s=0)}function A(t,e,o,s,l){var u=r?1:n,h=ov(l,t*u,e*u,o*u,s*u,a.color,a.symbolKeepAspect);if(r){var c=i.painter.renderOneToVNode(h);c&&x.children.push(c)}else// Paint to canvas for all other renderers.
Cv(p,h)}}(),s&&kv.put(e,m||x),t.image=m,t.svgElement=x,t.svgWidth=_.width,t.svgHeight=_.height}(s),s.rotation=a.rotation,s.scaleX=s.scaleY=r?1:1/n,Av.set(t,s),t.dirty=!1,s}
/**
             * Convert symbol array into normalized array
             *
             * @param {string | (string | string[])[]} symbol symbol input
             * @return {string[][]} normolized symbol array
             */function Ov(t){if(!t||0===t.length)return[["rect"]];if(H(t))return[[t]];for(var e=!0,n=0;n<t.length;++n)if(!H(t[n])){e=!1;break}if(e)return Ov([t]);var i=[];for(n=0;n<t.length;++n)H(t[n])?i.push([t[n]]):i.push(t[n]);return i}
/**
             * Convert dash input into dashArray
             *
             * @param {DecalDashArrayX} dash dash input
             * @return {number[][]} normolized dash array
             */function Rv(t){if(!t||0===t.length)return[[0,0]];if(X(t))return[[r=Math.ceil(t),r]];
/**
               * [20, 5] should be normalized into [[20, 5]],
               * while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]
               */for(var e=!0,n=0;n<t.length;++n)if(!X(t[n])){e=!1;break}if(e)return Rv([t]);var i=[];for(n=0;n<t.length;++n)if(X(t[n])){var r=Math.ceil(t[n]);i.push([r,r])}else(r=N(t[n],(function(t){return Math.ceil(t)}))).length%2==1?// [4, 2, 1] means |----  -    -- |----  -    -- |
// so normalize it to be [4, 2, 1, 4, 2, 1]
i.push(r.concat(r)):i.push(r);return i}function Nv(t){for(var e=0,n=0;n<t.length;++n)e+=t[n];return t.length%2==1?2*e:e}const Ev=new Bt;// The implementations will be registered when installing the component.
// Avoid these code being bundled to the core module.
var zv={},Vv=2e3,Bv=4500,Fv={PROCESSOR:{FILTER:1e3,SERIES_FILTER:800,STATISTIC:5e3},VISUAL:{LAYOUT:1e3,PROGRESSIVE_LAYOUT:1100,GLOBAL:Vv,CHART:3e3,POST_CHART_LAYOUT:4600,COMPONENT:4e3,BRUSH:5e3,CHART_ITEM:Bv,ARIA:6e3,DECAL:7e3}},Gv="__flagInMainProcess",Wv="__pendingUpdate",Hv="__needsUpdateStatus",Yv=/^[a-zA-Z0-9_]+$/,Xv="__connectUpdateStatus";// TODO Type
function Uv(t){return function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];if(!this.isDisposed())return jv(this,t,e);this.id}}function Zv(t){return function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];return jv(this,t,e)}}function jv(t,e,n){// `args[0]` is event name. Event name is all lowercase.
return n[0]=n[0]&&n[0].toLowerCase(),Bt.prototype[e].apply(t,n)}var qv,Kv,$v,Jv,Qv,tm,em,nm,im,rm,om,am,sm,lm,um,hm,cm,pm,dm=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e}(Bt),fm=dm.prototype;fm.on=Zv("on"),fm.off=Zv("off");var gm=/** @class */function(t){function e(e,// Theme name or themeOption.
n,i){var r=t.call(this,new Ey)||this;r._chartsViews=[],r._chartsMap={},r._componentsViews=[],r._componentsMap={},// Can't dispatch action during rendering procedure
r._pendingActions=[],i=i||{},// Get theme by name
H(n)&&(n=Sm[n]),r._dom=e;var o=r._zr=Nr(e,{renderer:i.renderer||"canvas",devicePixelRatio:i.devicePixelRatio,width:i.width,height:i.height,ssr:i.ssr,useDirtyRect:Q(i.useDirtyRect,!1),useCoarsePointer:Q(i.useCoarsePointer,"auto"),pointerSize:i.pointerSize});r._ssr=i.ssr,// Expect 60 fps.
r._throttledZrFlush=Qg(B(o.flush,o),17),(n=T(n))&&Qd(n,!0),r._theme=n,r._locale=function(t){if(H(t)){var e=Bc[t.toUpperCase()]||{};return t===Ec||t===zc?T(e):C(T(e),T(Bc[Vc]),!1)}return C(T(t),T(Bc[Vc]),!1)}(i.locale||Gc),r._coordSysMgr=new Ad;var a=r._api=um(r);// Sort on demand
function s(t,e){return t.__prio-e.__prio}return Ye(wm,s),Ye(_m,s),r._scheduler=new Cy(r,a,_m,wm),r._messageCenter=new dm,// Init mouse events
r._initEvents(),// In case some people write `window.onresize = chart.resize`
r.resize=B(r.resize,r),o.animation.on("frame",r._onframe,r),rm(o,r),om(o,r),// ECharts instance can be used as value.
at(r),r}return n(e,t),e.prototype._onframe=function(){if(!this._disposed){pm(this);var t=this._scheduler;// Lazy update
if(this[Wv]){var e=this[Wv].silent;this[Gv]=!0;try{qv(this),Jv.update.call(this,null,this[Wv].updateParams)}catch(ku){throw this[Gv]=!1,this[Wv]=null,ku}// At present, in each frame, zrender performs:
//   (1) animation step forward.
//   (2) trigger('frame') (where this `_onframe` is called)
//   (3) zrender flush (render).
// If we do nothing here, since we use `setToFinal: true`, the step (3) above
// will render the final state of the elements before the real animation started.
this._zr.flush(),this[Gv]=!1,this[Wv]=null,nm.call(this,e),im.call(this,e)}// Avoid do both lazy update and progress in one frame.
else if(t.unfinished){// Stream progress.
var n=1,i=this._model,r=this._api;t.unfinished=!1;do{var o=+new Date;t.performSeriesTasks(i),// Currently dataProcessorFuncs do not check threshold.
t.performDataProcessorTasks(i),tm(this,i),// Do not update coordinate system here. Because that coord system update in
// each frame is not a good user experience. So we follow the rule that
// the extent of the coordinate system is determined in the first frame (the
// frame is executed immediately after task reset.
// this._coordSysMgr.update(ecModel, api);
// console.log('--- ec frame visual ---', remainTime);
t.performVisualTasks(i),lm(this,this._model,r,"remain",{}),n-=+new Date-o}while(n>0&&t.unfinished);// Call flush explicitly for trigger finished event.
t.unfinished||this._zr.flush();// Else, zr flushing be ensue within the same frame,
// because zr flushing is after onframe event.
}}},e.prototype.getDom=function(){return this._dom},e.prototype.getId=function(){return this.id},e.prototype.getZr=function(){return this._zr},e.prototype.isSSR=function(){return this._ssr},/* eslint-disable-next-line */e.prototype.setOption=function(t,e,n){if(!this[Gv])if(this._disposed)this.id;else{var i,r,o;if(U(e)&&(n=e.lazyUpdate,i=e.silent,r=e.replaceMerge,o=e.transition,e=e.notMerge),this[Gv]=!0,!this._model||e){var a=new Od(this._api),s=this._theme,l=this._model=new Md;l.scheduler=this._scheduler,l.ssr=this._ssr,l.init(null,null,null,s,this._locale,a)}this._model.setOption(t,{replaceMerge:r},bm);var u={seriesTransition:o,optionChanged:!0};if(n)this[Wv]={silent:i,updateParams:u},this[Gv]=!1,// `setOption(option, {lazyMode: true})` may be called when zrender has been slept.
// It should wake it up to make sure zrender start to render at the next frame.
this.getZr().wakeUp();else{try{qv(this),Jv.update.call(this,null,u)}catch(ku){throw this[Wv]=null,this[Gv]=!1,ku}// Ensure zr refresh sychronously, and then pixel in canvas can be
// fetched after `setOption`.
this._ssr||// not use flush when using ssr mode.
this._zr.flush(),this[Wv]=null,this[Gv]=!1,nm.call(this,i),im.call(this,i)}}},
/**
               * @deprecated
               */
e.prototype.setTheme=function(){},// We don't want developers to use getModel directly.
e.prototype.getModel=function(){return this._model},e.prototype.getOption=function(){return this._model&&this._model.getOption()},e.prototype.getWidth=function(){return this._zr.getWidth()},e.prototype.getHeight=function(){return this._zr.getHeight()},e.prototype.getDevicePixelRatio=function(){return this._zr.painter.dpr/* eslint-disable-next-line */||o.hasGlobalWindow&&window.devicePixelRatio||1},
/**
               * Get canvas which has all thing rendered
               * @deprecated Use renderToCanvas instead.
               */
e.prototype.getRenderedCanvas=function(t){return this.renderToCanvas(t)},e.prototype.renderToCanvas=function(t){return t=t||{},this._zr.painter.getRenderedCanvas({backgroundColor:t.backgroundColor||this._model.get("backgroundColor"),pixelRatio:t.pixelRatio||this.getDevicePixelRatio()})},e.prototype.renderToSVGString=function(t){return t=t||{},this._zr.painter.renderToString({useViewBox:t.useViewBox})},
/**
               * Get svg data url
               */
e.prototype.getSvgDataURL=function(){if(o.svgSupported){var t=this._zr;// Stop animations
return R(t.storage.getDisplayList(),(function(t){t.stopAnimation(null,!0)})),t.painter.toDataURL()}},e.prototype.getDataURL=function(t){if(!this._disposed){var e=(t=t||{}).excludeComponents,n=this._model,i=[],r=this;R(e,(function(t){n.eachComponent({mainType:t},(function(t){var e=r._componentsMap[t.__viewId];e.group.ignore||(i.push(e),e.group.ignore=!0)}))}));var o="svg"===this._zr.painter.getType()?this.getSvgDataURL():this.renderToCanvas(t).toDataURL("image/"+(t&&t.type||"png"));return R(i,(function(t){t.group.ignore=!1})),o}this.id},e.prototype.getConnectedDataURL=function(t){if(!this._disposed){var e="svg"===t.type,n=this.group,i=Math.min,r=Math.max,o=1/0;if(Tm[n]){var a=o,s=o,l=-1/0,u=-1/0,h=[],p=t&&t.pixelRatio||this.getDevicePixelRatio();R(Im,(function(o,c){if(o.group===n){var p=e?o.getZr().painter.getSvgDom().innerHTML:o.renderToCanvas(T(t)),d=o.getDom().getBoundingClientRect();a=i(d.left,a),s=i(d.top,s),l=r(d.right,l),u=r(d.bottom,u),h.push({dom:p,left:d.left,top:d.top})}}));var d=(l*=p)-(a*=p),f=(u*=p)-(s*=p),g=c.createCanvas(),y=Nr(g,{renderer:e?"svg":"canvas"});if(y.resize({width:d,height:f}),e){var v="";return R(h,(function(t){var e=t.left-a,n=t.top-s;v+='<g transform="translate('+e+","+n+')">'+t.dom+"</g>"})),y.painter.getSvgRoot().innerHTML=v,t.connectedBackgroundColor&&y.painter.setBackgroundColor(t.connectedBackgroundColor),y.refreshImmediately(),y.painter.toDataURL()}// Background between the charts
return t.connectedBackgroundColor&&y.add(new Ls({shape:{x:0,y:0,width:d,height:f},style:{fill:t.connectedBackgroundColor}})),R(h,(function(t){var e=new Ss({style:{x:t.left*p-a,y:t.top*p-s,image:t.dom}});y.add(e)})),y.refreshImmediately(),g.toDataURL("image/"+(t&&t.type||"png"))}return this.getDataURL(t)}this.id},e.prototype.convertToPixel=function(t,e){return Qv(this,"convertToPixel",t,e)},e.prototype.convertFromPixel=function(t,e){return Qv(this,"convertFromPixel",t,e)},
/**
               * Is the specified coordinate systems or components contain the given pixel point.
               * @param {Array|number} value
               * @return {boolean} result
               */
e.prototype.containPixel=function(t,e){var n;if(!this._disposed)return R(So(this._model,t),(function(t,i){i.indexOf("Models")>=0&&R(t,(function(t){var r=t.coordinateSystem;if(r&&r.containPoint)n=n||!!r.containPoint(e);else if("seriesModels"===i){var o=this._chartsMap[t.__viewId];o&&o.containPoint&&(n=n||o.containPoint(e,t))}}),this)}),this),!!n;this.id},
/**
               * Get visual from series or data.
               * @param finder
               *        If string, e.g., 'series', means {seriesIndex: 0}.
               *        If Object, could contain some of these properties below:
               *        {
               *            seriesIndex / seriesId / seriesName,
               *            dataIndex / dataIndexInside
               *        }
               *        If dataIndex is not specified, series visual will be fetched,
               *        but not data item visual.
               *        If all of seriesIndex, seriesId, seriesName are not specified,
               *        visual will be fetched from first series.
               * @param visualType 'color', 'symbol', 'symbolSize'
               */
e.prototype.getVisual=function(t,e){var n=So(this._model,t,{defaultMainType:"series"}),i=n.seriesModel.getData(),r=n.hasOwnProperty("dataIndexInside")?n.dataIndexInside:n.hasOwnProperty("dataIndex")?i.indexOfRawIndex(n.dataIndex):null;return null!=r?Gy(i,r,e):Wy(i,e)},
/**
               * Get view of corresponding component model
               */
e.prototype.getViewOfComponentModel=function(t){return this._componentsMap[t.__viewId]},
/**
               * Get view of corresponding series model
               */
e.prototype.getViewOfSeriesModel=function(t){return this._chartsMap[t.__viewId]},e.prototype._initEvents=function(){var t,e,n,i=this;R(vm,(function(t){var e=function(e){var n,r=i.getModel(),o=e.target;// Contract: if params prepared in mouse event,
// these properties must be specified:
// {
//    componentType: string (component main type)
//    componentIndex: number
// }
// Otherwise event query can not work.
if(// no e.target when 'globalout'.
"globalout"===t?n={}:o&&Uy(o,(function(t){var e=js(t);if(e&&null!=e.dataIndex){var i=e.dataModel||r.getSeriesByIndex(e.seriesIndex);return n=i&&i.getDataParams(e.dataIndex,e.dataType)||{},!0}// If element has custom eventData of components
if(e.eventData)return n=A({},e.eventData),!0}),!0),n){var a=n.componentType,s=n.componentIndex;// Special handling for historic reason: when trigger by
// markLine/markPoint/markArea, the componentType is
// 'markLine'/'markPoint'/'markArea', but we should better
// enable them to be queried by seriesIndex, since their
// option is set in each series.
"markLine"!==a&&"markPoint"!==a&&"markArea"!==a||(a="series",s=n.seriesIndex);var l=a&&null!=s&&r.getComponent(a,s),u=l&&i["series"===l.mainType?"_chartsMap":"_componentsMap"][l.__viewId];n.event=e,n.type=t,i._$eventProcessor.eventInfo={targetEl:o,packedEvent:n,model:l,view:u},i.trigger(t,n)}};// Consider that some component (like tooltip, brush, ...)
// register zr event handler, but user event handler might
// do anything, such as call `setOption` or `dispatchAction`,
// which probably update any of the content and probably
// cause problem if it is called previous other inner handlers.
e.zrEventfulCallAtLast=!0,i._zr.on(t,e,i)})),R(xm,(function(t,e){i._messageCenter.on(e,(function(t){this.trigger(e,t)}),i)})),// Extra events
// TODO register?
R(["selectchanged"],(function(t){i._messageCenter.on(t,(function(e){this.trigger(t,e)}),i)})),t=this._messageCenter,e=this,n=this._api,t.on("selectchanged",(function(t){var i=n.getModel();t.isFromClick?(Xy("map","selectchanged",e,i,t),Xy("pie","selectchanged",e,i,t)):"select"===t.fromAction?(Xy("map","selected",e,i,t),Xy("pie","selected",e,i,t)):"unselect"===t.fromAction&&(Xy("map","unselected",e,i,t),Xy("pie","unselected",e,i,t))}))},e.prototype.isDisposed=function(){return this._disposed},e.prototype.clear=function(){this._disposed?this.id:this.setOption({series:[]},!0)},e.prototype.dispose=function(){if(this._disposed)this.id;else{this._disposed=!0,this.getDom()&&Do(this.getDom(),Dm,"");var t=this,e=t._api,n=t._model;R(t._componentsViews,(function(t){t.dispose(n,e)})),R(t._chartsViews,(function(t){t.dispose(n,e)})),// Dispose after all views disposed
t._zr.dispose(),// Set properties to null.
// To reduce the memory cost in case the top code still holds this instance unexpectedly.
t._dom=t._model=t._chartsMap=t._componentsMap=t._chartsViews=t._componentsViews=t._scheduler=t._api=t._zr=t._throttledZrFlush=t._theme=t._coordSysMgr=t._messageCenter=null,delete Im[t.id]}},
/**
               * Resize the chart
               */
e.prototype.resize=function(t){if(!this[Gv])if(this._disposed)this.id;else{this._zr.resize(t);var e=this._model;// Resize loading effect
if(this._loadingFX&&this._loadingFX.resize(),e){var n=e.resetOption("media"),i=t&&t.silent;// There is some real cases that:
// chart.setOption(option, { lazyUpdate: true });
// chart.resize();
this[Wv]&&(null==i&&(i=this[Wv].silent),n=!0,this[Wv]=null),this[Gv]=!0;try{n&&qv(this),Jv.update.call(this,{type:"resize",animation:A({// Disable animation
duration:0},t&&t.animation)})}catch(ku){throw this[Gv]=!1,ku}this[Gv]=!1,nm.call(this,i),im.call(this,i)}}},e.prototype.showLoading=function(t,e){if(this._disposed)this.id;else if(U(t)&&(e=t,t=""),t=t||"default",this.hideLoading(),Mm[t]){var n=Mm[t](this._api,e),i=this._zr;this._loadingFX=n,i.add(n)}},
/**
               * Hide loading effect
               */
e.prototype.hideLoading=function(){this._disposed?this.id:(this._loadingFX&&this._zr.remove(this._loadingFX),this._loadingFX=null)},e.prototype.makeActionFromEvent=function(t){var e=A({},t);return e.type=xm[t.type],e},
/**
               * @param opt If pass boolean, means opt.silent
               * @param opt.silent Default `false`. Whether trigger events.
               * @param opt.flush Default `undefined`.
               *        true: Flush immediately, and then pixel in canvas can be fetched
               *            immediately. Caution: it might affect performance.
               *        false: Not flush.
               *        undefined: Auto decide whether perform flush.
               */
e.prototype.dispatchAction=function(t,e){if(this._disposed)this.id;else if(U(e)||(e={silent:!!e}),mm[t.type]&&this._model)// May dispatchAction in rendering procedure
if(this[Gv])this._pendingActions.push(t);else{var n=e.silent;em.call(this,t,n);var i=e.flush;i?this._zr.flush():!1!==i&&o.browser.weChat&&// In WeChat embedded browser, `requestAnimationFrame` and `setInterval`
// hang when sliding page (on touch event), which cause that zr does not
// refresh until user interaction finished, which is not expected.
// But `dispatchAction` may be called too frequently when pan on touch
// screen, which impacts performance if do not throttle them.
this._throttledZrFlush(),nm.call(this,n),im.call(this,n)}// Avoid dispatch action before setOption. Especially in `connect`.
},e.prototype.updateLabelLayout=function(){Ev.trigger("series:layoutlabels",this._model,this._api,{// Not adding series labels.
// TODO
updatedSeries:[]})},e.prototype.appendData=function(t){if(this._disposed)this.id;else{var e=t.seriesIndex;this.getModel().getSeriesByIndex(e).appendData(t),// Note: `appendData` does not support that update extent of coordinate
// system, util some scenario require that. In the expected usage of
// `appendData`, the initial extent of coordinate system should better
// be fixed by axis `min`/`max` setting or initial data, otherwise if
// the extent changed while `appendData`, the location of the painted
// graphic elements have to be changed, which make the usage of
// `appendData` meaningless.
this._scheduler.unfinished=!0,this.getZr().wakeUp()}},// A work around for no `internal` modifier in ts yet but
// need to strictly hide private methods to JS users.
e.internalField=function(){function t(t){t.clearColorPalette(),t.eachSeries((function(t){t.clearColorPalette()}))}function e(t){// Keep other states.
for(var e=[],n=t.currentStates,i=0;i<n.length;i++){var r=n[i];"emphasis"!==r&&"blur"!==r&&"select"!==r&&e.push(r)}// Only use states when it's exists.
t.selected&&t.states.select&&e.push("select"),2===t.hoverState&&t.states.emphasis?e.push("emphasis"):1===t.hoverState&&t.states.blur&&e.push("blur"),t.useStates(e)}function i(t,e){if(!t.preventAutoZ){var n=t.get("z")||0,i=t.get("zlevel")||0;// Set z and zlevel
e.eachRendered((function(t){// Don't traverse the children because it has been traversed in _updateZ.
return r(t,n,i,-1/0),!0}))}}function r(t,e,n,i){// Group may also have textContent
var o=t.getTextContent(),a=t.getTextGuideLine();if(t.isGroup)for(// set z & zlevel of children elements of Group
var s=t.childrenRef(),l=0;l<s.length;l++)i=Math.max(r(s[l],e,n,i),i);else// not Group
t.z=e,t.zlevel=n,i=Math.max(t.z2,i);// always set z and zlevel if label/labelLine exists
if(o&&(o.z=e,o.zlevel=n,// lift z2 of text content
// TODO if el.emphasis.z2 is spcefied, what about textContent.
isFinite(i)&&(o.z2=i+2)),a){var u=t.textGuideLineConfig;a.z=e,a.zlevel=n,isFinite(i)&&(a.z2=i+(u&&u.showAbove?1:-1))}return i}// Clear states without animation.
// TODO States on component.
function a(t,e){e.eachRendered((function(t){// Not applied on removed elements, it may still in fading.
if(!Ih(t)){var e=t.getTextContent(),n=t.getTextGuideLine();t.stateTransition&&(t.stateTransition=null),e&&e.stateTransition&&(e.stateTransition=null),n&&n.stateTransition&&(n.stateTransition=null),// TODO If el is incremental.
t.hasState()?(t.prevStates=t.currentStates,t.clearStates()):t.prevStates&&(t.prevStates=null)}}))}function s(t,n){var i=t.getModel("stateAnimation"),r=t.isAnimationEnabled(),o=i.get("duration"),a=o>0?{duration:o,delay:i.get("delay"),easing:i.get("easing")}:null;n.eachRendered((function(t){if(t.states&&t.states.emphasis){// Not applied on removed elements, it may still in fading.
if(Ih(t))return;// Only updated on changed element. In case element is incremental and don't want to rerender.
// TODO, a more proper way?
if(t instanceof ys&&function(t){var e=Js(t);e.normalFill=t.style.fill,e.normalStroke=t.style.stroke;var n=t.states.select||{};e.selectFill=n.style&&n.style.fill||null,e.selectStroke=n.style&&n.style.stroke||null}(t),t.__dirty){var n=t.prevStates;// Restore states without animation
n&&t.useStates(n)}// Update state transition and enable animation again.
if(r){t.stateTransition=a;var i=t.getTextContent(),o=t.getTextGuideLine();// TODO Is it necessary to animate label?
i&&(i.stateTransition=a),o&&(o.stateTransition=a)}// Use highlighted and selected flag to toggle states.
t.__dirty&&e(t)}}))}qv=function(t){var e=t._scheduler;e.restorePipelines(t._model),e.prepareStageTasks(),Kv(t,!0),Kv(t,!1),e.plan()},
/**
                 * Prepare view instances of charts and components
                 */
Kv=function(t,e){for(var n=t._model,i=t._scheduler,r=e?t._componentsViews:t._chartsViews,o=e?t._componentsMap:t._chartsMap,a=t._zr,s=t._api,l=0;l<r.length;l++)r[l].__alive=!1;function u(t){// By default view will be reused if possible for the case that `setOption` with "notMerge"
// mode and need to enable transition animation. (Usually, when they have the same id, or
// especially no id but have the same type & name & index. See the `model.id` generation
// rule in `makeIdAndName` and `viewId` generation rule here).
// But in `replaceMerge` mode, this feature should be able to disabled when it is clear that
// the new model has nothing to do with the old model.
var l=t.__requireNewView;// This command should not work twice.
t.__requireNewView=!1;// Consider: id same and type changed.
var u="_ec_"+t.id+"_"+t.type,h=!l&&o[u];if(!h){var c=Oo(t.type);(h=new(e?Bg.getClass(c.main,c.sub):// FIXME:TS
// (ChartView as ChartViewConstructor).getClass('series', classType.sub)
// For backward compat, still support a chart type declared as only subType
// like "liquidfill", but recommend "series.liquidfill"
// But need a base class to make a type series.
qg.getClass(c.sub))).init(n,s),o[u]=h,r.push(h),a.add(h.group)}t.__viewId=h.__id=u,h.__alive=!0,h.__model=t,h.group.__ecComponentInfo={mainType:t.mainType,index:t.componentIndex},!e&&i.prepareView(h,t,n,s)}for(e?n.eachComponent((function(t,e){"series"!==t&&u(e)})):n.eachSeries(u),l=0;l<r.length;){var h=r[l];h.__alive?l++:(!e&&h.renderTask.dispose(),a.remove(h.group),h.dispose(n,s),r.splice(l,1),o[h.__id]===h&&delete o[h.__id],h.__id=h.group.__ecComponentInfo=null)}},$v=function(t,e,n,i,r){var o=t._model;// broadcast
if(o.setUpdatePayload(n),i){var a={};a[i+"Id"]=n[i+"Id"],a[i+"Index"]=n[i+"Index"],a[i+"Name"]=n[i+"Name"];var s={mainType:i,query:a};r&&(s.subType=r);// subType may be '' by parseClassType;
var l,u=n.excludeSeriesId;null!=u&&(l=ct(),R(lo(u),(function(t){var e=vo(t,null);null!=e&&l.set(e,!0)}))),// If dispatchAction before setOption, do nothing.
o&&o.eachComponent(s,(function(e){if(!l||null==l.get(e.id))if(Zl(n))if(e instanceof zg)n.type!==il||n.notBlur||e.get(["emphasis","disabled"])||function(t,e,n){var i=t.seriesIndex,r=t.getData(e.dataType);if(r){var o=_o(r,e);// Pick the first one if there is multiple/none exists.
o=(G(o)?o[0]:o)||0;var a=r.getItemGraphicEl(o);if(!a)// If data on dataIndex is NaN.
for(var s=r.count(),l=0;!a&&l<s;)a=r.getItemGraphicEl(l++);if(a){var u=js(a);Ol(i,u.focus,u.blurScope,n)}else{// If there is no element put on the data. Try getting it from raw option
// TODO Should put it on seriesModel?
var h=t.get(["emphasis","focus"]),c=t.get(["emphasis","blurScope"]);null!=h&&Ol(i,h,c,n)}}}(e,n,t._api);else{var i=Nl(e.mainType,e.componentIndex,n.name,t._api),r=i.focusSelf,o=i.dispatchers;n.type===il&&r&&!n.notBlur&&Rl(e.mainType,e.componentIndex,t._api),// PENDING:
// Whether to put this "enter emphasis" code in `ComponentView`,
// which will be the same as `ChartView` but might be not necessary
// and will be far from this logic.
o&&R(o,(function(t){n.type===il?Il(t):Tl(t)}))}else Ul(n)&&e instanceof zg&&(function(t,e,n){if(Ul(e)){var i=e.dataType,r=_o(t.getData(i),e);G(r)||(r=[r]),t[e.type===sl?"toggleSelect":e.type===ol?"select":"unselect"](r,i)}}(e,n,t._api),El(e),cm(t))}),t),o&&o.eachComponent(s,(function(e){l&&null!=l.get(e.id)||h(t["series"===i?"_chartsMap":"_componentsMap"][e.__viewId])}),t)}else// FIXME
// Chart will not be update directly here, except set dirty.
// But there is no such scenario now.
R([].concat(t._componentsViews).concat(t._chartsViews),h);function h(i){i&&i.__alive&&i[e]&&i[e](i.__model,o,t._api,n)}},Jv={prepareAndUpdate:function(t){qv(this),Jv.update.call(this,t,{// Needs to mark option changed if newOption is given.
// It's from MagicType.
// TODO If use a separate flag optionChanged in payload?
optionChanged:null!=t.newOption})},update:function(e,n){var i=this._model,r=this._api,o=this._zr,a=this._coordSysMgr,s=this._scheduler;// update before setOption
if(i){i.setUpdatePayload(e),s.restoreData(i,e),s.performSeriesTasks(i),// TODO
// Save total ecModel here for undo/redo (after restoring data and before processing data).
// Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
// Create new coordinate system each update
// In LineView may save the old coordinate system and use it to get the original point.
a.create(i,r),s.performDataProcessorTasks(i,e),// Current stream render is not supported in data process. So we can update
// stream modes after data processing, where the filtered data is used to
// determine whether to use progressive rendering.
tm(this,i),// We update stream modes before coordinate system updated, then the modes info
// can be fetched when coord sys updating (consider the barGrid extent fix). But
// the drawback is the full coord info can not be fetched. Fortunately this full
// coord is not required in stream mode updater currently.
a.update(i,r),t(i),s.performVisualTasks(i,e),am(this,i,r,e,n);// Set background
var l=i.get("backgroundColor")||"transparent",u=i.get("darkMode");o.setBackgroundColor(l),// Force set dark mode.
null!=u&&"auto"!==u&&o.setDarkMode(u),Ev.trigger("afterupdate",i,r)}},updateTransform:function(e){var n=this,i=this._model,r=this._api;// update before setOption
if(i){i.setUpdatePayload(e);// ChartView.markUpdateMethod(payload, 'updateTransform');
var o=[];i.eachComponent((function(t,a){if("series"!==t){var s=n.getViewOfComponentModel(a);if(s&&s.__alive)if(s.updateTransform){var l=s.updateTransform(a,i,r,e);l&&l.update&&o.push(s)}else o.push(s)}}));var a=ct();i.eachSeries((function(t){var o=n._chartsMap[t.__viewId];if(o.updateTransform){var s=o.updateTransform(t,i,r,e);s&&s.update&&a.set(t.uid,1)}else a.set(t.uid,1)})),t(i),// Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
// this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);
this._scheduler.performVisualTasks(i,e,{setDirty:!0,dirtyMap:a}),// Currently, not call render of components. Geo render cost a lot.
// renderComponents(ecIns, ecModel, api, payload, componentDirtyList);
lm(this,i,r,e,{},a),Ev.trigger("afterupdate",i,r)}},updateView:function(e){var n=this._model;// update before setOption
n&&(n.setUpdatePayload(e),qg.markUpdateMethod(e,"updateView"),t(n),// Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
this._scheduler.performVisualTasks(n,e,{setDirty:!0}),am(this,n,this._api,e,{}),Ev.trigger("afterupdate",n,this._api))},updateVisual:function(e){// updateMethods.update.call(this, payload);
var n=this,i=this._model;// update before setOption
i&&(i.setUpdatePayload(e),// clear all visual
i.eachSeries((function(t){t.getData().clearAllVisual()})),// Perform visual
qg.markUpdateMethod(e,"updateVisual"),t(i),// Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
this._scheduler.performVisualTasks(i,e,{visualType:"visual",setDirty:!0}),i.eachComponent((function(t,r){if("series"!==t){var o=n.getViewOfComponentModel(r);o&&o.__alive&&o.updateVisual(r,i,n._api,e)}})),i.eachSeries((function(t){n._chartsMap[t.__viewId].updateVisual(t,i,n._api,e)})),Ev.trigger("afterupdate",i,this._api))},updateLayout:function(t){Jv.update.call(this,t)}},Qv=function(t,e,n,i){if(t._disposed)t.id;else for(var r,o=t._model,a=t._coordSysMgr.getCoordinateSystems(),s=So(o,n),l=0;l<a.length;l++){var u=a[l];if(u[e]&&null!=(r=u[e](o,s,i)))return r}},tm=function(t,e){var n=t._chartsMap,i=t._scheduler;e.eachSeries((function(t){i.updateStreamModes(t,n[t.__viewId])}))},em=function(t,e){var n=this,i=this.getModel(),r=t.type,o=t.escapeConnect,a=mm[r],s=a.actionInfo,l=(s.update||"update").split(":"),u=l.pop(),h=null!=l[0]&&Oo(l[0]);this[Gv]=!0;var c=[t],p=!1;// Batch action
t.batch&&(p=!0,c=N(t.batch,(function(e){return(e=k(A({},e),t)).batch=null,e})));var d,f=[],g=Ul(t),y=Zl(t);if(// Only leave blur once if there are multiple batches.
y&&Pl(this._api),R(c,(function(e){// light update does not perform data process, layout and visual.
if(// Action can specify the event by return it.
// Convert type to eventType
(// Emit event outside
d=(d=a.action(e,n._model,n._api))||A({},e)).type=s.event||d.type,f.push(d),y){var i=Mo(t),r=i.queryOptionMap,o=i.mainTypeSpecified?r.keys()[0]:"series";$v(n,u,e,o),cm(n)}else g?(// At present `dispatchAction({ type: 'select', ... })` is not supported on components.
// geo still use 'geoselect'.
$v(n,u,e,"series"),cm(n)):h&&$v(n,u,e,h.main,h.sub)})),"none"!==u&&!y&&!g&&!h)try{// Still dirty
this[Wv]?(qv(this),Jv.update.call(this,t),this[Wv]=null):Jv[u].call(this,t)}catch(ku){throw this[Gv]=!1,ku}// Follow the rule of action batch
if(d=p?{type:s.event||r,escapeConnect:o,batch:f}:f[0],this[Gv]=!1,!e){var v=this._messageCenter;// Extra triggered 'selectchanged' event
if(v.trigger(d.type,d),g){var m={type:"selectchanged",escapeConnect:o,selected:zl(i),isFromClick:t.isFromClick||!1,fromAction:t.type,fromActionPayload:t};v.trigger(m.type,m)}}},nm=function(t){for(var e=this._pendingActions;e.length;){var n=e.shift();em.call(this,n,t)}},im=function(t){!t&&this.trigger("updated")},
/**
                 * Event `rendered` is triggered when zr
                 * rendered. It is useful for realtime
                 * snapshot (reflect animation).
                 *
                 * Event `finished` is triggered when:
                 * (1) zrender rendering finished.
                 * (2) initial animation finished.
                 * (3) progressive rendering finished.
                 * (4) no pending action.
                 * (5) no delayed setOption needs to be processed.
                 */
rm=function(t,e){t.on("rendered",(function(n){e.trigger("rendered",n),// The `finished` event should not be triggered repeatedly,
// so it should only be triggered when rendering indeed happens
// in zrender. (Consider the case that dipatchAction is keep
// triggering when mouse move).
// Although zr is dirty if initial animation is not finished
// and this checking is called on frame, we also check
// animation finished for robustness.
!t.animation.isFinished()||e[Wv]||e._scheduler.unfinished||e._pendingActions.length||e.trigger("finished")}))},om=function(t,e){t.on("mouseover",(function(t){var n=Uy(t.target,Xl);n&&(function(t,e,n){var i=js(t),r=Nl(i.componentMainType,i.componentIndex,i.componentHighDownName,n),o=r.dispatchers,a=r.focusSelf;// If `findHighDownDispatchers` is supported on the component,
// highlight/downplay elements with the same name.
o?(a&&Rl(i.componentMainType,i.componentIndex,n),R(o,(function(t){return Sl(t,e)}))):(// Try blur all in the related series. Then emphasis the hoverred.
// TODO. progressive mode.
Ol(i.seriesIndex,i.focus,i.blurScope,n),"self"===i.focus&&Rl(i.componentMainType,i.componentIndex,n),// Other than series, component that not support `findHighDownDispatcher` will
// also use it. But in this case, highlight/downplay are only supported in
// mouse hover but not in dispatchAction.
Sl(t,e))}(n,t,e._api),cm(e))})).on("mouseout",(function(t){var n=Uy(t.target,Xl);n&&(function(t,e,n){Pl(n);var i=js(t),r=Nl(i.componentMainType,i.componentIndex,i.componentHighDownName,n).dispatchers;r?R(r,(function(t){return Ml(t,e)})):Ml(t,e)}(n,t,e._api),cm(e))})).on("click",(function(t){var n=Uy(t.target,(function(t){return null!=js(t).dataIndex}),!0);if(n){var i=n.selected?"unselect":"select",r=js(n);e._api.dispatchAction({type:i,dataType:r.dataType,dataIndexInside:r.dataIndex,seriesIndex:r.seriesIndex,isFromClick:!0})}}))},am=function(t,e,n,i,r){!function(t){var e=[],n=[],i=!1;if(t.eachComponent((function(t,r){var o=r.get("zlevel")||0,a=r.get("z")||0,s=r.getZLevelKey();i=i||!!s,("series"===t?n:e).push({zlevel:o,z:a,idx:r.componentIndex,type:t,key:s})})),i){// Series after component
var r,o,a=e.concat(n);Ye(a,(function(t,e){return t.zlevel===e.zlevel?t.z-e.z:t.zlevel-e.zlevel})),R(a,(function(e){var n=t.getComponent(e.type,e.idx),i=e.zlevel,a=e.key;null!=r&&(i=Math.max(r,i)),a?(i===r&&a!==o&&i++,o=a):o&&(i===r&&i++,o=""),r=i,n.setZLevel(i)}))}}(e),sm(t,e,n,i,r),R(t._chartsViews,(function(t){t.__alive=!1})),lm(t,e,n,i,r),// Remove groups of unrendered charts
R(t._chartsViews,(function(t){t.__alive||t.remove(e,n)}))},sm=function(t,e,n,r,o,l){R(l||t._componentsViews,(function(t){var o=t.__model;a(0,t),t.render(o,e,n,r),i(o,t),s(o,t)}))},
/**
                 * Render each chart and component
                 */
lm=function(t,e,n,r,l,u){// Render all charts
var h=t._scheduler;l=A(l||{},{updatedSeries:e.getSeries()}),// TODO progressive?
Ev.trigger("series:beforeupdate",e,n,l);var c=!1;e.eachSeries((function(e){var n=t._chartsMap[e.__viewId];n.__alive=!0;var i=n.renderTask;h.updatePayload(i,r),// TODO states on marker.
a(0,n),u&&u.get(e.uid)&&i.dirty(),i.perform(h.getPerformArgs(i))&&(c=!0),n.group.silent=!!e.get("silent"),// Should not call markRedraw on group, because it will disable zrender
// incremental render (always render from the __startIndex each frame)
// chartView.group.markRedraw();
/**
                 * Update chart and blend.
                 */
function(t,e){var n=t.get("blendMode")||null;e.eachRendered((function(t){// FIXME marker and other components
t.isGroup||(// DON'T mark the element dirty. In case element is incremental and don't want to rerender.
t.style.blend=n)}))}(e,n),El(e)})),h.unfinished=c||h.unfinished,Ev.trigger("series:layoutlabels",e,n,l),// transition after label is layouted.
Ev.trigger("series:transition",e,n,l),e.eachSeries((function(e){var n=t._chartsMap[e.__viewId];// Update Z after labels updated. Before applying states.
i(e,n),// NOTE: Update states after label is updated.
// label should be in normal status when layouting.
s(e,n)})),// If use hover layer
function(t,e){var n=t._zr,i=n.storage,r=0;i.traverse((function(t){t.isGroup||r++})),r>e.get("hoverLayerThreshold")&&!o.node&&!o.worker&&e.eachSeries((function(e){if(!e.preventUsingHoverLayer){var n=t._chartsMap[e.__viewId];n.__alive&&n.eachRendered((function(t){t.states.emphasis&&(t.states.emphasis.hoverLayer=!0)}))}}))}(t,e),Ev.trigger("series:afterupdate",e,n,l)},cm=function(t){t[Hv]=!0,// Wake up zrender if it's sleep. Let it update states in the next frame.
t.getZr().wakeUp()},pm=function(t){t[Hv]&&(t.getZr().storage.traverse((function(t){// Not applied on removed elements, it may still in fading.
Ih(t)||e(t)})),t[Hv]=!1)},um=function(t){return new(/** @class */function(e){function i(){return null!==e&&e.apply(this,arguments)||this}return n(i,e),i.prototype.getCoordinateSystems=function(){return t._coordSysMgr.getCoordinateSystems()},i.prototype.getComponentByElement=function(e){for(;e;){var n=e.__ecComponentInfo;if(null!=n)return t._model.getComponent(n.mainType,n.index);e=e.parent}},i.prototype.enterEmphasis=function(e,n){Il(e,n),cm(t)},i.prototype.leaveEmphasis=function(e,n){Tl(e,n),cm(t)},i.prototype.enterBlur=function(e){Cl(e),cm(t)},i.prototype.leaveBlur=function(e){Dl(e),cm(t)},i.prototype.enterSelect=function(e){Al(e),cm(t)},i.prototype.leaveSelect=function(e){kl(e),cm(t)},i.prototype.getModel=function(){return t.getModel()},i.prototype.getViewOfComponentModel=function(e){return t.getViewOfComponentModel(e)},i.prototype.getViewOfSeriesModel=function(e){return t.getViewOfSeriesModel(e)},i}(Td))(t)},hm=function(t){function e(t,e){for(var n=0;n<t.length;n++)t[n][Xv]=e}R(xm,(function(n,i){t._messageCenter.on(i,(function(n){if(Tm[t.group]&&0!==t[Xv]){if(n&&n.escapeConnect)return;var i=t.makeActionFromEvent(n),r=[];R(Im,(function(e){e!==t&&e.group===t.group&&r.push(e)})),e(r,0),R(r,(function(t){1!==t[Xv]&&t.dispatchAction(i)})),e(r,2)}}))}))}}(),e}(Bt),ym=gm.prototype;ym.on=Uv("on"),ym.off=Uv("off"),
/**
             * @deprecated
             */
// @ts-ignore
ym.one=function(t,e,n){var i=this;this.on.call(this,t,(function n(){for(var r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];e&&e.apply&&e.apply(this,r),// @ts-ignore
i.off(t,n)}),n)};var vm=["click","dblclick","mouseover","mouseout","mousemove","mousedown","mouseup","globalout","contextmenu"],mm={},xm={},_m=[],bm=[],wm=[],Sm={},Mm={},Im={},Tm={},Cm=+new Date-0,Dm="_echarts_instance_";function Am(t,e){Sm[t]=e}
/**
             * Register option preprocessor
             */function km(t){L(bm,t)<0&&bm.push(t)}function Lm(t,e){Em(_m,t,e,2e3)}
/**
             * Register postIniter
             * @param {Function} postInitFunc
             */function Pm(t,e){Ev.on(t,e)}function Om(t,e,n){W(e)&&(n=e,e="");var i=U(t)?t.type:[t,t={event:e}][0];// Event name is all lowercase
t.event=(t.event||i).toLowerCase(),e=t.event,xm[e]||(// Validate action type and event name.
it(Yv.test(i)&&Yv.test(e)),mm[i]||(mm[i]={action:n,actionInfo:t}),xm[e]=i)}function Rm(t,e){Em(wm,t,e,3e3,"visual")}var Nm=[];function Em(t,e,n,i,r){if((W(e)||U(e))&&(n=e,e=i),!(L(Nm,n)>=0)){Nm.push(n);var o=Cy.wrapStageHandler(n,r);o.__prio=e,o.__raw=n,t.push(o)}}function zm(t,e){Mm[t]=e}
/**
             * The parameters and usage: see `geoSourceManager.registerMap`.
             * Compatible with previous `echarts.registerMap`.
             */function Vm(t,e,n){var i=zv.registerMap;i&&i(t,e,n)}var Bm=function(t){var e=(t=T(t)).type;e||ro("");var n=e.split(":");2!==n.length&&ro("");// Namespace 'echarts:xxx' is official namespace, where the transforms should
// be called directly via 'xxx' rather than 'echarts:xxx'.
var i=!1;"echarts"===n[0]&&(e=n[1],i=!0),t.__isBuiltIn=i,Uf.set(e,t)};
/**
             * Globa dispatchAction to a specified chart instance.
             */
// export function dispatchAction(payload: { chartId: string } & Payload, opt?: Parameters<ECharts['dispatchAction']>[1]) {
//     if (!payload || !payload.chartId) {
//         // Must have chartId to find chart
//         return;
//     }
//     const chart = instances[payload.chartId];
//     if (chart) {
//         chart.dispatchAction(payload, opt);
//     }
// }
// Builtin global visual
Rm(Vv,sy),Rm(Bv,uy),Rm(Bv,hy),Rm(Vv,By),Rm(Bv,Fy),Rm(7e3,(function(t,e){t.eachRawSeries((function(n){if(!t.isSeriesFiltered(n)){var i=n.getData();i.hasItemVisual()&&i.each((function(t){var n=i.getItemVisual(t,"decal");n&&(i.ensureUniqueItemVisual(t,"style").decal=Pv(n,e))}));var r=i.getVisual("decal");r&&(i.getVisual("style").decal=Pv(r,e))}}))})),km(Qd),Lm(900,(function(t){var e=ct();t.eachSeries((function(t){var n=t.get("stack");// Compatible: when `stack` is set as '', do not stack.
if(n){var i=e.get(n)||e.set(n,[]),r=t.getData(),o={// Used for calculate axis extent automatically.
// TODO: Type getCalculationInfo return more specific type?
stackResultDimension:r.getCalculationInfo("stackResultDimension"),stackedOverDimension:r.getCalculationInfo("stackedOverDimension"),stackedDimension:r.getCalculationInfo("stackedDimension"),stackedByDimension:r.getCalculationInfo("stackedByDimension"),isStackedByIndex:r.getCalculationInfo("isStackedByIndex"),data:r,seriesModel:t};// If stacked on axis that do not support data stack.
if(!o.stackedDimension||!o.isStackedByIndex&&!o.stackedByDimension)return;i.length&&r.setCalculationInfo("stackedOnSeries",i[i.length-1].seriesModel),i.push(o)}})),e.each(tf)})),zm("default",(
/**
             * @param {module:echarts/ExtensionAPI} api
             * @param {Object} [opts]
             * @param {string} [opts.text]
             * @param {string} [opts.color]
             * @param {string} [opts.textColor]
             * @return {module:zrender/Element}
             */
function(t,e){k(e=e||{},{text:"loading",textColor:"#000",fontSize:12,fontWeight:"normal",fontStyle:"normal",fontFamily:"sans-serif",maskColor:"rgba(255, 255, 255, 0.8)",showSpinner:!0,color:"#5470c6",spinnerRadius:10,lineWidth:5,zlevel:0});var n=new Lr,i=new Ls({style:{fill:e.maskColor},zlevel:e.zlevel,z:1e4});n.add(i);var r,o=new Zs({style:{text:e.text,fill:e.textColor,fontSize:e.fontSize,fontWeight:e.fontWeight,fontStyle:e.fontStyle,fontFamily:e.fontFamily},zlevel:e.zlevel,z:10001}),a=new Ls({style:{fill:"none"},textContent:o,textConfig:{position:"right",distance:10},zlevel:e.zlevel,z:10001});return n.add(a),e.showSpinner&&((r=new ih({shape:{startAngle:-cy/2,endAngle:-cy/2+.1,r:e.spinnerRadius},style:{stroke:e.color,lineCap:"round",lineWidth:e.lineWidth},zlevel:e.zlevel,z:10001})).animateShape(!0).when(1e3,{endAngle:3*cy/2}).start("circularInOut"),r.animateShape(!0).when(1e3,{startAngle:3*cy/2}).delay(300).start("circularInOut"),n.add(r)),// Inject resize
n.resize=function(){var n=o.getBoundingRect().width,s=e.showSpinner?e.spinnerRadius:0,l=(t.getWidth()-2*s-(e.showSpinner&&n?10:0)-n)/2-(e.showSpinner&&n?0:5+n/2)+(e.showSpinner?0:n/2)+(n?0:s),u=t.getHeight()/2;e.showSpinner&&r.setShape({cx:l,cy:u}),a.setShape({x:l-s,y:u-s,width:2*s,height:2*s}),i.setShape({x:0,y:0,width:t.getWidth(),height:t.getHeight()})},n.resize(),n})),// Default actions
Om({type:il,event:il,update:il},yt),Om({type:rl,event:rl,update:rl},yt),Om({type:ol,event:ol,update:ol},yt),Om({type:al,event:al,update:al},yt),Om({type:sl,event:sl,update:sl},yt),// Default theme
Am("light",Ay),Am("dark",Ny);// For backward compatibility, where the namespace `dataTool` will
var Fm=[],Gm={registerPreprocessor:km,registerProcessor:Lm,registerPostInit:function(t){Pm("afterinit",t)}
/**
             * Register postUpdater
             * @param {Function} postUpdateFunc
             */,registerPostUpdate:function(t){Pm("afterupdate",t)},registerUpdateLifecycle:Pm,registerAction:Om,registerCoordinateSystem:function(t,e){Ad.register(t,e)},registerLayout:function(t,e){Em(wm,t,e,1e3,"layout")},registerVisual:Rm,registerTransform:Bm,registerLoading:zm,registerMap:Vm,registerImpl:function(t,e){zv[t]=e},PRIORITY:Fv,ComponentModel:Wp,ComponentView:Bg,SeriesModel:zg,ChartView:qg,// TODO Use ComponentModel and SeriesModel instead of Constructor
registerComponentModel:function(t){Wp.registerClass(t)},registerComponentView:function(t){Bg.registerClass(t)},registerSeriesModel:function(t){zg.registerClass(t)},registerChartView:function(t){qg.registerClass(t)},registerSubTypeDefaulter:function(t,e){Wp.registerSubTypeDefaulter(t,e)},registerPainter:function(t,e){var n;n=e,Pr[t]=n}};function Wm(t){G(t)?// use([ChartLine, ChartBar]);
R(t,(function(t){Wm(t)})):L(Fm,t)>=0||(Fm.push(t),W(t)&&(t={install:t}),t.install(Gm))}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function Hm(t){return null==t?0:t.length||1}function Ym(t){return t}var Xm=/** @class */function(){
/**
               * @param context Can be visited by this.context in callback.
               */
function t(t,e,n,i,r,// By default: 'oneToOne'.
o){this._old=t,this._new=e,this._oldKeyGetter=n||Ym,this._newKeyGetter=i||Ym,// Visible in callback via `this.context`;
this.context=r,this._diffModeMultiple="multiple"===o}
/**
               * Callback function when add a data
               */return t.prototype.add=function(t){return this._add=t,this},
/**
               * Callback function when update a data
               */
t.prototype.update=function(t){return this._update=t,this},
/**
               * Callback function when update a data and only work in `cbMode: 'byKey'`.
               */
t.prototype.updateManyToOne=function(t){return this._updateManyToOne=t,this},
/**
               * Callback function when update a data and only work in `cbMode: 'byKey'`.
               */
t.prototype.updateOneToMany=function(t){return this._updateOneToMany=t,this},
/**
               * Callback function when update a data and only work in `cbMode: 'byKey'`.
               */
t.prototype.updateManyToMany=function(t){return this._updateManyToMany=t,this},
/**
               * Callback function when remove a data
               */
t.prototype.remove=function(t){return this._remove=t,this},t.prototype.execute=function(){this[this._diffModeMultiple?"_executeMultiple":"_executeOneToOne"]()},t.prototype._executeOneToOne=function(){var t=this._old,e=this._new,n={},i=new Array(t.length),r=new Array(e.length);this._initIndexMap(t,null,i,"_oldKeyGetter"),this._initIndexMap(e,n,r,"_newKeyGetter");for(var o=0;o<t.length;o++){var a=i[o],s=n[a],l=Hm(s);// idx can never be empty array here. see 'set null' logic below.
if(l>1){// Consider there is duplicate key (for example, use dataItem.name as key).
// We should make sure every item in newArr and oldArr can be visited.
var u=s.shift();1===s.length&&(n[a]=s[0]),this._update&&this._update(u,o)}else 1===l?(n[a]=null,this._update&&this._update(s,o)):this._remove&&this._remove(o)}this._performRestAdd(r,n)},
/**
               * For example, consider the case:
               * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],
               * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],
               * Where:
               *     o0, o1, n0 has key 'a' (many to one)
               *     o5, n4, n5, n6 has key 'b' (one to many)
               *     o2, n1 has key 'c' (one to one)
               *     n2, n3 has key 'd' (add)
               *     o3, o4 has key 'e' (remove)
               *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)
               * Then:
               *     (The order of the following directives are not ensured.)
               *     this._updateManyToOne(n0, [o0, o1]);
               *     this._updateOneToMany([n4, n5, n6], o5);
               *     this._update(n1, o2);
               *     this._remove(o3);
               *     this._remove(o4);
               *     this._remove(o6);
               *     this._remove(o7);
               *     this._add(n2);
               *     this._add(n3);
               *     this._add(n7);
               *     this._add(n8);
               */
t.prototype._executeMultiple=function(){var t=this._old,e=this._new,n={},i={},r=[],o=[];this._initIndexMap(t,n,r,"_oldKeyGetter"),this._initIndexMap(e,i,o,"_newKeyGetter");for(var a=0;a<r.length;a++){var s=r[a],l=n[s],u=i[s],h=Hm(l),c=Hm(u);if(h>1&&1===c)this._updateManyToOne&&this._updateManyToOne(u,l),i[s]=null;else if(1===h&&c>1)this._updateOneToMany&&this._updateOneToMany(u,l),i[s]=null;else if(1===h&&1===c)this._update&&this._update(u,l),i[s]=null;else if(h>1&&c>1)this._updateManyToMany&&this._updateManyToMany(u,l),i[s]=null;else if(h>1)for(var p=0;p<h;p++)this._remove&&this._remove(l[p]);else this._remove&&this._remove(l)}this._performRestAdd(o,i)},t.prototype._performRestAdd=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[i],o=Hm(r);if(o>1)for(var a=0;a<o;a++)this._add&&this._add(r[a]);else 1===o&&this._add&&this._add(r);// Support both `newDataKeyArr` are duplication removed or not removed.
e[i]=null}},t.prototype._initIndexMap=function(t,// Can be null.
e,// In 'byKey', the output `keyArr` is duplication removed.
// In 'byIndex', the output `keyArr` is not duplication removed and
//     its indices are accurately corresponding to `arr`.
n,i){for(var r=this._diffModeMultiple,o=0;o<t.length;o++){// Add prefix to avoid conflict with Object.prototype.
var a="_ec_"+this[i](t[o],o);if(r||(n[o]=a),e){var s=e[a],l=Hm(s);0===l?(// Simple optimize: in most cases, one index has one key,
// do not need array.
e[a]=o,r&&n.push(a)):1===l?e[a]=[s,o]:s.push(o)}}},t}();const Um=Xm;var Zm=/** @class */function(){function t(t,e){this._encode=t,this._schema=e}return t.prototype.get=function(){return{// Do not generate full dimension name until fist used.
fullDimensions:this._getFullDimensionNames(),encode:this._encode}},
/**
               * Get all data store dimension names.
               * Theoretically a series data store is defined both by series and used dataset (if any).
               * If some dimensions are omitted for performance reason in `this.dimensions`,
               * the dimension name may not be auto-generated if user does not specify a dimension name.
               * In this case, the dimension name is `null`/`undefined`.
               */
t.prototype._getFullDimensionNames=function(){return this._cachedDimNames||(this._cachedDimNames=this._schema?this._schema.makeOutputDimensionNames():[]),this._cachedDimNames},t}();function jm(t,e){return t.hasOwnProperty(e)||(t[e]=[]),t[e]}// FIXME:TS should be type `AxisType`
function qm(t){return"category"===t?"ordinal":"time"===t?"time":"float"}const Km=
/**
               * @param opt All of the fields will be shallow copied.
               */
function(t){
/**
                 * The format of `otherDims` is:
                 * ```js
                 * {
                 *     tooltip?: number
                 *     label?: number
                 *     itemName?: number
                 *     seriesName?: number
                 * }
                 * ```
                 *
                 * A `series.encode` can specified these fields:
                 * ```js
                 * encode: {
                 *     // "3, 1, 5" is the index of data dimension.
                 *     tooltip: [3, 1, 5],
                 *     label: [0, 3],
                 *     ...
                 * }
                 * ```
                 * `otherDims` is the parse result of the `series.encode` above, like:
                 * ```js
                 * // Suppose the index of this data dimension is `3`.
                 * this.otherDims = {
                 *     // `3` is at the index `0` of the `encode.tooltip`
                 *     tooltip: 0,
                 *     // `3` is at the index `1` of the `encode.label`
                 *     label: 1
                 * };
                 * ```
                 *
                 * This prop should never be `null`/`undefined` after initialized.
                 */
this.otherDims={},null!=t&&A(this,t)};var $m=bo(),Jm={float:"f",int:"i",ordinal:"o",number:"n",time:"t"},Qm=/** @class */function(){function t(t){this.dimensions=t.dimensions,this._dimOmitted=t.dimensionOmitted,this.source=t.source,this._fullDimCount=t.fullDimensionCount,this._updateDimOmitted(t.dimensionOmitted)}return t.prototype.isDimensionOmitted=function(){return this._dimOmitted},t.prototype._updateDimOmitted=function(t){this._dimOmitted=t,t&&(this._dimNameMap||(this._dimNameMap=nx(this.source)))},
/**
               * @caution Can only be used when `dimensionOmitted: true`.
               *
               * Get index by user defined dimension name (i.e., not internal generate name).
               * That is, get index from `dimensionsDefine`.
               * If no `dimensionsDefine`, or no name get, return -1.
               */
t.prototype.getSourceDimensionIndex=function(t){return Q(this._dimNameMap.get(t),-1)},
/**
               * @caution Can only be used when `dimensionOmitted: true`.
               *
               * Notice: may return `null`/`undefined` if user not specify dimension names.
               */
t.prototype.getSourceDimension=function(t){var e=this.source.dimensionsDefine;if(e)return e[t]},t.prototype.makeStoreSchema=function(){for(var t=this._fullDimCount,e=ff(this.source),n=!ix(t),i="",r=[],o=0,a=0;o<t;o++){var s=void 0,l=void 0,u=void 0,h=this.dimensions[a];// The list has been sorted by `storeDimIndex` asc.
if(h&&h.storeDimIndex===o)s=e?h.name:null,l=h.type,u=h.ordinalMeta,a++;else{var c=this.getSourceDimension(o);c&&(s=e?c.name:null,l=c.type)}r.push({property:s,type:l,ordinalMeta:u}),// If retrieving data by index,
//   use <index, type, ordinalMeta> to determine whether data can be shared.
//   (Because in this case there might be no dimension name defined in dataset, but indices always exists).
//   (Indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).
// Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),
//   use <property, type, ordinalMeta> in hash.
!e||null==s||h&&h.isCalculationCoord||(i+=n?s.replace(/\`/g,"`1").replace(/\$/g,"`2"):s),i+="$",i+=Jm[l]||"f",u&&(i+=u.uid),i+="$"}// Source from endpoint(usually series) will be read differently
// when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.
// So we use this three props as key.
var p=this.source;return{dimensions:r,hash:[p.seriesLayoutBy,p.startIndex,i].join("$$")}},t.prototype.makeOutputDimensionNames=function(){for(var t=[],e=0,n=0;e<this._fullDimCount;e++){var i=void 0,r=this.dimensions[n];// The list has been sorted by `storeDimIndex` asc.
if(r&&r.storeDimIndex===e)r.isCalculationCoord||(i=r.name),n++;else{var o=this.getSourceDimension(e);o&&(i=o.name)}t.push(i)}return t},t.prototype.appendCalculationDimension=function(t){this.dimensions.push(t),t.isCalculationCoord=!0,this._fullDimCount++,// If append dimension on a data store, consider the store
// might be shared by different series, series dimensions not
// really map to store dimensions.
this._updateDimOmitted(!0)},t}();function tx(t){return t instanceof Qm}function ex(t){for(var e=ct(),n=0;n<(t||[]).length;n++){var i=t[n],r=U(i)?i.name:i;null!=r&&null==e.get(r)&&e.set(r,n)}return e}function nx(t){var e=$m(t);return e.dimNameMap||(e.dimNameMap=ex(t.dimensionsDefine))}function ix(t){return t>30}var rx,ox,ax,sx,lx,ux,hx,cx=U,px=N,dx="undefined"==typeof Int32Array?Array:Int32Array,fx=["hasItemOption","_nameList","_idList","_invertedIndicesMap","_dimSummary","userOutput","_rawData","_dimValueGetter","_nameDimIdx","_idDimIdx","_nameRepeatCount"],gx=["_approximateExtent"],yx=/** @class */function(){
/**
               * @param dimensionsInput.dimensions
               *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
               *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
               */
function t(t,e){var n;this.type="list",this._dimOmitted=!1,this._nameList=[],this._idList=[],// Models of data option is stored sparse for optimizing memory cost
// Never used yet (not used yet).
// private _optionModels: Model[] = [];
// Global visual properties after visual coding
this._visual={},// Global layout properties.
this._layout={},// Item visual properties after visual coding
this._itemVisuals=[],// Item layout properties after layout
this._itemLayouts=[],// Graphic elements
this._graphicEls=[],// key: dim, value: extent
this._approximateExtent={},this._calculationInfo={},// Having detected that there is data item is non primitive type
// (in type `OptionDataItemObject`).
// Like `data: [ { value: xx, itemStyle: {...} }, ...]`
// At present it only happen in `SOURCE_FORMAT_ORIGINAL`.
this.hasItemOption=!1,// Methods that create a new list based on this list should be listed here.
// Notice that those method should `RETURN` the new list.
this.TRANSFERABLE_METHODS=["cloneShallow","downSample","lttbDownSample","map"],// Methods that change indices of this list should be listed here.
this.CHANGABLE_METHODS=["filterSelf","selectRange"],this.DOWNSAMPLE_METHODS=["downSample","lttbDownSample"];var i=!1;tx(t)?(n=t.dimensions,this._dimOmitted=t.isDimensionOmitted(),this._schema=t):(i=!0,n=t),n=n||["x","y"];for(var r={},o=[],a={},s=!1,l={},u=0;u<n.length;u++){// Use the original dimensions[i], where other flag props may exists.
var h=n[u],c=H(h)?new Km({name:h}):h instanceof Km?h:new Km(h),p=c.name;c.type=c.type||"float",c.coordDim||(c.coordDim=p,c.coordDimIndex=0);var d=c.otherDims=c.otherDims||{};o.push(p),r[p]=c,null!=l[p]&&(s=!0),c.createInvertedIndices&&(a[p]=[]),0===d.itemName&&(this._nameDimIdx=u),0===d.itemId&&(this._idDimIdx=u),i&&(c.storeDimIndex=u)}if(this.dimensions=o,this._dimInfos=r,this._initGetDimensionInfo(s),this.hostModel=e,this._invertedIndicesMap=a,this._dimOmitted){var f=this._dimIdxToName=ct();R(o,(function(t){f.set(r[t].storeDimIndex,t)}))}}
/**
               *
               * Get concrete dimension name by dimension name or dimension index.
               * If input a dimension name, do not validate whether the dimension name exits.
               *
               * @caution
               * @param dim Must make sure the dimension is `SeriesDimensionLoose`.
               * Because only those dimensions will have auto-generated dimension names if not
               * have a user-specified name, and other dimensions will get a return of null/undefined.
               *
               * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:
               * ```js
               * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);
               * ```
               *
               * @return Concrete dim name.
               */return t.prototype.getDimension=function(t){var e=this._recognizeDimIndex(t);if(null==e)return t;if(e=t,!this._dimOmitted)return this.dimensions[e];// Retrieve from series dimension definition because it probably contains
// generated dimension name (like 'x', 'y').
var n=this._dimIdxToName.get(e);if(null!=n)return n;var i=this._schema.getSourceDimension(e);return i?i.name:void 0},
/**
               * Get dimension index in data store. Return -1 if not found.
               * Can be used to index value from getRawValue.
               */
t.prototype.getDimensionIndex=function(t){var e=this._recognizeDimIndex(t);if(null!=e)return e;if(null==t)return-1;var n=this._getDimInfo(t);return n?n.storeDimIndex:this._dimOmitted?this._schema.getSourceDimensionIndex(t):-1},
/**
               * The meanings of the input parameter `dim`:
               *
               * + If dim is a number (e.g., `1`), it means the index of the dimension.
               *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
               * + If dim is a number-like string (e.g., `"1"`):
               *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,
               *        it means that concrete name.
               *     + If not, it will be converted to a number, which means the index of the dimension.
               *        (why? because of the backward compatibility. We have been tolerating number-like string in
               *        dimension setting, although now it seems that it is not a good idea.)
               *     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
               *     if no dimension name is defined as `"1"`.
               * + If dim is a not-number-like string, it means the concrete dim name.
               *   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
               *   or customized in `dimensions` property of option like `"age"`.
               *
               * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).
               */
t.prototype._recognizeDimIndex=function(t){if(X(t)||null!=t&&!isNaN(t)&&!this._getDimInfo(t)&&(!this._dimOmitted||this._schema.getSourceDimensionIndex(t)<0))return+t},t.prototype._getStoreDimIndex=function(t){return this.getDimensionIndex(t)},
/**
               * Get type and calculation info of particular dimension
               * @param dim
               *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
               *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
               */
t.prototype.getDimensionInfo=function(t){// Do not clone, because there may be categories in dimInfo.
return this._getDimInfo(this.getDimension(t))},t.prototype._initGetDimensionInfo=function(t){var e=this._dimInfos;this._getDimInfo=t?function(t){return e.hasOwnProperty(t)?e[t]:void 0}:function(t){return e[t]}},
/**
               * concrete dimension name list on coord.
               */
t.prototype.getDimensionsOnCoord=function(){return this._dimSummary.dataDimsOnCoord.slice()},t.prototype.mapDimension=function(t,e){var n=this._dimSummary;if(null==e)return n.encodeFirstDimNotExtra[t];var i=n.encode[t];return i?i[e]:null},t.prototype.mapDimensionsAll=function(t){return(this._dimSummary.encode[t]||[]).slice()},t.prototype.getStore=function(){return this._store},
/**
               * Initialize from data
               * @param data source or data or data store.
               * @param nameList The name of a datum is used on data diff and
               *        default label/tooltip.
               *        A name can be specified in encode.itemName,
               *        or dataItem.name (only for series option data),
               *        or provided in nameList from outside.
               */
t.prototype.initData=function(t,e,n){var i,r=this;if(t instanceof rg&&(i=t),!i){var o=this.dimensions,a=lf(t)||O(t)?new gf(t,o.length):t;i=new rg;var s=px(o,(function(t){return{type:r._dimInfos[t].type,property:t}}));i.initData(a,s,n)}this._store=i,// Reset
this._nameList=(e||[]).slice(),this._idList=[],this._nameRepeatCount={},this._doInit(0,i.count()),// Cache summary info for fast visit. See "dimensionHelper".
// Needs to be initialized after store is prepared.
this._dimSummary=function(t,e){var n={},i=n.encode={},r=ct(),o=[],a=[],s={};R(t.dimensions,(function(e){var n,l=t.getDimensionInfo(e),u=l.coordDim;if(u){var h=l.coordDimIndex;jm(i,u)[h]=e,l.isExtraCoord||(r.set(u,1),// Use the last coord dim (and label friendly) as default label,
// because when dataset is used, it is hard to guess which dimension
// can be value dimension. If both show x, y on label is not look good,
// and conventionally y axis is focused more.
"ordinal"!==(n=l.type)&&"time"!==n&&(o[0]=e),// User output encode do not contain generated coords.
// And it only has index. User can use index to retrieve value from the raw item array.
jm(s,u)[h]=t.getDimensionIndex(l.name)),l.defaultTooltip&&a.push(e)}Up.each((function(t,e){var n=jm(i,e),r=l.otherDims[e];null!=r&&!1!==r&&(n[r]=l.name)}))}));var l=[],u={};r.each((function(t,e){var n=i[e];u[e]=n[0],// Not necessary to remove duplicate, because a data
// dim canot on more than one coordDim.
l=l.concat(n)})),n.dataDimsOnCoord=l,n.dataDimIndicesOnCoord=N(l,(function(e){return t.getDimensionInfo(e).storeDimIndex})),n.encodeFirstDimNotExtra=u;var h=i.label;// FIXME `encode.label` is not recommended, because formatter cannot be set
// in this way. Use label.formatter instead. Maybe remove this approach someday.
h&&h.length&&(o=h.slice());var c=i.tooltip;return c&&c.length?a=c.slice():a.length||(a=o.slice()),i.defaultedLabel=o,i.defaultedTooltip=a,n.userOutput=new Zm(s,e),n}(this,this._schema),this.userOutput=this._dimSummary.userOutput},
/**
               * Caution: Can be only called on raw data (before `this._indices` created).
               */
t.prototype.appendData=function(t){var e=this._store.appendData(t);this._doInit(e[0],e[1])},
/**
               * Caution: Can be only called on raw data (before `this._indices` created).
               * This method does not modify `rawData` (`dataProvider`), but only
               * add values to store.
               *
               * The final count will be increased by `Math.max(values.length, names.length)`.
               *
               * @param values That is the SourceType: 'arrayRows', like
               *        [
               *            [12, 33, 44],
               *            [NaN, 43, 1],
               *            ['-', 'asdf', 0]
               *        ]
               *        Each item is exactly corresponding to a dimension.
               */
t.prototype.appendValues=function(t,e){var n=this._store.appendValues(t,e.length),i=n.start,r=n.end,o=this._shouldMakeIdFromName();if(this._updateOrdinalMeta(),e)for(var a=i;a<r;a++){var s=a-i;this._nameList[a]=e[s],o&&hx(this,a)}},t.prototype._updateOrdinalMeta=function(){for(var t=this._store,e=this.dimensions,n=0;n<e.length;n++){var i=this._dimInfos[e[n]];i.ordinalMeta&&t.collectOrdinalMeta(i.storeDimIndex,i.ordinalMeta)}},t.prototype._shouldMakeIdFromName=function(){var t=this._store.getProvider();return null==this._idDimIdx&&t.getSource().sourceFormat!==$p&&!t.fillStorage},t.prototype._doInit=function(t,e){if(!(t>=e)){var n=this._store.getProvider();this._updateOrdinalMeta();var i=this._nameList,r=this._idList;// Each data item is value
// [1, 2]
// 2
// Bar chart, line chart which uses category axis
// only gives the 'y' value. 'x' value is the indices of category
// Use a tempValue to normalize the value to be a (x, y) value
// If dataItem is {name: ...} or {id: ...}, it has highest priority.
// This kind of ids and names are always stored `_nameList` and `_idList`.
if(n.getSource().sourceFormat===Zp&&!n.pure)for(var o=[],a=t;a<e;a++){// NOTICE: Try not to write things into dataItem
var s=n.getItem(a,o);if(!this.hasItemOption&&po(s)&&(this.hasItemOption=!0),s){var l=s.name;null==i[a]&&null!=l&&(i[a]=vo(l,null));var u=s.id;null==r[a]&&null!=u&&(r[a]=vo(u,null))}}if(this._shouldMakeIdFromName())for(a=t;a<e;a++)hx(this,a);rx(this)}},
/**
               * PENDING: In fact currently this function is only used to short-circuit
               * the calling of `scale.unionExtentFromData` when data have been filtered by modules
               * like "dataZoom". `scale.unionExtentFromData` is used to calculate data extent for series on
               * an axis, but if a "axis related data filter module" is used, the extent of the axis have
               * been fixed and no need to calling `scale.unionExtentFromData` actually.
               * But if we add "custom data filter" in future, which is not "axis related", this method may
               * be still needed.
               *
               * Optimize for the scenario that data is filtered by a given extent.
               * Consider that if data amount is more than hundreds of thousand,
               * extent calculation will cost more than 10ms and the cache will
               * be erased because of the filtering.
               */
t.prototype.getApproximateExtent=function(t){return this._approximateExtent[t]||this._store.getDataExtent(this._getStoreDimIndex(t))},
/**
               * Calculate extent on a filtered data might be time consuming.
               * Approximate extent is only used for: calculate extent of filtered data outside.
               */
t.prototype.setApproximateExtent=function(t,e){e=this.getDimension(e),this._approximateExtent[e]=t.slice()},t.prototype.getCalculationInfo=function(t){return this._calculationInfo[t]},t.prototype.setCalculationInfo=function(t,e){cx(t)?A(this._calculationInfo,t):this._calculationInfo[t]=e},
/**
               * @return Never be null/undefined. `number` will be converted to string. Because:
               * In most cases, name is used in display, where returning a string is more convenient.
               * In other cases, name is used in query (see `indexOfName`), where we can keep the
               * rule that name `2` equals to name `'2'`.
               */
t.prototype.getName=function(t){var e=this.getRawIndex(t),n=this._nameList[e];return null==n&&null!=this._nameDimIdx&&(n=ax(this,this._nameDimIdx,e)),null==n&&(n=""),n},t.prototype._getCategory=function(t,e){var n=this._store.get(t,e),i=this._store.getOrdinalMeta(t);return i?i.categories[n]:n},
/**
               * @return Never null/undefined. `number` will be converted to string. Because:
               * In all cases having encountered at present, id is used in making diff comparison, which
               * are usually based on hash map. We can keep the rule that the internal id are always string
               * (treat `2` is the same as `'2'`) to make the related logic simple.
               */
t.prototype.getId=function(t){return ox(this,this.getRawIndex(t))},t.prototype.count=function(){return this._store.count()},
/**
               * Get value. Return NaN if idx is out of range.
               *
               * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.
               */
t.prototype.get=function(t,e){var n=this._store,i=this._dimInfos[t];if(i)return n.get(i.storeDimIndex,e)},
/**
               * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.
               */
t.prototype.getByRawIndex=function(t,e){var n=this._store,i=this._dimInfos[t];if(i)return n.getByRawIndex(i.storeDimIndex,e)},t.prototype.getIndices=function(){return this._store.getIndices()},t.prototype.getDataExtent=function(t){return this._store.getDataExtent(this._getStoreDimIndex(t))},t.prototype.getSum=function(t){return this._store.getSum(this._getStoreDimIndex(t))},t.prototype.getMedian=function(t){return this._store.getMedian(this._getStoreDimIndex(t))},t.prototype.getValues=function(t,e){var n=this,i=this._store;return G(t)?i.getValues(px(t,(function(t){return n._getStoreDimIndex(t)})),e):i.getValues(t)},
/**
               * If value is NaN. Including '-'
               * Only check the coord dimensions.
               */
t.prototype.hasValue=function(t){for(var e=this._dimSummary.dataDimIndicesOnCoord,n=0,i=e.length;n<i;n++)// Ordinal type originally can be string or number.
// But when an ordinal type is used on coord, it can
// not be string but only number. So we can also use isNaN.
if(isNaN(this._store.get(e[n],t)))return!1;return!0},
/**
               * Retrieve the index with given name
               */
t.prototype.indexOfName=function(t){for(var e=0,n=this._store.count();e<n;e++)if(this.getName(e)===t)return e;return-1},t.prototype.getRawIndex=function(t){return this._store.getRawIndex(t)},t.prototype.indexOfRawIndex=function(t){return this._store.indexOfRawIndex(t)},
/**
               * Only support the dimension which inverted index created.
               * Do not support other cases until required.
               * @param dim concrete dim
               * @param value ordinal index
               * @return rawIndex
               */
t.prototype.rawIndexOf=function(t,e){var n=(t&&this._invertedIndicesMap[t])[e];return null==n||isNaN(n)?-1:n},
/**
               * Retrieve the index of nearest value
               * @param dim
               * @param value
               * @param [maxDistance=Infinity]
               * @return If and only if multiple indices has
               *         the same value, they are put to the result.
               */
t.prototype.indicesOfNearest=function(t,e,n){return this._store.indicesOfNearest(this._getStoreDimIndex(t),e,n)},t.prototype.each=function(t,e,n){W(t)&&(n=e,e=t,t=[]);// ctxCompat just for compat echarts3
var i=n||this,r=px(sx(t),this._getStoreDimIndex,this);this._store.each(r,i?B(e,i):e)},t.prototype.filterSelf=function(t,e,n){W(t)&&(n=e,e=t,t=[]);// ctxCompat just for compat echarts3
var i=n||this,r=px(sx(t),this._getStoreDimIndex,this);return this._store=this._store.filter(r,i?B(e,i):e),this},
/**
               * Select data in range. (For optimization of filter)
               * (Manually inline code, support 5 million data filtering in data zoom.)
               */
t.prototype.selectRange=function(t){var e=this,n={};return R(V(t),(function(i){var r=e._getStoreDimIndex(i);n[r]=t[i]})),this._store=this._store.selectRange(n),this},/* eslint-enable max-len */t.prototype.mapArray=function(t,e,n){W(t)&&(n=e,e=t,t=[]),// ctxCompat just for compat echarts3
n=n||this;var i=[];return this.each(t,(function(){i.push(e&&e.apply(this,arguments))}),n),i},t.prototype.map=function(t,e,n,i){var r=n||i||this,o=px(sx(t),this._getStoreDimIndex,this),a=ux(this);return a._store=this._store.map(o,r?B(e,r):e),a},t.prototype.modify=function(t,e,n,i){var r=n||i||this,o=px(sx(t),this._getStoreDimIndex,this);// If do shallow clone here, if there are too many stacked series,
// it still cost lots of memory, because `_store.dimensions` are not shared.
// We should consider there probably be shallow clone happen in each series
// in consequent filter/map.
this._store.modify(o,r?B(e,r):e)},
/**
               * Large data down sampling on given dimension
               * @param sampleIndex Sample index for name and id
               */
t.prototype.downSample=function(t,e,n,i){var r=ux(this);return r._store=this._store.downSample(this._getStoreDimIndex(t),e,n,i),r},
/**
               * Large data down sampling using largest-triangle-three-buckets
               * @param {string} valueDimension
               * @param {number} targetCount
               */
t.prototype.lttbDownSample=function(t,e){var n=ux(this);return n._store=this._store.lttbDownSample(this._getStoreDimIndex(t),e),n},t.prototype.getRawDataItem=function(t){return this._store.getRawDataItem(t)},
/**
               * Get model of one data item.
               */
// TODO: Type of data item
t.prototype.getItemModel=function(t){var e=this.hostModel,n=this.getRawDataItem(t);return new Pc(n,e,e&&e.ecModel)},
/**
               * Create a data differ
               */
t.prototype.diff=function(t){var e=this;return new Um(t?t.getStore().getIndices():[],this.getStore().getIndices(),(function(e){return ox(t,e)}),(function(t){return ox(e,t)}))},
/**
               * Get visual property.
               */
t.prototype.getVisual=function(t){var e=this._visual;return e&&e[t]},t.prototype.setVisual=function(t,e){this._visual=this._visual||{},cx(t)?A(this._visual,t):this._visual[t]=e},
/**
               * Get visual property of single data item
               */
// eslint-disable-next-line
t.prototype.getItemVisual=function(t,e){var n=this._itemVisuals[t],i=n&&n[e];return null==i?this.getVisual(e):i},
/**
               * If exists visual property of single data item
               */
t.prototype.hasItemVisual=function(){return this._itemVisuals.length>0},
/**
               * Make sure itemVisual property is unique
               */
// TODO: use key to save visual to reduce memory.
t.prototype.ensureUniqueItemVisual=function(t,e){var n=this._itemVisuals,i=n[t];i||(i=n[t]={});var r=i[e];return null==r&&(// TODO Performance?
G(r=this.getVisual(e))?r=r.slice():cx(r)&&(r=A({},r)),i[e]=r),r},// eslint-disable-next-line
t.prototype.setItemVisual=function(t,e,n){var i=this._itemVisuals[t]||{};this._itemVisuals[t]=i,cx(e)?A(i,e):i[e]=n},
/**
               * Clear itemVisuals and list visual.
               */
t.prototype.clearAllVisual=function(){this._visual={},this._itemVisuals=[]},t.prototype.setLayout=function(t,e){cx(t)?A(this._layout,t):this._layout[t]=e},
/**
               * Get layout property.
               */
t.prototype.getLayout=function(t){return this._layout[t]},
/**
               * Get layout of single data item
               */
t.prototype.getItemLayout=function(t){return this._itemLayouts[t]},
/**
               * Set layout of single data item
               */
t.prototype.setItemLayout=function(t,e,n){this._itemLayouts[t]=n?A(this._itemLayouts[t]||{},e):e},
/**
               * Clear all layout of single data item
               */
t.prototype.clearItemLayouts=function(){this._itemLayouts.length=0},
/**
               * Set graphic element relative to data. It can be set as null
               */
t.prototype.setItemGraphicEl=function(t,e){var n=this.hostModel&&this.hostModel.seriesIndex;qs(n,this.dataType,t,e),this._graphicEls[t]=e},t.prototype.getItemGraphicEl=function(t){return this._graphicEls[t]},t.prototype.eachItemGraphicEl=function(t,e){R(this._graphicEls,(function(n,i){n&&t&&t.call(e,n,i)}))},
/**
               * Shallow clone a new list except visual and layout properties, and graph elements.
               * New list only change the indices.
               */
t.prototype.cloneShallow=function(e){return e||(e=new t(this._schema?this._schema:px(this.dimensions,this._getDimInfo,this),this.hostModel)),lx(e,this),e._store=this._store,e},
/**
               * Wrap some method to add more feature
               */
t.prototype.wrapMethod=function(t,e){var n=this[t];W(n)&&(this.__wrappedMethods=this.__wrappedMethods||[],this.__wrappedMethods.push(t),this[t]=function(){var t=n.apply(this,arguments);return e.apply(this,[t].concat(et(arguments)))})},// ----------------------------------------------------------
// A work around for internal method visiting private member.
// ----------------------------------------------------------
t.internalField=(rx=function(t){var e=t._invertedIndicesMap;R(e,(function(n,i){var r=t._dimInfos[i],o=r.ordinalMeta,a=t._store;// Currently, only dimensions that has ordinalMeta can create inverted indices.
if(o){n=e[i]=new dx(o.categories.length);// The default value of TypedArray is 0. To avoid miss
// mapping to 0, we should set it as INDEX_NOT_FOUND.
for(var s=0;s<n.length;s++)n[s]=-1;for(s=0;s<a.count();s++)// Only support the case that all values are distinct.
n[a.get(r.storeDimIndex,s)]=s}}))},ax=function(t,e,n){return vo(t._getCategory(e,n),null)},
/**
                 * @see the comment of `List['getId']`.
                 */
ox=function(t,e){var n=t._idList[e];return null==n&&null!=t._idDimIdx&&(n=ax(t,t._idDimIdx,e)),null==n&&(n="e\0\0"+e),n},sx=function(t){return G(t)||(t=null!=t?[t]:[]),t},
/**
                 * Data in excludeDimensions is copied, otherwise transferred.
                 */
ux=function(e){var n=new t(e._schema?e._schema:px(e.dimensions,e._getDimInfo,e),e.hostModel);// FIXME If needs stackedOn, value may already been stacked
return lx(n,e),n},lx=function(t,e){R(fx.concat(e.__wrappedMethods||[]),(function(n){e.hasOwnProperty(n)&&(t[n]=e[n])})),t.__wrappedMethods=e.__wrappedMethods,R(gx,(function(n){t[n]=T(e[n])})),t._calculationInfo=A({},e._calculationInfo)},void(hx=function(t,e){var n=t._nameList,i=t._idList,r=t._nameDimIdx,o=t._idDimIdx,a=n[e],s=i[e];if(null==a&&null!=r&&(n[e]=a=ax(t,r,e)),null==s&&null!=o&&(i[e]=s=ax(t,o,e)),null==s&&null!=a){var l=t._nameRepeatCount,u=l[a]=(l[a]||0)+1;s=a,u>1&&(s+="__ec__"+u),i[e]=s}})),t}();const vx=yx;
/**
             * This method builds the relationship between:
             * + "what the coord sys or series requires (see `coordDimensions`)",
             * + "what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)"
             * + "what the data source provids (see `source`)".
             *
             * Some guess strategy will be adapted if user does not define something.
             * If no 'value' dimension specified, the first no-named dimension will be
             * named as 'value'.
             *
             * @return The results are always sorted by `storeDimIndex` asc.
             */function mx(// TODO: TYPE completeDimensions type
t,e){lf(t)||(t=hf(t));var n=(e=e||{}).coordDimensions||[],i=e.dimensionsDefine||t.dimensionsDefine||[],r=ct(),o=[],a=// ??? TODO
// Originally detect dimCount by data[0]. Should we
// optimize it to only by sysDims and dimensions and encode.
// So only necessary dims will be initialized.
// But
// (1) custom series should be considered. where other dims
// may be visited.
// (2) sometimes user need to calculate bubble size or use visualMap
// on other dimensions besides coordSys needed.
// So, dims that is not used by system, should be shared in data store?
function(t,e,n,i){// Note that the result dimCount should not small than columns count
// of data, otherwise `dataDimNameMap` checking will be incorrect.
var r=Math.max(t.dimensionsDetectedCount||1,e.length,n.length,i||0);return R(e,(function(t){var e;U(t)&&(e=t.dimsDef)&&(r=Math.max(r,e.length))})),r}(t,n,i,e.dimensionsCount),s=e.canOmitUnusedDimensions&&ix(a),l=i===t.dimensionsDefine,u=l?nx(t):ex(i),h=e.encodeDefine;!h&&e.encodeDefaulter&&(h=e.encodeDefaulter(t,a));for(var c=ct(h),p=new Qf(a),d=0;d<p.length;d++)p[d]=-1;function f(t){var e=p[t];if(e<0){var n=i[t],r=U(n)?n:{name:n},a=new Km,s=r.name;null!=s&&null!=u.get(s)&&(// Only if `series.dimensions` is defined in option
// displayName, will be set, and dimension will be displayed vertically in
// tooltip by default.
a.name=a.displayName=s),null!=r.type&&(a.type=r.type),null!=r.displayName&&(a.displayName=r.displayName);var l=o.length;return p[t]=l,a.storeDimIndex=t,o.push(a),a}return o[e]}if(!s)for(d=0;d<a;d++)f(d);// Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.
c.each((function(t,e){var n=lo(t).slice();// Note: It is allowed that `dataDims.length` is `0`, e.g., options is
// `{encode: {x: -1, y: 1}}`. Should not filter anything in
// this case.
if(1===n.length&&!H(n[0])&&n[0]<0)c.set(e,!1);else{var i=c.set(e,[]);R(n,(function(t,n){// The input resultDimIdx can be dim name or index.
var r=H(t)?u.get(t):t;null!=r&&r<a&&(i[n]=r,y(f(r),e,n))}))}}));// Apply templates and default order from `sysDims`.
var g=0;function y(t,e,n){null!=Up.get(e)?t.otherDims[e]=n:(t.coordDim=e,t.coordDimIndex=n,r.set(e,!0))}// Make sure the first extra dim is 'value'.
R(n,(function(t){var e,n,i,r;if(H(t))e=t,r={};else{e=(r=t).name;var o=r.ordinalMeta;r.ordinalMeta=null,(r=A({},r)).ordinalMeta=o,// `coordDimIndex` should not be set directly.
n=r.dimsDef,i=r.otherDims,r.name=r.coordDim=r.coordDimIndex=r.dimsDef=r.otherDims=null}var s=c.get(e);// negative resultDimIdx means no need to mapping.
if(!1!==s){// dimensions provides default dim sequences.
if(!(s=lo(s)).length)for(var u=0;u<(n&&n.length||1);u++){for(;g<a&&null!=f(g).coordDim;)g++;g<a&&s.push(g++)}// Apply templates.
R(s,(function(t,o){var a=f(t);// Coordinate system has a higher priority on dim type than source.
if(l&&null!=r.type&&(a.type=r.type),y(k(a,r),e,o),null==a.name&&n){var s=n[o];!U(s)&&(s={name:s}),a.name=a.displayName=s.name,a.defaultTooltip=s.defaultTooltip}// FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}
i&&k(a.otherDims,i)}))}}));var v=e.generateCoord,m=e.generateCoordCount,x=null!=m;m=v?m||1:0;var _=v||"value";function b(t){null==t.name&&(// Duplication will be removed in the next step.
t.name=t.coordDim)}// Set dim `name` and other `coordDim` and other props.
if(s)R(o,(function(t){// PENDING: guessOrdinal or let user specify type: 'ordinal' manually?
b(t)})),// Sort dimensions: there are some rule that use the last dim as label,
// and for some latter travel process easier.
o.sort((function(t,e){return t.storeDimIndex-e.storeDimIndex}));else for(var w=0;w<a;w++){var S=f(w);null==S.coordDim&&(// TODO no need to generate coordDim for isExtraCoord?
S.coordDim=xx(_,r,x),S.coordDimIndex=0,// Series specified generateCoord is using out.
(!v||m<=0)&&(S.isExtraCoord=!0),m--),b(S),null!=S.type||ld(t,w)!==ed&&(!S.isExtraCoord||null==S.otherDims.itemName&&null==S.otherDims.seriesName)||(S.type="ordinal")}return function(t){for(var e=ct(),n=0;n<t.length;n++){var i=t[n],r=i.name,o=e.get(r)||0;o>0&&(// Starts from 0.
i.name=r+(o-1)),o++,e.set(r,o)}}(o),new Qm({source:t,dimensions:o,fullDimensionCount:a,dimensionOmitted:s})}function xx(t,e,n){if(n||e.hasKey(t)){for(var i=0;e.hasKey(t+i);)i++;t+=i}return e.set(t,!0),t}
/**
             * @class
             * For example:
             * {
             *     coordSysName: 'cartesian2d',
             *     coordSysDims: ['x', 'y', ...],
             *     axisMap: HashMap({
             *         x: xAxisModel,
             *         y: yAxisModel
             *     }),
             *     categoryAxisMap: HashMap({
             *         x: xAxisModel,
             *         y: undefined
             *     }),
             *     // The index of the first category axis in `coordSysDims`.
             *     // `null/undefined` means no category axis exists.
             *     firstCategoryDimIndex: 1,
             *     // To replace user specified encode.
             * }
             */var _x=function(t){this.coordSysDims=[],this.axisMap=ct(),this.categoryAxisMap=ct(),this.coordSysName=t},bx={cartesian2d:function(t,e,n,i){var r=t.getReferringComponents("xAxis",Io).models[0],o=t.getReferringComponents("yAxis",Io).models[0];e.coordSysDims=["x","y"],n.set("x",r),n.set("y",o),Sx(r)&&(i.set("x",r),e.firstCategoryDimIndex=0),Sx(o)&&(i.set("y",o),null==e.firstCategoryDimIndex&&(e.firstCategoryDimIndex=1))},singleAxis:function(t,e,n,i){var r=t.getReferringComponents("singleAxis",Io).models[0];e.coordSysDims=["single"],n.set("single",r),Sx(r)&&(i.set("single",r),e.firstCategoryDimIndex=0)},polar:function(t,e,n,i){var r=t.getReferringComponents("polar",Io).models[0],o=r.findAxisModel("radiusAxis"),a=r.findAxisModel("angleAxis");e.coordSysDims=["radius","angle"],n.set("radius",o),n.set("angle",a),Sx(o)&&(i.set("radius",o),e.firstCategoryDimIndex=0),Sx(a)&&(i.set("angle",a),null==e.firstCategoryDimIndex&&(e.firstCategoryDimIndex=1))},geo:function(t,e,n,i){e.coordSysDims=["lng","lat"]},parallel:function(t,e,n,i){var r=t.ecModel,o=r.getComponent("parallel",t.get("parallelIndex")),a=e.coordSysDims=o.dimensions.slice();R(o.parallelAxisIndex,(function(t,o){var s=r.getComponent("parallelAxis",t),l=a[o];n.set(l,s),Sx(s)&&(i.set(l,s),null==e.firstCategoryDimIndex&&(e.firstCategoryDimIndex=o))}))}};function Sx(t){return"category"===t.get("type")}
/**
             * Note that it is too complicated to support 3d stack by value
             * (have to create two-dimension inverted index), so in 3d case
             * we just support that stacked by index.
             *
             * @param seriesModel
             * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.
             *        The input will be modified.
             * @param opt
             * @param opt.stackedCoordDimension Specify a coord dimension if needed.
             * @param opt.byIndex=false
             * @return calculationInfo
             * {
             *     stackedDimension: string
             *     stackedByDimension: string
             *     isStackedByIndex: boolean
             *     stackedOverDimension: string
             *     stackResultDimension: string
             * }
             */function Mx(t,e,n){var i,r,o,a=(n=n||{}).byIndex,s=n.stackedCoordDimension;!function(t){return!tx(t.schema)}(e)?(r=e.schema,i=r.dimensions,o=e.store):i=e;// Compatibal: when `stack` is set as '', do not stack.
var l,u,h,c,p=!(!t||!t.get("stack"));// Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
// That put stack logic in List is for using conveniently in echarts extensions, but it
// might not be a good way.
if(R(i,(function(t,e){H(t)&&(i[e]=t={name:t}),p&&!t.isExtraCoord&&(// Find the first ordinal dimension as the stackedByDimInfo.
a||l||!t.ordinalMeta||(l=t),// Find the first stackable dimension as the stackedDimInfo.
u||"ordinal"===t.type||"time"===t.type||s&&s!==t.coordDim||(u=t))})),!u||a||l||(// Compatible with previous design, value axis (time axis) only stack by index.
// It may make sense if the user provides elaborately constructed data.
a=!0),u){// Use a weird name that not duplicated with other names.
// Also need to use seriesModel.id as postfix because different
// series may share same data store. The stack dimension needs to be distinguished.
h="__\0ecstackresult_"+t.id,c="__\0ecstackedover_"+t.id,// Create inverted index to fast query index by value.
l&&(l.createInvertedIndices=!0);var d=u.coordDim,f=u.type,g=0;R(i,(function(t){t.coordDim===d&&g++}));var y={name:h,coordDim:d,coordDimIndex:g,type:f,isExtraCoord:!0,isCalculationCoord:!0,storeDimIndex:i.length},v={name:c,// This dimension contains stack base (generally, 0), so do not set it as
// `stackedDimCoordDim` to avoid extent calculation, consider log scale.
coordDim:c,coordDimIndex:g+1,type:f,isExtraCoord:!0,isCalculationCoord:!0,storeDimIndex:i.length+1};r?(o&&(y.storeDimIndex=o.ensureCalculationDimension(c,f),v.storeDimIndex=o.ensureCalculationDimension(h,f)),r.appendCalculationDimension(y),r.appendCalculationDimension(v)):(i.push(y),i.push(v))}return{stackedDimension:u&&u.name,stackedByDimension:l&&l.name,isStackedByIndex:a,stackedOverDimension:c,stackResultDimension:h}}function Ix(t,e){// Each single series only maps to one pair of axis. So we do not need to
// check stackByDim, whatever stacked by a dimension or stacked by index.
return!!e&&e===t.getCalculationInfo("stackedDimension")}function Tx(t,e){return Ix(t,e)?t.getCalculationInfo("stackResultDimension"):e}
/**
             * Caution: there are side effects to `sourceManager` in this method.
             * Should better only be called in `Series['getInitialData']`.
             */
function Cx(t,e,n){n=n||{};var i,r=e.getSourceManager(),o=!1;t?(o=!0,i=hf(t)):// Is series.data. not dataset.
o=(i=r.getSource()).sourceFormat===Zp;var a=function(t){var e=t.get("coordinateSystem"),n=new _x(e),i=bx[e];if(i)return i(t,n,n.axisMap,n.categoryAxisMap),n}(e),s=function(t,e){var n,i=t.get("coordinateSystem"),r=Ad.get(i);return e&&e.coordSysDims&&(n=N(e.coordSysDims,(function(t){var n={name:t},i=e.axisMap.get(t);if(i){var r=i.get("type");n.type=qm(r)}return n}))),n||(// Get dimensions from registered coordinate system
n=r&&(r.getDimensionsInfo?r.getDimensionsInfo():r.dimensions.slice())||["x","y"]),n}(e,a),l=n.useEncodeDefaulter,u=W(l)?l:l?F(od,s,e):null,h=mx(i,{coordDimensions:s,generateCoord:n.generateCoord,encodeDefine:e.getEncode(),encodeDefaulter:u,canOmitUnusedDimensions:!o}),c=function(t,e,n){var i,r;return n&&R(t,(function(t,o){var a=t.coordDim,s=n.categoryAxisMap.get(a);s&&(null==i&&(i=o),t.ordinalMeta=s.getOrdinalMeta(),e&&(t.createInvertedIndices=!0)),null!=t.otherDims.itemName&&(r=!0)})),r||null==i||(t[i].otherDims.itemName=0),i}(h.dimensions,n.createInvertedIndices,a),p=o?null:r.getSharedDataStore(h),d=Mx(e,{schema:h,store:p}),f=new vx(h,e);f.setCalculationInfo(d);var g=null!=c&&function(t){if(t.sourceFormat===Zp){var e=function(t){for(var e=0;e<t.length&&null==t[e];)e++;return t[e]}(t.data||[]);return!G(co(e))}}(i)?function(t,e,n,i){// Use dataIndex as ordinal value in categoryAxis
return i===c?n:this.defaultDimValueGetter(t,e,n,i)}:null;return f.hasItemOption=!1,f.initData(// Try to reuse the data store in sourceManager if using dataset.
o?i:p,null,g),f}var Dx=/** @class */function(){function t(t){this._setting=t||{},this._extent=[1/0,-1/0]}return t.prototype.getSetting=function(t){return this._setting[t]},
/**
               * Set extent from data
               */
t.prototype.unionExtent=function(t){var e=this._extent;t[0]<e[0]&&(e[0]=t[0]),t[1]>e[1]&&(e[1]=t[1])},
/**
               * Set extent from data
               */
t.prototype.unionExtentFromData=function(t,e){this.unionExtent(t.getApproximateExtent(e))},
/**
               * Get extent
               *
               * Extent is always in increase order.
               */
t.prototype.getExtent=function(){return this._extent.slice()},
/**
               * Set extent
               */
t.prototype.setExtent=function(t,e){var n=this._extent;isNaN(t)||(n[0]=t),isNaN(e)||(n[1]=e)},
/**
               * If value is in extent range
               */
t.prototype.isInExtentRange=function(t){return this._extent[0]<=t&&this._extent[1]>=t},
/**
               * When axis extent depends on data and no data exists,
               * axis ticks should not be drawn, which is named 'blank'.
               */
t.prototype.isBlank=function(){return this._isBlank},
/**
               * When axis extent depends on data and no data exists,
               * axis ticks should not be drawn, which is named 'blank'.
               */
t.prototype.setBlank=function(t){this._isBlank=t},t}();Bo(Dx);const Ax=Dx;var kx=0,Lx=/** @class */function(){function t(t){this.categories=t.categories||[],this._needCollect=t.needCollect,this._deduplication=t.deduplication,this.uid=++kx}return t.createByAxisModel=function(e){var n=e.option,i=n.data,r=i&&N(i,Px);return new t({categories:r,needCollect:!r,// deduplication is default in axis.
deduplication:!1!==n.dedplication})},t.prototype.getOrdinal=function(t){// @ts-ignore
return this._getOrCreateMap().get(t)},
/**
               * @return The ordinal. If not found, return NaN.
               */
t.prototype.parseAndCollect=function(t){var e,n=this._needCollect;// The value of category dim can be the index of the given category set.
// This feature is only supported when !needCollect, because we should
// consider a common case: a value is 2017, which is a number but is
// expected to be tread as a category. This case usually happen in dataset,
// where it happent to be no need of the index feature.
if(!H(t)&&!n)return t;// Optimize for the scenario:
// category is ['2012-01-01', '2012-01-02', ...], where the input
// data has been ensured not duplicate and is large data.
// Notice, if a dataset dimension provide categroies, usually echarts
// should remove duplication except user tell echarts dont do that
// (set axis.deduplication = false), because echarts do not know whether
// the values in the category dimension has duplication (consider the
// parallel-aqi example)
if(n&&!this._deduplication)return e=this.categories.length,this.categories[e]=t,e;var i=this._getOrCreateMap();// @ts-ignore
return null==(e=i.get(t))&&(n?(e=this.categories.length,this.categories[e]=t,// @ts-ignore
i.set(t,e)):e=NaN),e},// Consider big data, do not create map until needed.
t.prototype._getOrCreateMap=function(){return this._map||(this._map=ct(this.categories))},t}();function Px(t){return U(t)&&null!=t.value?t.value:t+""}const Ox=Lx;function Rx(t){return"interval"===t.type||"log"===t.type}
/**
             * @param extent Both extent[0] and extent[1] should be valid number.
             *               Should be extent[0] < extent[1].
             * @param splitNumber splitNumber should be >= 1.
             */function Nx(t,e,n,i){var r={},o=t[1]-t[0],a=r.interval=Kr(o/e,!0);null!=n&&a<n&&(a=r.interval=n),null!=i&&a>i&&(a=r.interval=i);// Tow more digital for tick.
var s=r.intervalPrecision=zx(a);// Niced extent inside original extent
// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.
return function(t,e){!isFinite(t[0])&&(t[0]=e[0]),!isFinite(t[1])&&(t[1]=e[1]),Vx(t,0,e),Vx(t,1,e),t[0]>t[1]&&(t[0]=t[1])}(r.niceTickExtent=[Br(Math.ceil(t[0]/a)*a,s),Br(Math.floor(t[1]/a)*a,s)],t),r}function Ex(t){var e=Math.pow(10,qr(t)),n=t/e;// Increase interval
return n?2===n?n=3:3===n?n=5:// f is 1 or 5
n*=2:n=1,Br(n*e)}
/**
             * @return interval precision
             */function zx(t){// Tow more digital for tick.
return Gr(t)+2}function Vx(t,e,n){t[e]=Math.max(Math.min(t[e],n[1]),n[0])}function Bx(t,e){return t>=e[0]&&t<=e[1]}function Fx(t,e){return e[1]===e[0]?.5:(t-e[0])/(e[1]-e[0])}function Gx(t,e){return t*(e[1]-e[0])+e[0]}var Wx=/** @class */function(t){function e(e){var n=t.call(this,e)||this;n.type="ordinal";var i=n.getSetting("ordinalMeta");// Caution: Should not use instanceof, consider ec-extensions using
// import approach to get OrdinalMeta class.
return i||(i=new Ox({})),G(i)&&(i=new Ox({categories:N(i,(function(t){return U(t)?t.value:t}))})),n._ordinalMeta=i,n._extent=n.getSetting("extent")||[0,i.categories.length-1],n}return n(e,t),e.prototype.parse=function(t){// Caution: Math.round(null) will return `0` rather than `NaN`
return null==t?NaN:H(t)?this._ordinalMeta.getOrdinal(t):Math.round(t)},e.prototype.contain=function(t){return Bx(t=this.parse(t),this._extent)&&null!=this._ordinalMeta.categories[t]},
/**
               * Normalize given rank or name to linear [0, 1]
               * @param val raw ordinal number.
               * @return normalized value in [0, 1].
               */
e.prototype.normalize=function(t){return Fx(t=this._getTickNumber(this.parse(t)),this._extent)},
/**
               * @param val normalized value in [0, 1].
               * @return raw ordinal number.
               */
e.prototype.scale=function(t){return t=Math.round(Gx(t,this._extent)),this.getRawOrdinalNumber(t)},e.prototype.getTicks=function(){for(var t=[],e=this._extent,n=e[0];n<=e[1];)t.push({value:n}),n++;return t},e.prototype.getMinorTicks=function(t){},
/**
               * @see `Ordinal['_ordinalNumbersByTick']`
               */
e.prototype.setSortInfo=function(t){if(null!=t){for(var e=t.ordinalNumbers,n=this._ordinalNumbersByTick=[],i=this._ticksByOrdinalNumber=[],r=0,o=this._ordinalMeta.categories.length,a=Math.min(o,e.length);r<a;++r){var s=e[r];n[r]=s,i[s]=r}// Handle that `series.data` only covers part of the `axis.category.data`.
for(var l=0;r<o;++r){for(;null!=i[l];)l++;n.push(l),i[l]=r}}else this._ordinalNumbersByTick=this._ticksByOrdinalNumber=null},e.prototype._getTickNumber=function(t){var e=this._ticksByOrdinalNumber;// also support ordinal out of range of `ordinalMeta.categories.length`,
// where ordinal numbers are used as tick value directly.
return e&&t>=0&&t<e.length?e[t]:t},
/**
               * @usage
               * ```js
               * const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);
               *
               * // case0
               * const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];
               * // case1
               * const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];
               * // case2
               * const coord = axis.dataToCoord(ordinalNumber);
               * ```
               *
               * @param {OrdinalNumber} tickNumber index of display
               */
e.prototype.getRawOrdinalNumber=function(t){var e=this._ordinalNumbersByTick;// tickNumber may be out of range, e.g., when axis max is larger than `ordinalMeta.categories.length`.,
// where ordinal numbers are used as tick value directly.
return e&&t>=0&&t<e.length?e[t]:t},
/**
               * Get item on tick
               */
e.prototype.getLabel=function(t){if(!this.isBlank()){var e=this.getRawOrdinalNumber(t.value),n=this._ordinalMeta.categories[e];// Note that if no data, ordinalMeta.categories is an empty array.
// Return empty if it's not exist.
return null==n?"":n+""}},e.prototype.count=function(){return this._extent[1]-this._extent[0]+1},e.prototype.unionExtentFromData=function(t,e){this.unionExtent(t.getApproximateExtent(e))},
/**
               * @override
               * If value is in extent range
               */
e.prototype.isInExtentRange=function(t){return t=this._getTickNumber(t),this._extent[0]<=t&&this._extent[1]>=t},e.prototype.getOrdinalMeta=function(){return this._ordinalMeta},e.prototype.calcNiceTicks=function(){},e.prototype.calcNiceExtent=function(){},e.type="ordinal",e}(Ax);Ax.registerClass(Wx);const Hx=Wx;var Yx=Br,Xx=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="interval",// Step is calculated in adjustExtent.
e._interval=0,e._intervalPrecision=2,e}return n(e,t),e.prototype.parse=function(t){return t},e.prototype.contain=function(t){return Bx(t,this._extent)},e.prototype.normalize=function(t){return Fx(t,this._extent)},e.prototype.scale=function(t){return Gx(t,this._extent)},e.prototype.setExtent=function(t,e){var n=this._extent;// start,end may be a Number like '25',so...
isNaN(t)||(n[0]=parseFloat(t)),isNaN(e)||(n[1]=parseFloat(e))},e.prototype.unionExtent=function(t){var e=this._extent;t[0]<e[0]&&(e[0]=t[0]),t[1]>e[1]&&(e[1]=t[1]),// unionExtent may called by it's sub classes
this.setExtent(e[0],e[1])},e.prototype.getInterval=function(){return this._interval},e.prototype.setInterval=function(t){this._interval=t,// Dropped auto calculated niceExtent and use user-set extent.
// We assume user wants to set both interval, min, max to get a better result.
this._niceExtent=this._extent.slice(),this._intervalPrecision=zx(t)},
/**
               * @param expandToNicedExtent Whether expand the ticks to niced extent.
               */
e.prototype.getTicks=function(t){var e=this._interval,n=this._extent,i=this._niceExtent,r=this._intervalPrecision,o=[];// If interval is 0, return [];
if(!e)return o;// Consider this case: using dataZoom toolbox, zoom and zoom.
n[0]<i[0]&&(t?o.push({value:Yx(i[0]-e,r)}):o.push({value:n[0]}));for(var a=i[0];a<=i[1]&&(o.push({value:a}),(// Avoid rounding error
a=Yx(a+e,r))!==o[o.length-1].value);)if(o.length>1e4)return[];// Consider this case: the last item of ticks is smaller
// than niceTickExtent[1] and niceTickExtent[1] === extent[1].
var s=o.length?o[o.length-1].value:i[1];return n[1]>s&&(t?o.push({value:Yx(s+e,r)}):o.push({value:n[1]})),o},e.prototype.getMinorTicks=function(t){for(var e=this.getTicks(!0),n=[],i=this.getExtent(),r=1;r<e.length;r++){for(var o=e[r],a=e[r-1],s=0,l=[],u=(o.value-a.value)/t;s<t-1;){var h=Yx(a.value+(s+1)*u);// For the first and last interval. The count may be less than splitNumber.
h>i[0]&&h<i[1]&&l.push(h),s++}n.push(l)}return n},
/**
               * @param opt.precision If 'auto', use nice presision.
               * @param opt.pad returns 1.50 but not 1.5 if precision is 2.
               */
e.prototype.getLabel=function(t,e){if(null==t)return"";var n=e&&e.precision;return null==n?n=Gr(t.value)||0:"auto"===n&&(// Should be more precise then tick.
n=this._intervalPrecision),_p(Yx(t.value,n,!0))},
/**
               * @param splitNumber By default `5`.
               */
e.prototype.calcNiceTicks=function(t,e,n){t=t||5;var i=this._extent,r=i[1]-i[0];if(isFinite(r)){// User may set axis min 0 and data are all negative
// FIXME If it needs to reverse ?
r<0&&(r=-r,i.reverse());var o=Nx(i,t,e,n);this._intervalPrecision=o.intervalPrecision,this._interval=o.interval,this._niceExtent=o.niceTickExtent}},e.prototype.calcNiceExtent=function(t){var e=this._extent;// If extent start and end are same, expand them
if(e[0]===e[1])if(0!==e[0]){// Expand extent
// Note that extents can be both negative. See #13154
var n=Math.abs(e[0]);// In the fowllowing case
//      Axis has been fixed max 100
//      Plus data are all 100 and axis extent are [100, 100].
// Extend to the both side will cause expanded max is larger than fixed max.
// So only expand to the smaller side.
t.fixMax||(e[1]+=n/2),e[0]-=n/2}else e[1]=1;var i=e[1]-e[0];// If there are no data and extent are [Infinity, -Infinity]
isFinite(i)||(e[0]=0,e[1]=1),this.calcNiceTicks(t.splitNumber,t.minInterval,t.maxInterval);// let extent = this._extent;
var r=this._interval;t.fixMin||(e[0]=Yx(Math.floor(e[0]/r)*r)),t.fixMax||(e[1]=Yx(Math.ceil(e[1]/r)*r))},e.prototype.setNiceExtent=function(t,e){this._niceExtent=[t,e]},e.type="interval",e}(Ax);Ax.registerClass(Xx);const Ux=Xx;/* global Float32Array */var Zx="undefined"!=typeof Float32Array,jx=Zx?Float32Array:Array;function qx(t){return G(t)?Zx?new Float32Array(t):t:new jx(t);// Else is number
}var Kx="__ec_stack_";function $x(t){return t.get("stack")||Kx+t.seriesIndex}function Jx(t){return t.dim+t.index}
/**
             * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
             */function Qx(t,e){var n=[];return e.eachSeriesByType(t,(function(t){// Check series coordinate, do layout for cartesian2d only
r_(t)&&n.push(t)})),n}
/**
             * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
             * values.
             * This works for time axes, value axes, and log axes.
             * For a single time axis, return value is in the form like
             * {'x_0': [1000000]}.
             * The value of 1000000 is in milliseconds.
             */function t_(t){var e=function(t){
/**
               * Map from axis.index to values.
               * For a single time axis, axisValues is in the form like
               * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
               * Items in axisValues[x], e.g. 1495555200000, are time values of all
               * series.
               */
var e={};R(t,(function(t){var n=t.coordinateSystem.getBaseAxis();if("time"===n.type||"value"===n.type)for(var i=t.getData(),r=n.dim+"_"+n.index,o=i.getDimensionIndex(i.mapDimension(n.dim)),a=i.getStore(),s=0,l=a.count();s<l;++s){var u=a.get(o,s);e[r]?// No value in previous series
e[r].push(u):// No previous data for the axis
e[r]=[u];// Ignore duplicated time values in the same axis
}}));var n={};for(var i in e)if(e.hasOwnProperty(i)){var r=e[i];if(r){// Sort axis values into ascending order to calculate gaps
r.sort((function(t,e){return t-e}));for(var o=null,a=1;a<r.length;++a){var s=r[a]-r[a-1];s>0&&(// Ignore 0 delta because they are of the same axis value
o=null===o?s:Math.min(o,s))}// Set to null if only have one data
n[i]=o}}return n}(t),n=[];return R(t,(function(t){var i,r=t.coordinateSystem.getBaseAxis(),o=r.getExtent();if("category"===r.type)i=r.getBandWidth();else if("value"===r.type||"time"===r.type){var a=r.dim+"_"+r.index,s=e[a],l=Math.abs(o[1]-o[0]),u=r.scale.getExtent(),h=Math.abs(u[1]-u[0]);i=s?l/h*s:l}else{var c=t.getData();i=Math.abs(o[1]-o[0])/c.count()}var p=Vr(t.get("barWidth"),i),d=Vr(t.get("barMaxWidth"),i),f=Vr(// barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
// the auto-calculated bar width might be less than 0.5 / 1.
t.get("barMinWidth")||(o_(t)?.5:1),i),g=t.get("barGap"),y=t.get("barCategoryGap");n.push({bandWidth:i,barWidth:p,barMaxWidth:d,barMinWidth:f,barGap:g,barCategoryGap:y,axisKey:Jx(r),stackId:$x(t)})})),e_(n)}function e_(t){// Columns info on each category axis. Key is cartesian name
var e={};R(t,(function(t,n){var i=t.axisKey,r=t.bandWidth,o=e[i]||{bandWidth:r,remainedWidth:r,autoWidthCount:0,categoryGap:null,gap:"20%",stacks:{}},a=o.stacks;e[i]=o;var s=t.stackId;a[s]||o.autoWidthCount++,a[s]=a[s]||{width:0,maxWidth:0};// Caution: In a single coordinate system, these barGrid attributes
// will be shared by series. Consider that they have default values,
// only the attributes set on the last series will work.
// Do not change this fact unless there will be a break change.
var l=t.barWidth;l&&!a[s].width&&(// See #6312, do not restrict width.
a[s].width=l,l=Math.min(o.remainedWidth,l),o.remainedWidth-=l);var u=t.barMaxWidth;u&&(a[s].maxWidth=u);var h=t.barMinWidth;h&&(a[s].minWidth=h);var c=t.barGap;null!=c&&(o.gap=c);var p=t.barCategoryGap;null!=p&&(o.categoryGap=p)}));var n={};return R(e,(function(t,e){n[e]={};var i=t.stacks,r=t.bandWidth,o=t.categoryGap;if(null==o){var a=V(i).length;// More columns in one group
// the spaces between group is smaller. Or the column will be too thin.
o=Math.max(35-4*a,15)+"%"}var s=Vr(o,r),l=Vr(t.gap,1),u=t.remainedWidth,h=t.autoWidthCount,c=(u-s)/(h+(h-1)*l);c=Math.max(c,0),// Find if any auto calculated bar exceeded maxBarWidth
R(i,(function(t){var e=t.maxWidth,n=t.minWidth;if(t.width)i=t.width,e&&(i=Math.min(i,e)),// `minWidth` has higher priority, as described above
n&&(i=Math.max(i,n)),t.width=i,u-=i+l*i,h--;else{var i=c;e&&e<i&&(i=Math.min(e,u)),// `minWidth` has higher priority. `minWidth` decide that whether the
// bar is able to be visible. So `minWidth` should not be restricted
// by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In
// the extreme cases for `value` axis, bars are allowed to overlap
// with each other if `minWidth` specified.
n&&n>i&&(i=n),i!==c&&(t.width=i,u-=i+l*i,h--)}})),// Recalculate width again
c=(u-s)/(h+(h-1)*l),c=Math.max(c,0);var p,d=0;R(i,(function(t,e){t.width||(t.width=c),p=t,d+=t.width*(1+l)})),p&&(d-=p.width*l);var f=-d/2;R(i,(function(t,i){n[e][i]=n[e][i]||{bandWidth:r,offset:f,width:t.width},f+=t.width*(1+l)}))})),n}function n_(t,e){var n=Qx(t,e),i=t_(n);R(n,(function(t){var e=t.getData(),n=t.coordinateSystem.getBaseAxis(),r=$x(t),o=i[Jx(n)][r],a=o.offset,s=o.width;e.setLayout({bandWidth:o.bandWidth,offset:a,size:s})}))}// TODO: Do not support stack in large mode yet.
function i_(t){return{seriesType:t,plan:Fg(),reset:function(t){if(r_(t)){var e=t.getData(),n=t.coordinateSystem,i=n.getBaseAxis(),r=n.getOtherAxis(i),o=e.getDimensionIndex(e.mapDimension(r.dim)),a=e.getDimensionIndex(e.mapDimension(i.dim)),s=t.get("showBackground",!0),l=e.mapDimension(r.dim),u=e.getCalculationInfo("stackResultDimension"),h=Ix(e,l)&&!!e.getCalculationInfo("stackedOnSeries"),c=r.isHorizontal(),p=// See cases in `test/bar-start.html` and `#7412`, `#8747`.
function(t,e){return e.toGlobalCoord(e.dataToCoord("log"===e.type?1:0))}(0,r),d=o_(t),f=t.get("barMinHeight")||0,g=u&&e.getDimensionIndex(u),y=e.getLayout("size"),v=e.getLayout("offset");return{progress:function(t,e){for(var i,r=t.count,l=d&&qx(3*r),u=d&&s&&qx(3*r),m=d&&qx(r),x=n.master.getRect(),_=c?x.width:x.height,b=e.getStore(),w=0;null!=(i=t.next());){var S=b.get(h?g:o,i),M=b.get(a,i),I=p,T=void 0;// Because of the barMinHeight, we can not use the value in
// stackResultDimension directly.
h&&(T=+S-b.get(o,i));var C=void 0,D=void 0,A=void 0,k=void 0;if(c){var L=n.dataToPoint([S,M]);h&&(I=n.dataToPoint([T,M])[0]),C=I,D=L[1]+v,A=L[0]-I,k=y,Math.abs(A)<f&&(A=(A<0?-1:1)*f)}else L=n.dataToPoint([M,S]),h&&(I=n.dataToPoint([M,T])[1]),C=L[0]+v,D=I,A=y,k=L[1]-I,Math.abs(k)<f&&(// Include zero to has a positive bar
k=(k<=0?-1:1)*f);d?(l[w]=C,l[w+1]=D,l[w+2]=c?A:k,u&&(u[w]=c?x.x:C,u[w+1]=c?D:x.y,u[w+2]=_),m[i]=i):e.setItemLayout(i,{x:C,y:D,width:A,height:k}),w+=3}d&&e.setLayout({largePoints:l,largeDataIndices:m,largeBackgroundPoints:u,valueAxisHorizontal:c})}}}}}}function r_(t){return t.coordinateSystem&&"cartesian2d"===t.coordinateSystem.type}function o_(t){return t.pipelineContext&&t.pipelineContext.large}var a_=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="time",n}
/**
               * Get label is mainly for other components like dataZoom, tooltip.
               */return n(e,t),e.prototype.getLabel=function(t){var e=this.getSetting("useUTC");return ip(t.value,$c[function(t){switch(t){case"year":case"month":return"day";case"millisecond":return"millisecond";default:// Also for day, hour, minute, second
return"second"}}(ep(this._minLevelUnit))]||$c.second,e,this.getSetting("locale"))},e.prototype.getFormattedLabel=function(t,e,n){var i=this.getSetting("useUTC");return function(t,e,n,i,r){var o=null;if(H(n))// Single formatter for all units at all levels
o=n;else if(W(n))// Callback formatter
o=n(t.value,e,{level:t.level});else{var a=A({},qc);if(t.level>0)for(var s=0;s<Jc.length;++s)a[Jc[s]]="{primary|"+a[Jc[s]]+"}";var l=n?!1===n.inherit?n:k(n,a):a,u=rp(t.value,r);if(l[u])o=l[u];else if(l.inherit){for(s=Qc.indexOf(u)-1;s>=0;--s)if(l[u]){o=l[u];break}o=o||a.none}if(G(o)){var h=null==t.level?0:t.level>=0?t.level:o.length+t.level;o=o[h=Math.min(h,o.length-1)]}}return ip(new Date(t.value),o,r,i)}(t,e,n,this.getSetting("locale"),i)},
/**
               * @override
               */
e.prototype.getTicks=function(){var t=this._interval,e=this._extent,n=[];// If interval is 0, return [];
if(!t)return n;n.push({value:e[0],level:0});var i=this.getSetting("useUTC"),r=function(t,e,n,i){var r=1e4,o=Qc,a=0;function s(t,e,n,r,o,a,s){// if (isDate) {
//     d -= 1; // Starts with 0;   PENDING
// }
for(var l=new Date(e),u=e,h=l[r]();u<n&&u<=i[1];)s.push({value:u}),h+=t,l[o](h),u=l.getTime();// This extra tick is for calcuating ticks of next level. Will not been added to the final result
s.push({value:u,notAdd:!0})}function l(t,r,o){var a=[],l=!r.length;if(!function(t,e,n,i){var r=jr(e),o=jr(n),a=function(t){return op(r,t,i)===op(o,t,i)},s=function(){return a("year")},l=function(){return s()&&a("month")},u=function(){return l()&&a("day")},h=function(){return u()&&a("hour")},c=function(){return h()&&a("minute")},p=function(){return c()&&a("second")},d=function(){return p()&&a("millisecond")};switch(t){case"year":return s();case"month":return l();case"day":return u();case"hour":return h();case"minute":return c();case"second":return p();case"millisecond":return d()}}// const primaryUnitGetters = {
//     year: fullYearGetterName(),
//     month: monthGetterName(),
//     day: dateGetterName(),
//     hour: hoursGetterName(),
//     minute: minutesGetterName(),
//     second: secondsGetterName(),
//     millisecond: millisecondsGetterName()
// };
// const primaryUnitUTCGetters = {
//     year: fullYearGetterName(true),
//     month: monthGetterName(true),
//     day: dateGetterName(true),
//     hour: hoursGetterName(true),
//     minute: minutesGetterName(true),
//     second: secondsGetterName(true),
//     millisecond: millisecondsGetterName(true)
// };
// function moveTick(date: Date, unitName: TimeUnit, step: number, isUTC: boolean) {
//     step = step || 1;
//     switch (getPrimaryTimeUnit(unitName)) {
//         case 'year':
//             date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + step);
//             break;
//         case 'month':
//             date[monthSetterName(isUTC)](date[monthGetterName(isUTC)]() + step);
//             break;
//         case 'day':
//             date[dateSetterName(isUTC)](date[dateGetterName(isUTC)]() + step);
//             break;
//         case 'hour':
//             date[hoursSetterName(isUTC)](date[hoursGetterName(isUTC)]() + step);
//             break;
//         case 'minute':
//             date[minutesSetterName(isUTC)](date[minutesGetterName(isUTC)]() + step);
//             break;
//         case 'second':
//             date[secondsSetterName(isUTC)](date[secondsGetterName(isUTC)]() + step);
//             break;
//         case 'millisecond':
//             date[millisecondsSetterName(isUTC)](date[millisecondsGetterName(isUTC)]() + step);
//             break;
//     }
//     return date.getTime();
// }
// const DATE_INTERVALS = [[8, 7.5], [4, 3.5], [2, 1.5]];
// const MONTH_INTERVALS = [[6, 5.5], [3, 2.5], [2, 1.5]];
// const MINUTES_SECONDS_INTERVALS = [[30, 30], [20, 20], [15, 15], [10, 10], [5, 5], [2, 2]];
(ep(t),i[0],i[1],n)){l&&(r=[{// TODO Optimize. Not include so may ticks.
value:d_(new Date(i[0]),t,n)},{value:i[1]}]);for(var u=0;u<r.length-1;u++){var h=r[u].value,c=r[u+1].value;if(h!==c){var p=void 0,d=void 0,f=void 0,g=!1;switch(t){case"year":p=Math.max(1,Math.round(e/Zc/365)),d=ap(n),f=dp(n);break;case"half-year":case"quarter":case"month":p=u_(e),d=sp(n),f=fp(n);break;case"week":// PENDING If week is added. Ignore day.
case"half-week":case"day":p=l_(e),// Use 32 days and let interval been 16
d=lp(n),f=gp(n),g=!0;break;case"half-day":case"quarter-day":case"hour":p=h_(e),d=up(n),f=yp(n);break;case"minute":p=c_(e,!0),d=hp(n),f=vp(n);break;case"second":p=c_(e,!1),d=cp(n),f=mp(n);break;case"millisecond":p=p_(e),d=pp(n),f=xp(n)}s(p,h,c,d,f,g,a),"year"===t&&o.length>1&&0===u&&// Add nearest years to the left extent.
o.unshift({value:o[0].value-p})}}for(u=0;u<a.length;u++)o.push(a[u]);// newAddedTicks.length && console.log(unitName, newAddedTicks);
return a}}for(var u=[],h=[],c=0,p=0,d=0;d<o.length&&a++<r;++d){var f=ep(o[d]);if(np(o[d])&&(l(o[d],u[u.length-1]||[],h),f!==(o[d+1]?ep(o[d+1]):null))){if(h.length){p=c,// Remove the duplicate so the tick count can be precisely.
h.sort((function(t,e){return t.value-e.value}));for(var g=[],y=0;y<h.length;++y){var v=h[y].value;0!==y&&h[y-1].value===v||(g.push(h[y]),v>=i[0]&&v<=i[1]&&c++)}var m=(i[1]-i[0])/e;// Added too much in this level and not too less in last level
if(c>1.5*m&&p>m/1.5)break;// Only treat primary time unit as one level.
if(u.push(g),c>m||t===o[d])break}// Reset if next unitName is primary
h=[]}}var x=z(N(u,(function(t){return z(t,(function(t){return t.value>=i[0]&&t.value<=i[1]&&!t.notAdd}))})),(function(t){return t.length>0})),_=[],b=x.length-1;for(d=0;d<x.length;++d)for(var w=x[d],S=0;S<w.length;++S)_.push({value:w[S].value,level:b-d});_.sort((function(t,e){return t.value-e.value}));// Remove duplicates
var M=[];for(d=0;d<_.length;++d)0!==d&&_[d].value===_[d-1].value||M.push(_[d]);return M}(this._minLevelUnit,this._approxInterval,i,e);return(n=n.concat(r)).push({value:e[1],level:0}),n},e.prototype.calcNiceExtent=function(t){var e=this._extent;// If extent start and end are same, expand them
// If there are no data and extent are [Infinity, -Infinity]
if(e[0]===e[1]&&(// Expand extent
e[0]-=Zc,e[1]+=Zc),e[1]===-1/0&&e[0]===1/0){var n=new Date;e[1]=+new Date(n.getFullYear(),n.getMonth(),n.getDate()),e[0]=e[1]-Zc}this.calcNiceTicks(t.splitNumber,t.minInterval,t.maxInterval)},e.prototype.calcNiceTicks=function(t,e,n){t=t||10;var i=this._extent,r=i[1]-i[0];this._approxInterval=r/t,null!=e&&this._approxInterval<e&&(this._approxInterval=e),null!=n&&this._approxInterval>n&&(this._approxInterval=n);var o=s_.length,a=Math.min(function(t,e,n,i){for(;n<i;){var r=n+i>>>1;t[r][1]<e?n=r+1:i=r}return n}(s_,this._approxInterval,0,o),o-1);// Interval that can be used to calculate ticks
this._interval=s_[a][1],// Min level used when picking ticks from top down.
// We check one more level to avoid the ticks are to sparse in some case.
this._minLevelUnit=s_[Math.max(a-1,0)][0]},e.prototype.parse=function(t){// val might be float.
return X(t)?t:+jr(t)},e.prototype.contain=function(t){return Bx(this.parse(t),this._extent)},e.prototype.normalize=function(t){return Fx(this.parse(t),this._extent)},e.prototype.scale=function(t){return Gx(t,this._extent)},e.type="time",e}(Ux),s_=[// Format                           interval
["second",Yc],["minute",Xc],["hour",Uc],["quarter-day",216e5],["half-day",432e5],["day",10368e4],["half-week",3024e5],["week",6048e5],["month",26784e5],["quarter",8208e6],["half-year",jc/2],["year",jc]];function l_(t,e){return(t/=Zc)>16?16:t>7.5?7:t>3.5?4:t>1.5?2:1}function u_(t){return(t/=2592e6)>6?6:t>3?3:t>2?2:1}function h_(t){return(t/=Uc)>12?12:t>6?6:t>3.5?4:t>2?2:1}function c_(t,e){return(t/=e?Xc:Yc)>30?30:t>20?20:t>15?15:t>10?10:t>5?5:t>2?2:1}function p_(t){return Kr(t,!0)}function d_(t,e,n){var i=new Date(t);switch(ep(e)){case"year":case"month":i[fp(n)](0);case"day":i[gp(n)](1);case"hour":i[yp(n)](0);case"minute":i[vp(n)](0);case"second":i[mp(n)](0),i[xp(n)](0)}return i.getTime()}Ax.registerClass(a_);const f_=a_;var g_=Ax.prototype,y_=Ux.prototype,v_=Br,m_=Math.floor,x_=Math.ceil,__=Math.pow,b_=Math.log,w_=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="log",e.base=10,e._originalScale=new Ux,// FIXME:TS actually used by `IntervalScale`
e._interval=0,e}
/**
               * @param Whether expand the ticks to niced extent.
               */return n(e,t),e.prototype.getTicks=function(t){var e=this._originalScale,n=this._extent,i=e.getExtent();return N(y_.getTicks.call(this,t),(function(t){var e=t.value,r=Br(__(this.base,e));// Fix #4158
return r=e===n[0]&&this._fixMin?M_(r,i[0]):r,{value:r=e===n[1]&&this._fixMax?M_(r,i[1]):r}}),this)},e.prototype.setExtent=function(t,e){var n=b_(this.base);// log(-Infinity) is NaN, so safe guard here
t=b_(Math.max(0,t))/n,e=b_(Math.max(0,e))/n,y_.setExtent.call(this,t,e)},
/**
               * @return {number} end
               */
e.prototype.getExtent=function(){var t=this.base,e=g_.getExtent.call(this);e[0]=__(t,e[0]),e[1]=__(t,e[1]);// Fix #4158
var n=this._originalScale.getExtent();return this._fixMin&&(e[0]=M_(e[0],n[0])),this._fixMax&&(e[1]=M_(e[1],n[1])),e},e.prototype.unionExtent=function(t){this._originalScale.unionExtent(t);var e=this.base;t[0]=b_(t[0])/b_(e),t[1]=b_(t[1])/b_(e),g_.unionExtent.call(this,t)},e.prototype.unionExtentFromData=function(t,e){// TODO
// filter value that <= 0
this.unionExtent(t.getApproximateExtent(e))},
/**
               * Update interval and extent of intervals for nice ticks
               * @param approxTickNum default 10 Given approx tick number
               */
e.prototype.calcNiceTicks=function(t){t=t||10;var e=this._extent,n=e[1]-e[0];if(!(n===1/0||n<=0)){var i,r=(i=n,Math.pow(10,qr(i)));// Interval should be integer
for(// Filter ticks to get closer to the desired count.
t/n*r<=.5&&(r*=10);!isNaN(r)&&Math.abs(r)<1&&Math.abs(r)>0;)r*=10;var o=[Br(x_(e[0]/r)*r),Br(m_(e[1]/r)*r)];this._interval=r,this._niceExtent=o}},e.prototype.calcNiceExtent=function(t){y_.calcNiceExtent.call(this,t),this._fixMin=t.fixMin,this._fixMax=t.fixMax},e.prototype.parse=function(t){return t},e.prototype.contain=function(t){return Bx(t=b_(t)/b_(this.base),this._extent)},e.prototype.normalize=function(t){return Fx(t=b_(t)/b_(this.base),this._extent)},e.prototype.scale=function(t){return t=Gx(t,this._extent),__(this.base,t)},e.type="log",e}(Ax),S_=w_.prototype;// FIXME:TS refactor: not good to call it directly with `this`?
function M_(t,e){return v_(t,Gr(e))}S_.getMinorTicks=y_.getMinorTicks,S_.getLabel=y_.getLabel,Ax.registerClass(w_);const I_=w_;var T_=/** @class */function(){function t(t,e,// Usually: data extent from all series on this axis.
n){this._prepareParams(t,e,n)}
/**
               * Parameters depending on outside (like model, user callback)
               * are prepared and fixed here.
               */return t.prototype._prepareParams=function(t,e,// Usually: data extent from all series on this axis.
n){n[1]<n[0]&&(n=[NaN,NaN]),this._dataMin=n[0],this._dataMax=n[1];var i=this._isOrdinal="ordinal"===t.type;this._needCrossZero="interval"===t.type&&e.getNeedCrossZero&&e.getNeedCrossZero();var r=this._modelMinRaw=e.get("min",!0);W(r)?// This callback always provides users the full data extent (before data is filtered).
this._modelMinNum=k_(t,r({min:n[0],max:n[1]})):"dataMin"!==r&&(this._modelMinNum=k_(t,r));var o=this._modelMaxRaw=e.get("max",!0);if(W(o)?// This callback always provides users the full data extent (before data is filtered).
this._modelMaxNum=k_(t,o({min:n[0],max:n[1]})):"dataMax"!==o&&(this._modelMaxNum=k_(t,o)),i)// FIXME: there is a flaw here: if there is no "block" data processor like `dataZoom`,
// and progressive rendering is using, here the category result might just only contain
// the processed chunk rather than the entire result.
this._axisDataLen=e.getCategories().length;else{var a=e.get("boundaryGap"),s=G(a)?a:[a||0,a||0];"boolean"==typeof s[0]||"boolean"==typeof s[1]?this._boundaryGapInner=[0,0]:this._boundaryGapInner=[vr(s[0],1),vr(s[1],1)]}},
/**
               * Calculate extent by prepared parameters.
               * This method has no external dependency and can be called duplicatedly,
               * getting the same result.
               * If parameters changed, should call this method to recalcuate.
               */
t.prototype.calculate=function(){// Notice: When min/max is not set (that is, when there are null/undefined,
// which is the most common case), these cases should be ensured:
// (1) For 'ordinal', show all axis.data.
// (2) For others:
//      + `boundaryGap` is applied (if min/max set, boundaryGap is
//      disabled).
//      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
//      be the result that originalExtent enlarged by boundaryGap.
// (3) If no data, it should be ensured that `scale.setBlank` is set.
var t=this._isOrdinal,e=this._dataMin,n=this._dataMax,i=this._axisDataLen,r=this._boundaryGapInner,o=t?null:n-e||Math.abs(e),a="dataMin"===this._modelMinRaw?e:this._modelMinNum,s="dataMax"===this._modelMaxRaw?n:this._modelMaxNum,l=null!=a,u=null!=s;null==a&&(a=t?i?0:NaN:e-r[0]*o),null==s&&(s=t?i?i-1:NaN:n+r[1]*o),(null==a||!isFinite(a))&&(a=NaN),(null==s||!isFinite(s))&&(s=NaN);var h=$(a)||$(s)||t&&!i;// If data extent modified, need to recalculated to ensure cross zero.
this._needCrossZero&&(// Axis is over zero and min is not set
a>0&&s>0&&!l&&(a=0),// Axis is under zero and max is not set
a<0&&s<0&&!u&&(s=0));var c=this._determinedMin,p=this._determinedMax;// Ensure min/max be finite number or NaN here. (not to be null/undefined)
// `NaN` means min/max axis is blank.
return null!=c&&(a=c,l=!0),null!=p&&(s=p,u=!0),{min:a,max:s,minFixed:l,maxFixed:u,isBlank:h}},t.prototype.modifyDataMinMax=function(t,e){this[D_[t]]=e},t.prototype.setDeterminedMinMax=function(t,e){this[C_[t]]=e},t.prototype.freeze=function(){// @ts-ignore
this.frozen=!0},t}(),C_={min:"_determinedMin",max:"_determinedMax"},D_={min:"_dataMin",max:"_dataMax"};
/**
             * Get scale min max and related info only depends on model settings.
             * This method can be called after coordinate system created.
             * For example, in data processing stage.
             *
             * Scale extent info probably be required multiple times during a workflow.
             * For example:
             * (1) `dataZoom` depends it to get the axis extent in "100%" state.
             * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.
             * (3) `coordSys.update` use it to finally decide the scale extent.
             * But the callback of `min`/`max` should not be called multiple times.
             * The code below should not be implemented repeatedly either.
             * So we cache the result in the scale instance, which will be recreated at the beginning
             * of the workflow (because `scale` instance will be recreated each round of the workflow).
             */
function A_(t,e,// Usually: data extent from all series on this axis.
n){// Do not permit to recreate.
var i=t.rawExtentInfo;return i||(i=new T_(t,e,n),// @ts-ignore
t.rawExtentInfo=i,i)}function k_(t,e){return null==e?null:$(e)?NaN:t.parse(e)}
/**
             * Get axis scale extent before niced.
             * Item of returned array can only be number (including Infinity and NaN).
             *
             * Caution:
             * Precondition of calling this method:
             * The scale extent has been initialized using series data extent via
             * `scale.setExtent` or `scale.unionExtentFromData`;
             */function L_(t,e){var n=t.type,i=A_(t,e,t.getExtent()).calculate();t.setBlank(i.isBlank);var r=i.min,o=i.max,a=e.ecModel;if(a&&"time"/* || scaleType === 'interval' */===n){var s=Qx("bar",a),l=!1;if(R(s,(function(t){l=l||t.getBaseAxis()===e.axis})),l){// Calculate placement of bars on axis. TODO should be decoupled
// with barLayout
var u=t_(s),h=function(t,e,n,// Only support cartesian coord yet.
i){// Get Axis Length
var r=n.axis.getExtent(),o=r[1]-r[0],a=function(t,e,n){if(t&&e){var i=t[Jx(e)];return null!=i&&null!=n?i[$x(n)]:i}}(i,n.axis);if(void 0===a)return{min:t,max:e};var s=1/0;R(a,(function(t){s=Math.min(t.offset,s)}));var l=-1/0;R(a,(function(t){l=Math.max(t.offset+t.width,l)})),s=Math.abs(s),l=Math.abs(l);var u=s+l,h=e-t,c=h/(1-(s+l)/o)-h;// Calculate required buffer based on old range and overflow
return{min:t-=c*(s/u),max:e+=c*(l/u)}}// Precondition of calling this method:
// The scale extent has been initialized using series data extent via
// `scale.setExtent` or `scale.unionExtentFromData`;
(r,o,e,u);// Adjust axis min and max to account for overflow
r=h.min,o=h.max}}return{extent:[r,o],// "fix" means "fixed", the value should not be
// changed in the subsequent steps.
fixMin:i.minFixed,fixMax:i.maxFixed}}function P_(t,e){var n=e,i=L_(t,n),r=i.extent,o=n.get("splitNumber");t instanceof I_&&(t.base=n.get("logBase"));var a=t.type,s=n.get("interval"),l="interval"===a||"time"===a;t.setExtent(r[0],r[1]),t.calcNiceExtent({splitNumber:o,fixMin:i.fixMin,fixMax:i.fixMax,minInterval:l?n.get("minInterval"):null,maxInterval:l?n.get("maxInterval"):null}),// If some one specified the min, max. And the default calculated interval
// is not good enough. He can specify the interval. It is often appeared
// in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
// to be 60.
// FIXME
null!=s&&t.setInterval&&t.setInterval(s)}
/**
             * @param axisType Default retrieve from model.type
             */function O_(t,e){if(e=e||t.get("type"))switch(e){// Buildin scale
case"category":return new Hx({ordinalMeta:t.getOrdinalMeta?t.getOrdinalMeta():t.getCategories(),extent:[1/0,-1/0]});case"time":return new f_({locale:t.ecModel.getLocaleModel(),useUTC:t.ecModel.get("useUTC")});default:// case 'value'/'interval', 'log', or others.
return new(Ax.getClass(e)||Ux)}}
/**
             * Check if the axis cross 0
             */
/**
             * @param axis
             * @return Label formatter function.
             *         param: {number} tickValue,
             *         param: {number} idx, the index in all ticks.
             *                         If category axis, this param is not required.
             *         return: {string} label string.
             */
function R_(t){var e,n,i=t.getLabelModel().get("formatter"),r="category"===t.type?t.scale.getExtent()[0]:null;return"time"===t.scale.type?(n=i,function(e,i){return t.scale.getFormattedLabel(e,i,n)}):H(i)?function(e){return function(n){// For category axis, get raw value; for numeric axis,
// get formatted label like '1,333,444'.
var i=t.scale.getLabel(n);return e.replace("{value}",null!=i?i:"")}}(i):W(i)?(e=i,function(n,i){// The original intention of `idx` is "the index of the tick in all ticks".
// But the previous implementation of category axis do not consider the
// `axisLabel.interval`, which cause that, for example, the `interval` is
// `1`, then the ticks "name5", "name7", "name9" are displayed, where the
// corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
// the definition here for back compatibility.
return null!=r&&(i=n.value-r),e(N_(t,n),i,null!=n.level?{level:n.level}:null)}):function(e){return t.scale.getLabel(e)}}function N_(t,e){// In category axis with data zoom, tick is not the original
// index of axis.data. So tick should not be exposed to user
// in category axis.
return"category"===t.type?t.scale.getLabel(e):e.value}
/**
             * @param axis
             * @return Be null/undefined if no labels.
             */function E_(t,e){var n=e*Math.PI/180,i=t.width,r=t.height,o=i*Math.abs(Math.cos(n))+Math.abs(r*Math.sin(n)),a=i*Math.abs(Math.sin(n))+Math.abs(r*Math.cos(n));return new Ce(t.x,t.y,o,a)}
/**
             * @param model axisLabelModel or axisTickModel
             * @return {number|String} Can be null|'auto'|number|function
             */function z_(t){var e=t.get("interval");return null==e?"auto":e}
/**
             * Set `categoryInterval` as 0 implicitly indicates that
             * show all labels regardless of overlap.
             * @param {Object} axis axisModel.axis
             */function V_(t){return"category"===t.type&&0===z_(t.getLabelModel())}function B_(t,e){// Remove duplicated dat dimensions caused by `getStackedDimension`.
var n={};// Currently `mapDimensionsAll` will contain stack result dimension ('__\0ecstackresult').
// PENDING: is it reasonable? Do we need to remove the original dim from "coord dim" since
// there has been stacked result dim?
return R(t.mapDimensionsAll(e),(function(e){// For example, the extent of the original dimension
// is [0.1, 0.5], the extent of the `stackResultDimension`
// is [7, 9], the final extent should NOT include [0.1, 0.5],
// because there is no graphic corresponding to [0.1, 0.5].
// See the case in `test/area-stack.html` `main1`, where area line
// stack needs `yAxis` not start from 0.
n[Tx(t,e)]=!0})),V(n)}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
var F_=/** @class */function(){function t(){}return t.prototype.getNeedCrossZero=function(){return!this.option.scale},
/**
               * Should be implemented by each axis model if necessary.
               * @return coordinate system model
               */
t.prototype.getCoordSysModel=function(){},t}();function G_(t,e){return Math.abs(t-e)<1e-8}function W_(t,e,n){var i=0,r=t[0];if(!r)return!1;for(var o=1;o<t.length;o++){var a=t[o];i+=is(r[0],r[1],a[0],a[1],e,n),r=a}var s=t[0];return G_(r[0],s[0])&&G_(r[1],s[1])||(i+=is(r[0],r[1],s[0],s[1],e,n)),0!==i}var H_=[];function Y_(t,e){for(var n=0;n<t.length;n++)Pt(t[n],t[n],e)}function X_(t,e,n,i){for(var r=0;r<t.length;r++){var o=t[r];i&&(// projection may return null point.
o=i.project(o)),o&&isFinite(o[0])&&isFinite(o[1])&&(Ot(e,e,o),Rt(n,n,o))}}var U_=/** @class */function(){function t(t){this.name=t}return t.prototype.setCenter=function(t){this._center=t},
/**
               * Get center point in data unit. That is,
               * for GeoJSONRegion, the unit is lat/lng,
               * for GeoSVGRegion, the unit is SVG local coord.
               */
t.prototype.getCenter=function(){var t=this._center;return t||(// In most cases there are no need to calculate this center.
// So calculate only when called.
t=this._center=this.calcCenter()),t},t}(),Z_=function(t,e){this.type="polygon",this.exterior=t,this.interiors=e},j_=function(t){this.type="linestring",this.points=t},q_=/** @class */function(t){function e(e,n,i){var r=t.call(this,e)||this;return r.type="geoJSON",r.geometries=n,r._center=i&&[i[0],i[1]],r}return n(e,t),e.prototype.calcCenter=function(){for(var t,e=this.geometries,n=0,i=0;i<e.length;i++){var r=e[i],o=r.exterior,a=o&&o.length;a>n&&(t=r,n=a)}if(t)return function(t){// Polygon should been closed.
for(var e=0,n=0,i=0,r=t.length,o=t[r-1][0],a=t[r-1][1],s=0;s<r;s++){var l=t[s][0],u=t[s][1],h=o*u-l*a;e+=h,n+=(o+l)*h,i+=(a+u)*h,o=l,a=u}return e?[n/e/3,i/e/3,e]:[t[0][0]||0,t[0][1]||0]}(t.exterior);// from bounding rect by default.
var s=this.getBoundingRect();return[s.x+s.width/2,s.y+s.height/2]},e.prototype.getBoundingRect=function(t){var e=this._rect;// Always recalculate if using projection.
if(e&&!t)return e;var n=[1/0,1/0],i=[-1/0,-1/0];return R(this.geometries,(function(e){"polygon"===e.type?// Doesn't consider hole
X_(e.exterior,n,i,t):R(e.points,(function(e){X_(e,n,i,t)}))})),// Normalie invalid bounding.
isFinite(n[0])&&isFinite(n[1])&&isFinite(i[0])&&isFinite(i[1])||(n[0]=n[1]=i[0]=i[1]=0),e=new Ce(n[0],n[1],i[0]-n[0],i[1]-n[1]),t||(this._rect=e),e},e.prototype.contain=function(t){var e=this.getBoundingRect(),n=this.geometries;if(!e.contain(t[0],t[1]))return!1;t:for(var i=0,r=n.length;i<r;i++){var o=n[i];// Only support polygon.
if("polygon"===o.type){var a=o.exterior,s=o.interiors;if(W_(a,t[0],t[1])){// Not in the region if point is in the hole.
for(var l=0;l<(s?s.length:0);l++)if(W_(s[l],t[0],t[1]))continue t;return!0}}}return!1},
/**
               * Transform the raw coords to target bounding.
               * @param x
               * @param y
               * @param width
               * @param height
               */
e.prototype.transformTo=function(t,e,n,i){var r=this.getBoundingRect(),o=r.width/r.height;n?i||(i=n/o):n=o*i;for(var a=new Ce(t,e,n,i),s=r.calculateTransform(a),l=this.geometries,u=0;u<l.length;u++){var h=l[u];"polygon"===h.type?(Y_(h.exterior,s),R(h.interiors,(function(t){Y_(t,s)}))):R(h.points,(function(t){Y_(t,s)}))}(r=this._rect).copy(a),// Update center
this._center=[r.x+r.width/2,r.y+r.height/2]},e.prototype.cloneShallow=function(t){null==t&&(t=this.name);var n=new e(t,this.geometries,this._center);// Simply avoid to be called.
return n._rect=this._rect,n.transformTo=null,n},e}(U_),K_=/** @class */function(t){function e(e,n){var i=t.call(this,e)||this;return i.type="geoSVG",i._elOnlyForCalculate=n,i}return n(e,t),e.prototype.calcCenter=function(){for(var t=this._elOnlyForCalculate,e=t.getBoundingRect(),n=[e.x+e.width/2,e.y+e.height/2],i=ue(H_),r=t;r&&!r.isGeoSVGGraphicRoot;)ce(i,r.getLocalTransform(),i),r=r.parent;return ge(i,i),Pt(n,n,i),n},e}(U_);function $_(t,e,n){for(var i=0;i<t.length;i++)t[i]=J_(t[i],e[i],n)}function J_(t,e,n){for(var i=[],r=e[0],o=e[1],a=0;a<t.length;a+=2){var s=t.charCodeAt(a)-64,l=t.charCodeAt(a+1)-64;// ZigZag decoding
s=s>>1^-(1&s),l=l>>1^-(1&l),r=// Delta deocding
s+=r,o=l+=o,// Dequantize
i.push([s/n,l/n])}return i}function Q_(t,e){return N(z((t=function(t){if(!t.UTF8Encoding)return t;var e=t,n=e.UTF8Scale;return null==n&&(n=1024),R(e.features,(function(t){var e=t.geometry,i=e.encodeOffsets,r=e.coordinates;// Geometry may be appeded manually in the script after json loaded.
// In this case this geometry is usually not encoded.
if(i)switch(e.type){case"LineString":e.coordinates=J_(r,i,n);break;case"Polygon":case"MultiLineString":$_(r,i,n);break;case"MultiPolygon":R(r,(function(t,e){return $_(t,i[e],n)}))}})),// Has been decoded
e.UTF8Encoding=!1,e}(t)).features,(function(t){// Output of mapshaper may have geometry null
return t.geometry&&t.properties&&t.geometry.coordinates.length>0})),(function(t){var n=t.properties,i=t.geometry,r=[];switch(i.type){case"Polygon":var o=i.coordinates;// According to the GeoJSON specification.
// First must be exterior, and the rest are all interior(holes).
r.push(new Z_(o[0],o.slice(1)));break;case"MultiPolygon":R(i.coordinates,(function(t){t[0]&&r.push(new Z_(t[0],t.slice(1)))}));break;case"LineString":r.push(new j_([i.coordinates]));break;case"MultiLineString":r.push(new j_(i.coordinates))}var a=new q_(n[e||"name"],r,n.cp);return a.properties=n,a}))}var tb=bo();function eb(t){// Only ordinal scale support tick interval
return"category"===t.type?function(t){var e=t.getLabelModel(),n=ib(t,e);return!e.get("show")||t.scale.isBlank()?{labels:[],labelCategoryInterval:n.labelCategoryInterval}:n}(t):function(t){var e=t.scale.getTicks(),n=R_(t);return{labels:N(e,(function(e,i){return{level:e.level,formattedLabel:n(e,i),rawLabel:t.scale.getLabel(e),tickValue:e.value}}))}}(t)}
/**
             * @param {module:echats/coord/Axis} axis
             * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
             * @return {Object} {
             *     ticks: Array.<number>
             *     tickCategoryInterval: number
             * }
             */function nb(t,e){// Only ordinal scale support tick interval
return"category"===t.type?function(t,e){var n,i,r=rb(t,"ticks"),o=z_(e),a=ob(r,o);if(a)return a;if(// Optimize for the case that large category data and no label displayed,
// we should not return all ticks.
e.get("show")&&!t.scale.isBlank()||(n=[]),W(o))n=lb(t,o,!0);else if("auto"===o){var s=ib(t,t.getLabelModel());i=s.labelCategoryInterval,n=N(s.labels,(function(t){return t.tickValue}))}else n=sb(t,i=o,!0);// Cache to avoid calling interval function repeatedly.
return ab(r,o,{ticks:n,tickCategoryInterval:i})}(t,e):{ticks:N(t.scale.getTicks(),(function(t){return t.value}))}}function ib(t,e){var n,i,r=rb(t,"labels"),o=z_(e),a=ob(r,o);return a||(W(o)?n=lb(t,o):(i="auto"===o?function(t){var e=tb(t).autoInterval;return null!=e?e:tb(t).autoInterval=t.calculateCategoryInterval()}
/**
             * Calculate interval for category axis ticks and labels.
             * To get precise result, at least one of `getRotate` and `isHorizontal`
             * should be implemented in axis.
             */(t):o,n=sb(t,i)),ab(r,o,{labels:n,labelCategoryInterval:i}))}function rb(t,e){// Because key can be a function, and cache size always is small, we use array cache.
return tb(t)[e]||(tb(t)[e]=[])}function ob(t,e){for(var n=0;n<t.length;n++)if(t[n].key===e)return t[n].value}function ab(t,e,n){return t.push({key:e,value:n}),n}function sb(t,e,n){var i=R_(t),r=t.scale,o=r.getExtent(),a=t.getLabelModel(),s=[],l=Math.max((e||0)+1,1),u=o[0],h=r.count();// Calculate start tick based on zero if possible to keep label consistent
// while zooming and moving while interval > 0. Otherwise the selection
// of displayable ticks and symbols probably keep changing.
// 3 is empirical value.
0!==u&&l>1&&h/l>2&&(u=Math.round(Math.ceil(u/l)*l));// (1) Only add min max label here but leave overlap checking
// to render stage, which also ensure the returned list
// suitable for splitLine and splitArea rendering.
// (2) Scales except category always contain min max label so
// do not need to perform this process.
var c=V_(t),p=a.get("showMinLabel")||c,d=a.get("showMaxLabel")||c;p&&u!==o[0]&&g(o[0]);// Optimize: avoid generating large array by `ordinalScale.getTicks()`.
for(var f=u;f<=o[1];f+=l)g(f);function g(t){var e={value:t};s.push(n?t:{formattedLabel:i(e),rawLabel:r.getLabel(e),tickValue:t})}return d&&f-l!==o[1]&&g(o[1]),s}function lb(t,e,n){var i=t.scale,r=R_(t),o=[];return R(i.getTicks(),(function(t){var a=i.getLabel(t),s=t.value;e(t.value,a)&&o.push(n?s:{formattedLabel:r(t),rawLabel:a,tickValue:s})})),o}var ub=[0,1],hb=/** @class */function(){function t(t,e,n){this.onBand=!1,this.inverse=!1,this.dim=t,this.scale=e,this._extent=n||[0,0]}
/**
               * If axis extent contain given coord
               */return t.prototype.contain=function(t){var e=this._extent,n=Math.min(e[0],e[1]),i=Math.max(e[0],e[1]);return t>=n&&t<=i},
/**
               * If axis extent contain given data
               */
t.prototype.containData=function(t){return this.scale.contain(t)},
/**
               * Get coord extent.
               */
t.prototype.getExtent=function(){return this._extent.slice()},
/**
               * Get precision used for formatting
               */
t.prototype.getPixelPrecision=function(t){return Wr(t||this.scale.getExtent(),this._extent)},
/**
               * Set coord extent
               */
t.prototype.setExtent=function(t,e){var n=this._extent;n[0]=t,n[1]=e},
/**
               * Convert data to coord. Data is the rank if it has an ordinal scale
               */
t.prototype.dataToCoord=function(t,e){var n=this._extent,i=this.scale;return t=i.normalize(t),this.onBand&&"ordinal"===i.type&&cb(n=n.slice(),i.count()),zr(t,ub,n,e)},
/**
               * Convert coord to data. Data is the rank if it has an ordinal scale
               */
t.prototype.coordToData=function(t,e){var n=this._extent,i=this.scale;this.onBand&&"ordinal"===i.type&&cb(n=n.slice(),i.count());var r=zr(t,n,ub,e);return this.scale.scale(r)},
/**
               * Convert pixel point to data in axis
               */
t.prototype.pointToData=function(t,e){},
/**
               * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
               * `axis.getTicksCoords` considers `onBand`, which is used by
               * `boundaryGap:true` of category axis and splitLine and splitArea.
               * @param opt.tickModel default: axis.model.getModel('axisTick')
               * @param opt.clamp If `true`, the first and the last
               *        tick must be at the axis end points. Otherwise, clip ticks
               *        that outside the axis extent.
               */
t.prototype.getTicksCoords=function(t){var e=(t=t||{}).tickModel||this.getTickModel(),n=N(nb(this,e).ticks,(function(t){return{coord:this.dataToCoord("ordinal"===this.scale.type?this.scale.getRawOrdinalNumber(t):t),tickValue:t}}),this);// If axis has labels [1, 2, 3, 4]. Bands on the axis are
// |---1---|---2---|---3---|---4---|.
// So the displayed ticks and splitLine/splitArea should between
// each data item, otherwise cause misleading (e.g., split tow bars
// of a single data item when there are two bar series).
// Also consider if tickCategoryInterval > 0 and onBand, ticks and
// splitLine/spliteArea should layout appropriately corresponding
// to displayed labels. (So we should not use `getBandWidth` in this
// case).
return function(t,e,n,i){var r=e.length;if(t.onBand&&!n&&r){var o,a,s=t.getExtent();if(1===r)e[0].coord=s[0],o=e[1]={coord:s[0]};else{var l=e[r-1].tickValue-e[0].tickValue,u=(e[r-1].coord-e[0].coord)/l;R(e,(function(t){t.coord-=u/2})),a=1+t.scale.getExtent()[1]-e[r-1].tickValue,o={coord:e[r-1].coord+u*a},e.push(o)}var h=s[0]>s[1];// Handling clamp.
c(e[0].coord,s[0])&&(i?e[0].coord=s[0]:e.shift()),i&&c(s[0],e[0].coord)&&e.unshift({coord:s[0]}),c(s[1],o.coord)&&(i?o.coord=s[1]:e.pop()),i&&c(o.coord,s[1])&&e.push({coord:s[1]})}function c(t,e){// Avoid rounding error cause calculated tick coord different with extent.
// It may cause an extra unnecessary tick added.
return t=Br(t),e=Br(e),h?t>e:t<e}}(this,n,e.get("alignWithLabel"),t.clamp),n},t.prototype.getMinorTicksCoords=function(){if("ordinal"===this.scale.type)// Category axis doesn't support minor ticks
return[];var t=this.model.getModel("minorTick").get("splitNumber");// Protection.
return t>0&&t<100||(t=5),N(this.scale.getMinorTicks(t),(function(t){return N(t,(function(t){return{coord:this.dataToCoord(t),tickValue:t}}),this)}),this)},t.prototype.getViewLabels=function(){return eb(this).labels},t.prototype.getLabelModel=function(){return this.model.getModel("axisLabel")},
/**
               * Notice here we only get the default tick model. For splitLine
               * or splitArea, we should pass the splitLineModel or splitAreaModel
               * manually when calling `getTicksCoords`.
               * In GL, this method may be overridden to:
               * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
               */
t.prototype.getTickModel=function(){return this.model.getModel("axisTick")},
/**
               * Get width of band
               */
t.prototype.getBandWidth=function(){var t=this._extent,e=this.scale.getExtent(),n=e[1]-e[0]+(this.onBand?1:0);// Fix #2728, avoid NaN when only one data.
0===n&&(n=1);var i=Math.abs(t[1]-t[0]);return Math.abs(i)/n},
/**
               * Only be called in category axis.
               * Can be overridden, consider other axes like in 3D.
               * @return Auto interval for cateogry axis tick and label
               */
t.prototype.calculateCategoryInterval=function(){return function(t){var e=function(t){var e=t.getLabelModel();return{axisRotate:t.getRotate?t.getRotate():t.isHorizontal&&!t.isHorizontal()?90:0,labelRotate:e.get("rotate")||0,font:e.getFont()}}(t),n=R_(t),i=(e.axisRotate-e.labelRotate)/180*Math.PI,r=t.scale,o=r.getExtent(),a=r.count();if(o[1]-o[0]<1)return 0;var s=1;// Simple optimization. Empirical value: tick count should less than 40.
a>40&&(s=Math.max(1,Math.floor(a/40)));// Caution: Performance sensitive for large category data.
// Consider dataZoom, we should make appropriate step to avoid O(n) loop.
for(var l=o[0],u=t.dataToCoord(l+1)-t.dataToCoord(l),h=Math.abs(u*Math.cos(i)),c=Math.abs(u*Math.sin(i)),p=0,d=0;l<=o[1];l+=s){var f,g,y=dr(n({value:l}),e.font,"center","top");// Magic number
f=1.3*y.width,g=1.3*y.height,// Min size, void long loop.
p=Math.max(p,f,7),d=Math.max(d,g,7)}var v=p/h,m=d/c;// 0/0 is NaN, 1/0 is Infinity.
isNaN(v)&&(v=1/0),isNaN(m)&&(m=1/0);var x=Math.max(0,Math.floor(Math.min(v,m))),_=tb(t.model),b=t.getExtent(),w=_.lastAutoInterval,S=_.lastTickCount;// Use cache to keep interval stable while moving zoom window,
// otherwise the calculated interval might jitter when the zoom
// window size is close to the interval-changing size.
// For example, if all of the axis labels are `a, b, c, d, e, f, g`.
// The jitter will cause that sometimes the displayed labels are
// `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).
return null!=w&&null!=S&&Math.abs(w-x)<=1&&Math.abs(S-a)<=1&&w>x&&_.axisExtent0===b[0]&&_.axisExtent1===b[1]?x=w:(_.lastTickCount=a,_.lastAutoInterval=x,_.axisExtent0=b[0],_.axisExtent1=b[1]),x}(this)},t}();
/**
             * Base class of Axis.
             */function cb(t,e){var n=(t[1]-t[0])/e/2;t[0]+=n,t[1]-=n}const pb=hb;var db=2*Math.PI,fb=qa.CMD,gb=["top","right","bottom","left"];function yb(t,e,n,i,r){var o=n.width,a=n.height;switch(t){case"top":i.set(n.x+o/2,n.y-e),r.set(0,-1);break;case"bottom":i.set(n.x+o/2,n.y+a+e),r.set(0,1);break;case"left":i.set(n.x-e,n.y+a/2),r.set(-1,0);break;case"right":i.set(n.x+o+e,n.y+a/2),r.set(1,0)}}function vb(t,e,n,i,r,o,a,s,l){a-=t,s-=e;var u=Math.sqrt(a*a+s*s),h=(a/=u)*n+t,c=(s/=u)*n+e;if(Math.abs(i-r)%db<1e-4)// Is a circle
return l[0]=h,l[1]=c,u-n;if(o){var p=i;i=ts(r),r=ts(p)}else i=ts(i),r=ts(r);i>r&&(r+=db);var d=Math.atan2(s,a);if(d<0&&(d+=db),d>=i&&d<=r||d+db>=i&&d+db<=r)// Project point is on the arc.
return l[0]=h,l[1]=c,u-n;var f=n*Math.cos(i)+t,g=n*Math.sin(i)+e,y=n*Math.cos(r)+t,v=n*Math.sin(r)+e,m=(f-a)*(f-a)+(g-s)*(g-s),x=(y-a)*(y-a)+(v-s)*(v-s);return m<x?(l[0]=f,l[1]=g,Math.sqrt(m)):(l[0]=y,l[1]=v,Math.sqrt(x))}function mb(t,e,n,i,r,o,a,s){var l=r-t,u=o-e,h=n-t,c=i-e,p=Math.sqrt(h*h+c*c),d=(l*(h/=p)+u*(c/=p))/p;s&&(d=Math.min(Math.max(d,0),1)),d*=p;var f=a[0]=t+d*h,g=a[1]=e+d*c;return Math.sqrt((f-r)*(f-r)+(g-o)*(g-o))}function xb(t,e,n,i,r,o,a){n<0&&(t+=n,n=-n),i<0&&(e+=i,i=-i);var s=t+n,l=e+i,u=a[0]=Math.min(Math.max(r,t),s),h=a[1]=Math.min(Math.max(o,e),l);return Math.sqrt((u-r)*(u-r)+(h-o)*(h-o))}var _b=[];function bb(t,e,n){var i=xb(e.x,e.y,e.width,e.height,t.x,t.y,_b);return n.set(_b[0],_b[1]),i}
/**
             * Calculate min distance corresponding point.
             * This method won't evaluate if point is in the path.
             */function wb(t,e,n){for(var i,r,o=0,a=0,s=0,l=0,u=1/0,h=e.data,c=t.x,p=t.y,d=0;d<h.length;){var f=h[d++];1===d&&(s=o=h[d],l=a=h[d+1]);var g=u;switch(f){case fb.M:o=// moveTo  subpath, 
//  closePath 
s=h[d++],a=l=h[d++];break;case fb.L:g=mb(o,a,h[d],h[d+1],c,p,_b,!0),o=h[d++],a=h[d++];break;case fb.C:g=yn(o,a,h[d++],h[d++],h[d++],h[d++],h[d],h[d+1],c,p,_b),o=h[d++],a=h[d++];break;case fb.Q:g=wn(o,a,h[d++],h[d++],h[d],h[d+1],c,p,_b),o=h[d++],a=h[d++];break;case fb.A:// TODO Arc 
var y=h[d++],v=h[d++],m=h[d++],x=h[d++],_=h[d++],b=h[d++];// TODO Arc 
d+=1;var w=!!(1-h[d++]);i=Math.cos(_)*m+y,r=Math.sin(_)*x+v,//  arc 
d<=1&&(// 
s=i,l=r),g=vb(y,v,x,_,_+b,w,(c-y)*x/m+y,p,_b),o=Math.cos(_+b)*m+y,a=Math.sin(_+b)*x+v;break;case fb.R:g=xb(s=o=h[d++],l=a=h[d++],h[d++],h[d++],c,p,_b);break;case fb.Z:g=mb(o,a,s,l,c,p,_b,!0),o=s,a=l}g<u&&(u=g,n.set(_b[0],_b[1]))}return u}// Temporal variable for intermediate usage.
var Sb=new ve,Mb=new ve,Ib=new ve,Tb=new ve,Cb=new ve;
/**
             * Calculate a proper guide line based on the label position and graphic element definition
             * @param label
             * @param labelRect
             * @param target
             * @param targetRect
             */
function Db(t,e){if(t){var n=t.getTextGuideLine(),i=t.getTextContent();// Needs to create text guide in each charts.
if(i&&n){var r=t.textGuideLineConfig||{},o=[[0,0],[0,0],[0,0]],a=r.candidates||gb,s=i.getBoundingRect().clone();s.applyTransform(i.getComputedTransform());var l=1/0,u=r.anchor,h=t.getComputedTransform(),c=h&&ge([],h),p=e.get("length2")||0;u&&Ib.copy(u);for(var d=0;d<a.length;d++){yb(a[d],0,s,Sb,Tb),ve.scaleAndAdd(Mb,Sb,Tb,p),// Transform to target coord space.
Mb.transform(c);// Note: getBoundingRect will ensure the `path` being created.
var f=t.getBoundingRect(),g=u?u.distance(Mb):t instanceof ys?wb(Mb,t.path,Ib):bb(Mb,f,Ib);// TODO pt2 is in the path
g<l&&(l=g,// Transform back to global space.
Mb.transform(h),Ib.transform(h),Ib.toArray(o[0]),Mb.toArray(o[1]),Sb.toArray(o[2]))}Lb(o,e.get("minTurnAngle")),n.setShape({points:o})}}}// Temporal variable for the limitTurnAngle function
var Ab=[],kb=new ve;
/**
             * Reduce the line segment attached to the label to limit the turn angle between two segments.
             * @param linePoints
             * @param minTurnAngle Radian of minimum turn angle. 0 - 180
             */
function Lb(t,e){if(e<=180&&e>0){e=e/180*Math.PI,// The line points can be
//      /pt1----pt2 (label)
//     /
// pt0/
Sb.fromArray(t[0]),Mb.fromArray(t[1]),Ib.fromArray(t[2]),ve.sub(Tb,Sb,Mb),ve.sub(Cb,Ib,Mb);var n=Tb.len(),i=Cb.len();if(!(n<.001||i<.001)){Tb.scale(1/n),Cb.scale(1/i);var r=Tb.dot(Cb);if(Math.cos(e)<r){// Smaller than minTurnAngle
// Calculate project point of pt0 on pt1-pt2
var o=mb(Mb.x,Mb.y,Ib.x,Ib.y,Sb.x,Sb.y,Ab,!1);kb.fromArray(Ab),// Calculate new projected length with limited minTurnAngle and get the new connect point
kb.scaleAndAdd(Cb,o/Math.tan(Math.PI-e));// Limit the new calculated connect point between pt1 and pt2.
var a=Ib.x!==Mb.x?(kb.x-Mb.x)/(Ib.x-Mb.x):(kb.y-Mb.y)/(Ib.y-Mb.y);if(isNaN(a))return;a<0?ve.copy(kb,Mb):a>1&&ve.copy(kb,Ib),kb.toArray(t[1])}}}}
/**
             * Limit the angle of line and the surface
             * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite
             */function Pb(t,e,n){if(n<=180&&n>0){n=n/180*Math.PI,Sb.fromArray(t[0]),Mb.fromArray(t[1]),Ib.fromArray(t[2]),ve.sub(Tb,Mb,Sb),ve.sub(Cb,Ib,Mb);var i=Tb.len(),r=Cb.len();if(!(i<.001||r<.001)&&(Tb.scale(1/i),Cb.scale(1/r),Tb.dot(e)<Math.cos(n))){// Calculate project point of pt0 on pt1-pt2
var o=mb(Mb.x,Mb.y,Ib.x,Ib.y,Sb.x,Sb.y,Ab,!1);kb.fromArray(Ab);var a=Math.PI/2,s=a+Math.acos(Cb.dot(e))-n;if(s>=a)// parallel
ve.copy(kb,Ib);else{// Calculate new projected length with limited minTurnAngle and get the new connect point
kb.scaleAndAdd(Cb,o/Math.tan(Math.PI/2-s));// Limit the new calculated connect point between pt1 and pt2.
var l=Ib.x!==Mb.x?(kb.x-Mb.x)/(Ib.x-Mb.x):(kb.y-Mb.y)/(Ib.y-Mb.y);if(isNaN(l))return;l<0?ve.copy(kb,Mb):l>1&&ve.copy(kb,Ib)}kb.toArray(t[1])}}}function Ob(t,e,n,i){var r="normal"===n,o=r?t:t.ensureState(n);// Make sure display.
o.ignore=e;// Set smooth
var a=i.get("smooth");a&&!0===a&&(a=.3),o.shape=o.shape||{},a>0&&(o.shape.smooth=a);var s=i.getModel("lineStyle").getLineStyle();r?t.useStyle(s):o.style=s}function Rb(t,e){var n=e.smooth,i=e.points;if(i)if(t.moveTo(i[0][0],i[0][1]),n>0&&i.length>=3){var r=At(i[0],i[1]),o=At(i[1],i[2]);if(!r||!o)return t.lineTo(i[1][0],i[1][1]),void t.lineTo(i[2][0],i[2][1]);var a=Math.min(r,o)*n,s=Lt([],i[1],i[0],a/r),l=Lt([],i[1],i[2],a/o),u=Lt([],s,l,.5);t.bezierCurveTo(s[0],s[1],s[0],s[1],u[0],u[1]),t.bezierCurveTo(l[0],l[1],l[0],l[1],i[2][0],i[2][1])}else for(var h=1;h<i.length;h++)t.lineTo(i[h][0],i[h][1])}
/**
             * Create a label line if necessary and set it's style.
             */function Nb(t,e,n){var i=t.getTextGuideLine(),r=t.getTextContent();if(r){for(var o=e.normal,a=o.get("show"),s=r.ignore,l=0;l<el.length;l++){var u=el[l],h=e[u],c="normal"===u;if(h){var p=h.get("show");if((c?s:Q(r.states[u]&&r.states[u].ignore,s))||!Q(p,a)){var d=c?i:i&&i.states[u];d&&(d.ignore=!0);continue}// Create labelLine if not exists
i||(i=new Xu,t.setTextGuideLine(i),// Reset state of normal because it's new created.
// NOTE: NORMAL should always been the first!
c||!s&&a||Ob(i,!0,"normal",e.normal),// Use same state proxy.
t.stateProxy&&(i.stateProxy=t.stateProxy)),Ob(i,!1,u,h)}}if(i){k(i.style,n),// Not fill.
i.style.fill=null;var f=o.get("showAbove");(t.textGuideLineConfig=t.textGuideLineConfig||{}).showAbove=f||!1,// Custom the buildPath.
i.buildPath=Rb}}else// Not show label line if there is no label.
i&&t.removeTextGuideLine()}function Eb(t,e){e=e||"labelLine";for(var n={normal:t.getModel(e)},i=0;i<tl.length;i++){var r=tl[i];n[r]=t.getModel([r,e])}return n}function zb(t){for(var e=[],n=0;n<t.length;n++){var i=t[n];if(!i.defaultAttr.ignore){var r=i.label,o=r.getComputedTransform(),a=r.getBoundingRect(),s=!o||o[1]<1e-5&&o[2]<1e-5,l=r.style.margin||0,u=a.clone();u.applyTransform(o),u.x-=l/2,u.y-=l/2,u.width+=l,u.height+=l;var h=s?new yh(a,o):null;e.push({label:r,labelLine:i.labelLine,rect:u,localRect:a,obb:h,priority:i.priority,defaultAttr:i.defaultAttr,layoutOption:i.computedLayoutOption,axisAligned:s,transform:o})}}return e}function Vb(t,e,n,i,r,o){var a=t.length;if(!(a<2)){t.sort((function(t,n){return t.rect[e]-n.rect[e]}));for(var s,l=0,u=!1,h=0,c=0;c<a;c++){var p=t[c],d=p.rect;(s=d[e]-l)<0&&(// shiftForward(i, len, -delta);
d[e]-=s,p.label[e]-=s,u=!0),h+=Math.max(-s,0),l=d[e]+d[n]}h>0&&o&&// Shift back to make the distribution more equally.
_(-h/a,0,a);// TODO bleedMargin?
var f,g,y=t[0],v=t[a-1];return m(),// If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.
f<0&&b(-f,.8),g<0&&b(g,.8),m(),x(f,g,1),x(g,f,-1),// Handle bailout when there is not enough space.
m(),f<0&&w(-f),g<0&&w(g),u}function m(){f=y.rect[e]-i,g=r-v.rect[e]-v.rect[n]}function x(t,e,n){if(t<0){// Move from other gap if can.
var i=Math.min(e,-t);if(i>0){_(i*n,0,a);var r=i+t;r<0&&b(-r*n,1)}else b(-t*n,1)}}function _(n,i,r){0!==n&&(u=!0);for(var o=i;o<r;o++){var a=t[o];a.rect[e]+=n,a.label[e]+=n}}// Squeeze gaps if the labels exceed margin.
function b(i,r){for(var o=[],s=0,l=1;l<a;l++){var u=t[l-1].rect,h=Math.max(t[l].rect[e]-u[e]-u[n],0);o.push(h),s+=h}if(s){var c=Math.min(Math.abs(i)/s,r);if(i>0)for(l=0;l<a-1;l++)// Forward
_(o[l]*c,0,l+1);else// Backward
for(l=a-1;l>0;l--)_(-o[l-1]*c,l,a)}}
/**
               * Squeeze to allow overlap if there is no more space available.
               * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.
               */function w(t){var e=t<0?-1:1;t=Math.abs(t);for(var n=Math.ceil(t/(a-1)),i=0;i<a-1;i++)if(e>0?// Forward
_(n,0,i+1):// Backward
_(-n,a-i-1,a),(t-=n)<=0)return}}
/**
             * Adjust labels on x direction to avoid overlap.
             */
/**
             * Adjust labels on y direction to avoid overlap.
             */
function Bb(t,e,n,// If average the shifts on all labels and add them to 0
i){return Vb(t,"y","height",e,n,i)}function Fb(t){var e=[];// TODO, render overflow visible first, put in the displayedLabels.
t.sort((function(t,e){return e.priority-t.priority}));var n=new Ce(0,0,0,0);function i(t){if(!t.ignore){// Show on emphasis.
var e=t.ensureState("emphasis");null==e.ignore&&(e.ignore=!1)}t.ignore=!0}for(var r=0;r<t.length;r++){var o=t[r],a=o.axisAligned,s=o.localRect,l=o.transform,u=o.label,h=o.labelLine;n.copy(o.rect),// Add a threshold because layout may be aligned precisely.
n.width-=.1,n.height-=.1,n.x+=.05,n.y+=.05;for(var c=o.obb,p=!1,d=0;d<e.length;d++){var f=e[d];// Fast rejection.
if(n.intersect(f.rect)){if(a&&f.axisAligned){// Is overlapped
p=!0;break}if(f.obb||(// If self is not axis aligned. But other is.
f.obb=new yh(f.localRect,f.transform)),c||(// If self is axis aligned. But other is not.
c=new yh(s,l)),c.intersect(f.obb)){p=!0;break}}}// TODO Callback to determine if this overlap should be handled?
p?(i(u),h&&i(h)):(u.attr("ignore",o.defaultAttr.ignore),h&&h.attr("ignore",o.defaultAttr.labelGuideIgnore),e.push(o))}}function Gb(t){if(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n].slice());return e}}function Wb(t,e){var n=t.label,i=e&&e.getTextGuideLine();return{dataIndex:t.dataIndex,dataType:t.dataType,seriesIndex:t.seriesModel.seriesIndex,text:t.label.style.text,rect:t.hostRect,labelRect:t.rect,// x: labelAttr.x,
// y: labelAttr.y,
align:n.style.align,verticalAlign:n.style.verticalAlign,labelLinePoints:Gb(i&&i.shape.points)}}var Hb=["align","verticalAlign","width","height","fontSize"],Yb=new sr,Xb=bo(),Ub=bo();function Zb(t,e,n){for(var i=0;i<n.length;i++){var r=n[i];null!=e[r]&&(t[r]=e[r])}}var jb=["x","y","rotation"],qb=/** @class */function(){function t(){this._labelList=[],this._chartViewList=[]}return t.prototype.clearLabels=function(){this._labelList=[],this._chartViewList=[]},
/**
               * Add label to manager
               */
t.prototype._addLabel=function(t,e,n,i,r){var o=i.style,a=i.__hostTarget.textConfig||{},s=i.getComputedTransform(),l=i.getBoundingRect().plain();Ce.applyTransform(l,l,s),s?Yb.setLocalTransform(s):(// Identity transform.
Yb.x=Yb.y=Yb.rotation=Yb.originX=Yb.originY=0,Yb.scaleX=Yb.scaleY=1);var u,h=i.__hostTarget;if(h){u=h.getBoundingRect().plain();var c=h.getComputedTransform();Ce.applyTransform(u,u,c)}var p=u&&h.getTextGuideLine();this._labelList.push({label:i,labelLine:p,seriesModel:n,dataIndex:t,dataType:e,layoutOption:r,computedLayoutOption:null,rect:l,hostRect:u,// Label with lower priority will be hidden when overlapped
// Use rect size as default priority
priority:u?u.width*u.height:0,// Save default label attributes.
// For restore if developers want get back to default value in callback.
defaultAttr:{ignore:i.ignore,labelGuideIgnore:p&&p.ignore,x:Yb.x,y:Yb.y,scaleX:Yb.scaleX,scaleY:Yb.scaleY,rotation:Yb.rotation,style:{x:o.x,y:o.y,align:o.align,verticalAlign:o.verticalAlign,width:o.width,height:o.height,fontSize:o.fontSize},cursor:i.cursor,attachedPos:a.position,attachedRot:a.rotation}})},t.prototype.addLabelsOfSeries=function(t){var e=this;this._chartViewList.push(t);var n=t.__model,i=n.get("labelLayout");
/**
                 * Ignore layouting if it's not specified anything.
                 */
(W(i)||V(i).length)&&t.group.traverse((function(t){if(t.ignore)return!0;// Stop traverse descendants.
// Only support label being hosted on graphic elements.
var r=t.getTextContent(),o=js(t);// Can only attach the text on the element with dataIndex
r&&!r.disableLabelLayout&&e._addLabel(o.dataIndex,o.dataType,n,r,i)}))},t.prototype.updateLayoutConfig=function(t){var e=t.getWidth(),n=t.getHeight();function i(t,e){return function(){Db(t,e)}}for(var r=0;r<this._labelList.length;r++){var o=this._labelList[r],a=o.label,s=a.__hostTarget,l=o.defaultAttr,u=void 0;u=(// TODO A global layout option?
u=W(o.layoutOption)?o.layoutOption(Wb(o,s)):o.layoutOption)||{},o.computedLayoutOption=u;var h=Math.PI/180;// TODO hostEl should always exists.
// Or label should not have parent because the x, y is all in global space.
s&&s.setTextConfig({// Force to set local false.
local:!1,// Ignore position and rotation config on the host el if x or y is changed.
position:null!=u.x||null!=u.y?null:l.attachedPos,// Ignore rotation config on the host el if rotation is changed.
rotation:null!=u.rotate?u.rotate*h:l.attachedRot,offset:[u.dx||0,u.dy||0]});var c=!1;if(null!=u.x?(// TODO width of chart view.
a.x=Vr(u.x,e),a.setStyle("x",0),// Ignore movement in style. TODO: origin.
c=!0):(a.x=l.x,a.setStyle("x",l.style.x)),null!=u.y?(// TODO height of chart view.
a.y=Vr(u.y,n),a.setStyle("y",0),// Ignore movement in style.
c=!0):(a.y=l.y,a.setStyle("y",l.style.y)),u.labelLinePoints){var p=s.getTextGuideLine();p&&(p.setShape({points:u.labelLinePoints}),// Not update
c=!1)}Xb(a).needsUpdateLabelLine=c,a.rotation=null!=u.rotate?u.rotate*h:l.rotation,a.scaleX=l.scaleX,a.scaleY=l.scaleY;for(var d=0;d<Hb.length;d++){var f=Hb[d];a.setStyle(f,null!=u[f]?u[f]:l.style[f])}if(u.draggable){if(a.draggable=!0,a.cursor="move",s){var g=o.seriesModel;null!=o.dataIndex&&(g=o.seriesModel.getData(o.dataType).getItemModel(o.dataIndex)),a.on("drag",i(s,g.getModel("labelLine")))}}else// TODO Other drag functions?
a.off("drag"),a.cursor=l.cursor}},t.prototype.layout=function(t){var// If average the shifts on all labels and add them to 0
// TODO: Not sure if should enable it.
// Pros: The angle of lines will distribute more equally
// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.
e,n=t.getWidth(),i=t.getHeight(),r=zb(this._labelList),o=z(r,(function(t){return"shiftX"===t.layoutOption.moveOverlap})),a=z(r,(function(t){return"shiftY"===t.layoutOption.moveOverlap}));Vb(o,"x","width",0,n,e),Bb(a,0,i),Fb(z(r,(function(t){return t.layoutOption.hideOverlap})))},
/**
               * Process all labels. Not only labels with layoutOption.
               */
t.prototype.processLabelsOverall=function(){var t=this;R(this._chartViewList,(function(e){var n=e.__model,i=e.ignoreLabelLineUpdate,r=n.isAnimationEnabled();e.group.traverse((function(e){if(e.ignore&&!e.forceLabelAnimation)return!0;// Stop traverse descendants.
var o=!i,a=e.getTextContent();!o&&a&&(o=Xb(a).needsUpdateLabelLine),o&&t._updateLabelLine(e,n),r&&t._animateLabels(e,n)}))}))},t.prototype._updateLabelLine=function(t,e){// Only support label being hosted on graphic elements.
var n=t.getTextContent(),i=js(t),r=i.dataIndex;// Update label line style.
// Only support labelLine on the labels represent data.
if(n&&null!=r){var o=e.getData(i.dataType),a=o.getItemModel(r),s={},l=o.getItemVisual(r,"style"),u=o.getVisual("drawType");// Default to be same with main color
s.stroke=l[u];var h=a.getModel("labelLine");Nb(t,Eb(a),s),Db(t,h)}},t.prototype._animateLabels=function(t,e){var n=t.getTextContent(),i=t.getTextGuideLine();// Animate
if(n&&(t.forceLabelAnimation||!n.ignore&&!n.invisible&&!t.disableLabelAnimation&&!Ih(t))){var r=(d=Xb(n)).oldLayout,o=js(t),a=o.dataIndex,s={x:n.x,y:n.y,rotation:n.rotation},l=e.getData(o.dataType);if(r){n.attr(r);// Make sure the animation from is in the right status.
var u=t.prevStates;u&&(L(u,"select")>=0&&n.attr(d.oldLayoutSelect),L(u,"emphasis")>=0&&n.attr(d.oldLayoutEmphasis)),Sh(n,s,e,a)}else// Disable fade in animation if value animation is enabled.
if(n.attr(s),!gc(n).valueAnimation){var h=Q(n.style.opacity,1);// Fade in animation
n.style.opacity=0,Mh(n,{style:{opacity:h}},e,a)}if(d.oldLayout=s,n.states.select){var c=d.oldLayoutSelect={};Zb(c,s,jb),Zb(c,n.states.select,jb)}if(n.states.emphasis){var p=d.oldLayoutEmphasis={};Zb(p,s,jb),Zb(p,n.states.emphasis,jb)}vc(n,a,l,e,e)}if(i&&!i.ignore&&!i.invisible){r=(d=Ub(i)).oldLayout;var d,f={points:i.shape.points};r?(i.attr({shape:r}),Sh(i,{shape:f},e)):(i.setShape(f),i.style.strokePercent=0,Mh(i,{style:{strokePercent:1}},e)),d.oldLayout=f}},t}();const Kb=qb;var $b=bo(),Jb=Math.sin,Qb=Math.cos,tw=Math.PI,ew=2*Math.PI,nw=180/tw,iw=function(){function t(){}return t.prototype.reset=function(t){this._start=!0,this._d=[],this._str="",this._p=Math.pow(10,t||4)},t.prototype.moveTo=function(t,e){this._add("M",t,e)},t.prototype.lineTo=function(t,e){this._add("L",t,e)},t.prototype.bezierCurveTo=function(t,e,n,i,r,o){this._add("C",t,e,n,i,r,o)},t.prototype.quadraticCurveTo=function(t,e,n,i){this._add("Q",t,e,n,i)},t.prototype.arc=function(t,e,n,i,r,o){this.ellipse(t,e,n,n,0,i,r,o)},t.prototype.ellipse=function(t,e,n,i,r,o,a,s){var l=a-o,u=!s,h=Math.abs(l),c=ti(h-ew)||(u?l>=ew:-l>=ew),p=l>0?l%ew:l%ew+ew,d=!1;d=!!c||!ti(h)&&p>=tw==!!u;var f=t+n*Qb(o),g=e+i*Jb(o);this._start&&this._add("M",f,g);var y=Math.round(r*nw);if(c){var v=1/this._p,m=(u?1:-1)*(ew-v);this._add("A",n,i,y,1,+u,t+n*Qb(o+m),e+i*Jb(o+m)),v>.01&&this._add("A",n,i,y,0,+u,f,g)}else{var x=t+n*Qb(a),_=e+i*Jb(a);this._add("A",n,i,y,+d,+u,x,_)}},t.prototype.rect=function(t,e,n,i){this._add("M",t,e),this._add("l",n,0),this._add("l",0,i),this._add("l",-n,0),this._add("Z")},t.prototype.closePath=function(){this._d.length>0&&this._add("Z")},t.prototype._add=function(t,e,n,i,r,o,a,s,l){for(var u=[],h=this._p,c=1;c<arguments.length;c++){var p=arguments[c];if(isNaN(p))return void(this._invalid=!0);u.push(Math.round(p*h)/h)}this._d.push(t+u.join(" ")),this._start="Z"===t},t.prototype.generateStr=function(){this._str=this._invalid?"":this._d.join(""),this._d=[]},t.prototype.getStr=function(){return this._str},t}();const rw=iw;var ow="none",aw=Math.round,sw=["lineCap","miterLimit","lineJoin"],lw=N(sw,(function(t){return"stroke-"+t.toLowerCase()}));function uw(t,e,n,i){var r=null==e.opacity?1:e.opacity;if(n instanceof Ss)t("opacity",r);else{if(function(t){var e=t.fill;return null!=e&&e!==ow}(e)){var o=Jn(e.fill);t("fill",o.color);var a=null!=e.fillOpacity?e.fillOpacity*o.opacity*r:o.opacity*r;(i||a<1)&&t("fill-opacity",a)}else t("fill",ow);if(function(t){var e=t.stroke;return null!=e&&e!==ow}(e)){var s=Jn(e.stroke);t("stroke",s.color);var l=e.strokeNoScale?n.getLineScale():1,u=l?(e.lineWidth||0)/l:0,h=null!=e.strokeOpacity?e.strokeOpacity*s.opacity*r:s.opacity*r,c=e.strokeFirst;if((i||1!==u)&&t("stroke-width",u),(i||c)&&t("paint-order",c?"stroke":"fill"),(i||h<1)&&t("stroke-opacity",h),e.lineDash){var p=pv(n),d=p[0],f=p[1];d&&(f=aw(f||0),t("stroke-dasharray",d.join(",")),(f||i)&&t("stroke-dashoffset",f))}else i&&t("stroke-dasharray",ow);for(var g=0;g<sw.length;g++){var y=sw[g];if(i||e[y]!==ps[y]){var v=e[y]||ps[y];v&&t(lw[g],v)}}}else i&&t("stroke",ow)}}var hw="http://www.w3.org/2000/svg",cw="http://www.w3.org/1999/xlink";function pw(t){return document.createElementNS(hw,t)}function dw(t,e,n,i,r){return{tag:t,attrs:n||{},children:i,text:r,key:e}}function fw(t,e){var n=(e=e||{}).newline?"\n":"";return function t(e){var i=e.children,r=e.tag;return function(t,e){var n=[];if(e)for(var i in e){var r=e[i],o=i;!1!==r&&(!0!==r&&null!=r&&(o+='="'+r+'"'),n.push(o))}return"<"+t+" "+n.join(" ")+">"}(r,e.attrs)+qt(e.text)+(i?""+n+N(i,(function(e){return t(e)})).join(n)+n:"")+"</"+r+">"}(t)}function gw(t){return{zrId:t,shadowCache:{},patternCache:{},gradientCache:{},clipPathCache:{},defs:{},cssNodes:{},cssAnims:{},cssClassIdx:0,cssAnimIdx:0,shadowIdx:0,gradientIdx:0,patternIdx:0,clipPathIdx:0}}function yw(t,e,n,i){return dw("svg","root",{width:t,height:e,xmlns:hw,"xmlns:xlink":cw,version:"1.1",baseProfile:"full",viewBox:!!i&&"0 0 "+t+" "+e},n)}var vw={cubicIn:"0.32,0,0.67,0",cubicOut:"0.33,1,0.68,1",cubicInOut:"0.65,0,0.35,1",quadraticIn:"0.11,0,0.5,0",quadraticOut:"0.5,1,0.89,1",quadraticInOut:"0.45,0,0.55,1",quarticIn:"0.5,0,0.75,0",quarticOut:"0.25,1,0.5,1",quarticInOut:"0.76,0,0.24,1",quinticIn:"0.64,0,0.78,0",quinticOut:"0.22,1,0.36,1",quinticInOut:"0.83,0,0.17,1",sinusoidalIn:"0.12,0,0.39,0",sinusoidalOut:"0.61,1,0.88,1",sinusoidalInOut:"0.37,0,0.63,1",exponentialIn:"0.7,0,0.84,0",exponentialOut:"0.16,1,0.3,1",exponentialInOut:"0.87,0,0.13,1",circularIn:"0.55,0,1,0.45",circularOut:"0,0.55,0.45,1",circularInOut:"0.85,0,0.15,1"},mw="transform-origin";function xw(t,e,n){var i=A({},t.shape);A(i,e),t.buildPath(n,i);var r=new rw;return r.reset(hi(t)),n.rebuildPath(r,1),r.generateStr(),r.getStr()}function _w(t,e){var n=e.originX,i=e.originY;(n||i)&&(t[mw]=n+"px "+i+"px")}var bw={fill:"fill",opacity:"opacity",lineWidth:"stroke-width",lineDashOffset:"stroke-dashoffset"};function ww(t,e){var n=e.zrId+"-ani-"+e.cssAnimIdx++;return e.cssAnims[n]=t,n}function Sw(t){return H(t)?vw[t]?"cubic-bezier("+vw[t]+")":In(t)?t:"":""}function Mw(t,e,n,i){var r=t.animators,o=r.length,a=[];if(t instanceof oh){var s=function(t,e,n){var i,r,o=t.shape.paths,a={};if(R(o,(function(t){var e=gw(n.zrId);e.animation=!0,Mw(t,{},e,!0);var o=e.cssAnims,s=e.cssNodes,l=V(o),u=l.length;if(u){var h=o[r=l[u-1]];for(var c in h){var p=h[c];a[c]=a[c]||{d:""},a[c].d+=p.d||""}for(var d in s){var f=s[d].animation;f.indexOf(r)>=0&&(i=f)}}})),i){e.d=!1;var s=ww(a,n);return i.replace(r,s)}}(t,e,n);if(s)a.push(s);else if(!o)return}else if(!o)return;for(var l={},u=0;u<o;u++){var h=r[u],c=[h.getMaxTime()/1e3+"s"],p=Sw(h.getClip().easing),d=h.getDelay();p?c.push(p):c.push("linear"),d&&c.push(d/1e3+"s"),h.getLoop()&&c.push("infinite");var f=c.join(" ");l[f]=l[f]||[f,[]],l[f][1].push(h)}function g(r){var o,a=r[1],s=a.length,l={},u={},h={},c="animation-timing-function";function p(t,e,n){for(var i=t.getTracks(),r=t.getMaxTime(),o=0;o<i.length;o++){var a=i[o];if(a.needsAnimate()){var s=a.keyframes,l=a.propName;if(n&&(l=n(l)),l)for(var u=0;u<s.length;u++){var h=s[u],p=Math.round(h.time/r*100)+"%",d=Sw(h.easing),f=h.rawValue;(H(f)||X(f))&&(e[p]=e[p]||{},e[p][l]=h.rawValue,d&&(e[p][c]=d))}}}}for(var d=0;d<s;d++)(S=(w=a[d]).targetName)?"shape"===S&&p(w,u):!i&&p(w,l);for(var f in l){var g={};ur(g,t),A(g,l[f]);var y=ci(g),v=l[f][c];h[f]=y?{transform:y}:{},_w(h[f],g),v&&(h[f][c]=v)}var m=!0;for(var f in u){h[f]=h[f]||{};var x=!o;v=u[f][c],x&&(o=new qa);var _=o.len();o.reset(),h[f].d=xw(t,u[f],o);var b=o.len();if(!x&&_!==b){m=!1;break}v&&(h[f][c]=v)}if(!m)for(var f in h)delete h[f].d;if(!i)for(d=0;d<s;d++){var w,S;"style"===(S=(w=a[d]).targetName)&&p(w,h,(function(t){return bw[t]}))}var M,I=V(h),T=!0;for(d=1;d<I.length;d++){var C=I[d-1],D=I[d];if(h[C][mw]!==h[D][mw]){T=!1;break}M=h[C][mw]}if(T&&M){for(var f in h)h[f][mw]&&delete h[f][mw];e[mw]=M}if(z(I,(function(t){return V(h[t]).length>0})).length)return ww(h,n)+" "+r[0]+" both"}for(var y in l)(s=g(l[y]))&&a.push(s);if(a.length){var v=n.zrId+"-cls-"+n.cssClassIdx++;n.cssNodes["."+v]={animation:a.join(",")},e.class=v}}var Iw=Math.round;function Tw(t){return t&&H(t.src)}function Cw(t){return t&&W(t.toDataURL)}function Dw(t,e,n,i){uw((function(r,o){var a="fill"===r||"stroke"===r;a&&li(o)?Vw(e,t,r,i):a&&oi(o)?Bw(n,t,r,i):t[r]=o}),e,n,!1),function(t,e,n){var i=t.style;if(function(t){return t&&(t.shadowBlur||t.shadowOffsetX||t.shadowOffsetY)}(i)){var r=function(t){var e=t.style,n=t.getGlobalScale();return[e.shadowColor,(e.shadowBlur||0).toFixed(2),(e.shadowOffsetX||0).toFixed(2),(e.shadowOffsetY||0).toFixed(2),n[0],n[1]].join(",")}(t),o=n.shadowCache,a=o[r];if(!a){var s=t.getGlobalScale(),l=s[0],u=s[1];if(!l||!u)return;var h=i.shadowOffsetX||0,c=i.shadowOffsetY||0,p=i.shadowBlur,d=Jn(i.shadowColor),f=d.opacity,g=d.color,y=p/2/l+" "+p/2/u;a=n.zrId+"-s"+n.shadowIdx++,n.defs[a]=dw("filter",a,{id:a,x:"-100%",y:"-100%",width:"300%",height:"300%"},[dw("feDropShadow","",{dx:h/l,dy:c/u,stdDeviation:y,"flood-color":g,"flood-opacity":f})]),o[r]=a}e.filter=ui(a)}}(n,t,i)}function Aw(t){return ti(t[0]-1)&&ti(t[1])&&ti(t[2])&&ti(t[3]-1)}function kw(t,e,n){if(e&&(!function(t){return ti(t[4])&&ti(t[5])}(e)||!Aw(e))){var i=n?10:1e4;t.transform=Aw(e)?"translate("+Iw(e[4]*i)/i+" "+Iw(e[5]*i)/i+")":function(t){return"matrix("+ei(t[0])+","+ei(t[1])+","+ei(t[2])+","+ei(t[3])+","+ni(t[4])+","+ni(t[5])+")"}(e)}}function Lw(t,e,n){for(var i=t.points,r=[],o=0;o<i.length;o++)r.push(Iw(i[o][0]*n)/n),r.push(Iw(i[o][1]*n)/n);e.points=r.join(" ")}function Pw(t){return!t.smooth}var Ow,Rw,Nw={circle:[(Ow=["cx","cy","r"],Rw=N(Ow,(function(t){return"string"==typeof t?[t,t]:t})),function(t,e,n){for(var i=0;i<Rw.length;i++){var r=Rw[i],o=t[r[0]];null!=o&&(e[r[1]]=Iw(o*n)/n)}})],polyline:[Lw,Pw],polygon:[Lw,Pw]};function Ew(t,e){var n=t.style,i=t.shape,r=Nw[t.type],o={},a=e.animation,s="path",l=t.style.strokePercent,u=e.compress&&hi(t)||4;if(!r||e.willUpdate||r[1]&&!r[1](i)||a&&function(t){for(var e=t.animators,n=0;n<e.length;n++)if("shape"===e[n].targetName)return!0;return!1}(t)||l<1){var h=!t.path||t.shapeChanged();t.path||t.createPathProxy();var c=t.path;h&&(c.beginPath(),t.buildPath(c,t.shape),t.pathUpdated());var p=c.getVersion(),d=t,f=d.__svgPathBuilder;d.__svgPathVersion===p&&f&&l===d.__svgPathStrokePercent||(f||(f=d.__svgPathBuilder=new rw),f.reset(u),c.rebuildPath(f,l),f.generateStr(),d.__svgPathVersion=p,d.__svgPathStrokePercent=l),o.d=f.getStr()}else{s=t.type;var g=Math.pow(10,u);r[0](i,o,g)}return kw(o,t.transform),Dw(o,n,t,e),e.animation&&Mw(t,o,e),dw(s,t.id+"",o)}function zw(t,e){return t instanceof ys?Ew(t,e):t instanceof Ss?function(t,e){var n=t.style,i=n.image;if(i&&!H(i)&&(Tw(i)?i=i.src:Cw(i)&&(i=i.toDataURL())),i){var r=n.x||0,o=n.y||0,a={href:i,width:n.width,height:n.height};return r&&(a.x=r),o&&(a.y=o),kw(a,t.transform),Dw(a,n,t,e),e.animation&&Mw(t,a,e),dw("image",t.id+"",a)}}(t,e):t instanceof xs?function(t,e){var n=t.style,i=n.text;if(null!=i&&(i+=""),i&&!isNaN(n.x)&&!isNaN(n.y)){var r=n.font||u,o=n.x||0,a=function(t,e,n){return"top"===n?t+=e/2:"bottom"===n&&(t-=e/2),t}(n.y||0,yr(r),n.textBaseline),s={"dominant-baseline":"central","text-anchor":ii[n.textAlign]||n.textAlign};if(Fs(n)){var h="",c=n.fontStyle,p=Vs(n.fontSize);if(!parseFloat(p))return;var d=n.fontFamily||l,f=n.fontWeight;h+="font-size:"+p+";font-family:"+d+";",c&&"normal"!==c&&(h+="font-style:"+c+";"),f&&"normal"!==f&&(h+="font-weight:"+f+";"),s.style=h}else s.style="font: "+r;return i.match(/\s/)&&(s["xml:space"]="preserve"),o&&(s.x=o),a&&(s.y=a),kw(s,t.transform),Dw(s,n,t,e),e.animation&&Mw(t,s,e),dw("text",t.id+"",s,void 0,i)}}(t,e):void 0}function Vw(t,e,n,i){var r,o=t[n],a={gradientUnits:o.global?"userSpaceOnUse":"objectBoundingBox"};if(ai(o))r="linearGradient",a.x1=o.x,a.y1=o.y,a.x2=o.x2,a.y2=o.y2;else{if(!si(o))return;r="radialGradient",a.cx=Q(o.x,.5),a.cy=Q(o.y,.5),a.r=Q(o.r,.5)}for(var s=o.colorStops,l=[],u=0,h=s.length;u<h;++u){var c=100*ni(s[u].offset)+"%",p=Jn(s[u].color),d=p.color,f=p.opacity,g={offset:c};g["stop-color"]=d,f<1&&(g["stop-opacity"]=f),l.push(dw("stop",u+"",g))}var y=fw(dw(r,"",a,l)),v=i.gradientCache,m=v[y];m||(m=i.zrId+"-g"+i.gradientIdx++,v[y]=m,a.id=m,i.defs[m]=dw(r,m,a,l)),e[n]=ui(m)}function Bw(t,e,n,i){var r,o=t.style[n],a=t.getBoundingRect(),s={},l=o.repeat,u="no-repeat"===l,h="repeat-x"===l,c="repeat-y"===l;if(ri(o)){var p=o.imageWidth,d=o.imageHeight,f=void 0,g=o.image;if(H(g)?f=g:Tw(g)?f=g.src:Cw(g)&&(f=g.toDataURL()),"undefined"==typeof Image){var y="Image width/height must been given explictly in svg-ssr renderer.";it(p,y),it(d,y)}else if(null==p||null==d){var v=function(t,e){if(t){var n=t.elm,i=p||e.width,r=d||e.height;"pattern"===t.tag&&(h?(r=1,i/=a.width):c&&(i=1,r/=a.height)),t.attrs.width=i,t.attrs.height=r,n&&(n.setAttribute("width",i),n.setAttribute("height",r))}},m=Xo(f,null,t,(function(t){u||v(w,t),v(r,t)}));m&&m.width&&m.height&&(p=p||m.width,d=d||m.height)}r=dw("image","img",{href:f,width:p,height:d}),s.width=p,s.height=d}else o.svgElement&&(r=T(o.svgElement),s.width=o.svgWidth,s.height=o.svgHeight);if(r){var x,_;u?x=_=1:h?(_=1,x=s.width/a.width):c?(x=1,_=s.height/a.height):s.patternUnits="userSpaceOnUse",null==x||isNaN(x)||(s.width=x),null==_||isNaN(_)||(s.height=_);var b=ci(o);b&&(s.patternTransform=b);var w=dw("pattern","",s,[r]),S=fw(w),M=i.patternCache,I=M[S];I||(I=i.zrId+"-p"+i.patternIdx++,M[S]=I,s.id=I,w=i.defs[I]=dw("pattern",I,s,[r])),e[n]=ui(I)}}function Fw(t,e,n){var i=n.clipPathCache,r=n.defs,o=i[t.id];if(!o){var a={id:o=n.zrId+"-c"+n.clipPathIdx++};i[t.id]=o,r[o]=dw("clipPath",o,a,[Ew(t,n)])}e["clip-path"]=ui(o)}function Gw(t){return document.createTextNode(t)}function Ww(t,e,n){t.insertBefore(e,n)}function Hw(t,e){t.removeChild(e)}function Yw(t,e){t.appendChild(e)}function Xw(t){return t.parentNode}function Uw(t){return t.nextSibling}function Zw(t,e){t.textContent=e}var jw=dw("","");function qw(t){return void 0===t}function Kw(t){return void 0!==t}function $w(t,e,n){for(var i={},r=e;r<=n;++r){var o=t[r].key;void 0!==o&&(i[o]=r)}return i}function Jw(t,e){var n=t.key===e.key;return t.tag===e.tag&&n}function Qw(t){var e,n=t.children,i=t.tag;if(Kw(i)){var r=t.elm=pw(i);if(nS(jw,t),G(n))for(e=0;e<n.length;++e){var o=n[e];null!=o&&Yw(r,Qw(o))}else Kw(t.text)&&!U(t.text)&&Yw(r,Gw(t.text))}else t.elm=Gw(t.text);return t.elm}function tS(t,e,n,i,r){for(;i<=r;++i){var o=n[i];null!=o&&Ww(t,Qw(o),e)}}function eS(t,e,n,i){for(;n<=i;++n){var r=e[n];null!=r&&(Kw(r.tag)?Hw(Xw(r.elm),r.elm):Hw(t,r.elm))}}function nS(t,e){var n,i=e.elm,r=t&&t.attrs||{},o=e.attrs||{};if(r!==o){for(n in o){var a=o[n];r[n]!==a&&(!0===a?i.setAttribute(n,""):!1===a?i.removeAttribute(n):120!==n.charCodeAt(0)?i.setAttribute(n,a):"xmlns:xlink"===n||"xmlns"===n?i.setAttributeNS("http://www.w3.org/2000/xmlns/",n,a):58===n.charCodeAt(3)?i.setAttributeNS("http://www.w3.org/XML/1998/namespace",n,a):58===n.charCodeAt(5)?i.setAttributeNS(cw,n,a):i.setAttribute(n,a))}for(n in r)n in o||i.removeAttribute(n)}}function iS(t,e){var n=e.elm=t.elm,i=t.children,r=e.children;t!==e&&(nS(t,e),qw(e.text)?Kw(i)&&Kw(r)?i!==r&&function(t,e,n){for(var i,r,o,a=0,s=0,l=e.length-1,u=e[0],h=e[l],c=n.length-1,p=n[0],d=n[c];a<=l&&s<=c;)null==u?u=e[++a]:null==h?h=e[--l]:null==p?p=n[++s]:null==d?d=n[--c]:Jw(u,p)?(iS(u,p),u=e[++a],p=n[++s]):Jw(h,d)?(iS(h,d),h=e[--l],d=n[--c]):Jw(u,d)?(iS(u,d),Ww(t,u.elm,Uw(h.elm)),u=e[++a],d=n[--c]):Jw(h,p)?(iS(h,p),Ww(t,h.elm,u.elm),h=e[--l],p=n[++s]):(qw(i)&&(i=$w(e,a,l)),qw(r=i[p.key])||(o=e[r]).tag!==p.tag?Ww(t,Qw(p),u.elm):(iS(o,p),e[r]=void 0,Ww(t,o.elm,u.elm)),p=n[++s]);(a<=l||s<=c)&&(a>l?tS(t,null==n[c+1]?null:n[c+1].elm,n,s,c):eS(t,e,a,l))}(n,i,r):Kw(r)?(Kw(t.text)&&Zw(n,""),tS(n,null,r,0,r.length-1)):Kw(i)?eS(n,i,0,i.length-1):Kw(t.text)&&Zw(n,""):t.text!==e.text&&(Kw(i)&&eS(n,i,0,i.length-1),Zw(n,e.text)))}var rS=0,oS=function(){function t(t,e,n){if(this.type="svg",this.refreshHover=function(){},this.configLayer=function(){},this.storage=e,this._opts=n=A({},n),this.root=t,this._id="zr"+rS++,this._oldVNode=yw(n.width,n.height),t&&!n.ssr){var i=this._viewport=document.createElement("div");i.style.cssText="position:relative;overflow:hidden";var r=this._svgDom=this._oldVNode.elm=pw("svg");nS(null,this._oldVNode),i.appendChild(r),t.appendChild(i)}this.resize(n.width,n.height)}return t.prototype.getType=function(){return this.type},t.prototype.getViewportRoot=function(){return this._viewport},t.prototype.getViewportRootOffset=function(){var t=this.getViewportRoot();if(t)return{offsetLeft:t.offsetLeft||0,offsetTop:t.offsetTop||0}},t.prototype.getSvgDom=function(){return this._svgDom},t.prototype.refresh=function(){if(this.root){var t=this.renderToVNode({willUpdate:!0});t.attrs.style="position:absolute;left:0;top:0;user-select:none",function(t,e){if(Jw(t,e))iS(t,e);else{var n=t.elm,i=Xw(n);Qw(e),null!==i&&(Ww(i,e.elm,Uw(n)),eS(i,[t],0,0))}}(this._oldVNode,t),this._oldVNode=t}},t.prototype.renderOneToVNode=function(t){return zw(t,gw(this._id))},t.prototype.renderToVNode=function(t){t=t||{};var e=this.storage.getDisplayList(!0),n=this._width,i=this._height,r=gw(this._id);r.animation=t.animation,r.willUpdate=t.willUpdate,r.compress=t.compress;var o=[],a=this._bgVNode=function(t,e,n,i){var r;if(n&&"none"!==n)if(r=dw("rect","bg",{width:t,height:e,x:"0",y:"0",id:"0"}),li(n))Vw({fill:n},r.attrs,"fill",i);else if(oi(n))Bw({style:{fill:n},dirty:yt,getBoundingRect:function(){return{width:t,height:e}}},r.attrs,"fill",i);else{var o=Jn(n),a=o.color,s=o.opacity;r.attrs.fill=a,s<1&&(r.attrs["fill-opacity"]=s)}return r}(n,i,this._backgroundColor,r);a&&o.push(a);var s=t.compress?null:this._mainVNode=dw("g","main",{},[]);this._paintList(e,r,s?s.children:o),s&&o.push(s);var l=N(V(r.defs),(function(t){return r.defs[t]}));if(l.length&&o.push(dw("defs","defs",{},l)),t.animation){var u=function(t,e,n){var i=(n=n||{}).newline?"\n":"",r=" {"+i,o=i+"}",a=N(V(t),(function(e){return e+r+N(V(t[e]),(function(n){return n+":"+t[e][n]+";"})).join(i)+o})).join(i),s=N(V(e),(function(t){return"@keyframes "+t+r+N(V(e[t]),(function(n){return n+r+N(V(e[t][n]),(function(i){var r=e[t][n][i];return"d"===i&&(r='path("'+r+'")'),i+":"+r+";"})).join(i)+o})).join(i)+o})).join(i);return a||s?["<![CDATA[",a,s,"]]>"].join(i):""}(r.cssNodes,r.cssAnims,{newline:!0});if(u){var h=dw("style","stl",{},[],u);o.push(h)}}return yw(n,i,o,t.useViewBox)},t.prototype.renderToString=function(t){return t=t||{},fw(this.renderToVNode({animation:Q(t.cssAnimation,!0),willUpdate:!1,compress:!0,useViewBox:Q(t.useViewBox,!0)}),{newline:!0})},t.prototype.setBackgroundColor=function(t){this._backgroundColor=t},t.prototype.getSvgRoot=function(){return this._mainVNode&&this._mainVNode.elm},t.prototype._paintList=function(t,e,n){for(var i,r,o=t.length,a=[],s=0,l=0,u=0;u<o;u++){var h=t[u];if(!h.invisible){var c=h.__clipPaths,p=c&&c.length||0,d=r&&r.length||0,f=void 0;for(f=Math.max(p-1,d-1);f>=0&&(!c||!r||c[f]!==r[f]);f--);for(var g=d-1;g>f;g--)i=a[--s-1];for(var y=f+1;y<p;y++){var v={};Fw(c[y],v,e);var m=dw("g","clip-g-"+l++,v,[]);(i?i.children:n).push(m),a[s++]=m,i=m}r=c;var x=zw(h,e);x&&(i?i.children:n).push(x)}}},t.prototype.resize=function(t,e){var n=this._opts,i=this.root,r=this._viewport;if(null!=t&&(n.width=t),null!=e&&(n.height=e),i&&r&&(r.style.display="none",t=cv(i,0,n),e=cv(i,1,n),r.style.display=""),this._width!==t||this._height!==e){if(this._width=t,this._height=e,r){var o=r.style;o.width=t+"px",o.height=e+"px"}if(oi(this._backgroundColor))this.refresh();else{var a=this._svgDom;a&&(a.setAttribute("width",t),a.setAttribute("height",e));var s=this._bgVNode&&this._bgVNode.elm;s&&(s.setAttribute("width",t),s.setAttribute("height",e))}}},t.prototype.getWidth=function(){return this._width},t.prototype.getHeight=function(){return this._height},t.prototype.dispose=function(){this.root&&(this.root.innerHTML=""),this._svgDom=this._viewport=this.storage=this._oldVNode=this._bgVNode=this._mainVNode=null},t.prototype.clear=function(){this._svgDom&&(this._svgDom.innerHTML=null),this._oldVNode=null},t.prototype.toDataURL=function(t){var e=this.renderToString(),n="data:image/svg+xml;";return t?(e=pi(e))&&n+"base64,"+e:n+"charset=UTF-8,"+encodeURIComponent(e)},t}();const aS=oS;function sS(t,e,n){var i=c.createCanvas(),r=e.getWidth(),o=e.getHeight(),a=i.style;return a&&(a.position="absolute",a.left="0",a.top="0",a.width=r+"px",a.height=o+"px",i.setAttribute("data-zr-dom-id",t)),i.width=r*n,i.height=o*n,i}var lS=function(t){function e(e,n,i){var r,o=t.call(this)||this;o.motionBlur=!1,o.lastFrameAlpha=.7,o.dpr=1,o.virtual=!1,o.config={},o.incremental=!1,o.zlevel=0,o.maxRepaintRectCount=5,o.__dirty=!0,o.__firstTimePaint=!0,o.__used=!1,o.__drawIndex=0,o.__startIndex=0,o.__endIndex=0,o.__prevStartIndex=null,o.__prevEndIndex=null,i=i||$i,"string"==typeof e?r=sS(e,n,i):U(e)&&(e=(r=e).id),o.id=e,o.dom=r;var a=r.style;return a&&(ft(r),r.onselectstart=function(){return!1},a.padding="0",a.margin="0",a.borderWidth="0"),o.painter=n,o.dpr=i,o}return n(e,t),e.prototype.getElementCount=function(){return this.__endIndex-this.__startIndex},e.prototype.afterBrush=function(){this.__prevStartIndex=this.__startIndex,this.__prevEndIndex=this.__endIndex},e.prototype.initContext=function(){this.ctx=this.dom.getContext("2d"),this.ctx.dpr=this.dpr},e.prototype.setUnpainted=function(){this.__firstTimePaint=!0},e.prototype.createBackBuffer=function(){var t=this.dpr;this.domBack=sS("back-"+this.id,this.painter,t),this.ctxBack=this.domBack.getContext("2d"),1!==t&&this.ctxBack.scale(t,t)},e.prototype.createRepaintRects=function(t,e,n,i){if(this.__firstTimePaint)return this.__firstTimePaint=!1,null;var r,o=[],a=this.maxRepaintRectCount,s=!1,l=new Ce(0,0,0,0);function u(t){if(t.isFinite()&&!t.isZero())if(0===o.length)(e=new Ce(0,0,0,0)).copy(t),o.push(e);else{for(var e,n=!1,i=1/0,r=0,u=0;u<o.length;++u){var h=o[u];if(h.intersect(t)){var c=new Ce(0,0,0,0);c.copy(h),c.union(t),o[u]=c,n=!0;break}if(s){l.copy(t),l.union(h);var p=t.width*t.height,d=h.width*h.height,f=l.width*l.height-p-d;f<i&&(i=f,r=u)}}s&&(o[r].union(t),n=!0),n||((e=new Ce(0,0,0,0)).copy(t),o.push(e)),s||(s=o.length>=a)}}for(var h=this.__startIndex;h<this.__endIndex;++h)if(d=t[h]){var c=d.shouldBePainted(n,i,!0,!0);(f=d.__isRendered&&(1&d.__dirty||!c)?d.getPrevPaintRect():null)&&u(f);var p=c&&(1&d.__dirty||!d.__isRendered)?d.getPaintRect():null;p&&u(p)}for(h=this.__prevStartIndex;h<this.__prevEndIndex;++h){var d,f;c=(d=e[h]).shouldBePainted(n,i,!0,!0),!d||c&&d.__zr||!d.__isRendered||(f=d.getPrevPaintRect())&&u(f)}do{for(r=!1,h=0;h<o.length;)if(o[h].isZero())o.splice(h,1);else{for(var g=h+1;g<o.length;)o[h].intersect(o[g])?(r=!0,o[h].union(o[g]),o.splice(g,1)):g++;h++}}while(r);return this._paintRects=o,o},e.prototype.debugGetPaintRects=function(){return(this._paintRects||[]).slice()},e.prototype.resize=function(t,e){var n=this.dpr,i=this.dom,r=i.style,o=this.domBack;r&&(r.width=t+"px",r.height=e+"px"),i.width=t*n,i.height=e*n,o&&(o.width=t*n,o.height=e*n,1!==n&&this.ctxBack.scale(n,n))},e.prototype.clear=function(t,e,n){var i=this.dom,r=this.ctx,o=i.width,a=i.height;e=e||this.clearColor;var s=this.motionBlur&&!t,l=this.lastFrameAlpha,u=this.dpr,h=this;s&&(this.domBack||this.createBackBuffer(),this.ctxBack.globalCompositeOperation="copy",this.ctxBack.drawImage(i,0,0,o/u,a/u));var c=this.domBack;function p(t,n,i,o){if(r.clearRect(t,n,i,o),e&&"transparent"!==e){var a=void 0;K(e)?(a=(e.global||e.__width===i&&e.__height===o)&&e.__canvasGradient||uv(r,e,{x:0,y:0,width:i,height:o}),e.__canvasGradient=a,e.__width=i,e.__height=o):null!=e.image&&(e.scaleX=e.scaleX||u,e.scaleY=e.scaleY||u,a=xv(r,e,{dirty:function(){h.setUnpainted(),h.__painter.refresh()}})),r.save(),r.fillStyle=a||e,r.fillRect(t,n,i,o),r.restore()}s&&(r.save(),r.globalAlpha=l,r.drawImage(c,t,n,i,o),r.restore())}!n||s?p(0,0,o,a):n.length&&R(n,(function(t){p(t.x*u,t.y*u,t.width*u,t.height*u)}))},e}(Bt);const uS=lS;var hS=1e5,cS=314159,pS=.01,dS=function(){function t(t,e,n,i){this.type="canvas",this._zlevelList=[],this._prevDisplayList=[],this._layers={},this._layerConfig={},this._needsManuallyCompositing=!1,this.type="canvas";var r=!t.nodeName||"CANVAS"===t.nodeName.toUpperCase();this._opts=n=A({},n||{}),this.dpr=n.devicePixelRatio||$i,this._singleCanvas=r,this.root=t,t.style&&(ft(t),t.innerHTML=""),this.storage=e;var o=this._zlevelList;this._prevDisplayList=[];var a=this._layers;if(r){var s=t,l=s.width,u=s.height;null!=n.width&&(l=n.width),null!=n.height&&(u=n.height),this.dpr=n.devicePixelRatio||1,s.width=l*this.dpr,s.height=u*this.dpr,this._width=l,this._height=u;var h=new uS(s,this,this.dpr);h.__builtin__=!0,h.initContext(),a[314159]=h,h.zlevel=cS,o.push(cS),this._domRoot=t}else{this._width=cv(t,0,n),this._height=cv(t,1,n);var c=this._domRoot=function(t,e){var n=document.createElement("div");return n.style.cssText=["position:relative","width:"+t+"px","height:"+e+"px","padding:0","margin:0","border-width:0"].join(";")+";",n}(this._width,this._height);t.appendChild(c)}}return t.prototype.getType=function(){return"canvas"},t.prototype.isSingleCanvas=function(){return this._singleCanvas},t.prototype.getViewportRoot=function(){return this._domRoot},t.prototype.getViewportRootOffset=function(){var t=this.getViewportRoot();if(t)return{offsetLeft:t.offsetLeft||0,offsetTop:t.offsetTop||0}},t.prototype.refresh=function(t){var e=this.storage.getDisplayList(!0),n=this._prevDisplayList,i=this._zlevelList;this._redrawId=Math.random(),this._paintList(e,n,t,this._redrawId);for(var r=0;r<i.length;r++){var o=i[r],a=this._layers[o];if(!a.__builtin__&&a.refresh){var s=0===r?this._backgroundColor:null;a.refresh(s)}}return this._opts.useDirtyRect&&(this._prevDisplayList=e.slice()),this},t.prototype.refreshHover=function(){this._paintHoverList(this.storage.getDisplayList(!1))},t.prototype._paintHoverList=function(t){var e=t.length,n=this._hoverlayer;if(n&&n.clear(),e){for(var i,r={inHover:!0,viewWidth:this._width,viewHeight:this._height},o=0;o<e;o++){var a=t[o];a.__inHover&&(n||(n=this._hoverlayer=this.getLayer(hS)),i||(i=n.ctx).save(),Dv(i,a,r,o===e-1))}i&&i.restore()}},t.prototype.getHoverLayer=function(){return this.getLayer(hS)},t.prototype.paintOne=function(t,e){Cv(t,e)},t.prototype._paintList=function(t,e,n,i){if(this._redrawId===i){n=n||!1,this._updateLayerStatus(t);var r=this._doPaintList(t,e,n),o=r.finished,a=r.needsRefreshHover;if(this._needsManuallyCompositing&&this._compositeManually(),a&&this._paintHoverList(t),o)this.eachLayer((function(t){t.afterBrush&&t.afterBrush()}));else{var s=this;Ke((function(){s._paintList(t,e,n,i)}))}}},t.prototype._compositeManually=function(){var t=this.getLayer(cS).ctx,e=this._domRoot.width,n=this._domRoot.height;t.clearRect(0,0,e,n),this.eachBuiltinLayer((function(i){i.virtual&&t.drawImage(i.dom,0,0,e,n)}))},t.prototype._doPaintList=function(t,e,n){for(var i=this,r=[],a=this._opts.useDirtyRect,s=0;s<this._zlevelList.length;s++){var l=this._zlevelList[s],u=this._layers[l];u.__builtin__&&u!==this._hoverlayer&&(u.__dirty||n)&&r.push(u)}for(var h=!0,c=!1,p=function(o){var s,l=r[o],u=l.ctx,p=a&&l.createRepaintRects(t,e,d._width,d._height),f=n?l.__startIndex:l.__drawIndex,g=!n&&l.incremental&&Date.now,y=g&&Date.now(),v=l.zlevel===d._zlevelList[0]?d._backgroundColor:null;if(l.__startIndex===l.__endIndex)l.clear(!1,v,p);else if(f===l.__startIndex){var m=t[f];m.incremental&&m.notClear&&!n||l.clear(!1,v,p)}-1===f&&(f=l.__startIndex);var x=function(e){var n={inHover:!1,allClipped:!1,prevEl:null,viewWidth:i._width,viewHeight:i._height};for(s=f;s<l.__endIndex;s++){var r=t[s];if(r.__inHover&&(c=!0),i._doPaintEl(r,l,a,e,n,s===l.__endIndex-1),g&&Date.now()-y>15)break}n.prevElClipPaths&&u.restore()};if(p)if(0===p.length)s=l.__endIndex;else for(var _=d.dpr,b=0;b<p.length;++b){var w=p[b];u.save(),u.beginPath(),u.rect(w.x*_,w.y*_,w.width*_,w.height*_),u.clip(),x(w),u.restore()}else u.save(),x(),u.restore();l.__drawIndex=s,l.__drawIndex<l.__endIndex&&(h=!1)},d=this,f=0;f<r.length;f++)p(f);return o.wxa&&R(this._layers,(function(t){t&&t.ctx&&t.ctx.draw&&t.ctx.draw()})),{finished:h,needsRefreshHover:c}},t.prototype._doPaintEl=function(t,e,n,i,r,o){var a=e.ctx;if(n){var s=t.getPaintRect();(!i||s&&s.intersect(i))&&(Dv(a,t,r,o),t.setPrevPaintRect(s))}else Dv(a,t,r,o)},t.prototype.getLayer=function(t,e){this._singleCanvas&&!this._needsManuallyCompositing&&(t=cS);var n=this._layers[t];return n||((n=new uS("zr_"+t,this,this.dpr)).zlevel=t,n.__builtin__=!0,this._layerConfig[t]?C(n,this._layerConfig[t],!0):this._layerConfig[t-pS]&&C(n,this._layerConfig[t-pS],!0),e&&(n.virtual=e),this.insertLayer(t,n),n.initContext()),n},t.prototype.insertLayer=function(t,e){var n=this._layers,i=this._zlevelList,r=i.length,o=this._domRoot,a=null,s=-1;if(!n[t]&&function(t){return!!t&&(!!t.__builtin__||"function"==typeof t.resize&&"function"==typeof t.refresh)}(e)){if(r>0&&t>i[0]){for(s=0;s<r-1&&!(i[s]<t&&i[s+1]>t);s++);a=n[i[s]]}if(i.splice(s+1,0,t),n[t]=e,!e.virtual)if(a){var l=a.dom;l.nextSibling?o.insertBefore(e.dom,l.nextSibling):o.appendChild(e.dom)}else o.firstChild?o.insertBefore(e.dom,o.firstChild):o.appendChild(e.dom);e.__painter=this}},t.prototype.eachLayer=function(t,e){for(var n=this._zlevelList,i=0;i<n.length;i++){var r=n[i];t.call(e,this._layers[r],r)}},t.prototype.eachBuiltinLayer=function(t,e){for(var n=this._zlevelList,i=0;i<n.length;i++){var r=n[i],o=this._layers[r];o.__builtin__&&t.call(e,o,r)}},t.prototype.eachOtherLayer=function(t,e){for(var n=this._zlevelList,i=0;i<n.length;i++){var r=n[i],o=this._layers[r];o.__builtin__||t.call(e,o,r)}},t.prototype.getLayers=function(){return this._layers},t.prototype._updateLayerStatus=function(t){function e(t){o&&(o.__endIndex!==t&&(o.__dirty=!0),o.__endIndex=t)}if(this.eachBuiltinLayer((function(t,e){t.__dirty=t.__used=!1})),this._singleCanvas)for(var n=1;n<t.length;n++)if((s=t[n]).zlevel!==t[n-1].zlevel||s.incremental){this._needsManuallyCompositing=!0;break}var i,r,o=null,a=0;for(r=0;r<t.length;r++){var s,l=(s=t[r]).zlevel,u=void 0;i!==l&&(i=l,a=0),s.incremental?((u=this.getLayer(l+.001,this._needsManuallyCompositing)).incremental=!0,a=1):u=this.getLayer(l+(a>0?pS:0),this._needsManuallyCompositing),u.__builtin__||I("ZLevel "+l+" has been used by unkown layer "+u.id),u!==o&&(u.__used=!0,u.__startIndex!==r&&(u.__dirty=!0),u.__startIndex=r,u.incremental?u.__drawIndex=-1:u.__drawIndex=r,e(r),o=u),1&s.__dirty&&!s.__inHover&&(u.__dirty=!0,u.incremental&&u.__drawIndex<0&&(u.__drawIndex=r))}e(r),this.eachBuiltinLayer((function(t,e){!t.__used&&t.getElementCount()>0&&(t.__dirty=!0,t.__startIndex=t.__endIndex=t.__drawIndex=0),t.__dirty&&t.__drawIndex<0&&(t.__drawIndex=t.__startIndex)}))},t.prototype.clear=function(){return this.eachBuiltinLayer(this._clearLayer),this},t.prototype._clearLayer=function(t){t.clear()},t.prototype.setBackgroundColor=function(t){this._backgroundColor=t,R(this._layers,(function(t){t.setUnpainted()}))},t.prototype.configLayer=function(t,e){if(e){var n=this._layerConfig;n[t]?C(n[t],e,!0):n[t]=e;for(var i=0;i<this._zlevelList.length;i++){var r=this._zlevelList[i];r!==t&&r!==t+pS||C(this._layers[r],n[t],!0)}}},t.prototype.delLayer=function(t){var e=this._layers,n=this._zlevelList,i=e[t];i&&(i.dom.parentNode.removeChild(i.dom),delete e[t],n.splice(L(n,t),1))},t.prototype.resize=function(t,e){if(this._domRoot.style){var n=this._domRoot;n.style.display="none";var i=this._opts,r=this.root;if(null!=t&&(i.width=t),null!=e&&(i.height=e),t=cv(r,0,i),e=cv(r,1,i),n.style.display="",this._width!==t||e!==this._height){for(var o in n.style.width=t+"px",n.style.height=e+"px",this._layers)this._layers.hasOwnProperty(o)&&this._layers[o].resize(t,e);this.refresh(!0)}this._width=t,this._height=e}else{if(null==t||null==e)return;this._width=t,this._height=e,this.getLayer(cS).resize(t,e)}return this},t.prototype.clearLayer=function(t){var e=this._layers[t];e&&e.clear()},t.prototype.dispose=function(){this.root.innerHTML="",this.root=this.storage=this._domRoot=this._layers=null},t.prototype.getRenderedCanvas=function(t){if(t=t||{},this._singleCanvas&&!this._compositeManually)return this._layers[314159].dom;var e=new uS("image",this,t.pixelRatio||this.dpr);e.initContext(),e.clear(!1,t.backgroundColor||this._backgroundColor);var n=e.ctx;if(t.pixelRatio<=this.dpr){this.refresh();var i=e.dom.width,r=e.dom.height;this.eachLayer((function(t){t.__builtin__?n.drawImage(t.dom,0,0,i,r):t.renderToCanvas&&(n.save(),t.renderToCanvas(n),n.restore())}))}else for(var o={inHover:!1,viewWidth:this._width,viewHeight:this._height},a=this.storage.getDisplayList(!0),s=0,l=a.length;s<l;s++){var u=a[s];Dv(n,u,o,s===l-1)}return e.dom},t.prototype.getWidth=function(){return this._width},t.prototype.getHeight=function(){return this._height},t}();const fS=dS;var gS=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n}return n(e,t),e.prototype.getInitialData=function(t){return Cx(null,this,{useEncodeDefaulter:!0})},e.prototype.getLegendIcon=function(t){var e=new Lr,n=ov("line",0,t.itemHeight/2,t.itemWidth,0,t.lineStyle.stroke,!1);e.add(n),n.setStyle(t.lineStyle);var i=this.getData().getVisual("symbol"),r=this.getData().getVisual("symbolRotate"),o="none"===i?"circle":i,a=.8*t.itemHeight,s=ov(o,(t.itemWidth-a)/2,(t.itemHeight-a)/2,a,a,t.itemStyle.fill);e.add(s),s.setStyle(t.itemStyle);var l="inherit"===t.iconRotate?r:t.iconRotate||0;return s.rotation=l*Math.PI/180,s.setOrigin([t.itemWidth/2,t.itemHeight/2]),o.indexOf("empty")>-1&&(s.style.stroke=s.style.fill,s.style.fill="#fff",s.style.lineWidth=2),e},e.type="series.line",e.dependencies=["grid","polar"],e.defaultOption={// zlevel: 0,
z:3,coordinateSystem:"cartesian2d",legendHoverLink:!0,clip:!0,label:{position:"top"},// itemStyle: {
// },
endLabel:{show:!1,valueAnimation:!0,distance:8},lineStyle:{width:2,type:"solid"},emphasis:{scale:!0},// areaStyle: {
// origin of areaStyle. Valid values:
// `'auto'/null/undefined`: from axisLine to data
// `'start'`: from min to data
// `'end'`: from data to max
// origin: 'auto'
// },
// false, 'start', 'end', 'middle'
step:!1,// Disabled if step is true
smooth:!1,smoothMonotone:null,symbol:"emptyCircle",symbolSize:4,symbolRotate:null,showSymbol:!0,// `false`: follow the label interval strategy.
// `true`: show all symbols.
// `'auto'`: If possible, show all symbols, otherwise
//           follow the label interval strategy.
showAllSymbol:"auto",// Whether to connect break point.
connectNulls:!1,// Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
sampling:"none",animationEasing:"linear",// Disable progressive
progressive:0,hoverLayerThreshold:1/0,universalTransition:{divideShape:"clone"},triggerLineEvent:!1},e}(zg);const yS=gS;
/**
             * @return label string. Not null/undefined
             */function vS(t,e){var n=t.mapDimensionsAll("defaultedLabel"),i=n.length;// Simple optimization (in lots of cases, label dims length is 1)
if(1===i){var r=Tf(t,e,n[0]);return null!=r?r+"":null}if(i){for(var o=[],a=0;a<n.length;a++)o.push(Tf(t,e,n[a]));return o.join(" ")}}function mS(t,e){var n=t.mapDimensionsAll("defaultedLabel");if(!G(e))return e+"";for(var i=[],r=0;r<n.length;r++){var o=t.getDimensionIndex(n[r]);o>=0&&i.push(e[o])}return i.join(" ")}var xS=/** @class */function(t){function e(e,n,i,r){var o=t.call(this)||this;return o.updateData(e,n,i,r),o}return n(e,t),e.prototype._createSymbol=function(t,e,n,i,r){// Remove paths created before
this.removeAll();// let symbolPath = createSymbol(
//     symbolType, -0.5, -0.5, 1, 1, color
// );
// If width/height are set too small (e.g., set to 1) on ios10
// and macOS Sierra, a circle stroke become a rect, no matter what
// the scale is set. So we set width/height as 2. See #4150.
var o=ov(t,-1,-1,2,2,null,r);o.attr({z2:100,culling:!0,scaleX:i[0]/2,scaleY:i[1]/2}),// Rewrite drift method
o.drift=_S,this._symbolType=t,this.add(o)},
/**
               * Stop animation
               * @param {boolean} toLastFrame
               */
e.prototype.stopSymbolAnimation=function(t){this.childAt(0).stopAnimation(null,t)},e.prototype.getSymbolType=function(){return this._symbolType},
/**
               * FIXME:
               * Caution: This method breaks the encapsulation of this module,
               * but it indeed brings convenience. So do not use the method
               * unless you detailedly know all the implements of `Symbol`,
               * especially animation.
               *
               * Get symbol path element.
               */
e.prototype.getSymbolPath=function(){return this.childAt(0)},
/**
               * Highlight symbol
               */
e.prototype.highlight=function(){Il(this.childAt(0))},
/**
               * Downplay symbol
               */
e.prototype.downplay=function(){Tl(this.childAt(0))},
/**
               * @param {number} zlevel
               * @param {number} z
               */
e.prototype.setZ=function(t,e){var n=this.childAt(0);n.zlevel=t,n.z=e},e.prototype.setDraggable=function(t,e){var n=this.childAt(0);n.draggable=t,n.cursor=!e&&t?"move":n.cursor},
/**
               * Update symbol properties
               */
e.prototype.updateData=function(t,n,i,r){this.silent=!1;var o=t.getItemVisual(n,"symbol")||"circle",a=t.hostModel,s=e.getSymbolSize(t,n),l=o!==this._symbolType,u=r&&r.disableAnimation;if(l){var h=t.getItemVisual(n,"symbolKeepAspect");this._createSymbol(o,t,n,s,h)}else{(p=this.childAt(0)).silent=!1;var c={scaleX:s[0]/2,scaleY:s[1]/2};u?p.attr(c):Sh(p,c,a,n),Ah(p)}if(this._updateCommon(t,n,s,i,r),l){var p=this.childAt(0);u||(c={scaleX:this._sizeX,scaleY:this._sizeY,style:{// Always fadeIn. Because it has fadeOut animation when symbol is removed..
opacity:p.style.opacity}},p.scaleX=p.scaleY=0,p.style.opacity=0,Mh(p,c,a,n))}u&&// Must stop leave transition manually if don't call initProps or updateProps.
this.childAt(0).stopAnimation("leave")},e.prototype._updateCommon=function(t,e,n,i,r){var o,a,s,l,u,h,c,p,d,f=this.childAt(0),g=t.hostModel;if(i&&(o=i.emphasisItemStyle,a=i.blurItemStyle,s=i.selectItemStyle,l=i.focus,u=i.blurScope,c=i.labelStatesModels,p=i.hoverScale,d=i.cursorStyle,h=i.emphasisDisabled),!i||t.hasItemOption){var y=i&&i.itemModel?i.itemModel:t.getItemModel(e),v=y.getModel("emphasis");o=v.getModel("itemStyle").getItemStyle(),s=y.getModel(["select","itemStyle"]).getItemStyle(),a=y.getModel(["blur","itemStyle"]).getItemStyle(),l=v.get("focus"),u=v.get("blurScope"),h=v.get("disabled"),c=sc(y),p=v.getShallow("scale"),d=y.getShallow("cursor")}var m=t.getItemVisual(e,"symbolRotate");f.attr("rotation",(m||0)*Math.PI/180||0);var x=sv(t.getItemVisual(e,"symbolOffset"),n);x&&(f.x=x[0],f.y=x[1]),d&&f.attr("cursor",d);var _=t.getItemVisual(e,"style"),b=_.fill;if(f instanceof Ss){var w=f.style;f.useStyle(A({// TODO other properties like x, y ?
image:w.image,x:w.x,y:w.y,width:w.width,height:w.height},_))}else f.__isEmptyBrush?// fill and stroke will be swapped if it's empty.
// So we cloned a new style to avoid it affecting the original style in visual storage.
// TODO Better implementation. No empty logic!
f.useStyle(A({},_)):f.useStyle(_),// Disable decal because symbol scale will been applied on the decal.
f.style.decal=null,f.setColor(b,r&&r.symbolInnerColor),f.style.strokeNoScale=!0;var S=t.getItemVisual(e,"liftZ"),M=this._z2;null!=S?null==M&&(this._z2=f.z2,f.z2+=S):null!=M&&(f.z2=M,this._z2=null);var I=r&&r.useNameLabel;ac(f,c,{labelFetcher:g,labelDataIndex:e,defaultText:// Do not execute util needed.
function(e){return I?t.getName(e):vS(t,e)},inheritColor:b,defaultOpacity:_.opacity}),this._sizeX=n[0]/2,this._sizeY=n[1]/2;var T=f.ensureState("emphasis");T.style=o,f.ensureState("select").style=s,f.ensureState("blur").style=a;// null / undefined / true means to use default strategy.
// 0 / false / negative number / NaN / Infinity means no scale.
var C=null==p||!0===p?Math.max(1.1,3/this._sizeY):isFinite(p)&&p>0?+p:1;// always set scale to allow resetting
T.scaleX=this._sizeX*C,T.scaleY=this._sizeY*C,this.setSymbolScale(1),Bl(this,l,u,h)},e.prototype.setSymbolScale=function(t){this.scaleX=this.scaleY=t},e.prototype.fadeOut=function(t,e,n){var i=this.childAt(0),r=js(this).dataIndex,o=n&&n.animation;// Not show text when animating
if(// Avoid mistaken hover when fading out
this.silent=i.silent=!0,n&&n.fadeLabel){var a=i.getTextContent();a&&Th(a,{style:{opacity:0}},e,{dataIndex:r,removeOpt:o,cb:function(){i.removeTextContent()}})}else i.removeTextContent();Th(i,{style:{opacity:0},scaleX:0,scaleY:0},e,{dataIndex:r,cb:t,removeOpt:o})},e.getSymbolSize=function(t,e){return av(t.getItemVisual(e,"symbolSize"))},e}(Lr);function _S(t,e){this.parent.drift(t,e)}const bS=xS;function wS(t,e,n,i){return e&&!isNaN(e[0])&&!isNaN(e[1])&&!(i.isIgnore&&i.isIgnore(n))&&!(i.clipShape&&!i.clipShape.contain(e[0],e[1]))&&"none"!==t.getItemVisual(n,"symbol")}function SS(t){return null==t||U(t)||(t={isIgnore:t}),t||{}}function MS(t){var e=t.hostModel,n=e.getModel("emphasis");return{emphasisItemStyle:n.getModel("itemStyle").getItemStyle(),blurItemStyle:e.getModel(["blur","itemStyle"]).getItemStyle(),selectItemStyle:e.getModel(["select","itemStyle"]).getItemStyle(),focus:n.get("focus"),blurScope:n.get("blurScope"),emphasisDisabled:n.get("disabled"),hoverScale:n.get("scale"),labelStatesModels:sc(e),cursorStyle:e.get("cursor")}}var IS=/** @class */function(){function t(t){this.group=new Lr,this._SymbolCtor=t||bS}
/**
               * Update symbols draw by new data
               */return t.prototype.updateData=function(t,e){// Remove progressive els.
this._progressiveEls=null,e=SS(e);var n=this.group,i=t.hostModel,r=this._data,o=this._SymbolCtor,a=e.disableAnimation,s=MS(t),l={disableAnimation:a},u=e.getSymbolPoint||function(e){return t.getItemLayout(e)};// There is no oldLineData only when first rendering or switching from
// stream mode to normal mode, where previous elements should be removed.
r||n.removeAll(),t.diff(r).add((function(i){var r=u(i);if(wS(t,r,i,e)){var a=new o(t,i,s,l);a.setPosition(r),t.setItemGraphicEl(i,a),n.add(a)}})).update((function(h,c){var p=r.getItemGraphicEl(c),d=u(h);if(wS(t,d,h,e)){var f=t.getItemVisual(h,"symbol")||"circle",g=p&&p.getSymbolType&&p.getSymbolType();if(!p||g&&g!==f)n.remove(p),(p=new o(t,h,s,l)).setPosition(d);else{p.updateData(t,h,s,l);var y={x:d[0],y:d[1]};a?p.attr(y):Sh(p,y,i)}// Add back
n.add(p),t.setItemGraphicEl(h,p)}else n.remove(p)})).remove((function(t){var e=r.getItemGraphicEl(t);e&&e.fadeOut((function(){n.remove(e)}),i)})).execute(),this._getSymbolPoint=u,this._data=t},t.prototype.updateLayout=function(){var t=this,e=this._data;e&&// Not use animation
e.eachItemGraphicEl((function(e,n){var i=t._getSymbolPoint(n);e.setPosition(i),e.markRedraw()}))},t.prototype.incrementalPrepareUpdate=function(t){this._seriesScope=MS(t),this._data=null,this.group.removeAll()},
/**
               * Update symbols draw by new data
               */
t.prototype.incrementalUpdate=function(t,e,n){function i(t){t.isGroup||(t.incremental=!0,t.ensureState("emphasis").hoverLayer=!0)}// Clear
this._progressiveEls=[],n=SS(n);for(var r=t.start;r<t.end;r++){var o=e.getItemLayout(r);if(wS(e,o,r,n)){var a=new this._SymbolCtor(e,r,this._seriesScope);a.traverse(i),a.setPosition(o),this.group.add(a),e.setItemGraphicEl(r,a),this._progressiveEls.push(a)}}},t.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},t.prototype.remove=function(t){var e=this.group,n=this._data;// Incremental model do not have this._data.
n&&t?n.eachItemGraphicEl((function(t){t.fadeOut((function(){e.remove(t)}),n.hostModel)})):e.removeAll()},t}();const TS=IS;function CS(t,e,n){var i=t.getBaseAxis(),r=t.getOtherAxis(i),o=function(t,e){var n=0,i=t.scale.getExtent();return"start"===e?n=i[0]:"end"===e?n=i[1]:X(e)&&!isNaN(e)?n=e:// Both positive
i[0]>0?n=i[0]:i[1]<0&&(n=i[1]),n}(r,n),a=i.dim,s=r.dim,l=e.mapDimension(s),u=e.mapDimension(a),h="x"===s||"radius"===s?1:0,c=N(t.dimensions,(function(t){return e.mapDimension(t)})),p=!1,d=e.getCalculationInfo("stackResultDimension");return Ix(e,c[0]/* , dims[1] */)&&(// jshint ignore:line
p=!0,c[0]=d),Ix(e,c[1]/* , dims[0] */)&&(// jshint ignore:line
p=!0,c[1]=d),{dataDimsForPoint:c,valueStart:o,valueAxisDim:s,baseAxisDim:a,stacked:!!p,valueDim:l,baseDim:u,baseDataOffset:h,stackedOverDimension:e.getCalculationInfo("stackedOverDimension")}}function DS(t,e,n,i){var r=NaN;t.stacked&&(r=n.get(n.getCalculationInfo("stackedOverDimension"),i)),isNaN(r)&&(r=t.valueStart);var o=t.baseDataOffset,a=[];return a[o]=n.get(t.baseDim,i),a[1-o]=r,e.dataToPoint(a)}var AS=Math.min,kS=Math.max;function LS(t,e){return isNaN(t)||isNaN(e)}
/**
             * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
             * situations. This should be used when points are non-monotone neither in x or
             * y dimension.
             */function PS(t,e,n,i,r,o,a,s,l){for(var u,h,c,p,d,f,g=n,y=0;y<i;y++){var v=e[2*g],m=e[2*g+1];if(g>=r||g<0)break;if(LS(v,m)){if(l){g+=o;continue}break}if(g===n)t[o>0?"moveTo":"lineTo"](v,m),c=v,p=m;else{var x=v-u,_=m-h;// Ignore tiny segment.
if(x*x+_*_<.5){g+=o;continue}if(a>0){// Ignore duplicate point
for(var b=g+o,w=e[2*b],S=e[2*b+1];w===v&&S===m&&y<i;)y++,g+=o,w=e[2*(b+=o)],S=e[2*b+1],x=(v=e[2*g])-u,_=(m=e[2*g+1])-h;var M=y+1;if(l)// Find next point not null
for(;LS(w,S)&&M<i;)M++,w=e[2*(b+=o)],S=e[2*b+1];var I=.5,T=0,C=0,D=void 0,A=void 0;// Is last point
if(M>=i||LS(w,S))d=v,f=m;else{T=w-u,C=S-h;var k=v-u,L=w-v,P=m-h,O=S-m,R=void 0,N=void 0;if("x"===s){var E=T>0?1:-1;d=v-E*(R=Math.abs(k))*a,f=m,D=v+E*(N=Math.abs(L))*a,A=m}else if("y"===s){var z=C>0?1:-1;d=v,f=m-z*(R=Math.abs(P))*a,D=v,A=m+z*(N=Math.abs(O))*a}else R=Math.sqrt(k*k+P*P),d=v-T*a*(1-(// Use ratio of seg length
I=(N=Math.sqrt(L*L+O*O))/(N+R))),f=m-C*a*(1-I),A=m+C*a*I,// Smooth constraint between point and next point.
// Avoid exceeding extreme after smoothing.
D=AS(// cp0 of next segment
D=v+T*a*I,kS(w,v)),A=AS(A,kS(S,m)),D=kS(D,AS(w,v)),f=m-(C=(A=kS(A,AS(S,m)))-m)*R/N,// Smooth constraint between point and prev point.
// Avoid exceeding extreme after smoothing.
d=AS(d=v-(// Reclaculate cp1 based on the adjusted cp0 of next seg.
T=D-v)*R/N,kS(u,v)),f=AS(f,kS(h,m)),D=v+(// Adjust next cp0 again.
T=v-(d=kS(d,AS(u,v))))*N/R,A=m+(C=m-(f=kS(f,AS(h,m))))*N/R}t.bezierCurveTo(c,p,d,f,v,m),c=D,p=A}else t.lineTo(v,m)}u=v,h=m,g+=o}return y}var OS=function(){this.smooth=0,this.smoothConstraint=!0},RS=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="ec-polyline",n}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new OS},e.prototype.buildPath=function(t,e){var n=e.points,i=0,r=n.length/2;// const result = getBoundingBox(points, shape.smoothConstraint);
if(e.connectNulls){// Must remove first and last null values avoid draw error in polygon
for(;r>0&&LS(n[2*r-2],n[2*r-1]);r--);for(;i<r&&LS(n[2*i],n[2*i+1]);i++);}for(;i<r;)i+=PS(t,n,i,r,r,1,e.smooth,e.smoothMonotone,e.connectNulls)+1},e.prototype.getPointOn=function(t,e){this.path||(this.createPathProxy(),this.buildPath(this.path,this.shape));for(var n,i,r=this.path.data,o=qa.CMD,a="x"===e,s=[],l=0;l<r.length;){var u=void 0,h=void 0,c=void 0,p=void 0,d=void 0,f=void 0,g=void 0;switch(r[l++]){case o.M:n=r[l++],i=r[l++];break;case o.L:if(u=r[l++],h=r[l++],(g=a?(t-n)/(u-n):(t-i)/(h-i))<=1&&g>=0){var y=a?(h-i)*g+i:(u-n)*g+n;return a?[t,y]:[y,t]}n=u,i=h;break;case o.C:u=r[l++],h=r[l++],c=r[l++],p=r[l++],d=r[l++],f=r[l++];var v=a?dn(n,u,c,d,t,s):dn(i,h,p,f,t,s);if(v>0)for(var m=0;m<v;m++){var x=s[m];if(x<=1&&x>=0)return y=a?cn(i,h,p,f,x):cn(n,u,c,d,x),a?[t,y]:[y,t]}n=d,i=f}}},e}(ys),NS=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e}(OS),ES=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="ec-polygon",n}return n(e,t),e.prototype.getDefaultShape=function(){return new NS},e.prototype.buildPath=function(t,e){var n=e.points,i=e.stackedOnPoints,r=0,o=n.length/2,a=e.smoothMonotone;if(e.connectNulls){// Must remove first and last null values avoid draw error in polygon
for(;o>0&&LS(n[2*o-2],n[2*o-1]);o--);for(;r<o&&LS(n[2*r],n[2*r+1]);r++);}for(;r<o;){var s=PS(t,n,r,o,o,1,e.smooth,a,e.connectNulls);PS(t,i,r+s-1,s,o,-1,e.stackedOnSmooth,a,e.connectNulls),r+=s+1,t.closePath()}},e}(ys);function zS(t,e,n,i,r){var o=t.getArea(),a=o.x,s=o.y,l=o.width,u=o.height,h=n.get(["lineStyle","width"])||2;// Expand the clip path a bit to avoid the border is clipped and looks thinner
a-=h/2,s-=h/2,l+=h,u+=h,// fix: https://github.com/apache/incubator-echarts/issues/11369
a=Math.floor(a),l=Math.round(l);var c=new Ls({shape:{x:a,y:s,width:l,height:u}});if(e){var p=t.getBaseAxis(),d=p.isHorizontal(),f=p.inverse;d?(f&&(c.shape.x+=l),c.shape.width=0):(f||(c.shape.y+=u),c.shape.height=0);var g=W(r)?function(t){r(t,c)}:null;Mh(c,{shape:{width:l,height:u,x:a,y:s}},n,null,i,g)}return c}function VS(t,e,n){var i=t.getArea(),r=Br(i.r0,1),o=Br(i.r,1),a=new Nu({shape:{cx:Br(t.cx,1),cy:Br(t.cy,1),r0:r,r:o,startAngle:i.startAngle,endAngle:i.endAngle,clockwise:i.clockwise}});// Avoid float number rounding error for symbol on the edge of axis extent.
return e&&("angle"===t.getBaseAxis().dim?a.shape.endAngle=i.startAngle:a.shape.r=r,Mh(a,{shape:{endAngle:i.endAngle,r:o}},n)),a}function BS(t,e,n,i,r){return t?"polar"===t.type?VS(t,e,n):"cartesian2d"===t.type?zS(t,e,n,i,r):null:null}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function FS(t,e){return t.type===e}function GS(t,e){if(t.length===e.length){for(var n=0;n<t.length;n++)if(t[n]!==e[n])return;return!0}}function WS(t){for(var e=1/0,n=1/0,i=-1/0,r=-1/0,o=0;o<t.length;){var a=t[o++],s=t[o++];isNaN(a)||(e=Math.min(a,e),i=Math.max(a,i)),isNaN(s)||(n=Math.min(s,n),r=Math.max(s,r))}return[[e,n],[i,r]]}function HS(t,e){var n=WS(t),i=n[0],r=n[1],o=WS(e),a=o[0],s=o[1];// Get a max value from each corner of two boundings.
return Math.max(Math.abs(i[0]-a[0]),Math.abs(i[1]-a[1]),Math.abs(r[0]-s[0]),Math.abs(r[1]-s[1]))}function YS(t){return X(t)?t:t?.5:0}function XS(t,e,n,i){var r=e.getBaseAxis(),o="x"===r.dim||"radius"===r.dim?0:1,a=[],s=0,l=[],u=[],h=[],c=[];if(i){for(s=0;s<t.length;s+=2)isNaN(t[s])||isNaN(t[s+1])||c.push(t[s],t[s+1]);t=c}for(s=0;s<t.length-2;s+=2)switch(h[0]=t[s+2],h[1]=t[s+3],u[0]=t[s],u[1]=t[s+1],a.push(u[0],u[1]),n){case"end":l[o]=h[o],l[1-o]=u[1-o],a.push(l[0],l[1]);break;case"middle":var p=(u[o]+h[o])/2,d=[];l[o]=d[o]=p,l[1-o]=u[1-o],d[1-o]=h[1-o],a.push(l[0],l[1]),a.push(d[0],d[1]);break;default:// default is start
l[o]=u[o],l[1-o]=h[1-o],a.push(l[0],l[1])}// Last points
return a.push(t[s++],t[s++]),a}
/**
             * Clip color stops to edge. Avoid creating too large gradients.
             * Which may lead to blurry when GPU acceleration is enabled. See #15680
             *
             * The stops has been sorted from small to large.
             */function US(t,e){var n,i,r=[],o=t.length;function a(t,e,n){var i=t.coord;return{coord:n,color:function(t,e,n){if(e&&e.length&&t>=0&&t<=1){var i=t*(e.length-1),r=Math.floor(i),o=Math.ceil(i),a=Hn(e[r]),s=Hn(e[o]),l=i-r,u=qn([Pn(zn(a[0],s[0],l)),Pn(zn(a[1],s[1],l)),Pn(zn(a[2],s[2],l)),On(zn(a[3],s[3],l))],"rgba");return n?{color:u,leftIndex:r,rightIndex:o,value:i}:u}}((n-i)/(e.coord-i),[t.color,e.color])}}for(var s=0;s<o;s++){var l=t[s],u=l.coord;if(u<0)n=l;else{if(u>e){i?r.push(a(i,l,e)):n&&// If there are two stops and coord range is between these two stops
r.push(a(n,l,0),a(n,l,e));// All following stop will be out of range. So just ignore them.
break}n&&(r.push(a(n,l,0)),// Reset
n=null),r.push(l),i=l}}return r}function ZS(t,e,n){var i=t.get("showAllSymbol"),r="auto"===i;if(!i||r){var o=n.getAxesByScale("ordinal")[0];if(o&&(!r||!function(t,e){// In most cases, line is monotonous on category axis, and the label size
// is close with each other. So we check the symbol size and some of the
// label size alone with the category axis to estimate whether all symbol
// can be shown without overlap.
var n=t.getExtent(),i=Math.abs(n[1]-n[0])/t.scale.count();isNaN(i)&&(i=0);for(// 0/0 is NaN.
// Sampling some points, max 5.
var r=e.count(),o=Math.max(1,Math.round(r/5)),a=0;a<r;a+=o)if(1.5*bS.getSymbolSize(e,a)[t.isHorizontal()?1:0]>i)return!1;return!0}(o,e)))// Note that category label interval strategy might bring some weird effect
// in some scenario: users may wonder why some of the symbols are not
// displayed. So we show all symbols as possible as we can.
{// Otherwise follow the label interval strategy on category axis.
var a=e.mapDimension(o.dim),s={};return R(o.getViewLabels(),(function(t){var e=o.scale.getRawOrdinalNumber(t.tickValue);s[e]=1})),function(t){return!s.hasOwnProperty(e.get(a,t))}}}}function jS(t,e){return[t[2*e],t[2*e+1]]}function qS(t){if(t.get(["endLabel","show"]))return!0;for(var e=0;e<tl.length;e++)if(t.get([tl[e],"endLabel","show"]))return!0;return!1}function KS(t,e,n,i){if(FS(e,"cartesian2d")){var r=i.getModel("endLabel"),o=r.get("valueAnimation"),a=i.getData(),s={lastFrameIndex:0},l=qS(i)?function(n,i){t._endLabelOnDuring(n,i,a,s,o,r,e)}:null,u=e.getBaseAxis().isHorizontal(),h=zS(e,n,i,(function(){var e=t._endLabel;e&&n&&null!=s.originalX&&e.attr({x:s.originalX,y:s.originalY})}),l);// Expand clip shape to avoid clipping when line value exceeds axis
if(!i.get("clip",!0)){var c=h.shape,p=Math.max(c.width,c.height);u?(c.y-=p,c.height+=2*p):(c.x-=p,c.width+=2*p)}// Set to the final frame. To make sure label layout is right.
return l&&l(1,h),h}return VS(e,n,i)}var $S=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.init=function(){var t=new Lr,e=new TS;this.group.add(e.group),this._symbolDraw=e,this._lineGroup=t},e.prototype.render=function(t,e,n){var i=this,r=t.coordinateSystem,o=this.group,a=t.getData(),s=t.getModel("lineStyle"),l=t.getModel("areaStyle"),u=a.getLayout("points")||[],h="polar"===r.type,c=this._coordSys,p=this._symbolDraw,d=this._polyline,f=this._polygon,g=this._lineGroup,y=t.get("animation"),v=!l.isEmpty(),m=l.get("origin"),x=CS(r,a,m),_=v&&function(t,e,n){if(!n.valueDim)return[];for(var i=e.count(),r=qx(2*i),o=0;o<i;o++){var a=DS(n,t,e,o);r[2*o]=a[0],r[2*o+1]=a[1]}return r}(r,a,x),b=t.get("showSymbol"),w=t.get("connectNulls"),S=b&&!h&&ZS(t,a,r),M=this._data;M&&M.eachItemGraphicEl((function(t,e){t.__temp&&(o.remove(t),M.setItemGraphicEl(e,null))})),// Remove previous created symbols if showSymbol changed to false
b||p.remove(),o.add(g);// FIXME step not support polar
var I,T=!h&&t.get("step");r&&r.getArea&&t.get("clip",!0)&&(// Avoid float number rounding error for symbol on the edge of axis extent.
// See #7913 and `test/dataZoom-clip.html`.
null!=(I=r.getArea()).width?(I.x-=.1,I.y-=.1,I.width+=.2,I.height+=.2):I.r0&&(I.r0-=.5,I.r+=.5)),this._clipShapeForSymbol=I;var C=function(t,e,n){var i=t.getVisual("visualMeta");if(i&&i.length&&t.count()&&"cartesian2d"===e.type){for(var r,o,a=i.length-1;a>=0;a--){var s=t.getDimensionInfo(i[a].dimension);// Can only be x or y
if("x"===(r=s&&s.coordDim)||"y"===r){o=i[a];break}}if(o){// If the area to be rendered is bigger than area defined by LinearGradient,
// the canvas spec prescribes that the color of the first stop and the last
// stop should be used. But if two stops are added at offset 0, in effect
// browsers use the color of the second stop to render area outside
// LinearGradient. So we can only infinitesimally extend area defined in
// LinearGradient to render `outerColors`.
var l=e.getAxis(r),u=N(o.stops,(function(t){// offset will be calculated later.
return{coord:l.toGlobalCoord(l.dataToCoord(t.value)),color:t.color}})),h=u.length,c=o.outerColors.slice();// dataToCoord mapping may not be linear, but must be monotonic.
h&&u[0].coord>u[h-1].coord&&(u.reverse(),c.reverse());var p=US(u,"x"===r?n.getWidth():n.getHeight()),d=p.length;if(!d&&h)// All stops are out of range. All will be the same color.
return u[0].coord<0?c[1]?c[1]:u[h-1].color:c[0]?c[0]:u[0].color;var f=p[0].coord-10,g=p[d-1].coord+10,y=g-f;// Arbitrary value: 10px
if(y<.001)return"transparent";R(p,(function(t){t.offset=(t.coord-f)/y})),p.push({// NOTE: inRangeStopLen may still be 0 if stoplen is zero.
offset:d?p[d-1].offset:.5,color:c[1]||"transparent"}),p.unshift({offset:d?p[0].offset:.5,color:c[0]||"transparent"});var v=new lh(0,0,0,0,p,!0);return v[r]=f,v[r+"2"]=g,v}}}(a,r,n)||a.getVisual("style")[a.getVisual("drawType")];// Initialization animation or coordinate system changed
if(d&&c.type===r.type&&T===this._step){v&&!f?// If areaStyle is added
f=this._newPolygon(u,_):f&&!v&&(// If areaStyle is removed
g.remove(f),f=this._polygon=null),// NOTE: Must update _endLabel before setClipPath.
h||this._initOrUpdateEndLabel(t,r,Cp(C));// Update clipPath
var D=g.getClipPath();D?Mh(D,{shape:KS(this,r,!1,t).shape},t):g.setClipPath(KS(this,r,!0,t)),// Always update, or it is wrong in the case turning on legend
// because points are not changed.
b&&p.updateData(a,{isIgnore:S,clipShape:I,disableAnimation:!0,getSymbolPoint:function(t){return[u[2*t],u[2*t+1]]}}),// In the case data zoom triggered refreshing frequently
// Data may not change if line has a category axis. So it should animate nothing.
GS(this._stackedOnPoints,_)&&GS(this._points,u)||(y?this._doUpdateAnimation(a,_,r,n,T,m,w):(// Not do it in update with animation
T&&(// TODO If stacked series is not step
u=XS(u,r,T,w),_&&(_=XS(_,r,T,w))),d.setShape({points:u}),f&&f.setShape({points:u,stackedOnPoints:_})))}else b&&p.updateData(a,{isIgnore:S,clipShape:I,disableAnimation:!0,getSymbolPoint:function(t){return[u[2*t],u[2*t+1]]}}),y&&this._initSymbolLabelAnimation(a,r,I),T&&(// TODO If stacked series is not step
u=XS(u,r,T,w),_&&(_=XS(_,r,T,w))),d=this._newPolyline(u),v?f=this._newPolygon(u,_):f&&(g.remove(f),f=this._polygon=null),// NOTE: Must update _endLabel before setClipPath.
h||this._initOrUpdateEndLabel(t,r,Cp(C)),g.setClipPath(KS(this,r,!0,t));var A=t.getModel("emphasis"),L=A.get("focus"),P=A.get("blurScope"),O=A.get("disabled");d.useStyle(k(// Use color in lineStyle first
s.getLineStyle(),{fill:"none",stroke:C,lineJoin:"bevel"})),Hl(d,t,"lineStyle"),d.style.lineWidth>0&&"bolder"===t.get(["emphasis","lineStyle","width"])&&(d.getState("emphasis").style.lineWidth=+d.style.lineWidth+1),// Needs seriesIndex for focus
js(d).seriesIndex=t.seriesIndex,Bl(d,L,P,O);var E=YS(t.get("smooth")),z=t.get("smoothMonotone");if(d.setShape({smooth:E,smoothMonotone:z,connectNulls:w}),f){var V=a.getCalculationInfo("stackedOnSeries"),B=0;f.useStyle(k(l.getAreaStyle(),{fill:C,opacity:.7,lineJoin:"bevel",decal:a.getVisual("style").decal})),V&&(B=YS(V.get("smooth"))),f.setShape({smooth:E,stackedOnSmooth:B,smoothMonotone:z,connectNulls:w}),Hl(f,t,"areaStyle"),// Needs seriesIndex for focus
js(f).seriesIndex=t.seriesIndex,Bl(f,L,P,O)}var F=function(t){i._changePolyState(t)};a.eachItemGraphicEl((function(t){// Switch polyline / polygon state if element changed its state.
t&&(t.onHoverStateChange=F)})),this._polyline.onHoverStateChange=F,this._data=a,// Save the coordinate system for transition animation when data changed
this._coordSys=r,this._stackedOnPoints=_,this._points=u,this._step=T,this._valueOrigin=m,t.get("triggerLineEvent")&&(this.packEventData(t,d),f&&this.packEventData(t,f))},e.prototype.packEventData=function(t,e){js(e).eventData={componentType:"series",componentSubType:"line",componentIndex:t.componentIndex,seriesIndex:t.seriesIndex,seriesName:t.name,seriesType:"line"}},e.prototype.highlight=function(t,e,n,i){var r=t.getData(),o=_o(r,i);if(this._changePolyState("emphasis"),!(o instanceof Array)&&null!=o&&o>=0){var a=r.getLayout("points"),s=r.getItemGraphicEl(o);if(!s){// Create a temporary symbol if it is not exists
var l=a[2*o],u=a[2*o+1];if(isNaN(l)||isNaN(u))// Null data
return;// fix #11360: shouldn't draw symbol outside clipShapeForSymbol
if(this._clipShapeForSymbol&&!this._clipShapeForSymbol.contain(l,u))return;var h=t.get("zlevel")||0,c=t.get("z")||0;(s=new bS(r,o)).x=l,s.y=u,s.setZ(h,c);// ensure label text of the temporary symbol is in front of line and area polygon
var p=s.getSymbolPath().getTextContent();p&&(p.zlevel=h,p.z=c,p.z2=this._polyline.z2+1),s.__temp=!0,r.setItemGraphicEl(o,s),// Stop scale animation
s.stopSymbolAnimation(!0),this.group.add(s)}s.highlight()}else// Highlight whole series
qg.prototype.highlight.call(this,t,e,n,i)},e.prototype.downplay=function(t,e,n,i){var r=t.getData(),o=_o(r,i);if(this._changePolyState("normal"),null!=o&&o>=0){var a=r.getItemGraphicEl(o);a&&(a.__temp?(r.setItemGraphicEl(o,null),this.group.remove(a)):a.downplay())}else// FIXME
// can not downplay completely.
// Downplay whole series
qg.prototype.downplay.call(this,t,e,n,i)},e.prototype._changePolyState=function(t){var e=this._polygon;_l(this._polyline,t),e&&_l(e,t)},e.prototype._newPolyline=function(t){var e=this._polyline;// Remove previous created polyline
return e&&this._lineGroup.remove(e),e=new RS({shape:{points:t},segmentIgnoreThreshold:2,z2:10}),this._lineGroup.add(e),this._polyline=e,e},e.prototype._newPolygon=function(t,e){var n=this._polygon;// Remove previous created polygon
return n&&this._lineGroup.remove(n),n=new ES({shape:{points:t,stackedOnPoints:e},segmentIgnoreThreshold:2}),this._lineGroup.add(n),this._polygon=n,n},e.prototype._initSymbolLabelAnimation=function(t,e,n){var i,r,o=e.getBaseAxis(),a=o.inverse;"cartesian2d"===e.type?(i=o.isHorizontal(),r=!1):"polar"===e.type&&(i="angle"===o.dim,r=!0);var s=t.hostModel,l=s.get("animationDuration");W(l)&&(l=l(null));var u=s.get("animationDelay")||0,h=W(u)?u(null):u;t.eachItemGraphicEl((function(t,o){var s=t;if(s){var c=[t.x,t.y],p=void 0,d=void 0,f=void 0;if(n)if(r){var g=n,y=e.pointToCoord(c);i?(p=g.startAngle,d=g.endAngle,f=-y[1]/180*Math.PI):(p=g.r0,d=g.r,f=y[0])}else{var v=n;i?(p=v.x,d=v.x+v.width,f=t.x):(p=v.y+v.height,d=v.y,f=t.y)}var m=d===p?0:(f-p)/(d-p);a&&(m=1-m);var x=W(u)?u(o):l*m+h,_=s.getSymbolPath(),b=_.getTextContent();s.attr({scaleX:0,scaleY:0}),s.animateTo({scaleX:1,scaleY:1},{duration:200,setToFinal:!0,delay:x}),b&&b.animateFrom({style:{opacity:0}},{duration:300,delay:x}),_.disableLabelAnimation=!0}}))},e.prototype._initOrUpdateEndLabel=function(t,e,n){var i=t.getModel("endLabel");if(qS(t)){var r=t.getData(),o=this._polyline,a=r.getLayout("points");if(!a)return o.removeTextContent(),void(this._endLabel=null);var s=this._endLabel;s||((s=this._endLabel=new Zs({z2:200})).ignoreClip=!0,o.setTextContent(this._endLabel),o.disableLabelAnimation=!0);// Find last non-NaN data to display data
var l=function(t){for(var e,n,i=t.length/2;i>0&&(e=t[2*i-2],n=t[2*i-1],isNaN(e)||isNaN(n));i--);return i-1}(a);l>=0&&(ac(o,sc(t,"endLabel"),{inheritColor:n,labelFetcher:t,labelDataIndex:l,defaultText:function(t,e,n){return null!=n?mS(r,n):vS(r,t)},enableTextSetter:!0},function(t,e){var n=e.getBaseAxis(),i=n.isHorizontal(),r=n.inverse,o=i?r?"right":"left":"center",a=i?"middle":r?"top":"bottom";return{normal:{align:t.get("align")||o,verticalAlign:t.get("verticalAlign")||a}}}(i,e)),o.textConfig.position=null)}else this._endLabel&&(this._polyline.removeTextContent(),this._endLabel=null)},e.prototype._endLabelOnDuring=function(t,e,n,i,r,o,a){var s=this._endLabel,l=this._polyline;if(s){// NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.
// The label is not prepared at this time.
t<1&&null==i.originalX&&(i.originalX=s.x,i.originalY=s.y);var u=n.getLayout("points"),h=n.hostModel,c=h.get("connectNulls"),p=o.get("precision"),d=o.get("distance")||0,f=a.getBaseAxis(),g=f.isHorizontal(),y=f.inverse,v=e.shape,m=y?g?v.x:v.y+v.height:g?v.x+v.width:v.y,x=(g?d:0)*(y?-1:1),_=(g?0:-d)*(y?-1:1),b=g?"x":"y",w=function(t,e,n){for(var i,r,o=t.length/2,a="x"===n?0:1,s=0,l=-1,u=0;u<o;u++)if(r=t[2*u+a],!isNaN(r)&&!isNaN(t[2*u+1-a]))if(0!==u){if(i<=e&&r>=e||i>=e&&r<=e){l=u;break}s=u,i=r}else i=r;return{range:[s,l],t:(e-i)/(r-i)}}(u,m,b),S=w.range,M=S[1]-S[0],I=void 0;if(M>=1){// diff > 1 && connectNulls, which is on the null data.
if(M>1&&!c){var T=jS(u,S[0]);s.attr({x:T[0]+x,y:T[1]+_}),r&&(I=h.getRawValue(S[0]))}else{(T=l.getPointOn(m,b))&&s.attr({x:T[0]+x,y:T[1]+_});var C=h.getRawValue(S[0]),D=h.getRawValue(S[1]);r&&(I=ko(n,p,C,D,w.t))}i.lastFrameIndex=S[0]}else{// If diff <= 0, which is the range is not found(Include NaN)
// Choose the first point or last point.
var A=1===t||i.lastFrameIndex>0?S[0]:0;T=jS(u,A),r&&(I=h.getRawValue(A)),s.attr({x:T[0]+x,y:T[1]+_})}r&&gc(s).setLabelText(I)}},
/**
               * @private
               */
// FIXME Two value axis
e.prototype._doUpdateAnimation=function(t,e,n,i,r,o,a){var s=this._polyline,l=this._polygon,u=t.hostModel,h=function(t,e,n,i,r,o,a,s){for(var l=function(t,e){var n=[];return e.diff(t).add((function(t){n.push({cmd:"+",idx:t})})).update((function(t,e){n.push({cmd:"=",idx:e,idx1:t})})).remove((function(t){n.push({cmd:"-",idx:t})})).execute(),n}(t,e),u=[],h=[],c=[],p=[],d=[],f=[],g=[],y=CS(r,e,a),v=t.getLayout("points")||[],m=e.getLayout("points")||[],x=0// let newIdList = newData.mapArray(newData.getId);
// let oldIdList = oldData.mapArray(oldData.getId);
// convertToIntId(newIdList, oldIdList);
// // FIXME One data ?
// diff = arrayDiff(oldIdList, newIdList);
;x<l.length;x++){var _=l[x],b=!0,w=void 0,S=void 0;// FIXME, animation is not so perfect when dataZoom window moves fast
// Which is in case remvoing or add more than one data in the tail or head
switch(_.cmd){case"=":w=2*_.idx,S=2*_.idx1;var M=v[w],I=v[w+1],T=m[S],C=m[S+1];// If previous data is NaN, use next point directly
(isNaN(M)||isNaN(I))&&(M=T,I=C),u.push(M,I),h.push(T,C),c.push(n[w],n[w+1]),p.push(i[S],i[S+1]),g.push(e.getRawIndex(_.idx1));break;case"+":var D=_.idx,A=y.dataDimsForPoint,k=r.dataToPoint([e.get(A[0],D),e.get(A[1],D)]);S=2*D,u.push(k[0],k[1]),h.push(m[S],m[S+1]);var L=DS(y,r,e,D);c.push(L[0],L[1]),p.push(i[S],i[S+1]),g.push(e.getRawIndex(D));break;case"-":b=!1}// Original indices
b&&(d.push(_),f.push(f.length))}// Diff result may be crossed if all items are changed
// Sort by data index
f.sort((function(t,e){return g[t]-g[e]}));var P=u.length,O=qx(P),R=qx(P),N=qx(P),E=qx(P),z=[];for(x=0;x<f.length;x++){var V=f[x],B=2*x,F=2*V;O[B]=u[F],O[B+1]=u[F+1],R[B]=h[F],R[B+1]=h[F+1],N[B]=c[F],N[B+1]=c[F+1],E[B]=p[F],E[B+1]=p[F+1],z[x]=d[V]}return{current:O,next:R,stackedOnCurrent:N,stackedOnNext:E,status:z}}(this._data,t,this._stackedOnPoints,e,this._coordSys,0,this._valueOrigin),c=h.current,p=h.stackedOnCurrent,d=h.next,f=h.stackedOnNext;// Don't apply animation if diff is large.
// For better result and avoid memory explosion problems like
// https://github.com/apache/incubator-echarts/issues/12229
if(r&&(// TODO If stacked series is not step
c=XS(h.current,n,r,a),p=XS(h.stackedOnCurrent,n,r,a),d=XS(h.next,n,r,a),f=XS(h.stackedOnNext,n,r,a)),HS(c,d)>3e3||l&&HS(p,f)>3e3)return s.stopAnimation(),s.setShape({points:d}),void(l&&(l.stopAnimation(),l.setShape({points:d,stackedOnPoints:f})));s.shape.__points=h.current,s.shape.points=c;var g={shape:{points:d}};// Also animate the original points.
// If points reference is changed when turning into step line.
h.current!==c&&(g.shape.__points=h.next),// Stop previous animation.
s.stopAnimation(),Sh(s,g,u),l&&(l.setShape({// Reuse the points with polyline.
points:c,stackedOnPoints:p}),l.stopAnimation(),Sh(l,{shape:{stackedOnPoints:f}},u),// If use attr directly in updateProps.
s.shape.points!==l.shape.points&&(l.shape.points=s.shape.points));for(var y=[],v=h.status,m=0;m<v.length;m++)if("="===v[m].cmd){var x=t.getItemGraphicEl(v[m].idx1);x&&y.push({el:x,ptIdx:m})}s.animators&&s.animators.length&&s.animators[0].during((function(){l&&l.dirtyShape();for(var t=s.shape.__points,e=0;e<y.length;e++){var n=y[e].el,i=2*y[e].ptIdx;n.x=t[i],n.y=t[i+1],n.markRedraw()}}))},e.prototype.remove=function(t){var e=this.group,n=this._data;this._lineGroup.removeAll(),this._symbolDraw.remove(!0),// Remove temporary created elements when highlighting
n&&n.eachItemGraphicEl((function(t,i){t.__temp&&(e.remove(t),n.setItemGraphicEl(i,null))})),this._polyline=this._polygon=this._coordSys=this._points=this._stackedOnPoints=this._endLabel=this._data=null},e.type="line",e}(qg);const JS=$S;function QS(t,e){return{seriesType:t,plan:Fg(),reset:function(t){var n=t.getData(),i=t.coordinateSystem,r=t.pipelineContext,o=e||r.large;if(i){var a=N(i.dimensions,(function(t){return n.mapDimension(t)})).slice(0,2),s=a.length,l=n.getCalculationInfo("stackResultDimension");Ix(n,a[0])&&(a[0]=l),Ix(n,a[1])&&(a[1]=l);var u=n.getStore(),h=n.getDimensionIndex(a[0]),c=n.getDimensionIndex(a[1]);return s&&{progress:function(t,e){for(var n=t.end-t.start,r=o&&qx(n*s),a=[],l=[],p=t.start,d=0;p<t.end;p++){var f=void 0;if(1===s){var g=u.get(h,p);// NOTE: Make sure the second parameter is null to use default strategy.
f=i.dataToPoint(g,null,l)}else a[0]=u.get(h,p),a[1]=u.get(c,p),// Let coordinate system to handle the NaN data.
f=i.dataToPoint(a,null,l);o?(r[d++]=f[0],r[d++]=f[1]):e.setItemLayout(p,f.slice())}o&&e.setLayout("points",r)}}}}}}var tM={average:function(t){for(var e=0,n=0,i=0;i<t.length;i++)isNaN(t[i])||(e+=t[i],n++);// Return NaN if count is 0
return 0===n?NaN:e/n},sum:function(t){for(var e=0,n=0;n<t.length;n++)// Ignore NaN
e+=t[n]||0;return e},max:function(t){for(var e=-1/0,n=0;n<t.length;n++)t[n]>e&&(e=t[n]);// NaN will cause illegal axis extent.
return isFinite(e)?e:NaN},min:function(t){for(var e=1/0,n=0;n<t.length;n++)t[n]<e&&(e=t[n]);// NaN will cause illegal axis extent.
return isFinite(e)?e:NaN},// TODO
// Median
nearest:function(t){return t[0]}},eM=function(t){return Math.round(t.length/2)};function nM(t){return{seriesType:t,// FIXME:TS never used, so comment it
// modifyOutputEnd: true,
reset:function(t,e,n){var i=t.getData(),r=t.get("sampling"),o=t.coordinateSystem,a=i.count();// Only cartesian2d support down sampling. Disable it when there is few data.
if(a>10&&"cartesian2d"===o.type&&r){var s=o.getBaseAxis(),l=o.getOtherAxis(s),u=s.getExtent(),h=n.getDevicePixelRatio(),c=Math.abs(u[1]-u[0])*(h||1),p=Math.round(a/c);if(isFinite(p)&&p>1){"lttb"===r&&t.setData(i.lttbDownSample(i.mapDimension(l.dim),1/p));var d=void 0;H(r)?d=tM[r]:W(r)&&(d=r),d&&// Only support sample the first dim mapped from value axis.
t.setData(i.downSample(i.mapDimension(l.dim),1/p,d,eM))}}}}}var iM=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.getInitialData=function(t,e){return Cx(null,this,{useEncodeDefaulter:!0})},e.prototype.getMarkerPosition=function(t,e,n){var i=this.coordinateSystem;if(i&&i.clampData){// PENDING if clamp ?
var r=i.dataToPoint(i.clampData(t));if(n)R(i.getAxes(),(function(n,o){// If axis type is category, use tick coords instead
if("category"===n.type){var a=n.getTicksCoords(),s=i.clampData(t)[o];// The index of rightmost tick of markArea is 1 larger than x1/y1 index
!e||"x1"!==e[o]&&"y1"!==e[o]||(s+=1),s>a.length-1&&(s=a.length-1),s<0&&(s=0),a[s]&&(r[o]=n.toGlobalCoord(a[s].coord))}}));else{var o=this.getData(),a=o.getLayout("offset"),s=o.getLayout("size"),l=i.getBaseAxis().isHorizontal()?0:1;r[l]+=a+s/2}return r}return[NaN,NaN]},e.type="series.__base_bar__",e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"cartesian2d",legendHoverLink:!0,// stack: null
// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
barMinHeight:0,barMinAngle:0,// cursor: null,
large:!1,largeThreshold:400,progressive:3e3,progressiveChunkMode:"mod"},e}(zg);zg.registerClass(iM);const rM=iM;var oM=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.getInitialData=function(){return Cx(null,this,{useEncodeDefaulter:!0,createInvertedIndices:!!this.get("realtimeSort",!0)||null})},
/**
               * @override
               */
e.prototype.getProgressive=function(){// Do not support progressive in normal mode.
return!!this.get("large")&&this.get("progressive")},
/**
               * @override
               */
e.prototype.getProgressiveThreshold=function(){// Do not support progressive in normal mode.
var t=this.get("progressiveThreshold"),e=this.get("largeThreshold");return e>t&&(t=e),t},e.prototype.brushSelector=function(t,e,n){return n.rect(e.getItemLayout(t))},e.type="series.bar",e.dependencies=["grid","polar"],e.defaultOption=Nc(rM.defaultOption,{// If clipped
// Only available on cartesian2d
clip:!0,roundCap:!1,showBackground:!1,backgroundStyle:{color:"rgba(180, 180, 180, 0.2)",borderColor:null,borderWidth:0,borderType:"solid",borderRadius:0,shadowBlur:0,shadowColor:null,shadowOffsetX:0,shadowOffsetY:0,opacity:1},select:{itemStyle:{borderColor:"#212121"}},realtimeSort:!1}),e}(rM);const aM=oM;
/**
             * Sausage: similar to sector, but have half circle on both sides
             */var sM=function(){this.cx=0,this.cy=0,this.r0=0,this.r=0,this.startAngle=0,this.endAngle=2*Math.PI,this.clockwise=!0},lM=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="sausage",n}return n(e,t),e.prototype.getDefaultShape=function(){return new sM},e.prototype.buildPath=function(t,e){var n=e.cx,i=e.cy,r=Math.max(e.r0||0,0),o=Math.max(e.r,0),a=.5*(o-r),s=r+a,l=e.startAngle,u=e.endAngle,h=e.clockwise,c=2*Math.PI,p=h?u-l<c:l-u<c;p||(// Normalize angles
l=u-(h?c:-c));var d=Math.cos(l),f=Math.sin(l),g=Math.cos(u),y=Math.sin(u);p?(t.moveTo(d*r+n,f*r+i),t.arc(d*s+n,f*s+i,a,-Math.PI+l,l,!h)):t.moveTo(d*o+n,f*o+i),t.arc(n,i,o,l,u,!h),t.arc(g*s+n,y*s+i,a,u-2*Math.PI,u-Math.PI,!h),0!==r&&t.arc(n,i,r,u,l,h)},e}(ys);const uM=lM;function hM(t,e,n){return e*Math.sin(t)*(n?-1:1)}function cM(t,e,n){return e*Math.cos(t)*(n?1:-1)}var pM=Math.max,dM=Math.min,fM=/** @class */function(t){function e(){var n=t.call(this)||this;return n.type=e.type,n._isFirstFrame=!0,n}return n(e,t),e.prototype.render=function(t,e,n,i){this._model=t,this._removeOnRenderedListener(n),this._updateDrawMode(t);var r=t.get("coordinateSystem");"cartesian2d"!==r&&"polar"!==r||(// Clear previously rendered progressive elements.
this._progressiveEls=null,this._isLargeDraw?this._renderLarge(t,e,n):this._renderNormal(t,e,n,i))},e.prototype.incrementalPrepareRender=function(t){this._clear(),this._updateDrawMode(t),// incremental also need to clip, otherwise might be overlow.
// But must not set clip in each frame, otherwise all of the children will be marked redraw.
this._updateLargeClip(t)},e.prototype.incrementalRender=function(t,e){// Reset
this._progressiveEls=[],// Do not support progressive in normal mode.
this._incrementalRenderLarge(t,e)},e.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},e.prototype._updateDrawMode=function(t){var e=t.pipelineContext.large;null!=this._isLargeDraw&&e===this._isLargeDraw||(this._isLargeDraw=e,this._clear())},e.prototype._renderNormal=function(t,e,n,i){var r,o=this.group,a=t.getData(),s=this._data,l=t.coordinateSystem,u=l.getBaseAxis();"cartesian2d"===l.type?r=u.isHorizontal():"polar"===l.type&&(r="angle"===u.dim);var h=t.isAnimationEnabled()?t:null,c=function(t,e){var n=t.get("realtimeSort",!0),i=e.getBaseAxis();if(n&&"category"===i.type&&"cartesian2d"===e.type)return{baseAxis:i,otherAxis:e.getOtherAxis(i)}}(t,l);c&&this._enableRealtimeSort(c,a,n);var p=t.get("clip",!0)||c,d=function(t,e){var n=t.getArea&&t.getArea();if(FS(t,"cartesian2d")){var i=t.getBaseAxis();// When boundaryGap is false or using time axis. bar may exceed the grid.
// We should not clip this part.
// See test/bar2.html
if("category"!==i.type||!i.onBand){var r=e.getLayout("bandWidth");i.isHorizontal()?(n.x-=r,n.width+=2*r):(n.y-=r,n.height+=2*r)}}return n}(l,a);// If there is clipPath created in large mode. Remove it.
o.removeClipPath();// We don't use clipPath in normal mode because we needs a perfect animation
// And don't want the label are clipped.
var f=t.get("roundCap",!0),g=t.get("showBackground",!0),y=t.getModel("backgroundStyle"),v=y.get("borderRadius")||0,m=[],x=this._backgroundEls,_=i&&i.isInitSort,b=i&&"changeAxisOrder"===i.type;function w(t){var e=wM[l.type](a,t),n=function(t,e,n){var i="polar"===t.type?Nu:Ls;return new i({shape:AM(e,n,t),silent:!0,z2:0})}(l,r,e);return n.useStyle(y.getItemStyle()),// Only cartesian2d support borderRadius.
"cartesian2d"===l.type&&n.setShape("r",v),m[t]=n,n}a.diff(s).add((function(e){var n=a.getItemModel(e),i=wM[l.type](a,e,n);// If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".
if(g&&w(e),a.hasValue(e)&&bM[l.type](i)){var s=!1;p&&(// Clip will modify the layout params.
// And return a boolean to determine if the shape are fully clipped.
s=gM[l.type](d,i));var y=yM[l.type](t,a,e,i,r,h,u.model,!1,f);c&&(
/**
                     * Force label animation because even if the element is
                     * ignored because it's clipped, it may not be clipped after
                     * changing order. Then, if not using forceLabelAnimation,
                     * the label animation was never started, in which case,
                     * the label will be the final value and doesn't have label
                     * animation.
                     */
y.forceLabelAnimation=!0),MM(y,a,e,n,i,t,r,"polar"===l.type),_?y.attr({shape:i}):c?vM(c,h,y,i,e,r,!1,!1):Mh(y,{shape:i},t,e),a.setItemGraphicEl(e,y),o.add(y),y.ignore=s}})).update((function(e,n){var i=a.getItemModel(e),S=wM[l.type](a,e,i);if(g){var M=void 0;0===x.length?M=w(n):((M=x[n]).useStyle(y.getItemStyle()),// Only cartesian2d support borderRadius.
"cartesian2d"===l.type&&M.setShape("r",v),m[e]=M);var I=wM[l.type](a,e);Sh(M,{shape:AM(r,I,l)},h,e)}var T=s.getItemGraphicEl(n);if(a.hasValue(e)&&bM[l.type](S)){var C=!1;if(p&&(C=gM[l.type](d,S))&&o.remove(T),T?Ah(T):T=yM[l.type](t,a,e,S,r,h,u.model,!!T,f),c&&(T.forceLabelAnimation=!0),b){var D=T.getTextContent();if(D){var A=gc(D);null!=A.prevValue&&(
/**
                         * Set preValue to be value so that no new label
                         * should be started, otherwise, it will take a full
                         * `animationDurationUpdate` time to finish the
                         * animation, which is not expected.
                         */
A.prevValue=A.value)}}// Not change anything if only order changed.
// Especially not change label.
else MM(T,a,e,i,S,t,r,"polar"===l.type);_?T.attr({shape:S}):c?vM(c,h,T,S,e,r,!0,b):Sh(T,{shape:S},t,e,null),a.setItemGraphicEl(e,T),T.ignore=C,o.add(T)}else o.remove(T)})).remove((function(e){var n=s.getItemGraphicEl(e);n&&Dh(n,t,e)})).execute();var S=this._backgroundGroup||(this._backgroundGroup=new Lr);S.removeAll();for(var M=0;M<m.length;++M)S.add(m[M]);o.add(S),this._backgroundEls=m,this._data=a},e.prototype._renderLarge=function(t,e,n){this._clear(),CM(t,this.group),this._updateLargeClip(t)},e.prototype._incrementalRenderLarge=function(t,e){this._removeBackground(),CM(e,this.group,this._progressiveEls,!0)},e.prototype._updateLargeClip=function(t){// Use clipPath in large mode.
var e=t.get("clip",!0)&&BS(t.coordinateSystem,!1,t),n=this.group;e?n.setClipPath(e):n.removeClipPath()},e.prototype._enableRealtimeSort=function(t,e,n){var i=this;// If no data in the first frame, wait for data to initSort
if(e.count()){var r=t.baseAxis;if(this._isFirstFrame)this._dispatchInitSort(e,t,n),this._isFirstFrame=!1;else{var o=function(t){var n=e.getItemGraphicEl(t),i=n&&n.shape;return i&&// The result should be consistent with the initial sort by data value.
// Do not support the case that both positive and negative exist.
Math.abs(r.isHorizontal()?i.height:i.width)||0};this._onRendered=function(){i._updateSortWithinSameData(e,o,r,n)},n.getZr().on("rendered",this._onRendered)}}},e.prototype._dataSort=function(t,e,n){var i=[];return t.each(t.mapDimension(e.dim),(function(t,e){var r=n(e);r=null==r?NaN:r,i.push({dataIndex:e,mappedValue:r,ordinalNumber:t})})),i.sort((function(t,e){// If NaN, it will be treated as min val.
return e.mappedValue-t.mappedValue})),{ordinalNumbers:N(i,(function(t){return t.ordinalNumber}))}},e.prototype._isOrderChangedWithinSameData=function(t,e,n){for(var i=n.scale,r=t.mapDimension(n.dim),o=Number.MAX_VALUE,a=0,s=i.getOrdinalMeta().categories.length;a<s;++a){var l=t.rawIndexOf(r,i.getRawOrdinalNumber(a)),u=l<0?Number.MIN_VALUE:e(t.indexOfRawIndex(l));if(u>o)return!0;o=u}return!1},
/*
               * Consider the case when A and B changed order, whose representing
               * bars are both out of sight, we don't wish to trigger reorder action
               * as long as the order in the view doesn't change.
               */
e.prototype._isOrderDifferentInView=function(t,e){for(var n=e.scale,i=n.getExtent(),r=Math.max(0,i[0]),o=Math.min(i[1],n.getOrdinalMeta().categories.length-1);r<=o;++r)if(t.ordinalNumbers[r]!==n.getRawOrdinalNumber(r))return!0},e.prototype._updateSortWithinSameData=function(t,e,n,i){if(this._isOrderChangedWithinSameData(t,e,n)){var r=this._dataSort(t,n,e);this._isOrderDifferentInView(r,n)&&(this._removeOnRenderedListener(i),i.dispatchAction({type:"changeAxisOrder",componentType:n.dim+"Axis",axisId:n.index,sortInfo:r}))}},e.prototype._dispatchInitSort=function(t,e,n){var i=e.baseAxis,r=this._dataSort(t,i,(function(n){return t.get(t.mapDimension(e.otherAxis.dim),n)}));n.dispatchAction({type:"changeAxisOrder",componentType:i.dim+"Axis",isInitSort:!0,axisId:i.index,sortInfo:r})},e.prototype.remove=function(t,e){this._clear(this._model),this._removeOnRenderedListener(e)},e.prototype.dispose=function(t,e){this._removeOnRenderedListener(e)},e.prototype._removeOnRenderedListener=function(t){this._onRendered&&(t.getZr().off("rendered",this._onRendered),this._onRendered=null)},e.prototype._clear=function(t){var e=this.group,n=this._data;t&&t.isAnimationEnabled()&&n&&!this._isLargeDraw?(this._removeBackground(),this._backgroundEls=[],n.eachItemGraphicEl((function(e){Dh(e,t,js(e).dataIndex)}))):e.removeAll(),this._data=null,this._isFirstFrame=!0},e.prototype._removeBackground=function(){this.group.remove(this._backgroundGroup),this._backgroundGroup=null},e.type="bar",e}(qg),gM={cartesian2d:function(t,e){var n=e.width<0?-1:1,i=e.height<0?-1:1;// Needs positive width and height
n<0&&(e.x+=e.width,e.width=-e.width),i<0&&(e.y+=e.height,e.height=-e.height);var r=t.x+t.width,o=t.y+t.height,a=pM(e.x,t.x),s=dM(e.x+e.width,r),l=pM(e.y,t.y),u=dM(e.y+e.height,o),h=s<a,c=u<l;// When xClipped or yClipped, the element will be marked as `ignore`.
// But we should also place the element at the edge of the coord sys bounding rect.
// Because if data changed and the bar shows again, its transition animation
// will begin at this place.
return e.x=h&&a>r?s:a,e.y=c&&l>o?u:l,e.width=h?0:s-a,e.height=c?0:u-l,// Reverse back
n<0&&(e.x+=e.width,e.width=-e.width),i<0&&(e.y+=e.height,e.height=-e.height),h||c},polar:function(t,e){var n=e.r0<=e.r?1:-1;// Make sure r is larger than r0
if(n<0){var i=e.r;e.r=e.r0,e.r0=i}var r=dM(e.r,t.r),o=pM(e.r0,t.r0);e.r=r,e.r0=o;var a=r-o<0;// Reverse back
return n<0&&(i=e.r,e.r=e.r0,e.r0=i),a}},yM={cartesian2d:function(t,e,n,i,r,o,a,s,l){var u=new Ls({shape:A({},i),z2:1});return u.__dataIndex=n,u.name="item",o&&(u.shape[r?"height":"width"]=0),u},polar:function(t,e,n,i,r,o,a,s,l){var u=!r&&l?uM:Nu,h=new u({shape:i,z2:1});h.name="item";var c,p,d=SM(r);// Animation
if(h.calculateTextPosition=(c=d,p=({isRoundCap:u===uM}||{}).isRoundCap,function(t,e,n){var i=e.position;if(!i||i instanceof Array)return mr(t,e,n);var r=c(i),o=null!=e.distance?e.distance:5,a=this.shape,s=a.cx,l=a.cy,u=a.r,h=a.r0,d=(u+h)/2,f=a.startAngle,g=a.endAngle,y=(f+g)/2,v=p?Math.abs(u-h)/2:0,m=Math.cos,x=Math.sin,_=s+u*m(f),b=l+u*x(f),w="left",S="top";switch(r){case"startArc":_=s+(h-o)*m(y),b=l+(h-o)*x(y),w="center",S="top";break;case"insideStartArc":_=s+(h+o)*m(y),b=l+(h+o)*x(y),w="center",S="bottom";break;case"startAngle":_=s+d*m(f)+hM(f,o+v,!1),b=l+d*x(f)+cM(f,o+v,!1),w="right",S="middle";break;case"insideStartAngle":_=s+d*m(f)+hM(f,-o+v,!1),b=l+d*x(f)+cM(f,-o+v,!1),w="left",S="middle";break;case"middle":_=s+d*m(y),b=l+d*x(y),w="center",S="middle";break;case"endArc":_=s+(u+o)*m(y),b=l+(u+o)*x(y),w="center",S="bottom";break;case"insideEndArc":_=s+(u-o)*m(y),b=l+(u-o)*x(y),w="center",S="top";break;case"endAngle":_=s+d*m(g)+hM(g,o+v,!0),b=l+d*x(g)+cM(g,o+v,!0),w="left",S="middle";break;case"insideEndAngle":_=s+d*m(g)+hM(g,-o+v,!0),b=l+d*x(g)+cM(g,-o+v,!0),w="right",S="middle";break;default:return mr(t,e,n)}return(t=t||{}).x=_,t.y=b,t.align=w,t.verticalAlign=S,t}),o){var f=r?"r":"endAngle",g={};h.shape[f]=r?0:i.startAngle,g[f]=i[f],(s?Sh:Mh)(h,{shape:g},o)}return h}};function vM(t,e,n,i,r,o,a,s){var l,u;o?(u={x:i.x,width:i.width},l={y:i.y,height:i.height}):(u={y:i.y,height:i.height},l={x:i.x,width:i.width}),s||// Keep the original growth animation if only axis order changed.
// Not start a new animation.
(a?Sh:Mh)(n,{shape:l},e,r,null),(a?Sh:Mh)(n,{shape:u},e?t.baseAxis.model:null,r)}function mM(t,e){for(var n=0;n<e.length;n++)if(!isFinite(t[e[n]]))return!0;return!1}var xM=["x","y","width","height"],_M=["cx","cy","r","startAngle","endAngle"],bM={cartesian2d:function(t){return!mM(t,xM)},polar:function(t){return!mM(t,_M)}},wM={// itemModel is only used to get borderWidth, which is not needed
// when calculating bar background layout.
cartesian2d:function(t,e,n){var i=t.getItemLayout(e),r=n?// In case width or height are too small.
function(t,e){// Has no border.
var n=t.get(["itemStyle","borderColor"]);if(!n||"none"===n)return 0;var i=t.get(["itemStyle","borderWidth"])||0,r=isNaN(e.width)?Number.MAX_VALUE:Math.abs(e.width),o=isNaN(e.height)?Number.MAX_VALUE:Math.abs(e.height);// width or height may be NaN for empty data
return Math.min(i,r,o)}(n,i):0,o=i.width>0?1:-1,a=i.height>0?1:-1;return{x:i.x+o*r/2,y:i.y+a*r/2,width:i.width-o*r,height:i.height-a*r}},polar:function(t,e,n){var i=t.getItemLayout(e);return{cx:i.cx,cy:i.cy,r0:i.r0,r:i.r,startAngle:i.startAngle,endAngle:i.endAngle,clockwise:i.clockwise}}};function SM(t){return function(t){var e=t?"Arc":"Angle";return function(t){switch(t){case"start":case"insideStart":case"end":case"insideEnd":return t+e;default:return t}}}(t)}function MM(t,e,n,i,r,o,a,s){var l=e.getItemVisual(n,"style");s||t.setShape("r",i.get(["itemStyle","borderRadius"])||0),t.useStyle(l);var u=i.getShallow("cursor");u&&t.attr("cursor",u);var h=s?a?r.r>=r.r0?"endArc":"startArc":r.endAngle>=r.startAngle?"endAngle":"startAngle":a?r.height>=0?"bottom":"top":r.width>=0?"right":"left",c=sc(i);ac(t,c,{labelFetcher:o,labelDataIndex:n,defaultText:vS(o.getData(),n),inheritColor:l.fill,defaultOpacity:l.opacity,defaultOutsidePosition:h});var p=t.getTextContent();if(s&&p){var d=i.get(["label","position"]);t.textConfig.inside="middle"===d||null,function(t,e,n,i){if(X(i))// user-set rotation
t.setTextConfig({rotation:i});else if(G(e))// user-set position, use 0 as auto rotation
t.setTextConfig({rotation:0});else{var r,o=t.shape,a=o.clockwise?o.startAngle:o.endAngle,s=o.clockwise?o.endAngle:o.startAngle,l=(a+s)/2,u=n(e);switch(u){case"startArc":case"insideStartArc":case"middle":case"insideEndArc":case"endArc":r=l;break;case"startAngle":case"insideStartAngle":r=a;break;case"endAngle":case"insideEndAngle":r=s;break;default:return void t.setTextConfig({rotation:0})}var h=1.5*Math.PI-r;
/**
               * TODO: labels with rotate > Math.PI / 2 should be rotate another
               * half round flipped to increase readability. However, only middle
               * position supports this for now, because in other positions, the
               * anchor point is not at the center of the text, so the positions
               * after rotating is not as expected.
               */"middle"===u&&h>Math.PI/2&&h<1.5*Math.PI&&(h-=Math.PI),t.setTextConfig({rotation:h})}}(t,"outside"===d?h:d,SM(a),i.get(["label","rotate"]))}yc(p,c,o.getRawValue(n),(function(t){return mS(e,t)}));var f=i.getModel(["emphasis"]);Bl(t,f.get("focus"),f.get("blurScope"),f.get("disabled")),Hl(t,i),function(t){return null!=t.startAngle&&null!=t.endAngle&&t.startAngle===t.endAngle}(r)&&(t.style.fill="none",t.style.stroke="none",R(t.states,(function(t){t.style&&(t.style.fill=t.style.stroke="none")})))}var IM=function(){},TM=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="largeBar",n}return n(e,t),e.prototype.getDefaultShape=function(){return new IM},e.prototype.buildPath=function(t,e){for(// Drawing lines is more efficient than drawing
// a whole line or drawing rects.
var n=e.points,i=this.baseDimIdx,r=1-this.baseDimIdx,o=[],a=[],s=this.barWidth,l=0;l<n.length;l+=3)a[i]=s,a[r]=n[l+2],o[i]=n[l+i],o[r]=n[l+r],t.rect(o[0],o[1],a[0],a[1])},e}(ys);function CM(t,e,n,i){// TODO support polar
var r=t.getData(),o=r.getLayout("valueAxisHorizontal")?1:0,a=r.getLayout("largeDataIndices"),s=r.getLayout("size"),l=t.getModel("backgroundStyle"),u=r.getLayout("largeBackgroundPoints");if(u){var h=new TM({shape:{points:u},incremental:!!i,silent:!0,z2:0});h.baseDimIdx=o,h.largeDataIndices=a,h.barWidth=s,h.useStyle(l.getItemStyle()),e.add(h),n&&n.push(h)}var c=new TM({shape:{points:r.getLayout("largePoints")},incremental:!!i,ignoreCoarsePointer:!0,z2:1});c.baseDimIdx=o,c.largeDataIndices=a,c.barWidth=s,e.add(c),c.useStyle(r.getVisual("style")),// Enable tooltip and user mouse/touch event handlers.
js(c).seriesIndex=t.seriesIndex,t.get("silent")||(c.on("mousedown",DM),c.on("mousemove",DM)),n&&n.push(c)}// Use throttle to avoid frequently traverse to find dataIndex.
var DM=Qg((function(t){var e=function(t,e,n){for(var i=t.baseDimIdx,r=1-i,o=t.shape.points,a=t.largeDataIndices,s=[],l=[],u=t.barWidth,h=0,c=o.length/3;h<c;h++){var p=3*h;if(l[i]=u,l[r]=o[p+2],s[i]=o[p+i],s[r]=o[p+r],l[r]<0&&(s[r]+=l[r],l[r]=-l[r]),e>=s[0]&&e<=s[0]+l[0]&&n>=s[1]&&n<=s[1]+l[1])return a[h]}return-1}(this,t.offsetX,t.offsetY);js(this).dataIndex=e>=0?e:null}),30,!1);function AM(t,e,n){if(FS(n,"cartesian2d")){var i=e,r=n.getArea();return{x:t?i.x:r.x,y:t?r.y:i.y,width:t?i.width:r.width,height:t?r.height:i.height}}var o=e;return{cx:(r=n.getArea()).cx,cy:r.cy,r0:t?r.r0:o.r0,r:t?r.r:o.r,startAngle:t?o.startAngle:0,endAngle:t?o.endAngle:2*Math.PI}}const kM=fM;var LM=2*Math.PI,PM=Math.PI/180;function OM(t,e){return Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()})}function RM(t,e){var n=OM(t,e),i=t.get("center"),r=t.get("radius");// center can be string or number when coordinateSystem is specified
G(r)||(r=[0,r]);var o,a,s=Vr(n.width,e.getWidth()),l=Vr(n.height,e.getHeight()),u=Math.min(s,l),h=Vr(r[0],u/2),c=Vr(r[1],u/2),p=t.coordinateSystem;if(p){// percentage is not allowed when coordinate system is specified
var d=p.dataToPoint(i);o=d[0]||0,a=d[1]||0}else G(i)||(i=[i,i]),o=Vr(i[0],s)+n.x,a=Vr(i[1],l)+n.y;return{cx:o,cy:a,r0:h,r:c}}function NM(t,e,n){e.eachSeriesByType(t,(function(t){var e=t.getData(),i=e.mapDimension("value"),r=OM(t,n),o=RM(t,n),a=o.cx,s=o.cy,l=o.r,u=o.r0,h=-t.get("startAngle")*PM,c=t.get("minAngle")*PM,p=0;e.each(i,(function(t){!isNaN(t)&&p++}));var d=e.getSum(i),f=Math.PI/(d||p)*2,g=t.get("clockwise"),y=t.get("roseType"),v=t.get("stillShowZeroSum"),m=e.getDataExtent(i);// Sum may be 0
m[0]=0;// In the case some sector angle is smaller than minAngle
var x=LM,_=0,b=h,w=g?1:-1;// Some sector is constrained by minAngle
// Rest sectors needs recalculate angle
if(e.setLayout({viewRect:r,r:l}),e.each(i,(function(t,n){var i;if(isNaN(t))e.setItemLayout(n,{angle:NaN,startAngle:NaN,endAngle:NaN,clockwise:g,cx:a,cy:s,r0:u,r:y?NaN:l});else{(// FIXME  2.0  roseType  area 
i="area"!==y?0===d&&v?f:t*f:LM/p)<c?(i=c,x-=c):_+=t;var r=b+w*i;e.setItemLayout(n,{angle:i,startAngle:b,endAngle:r,clockwise:g,cx:a,cy:s,r0:u,r:y?zr(t,m,[u,l]):l}),b=r}})),x<LM&&p)// Average the angle if rest angle is not enough after all angles is
// Constrained by minAngle
if(x<=.001){var S=LM/p;e.each(i,(function(t,n){if(!isNaN(t)){var i=e.getItemLayout(n);i.angle=S,i.startAngle=h+w*n*S,i.endAngle=h+w*(n+1)*S}}))}else f=x/_,b=h,e.each(i,(function(t,n){if(!isNaN(t)){var i=e.getItemLayout(n),r=i.angle===c?c:t*f;i.startAngle=b,i.endAngle=b+w*r,b+=w*r}}))}))}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function EM(t){return{seriesType:t,reset:function(t,e){var n=e.findComponents({mainType:"legend"});if(n&&n.length){var i=t.getData();i.filterSelf((function(t){// If in any legend component the status is not selected.
for(var e=i.getName(t),r=0;r<n.length;r++)// @ts-ignore FIXME: LegendModel
if(!n[r].isSelected(e))return!1;return!0}))}}}}var zM=Math.PI/180;function VM(t,e,n,i,r,o,a,s,l,u){if(!(t.length<2)){for(var h=t.length,c=0;c<h;c++)if("outer"===t[c].position&&"labelLine"===t[c].labelAlignTo){var p=t[c].label.x-u;t[c].linePoints[1][0]+=p,t[c].label.x=u}Bb(t,l,l+a)&&// Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.
function(t){for(// Extremes of
var o={list:[],maxY:0},a={list:[],maxY:0},s=0;s<t.length;s++)if("none"===t[s].labelAlignTo){var l=t[s],u=l.label.y>n?a:o,h=Math.abs(l.label.y-n);if(h>=u.maxY){var c=l.label.x-e-l.len2*r,p=i+l.len,f=Math.abs(c)<p?Math.sqrt(h*h/(1-c*c/p/p)):p;// horizontal r is always same with original r because x is not changed.
u.rB=f,u.maxY=h}u.list.push(l)}d(o),d(a)}(t)}function d(t){for(var o=t.rB,a=o*o,s=0;s<t.list.length;s++){var l=t.list[s],u=Math.abs(l.label.y-n),h=i+l.len,c=h*h,p=Math.sqrt((1-Math.abs(u*u/a))*c),d=e+(p+l.len2)*r,f=d-l.label.x;// text x is changed, so need to recalculate width.
BM(l,l.targetTextWidth-f*r,!0),l.label.x=d}}}
/**
             * Set max width of each label, and then wrap each label to the max width.
             *
             * @param layout label layout
             * @param availableWidth max width for the label to display
             * @param forceRecalculate recaculate the text layout even if the current width
             * is smaller than `availableWidth`. This is useful when the text was previously
             * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in
             * which case, previous wrapping should be redo.
             */
function BM(t,e,n){if(void 0===n&&(n=!1),null==t.labelStyleWidth){var i=t.label,r=i.style,o=t.rect,a=r.backgroundColor,s=r.padding,l=s?s[1]+s[3]:0,u=r.overflow,h=o.width+(a?0:l);if(e<h||n){var c=o.height;if(u&&u.match("break")){// Temporarily set background to be null to calculate
// the bounding box without background.
i.setStyle("backgroundColor",null),// Set constraining width
i.setStyle("width",e-l);// This is the real bounding box of the text without padding.
var p=i.getBoundingRect();i.setStyle("width",Math.ceil(p.width)),i.setStyle("backgroundColor",a)}else{var d=e-l,f=e<h?d:// Current available width is enough, but the text may have
// already been wrapped with a smaller available width.
n?d>t.unconstrainedWidth?null:d:// Current available width is enough, so no need to
// constrain.
null;i.setStyle("width",f)}var g=i.getBoundingRect();o.width=g.width;var y=(i.style.margin||0)+2.1;o.height=g.height+y,o.y-=(o.height-c)/2}}}function FM(t){// Not change x for center label
return"center"===t.position}function GM(t){var e,n,i=t.getData(),r=[],o=!1,a=(t.get("minShowLabelAngle")||0)*zM,s=i.getLayout("viewRect"),l=i.getLayout("r"),u=s.width,h=s.x,c=s.y,p=s.height;function d(t){t.ignore=!0}i.each((function(t){var s=i.getItemGraphicEl(t),c=s.shape,p=s.getTextContent(),f=s.getTextGuideLine(),g=i.getItemModel(t),y=g.getModel("label"),v=y.get("position")||g.get(["emphasis","label","position"]),m=y.get("distanceToLabelLine"),x=y.get("alignTo"),_=Vr(y.get("edgeDistance"),u),b=y.get("bleedMargin"),w=g.getModel("labelLine"),S=w.get("length");S=Vr(S,u);var M=w.get("length2");if(M=Vr(M,u),Math.abs(c.endAngle-c.startAngle)<a)return R(p.states,d),p.ignore=!0,void(f&&(R(f.states,d),f.ignore=!0));if(function(t){if(!t.ignore)return!0;for(var e in t.states)if(!1===t.states[e].ignore)return!0;return!1}(p)){var I,T,C,D,A=(c.startAngle+c.endAngle)/2,k=Math.cos(A),L=Math.sin(A);e=c.cx,n=c.cy;var P="inside"===v||"inner"===v;if("center"===v)I=c.cx,T=c.cy,D="center";else{var O=(P?(c.r+c.r0)/2*k:c.r*k)+e,N=(P?(c.r+c.r0)/2*L:c.r*L)+n;if(I=O+3*k,T=N+3*L,!P){// For roseType
var E=O+k*(S+l-c.r),z=N+L*(S+l-c.r),V=E+(k<0?-1:1)*M;// Adjust textX because text align of edge is opposite
I="edge"===x?k<0?h+_:h+u-_:V+(k<0?-m:m),T=z,C=[[O,N],[E,z],[V,z]]}D=P?"center":"edge"===x?k>0?"right":"left":k>0?"left":"right"}var B=Math.PI,F=0,G=y.get("rotate");if(X(G))F=G*(B/180);else if("center"===v)F=0;else if("radial"===G||!0===G)F=k<0?-A+B:-A;else if("tangential"===G&&"outside"!==v&&"outer"!==v){var W=Math.atan2(k,L);W<0&&(W=2*B+W),L>0&&(W=B+W),F=W-B}// Not sectorShape the inside label
if(o=!!F,p.x=I,p.y=T,p.rotation=F,p.setStyle({verticalAlign:"middle"}),P){p.setStyle({align:D});var H=p.states.select;H&&(H.x+=p.x,H.y+=p.y)}else{var Y=p.getBoundingRect().clone();Y.applyTransform(p.getComputedTransform());// Text has a default 1px stroke. Exclude this.
var U=(p.style.margin||0)+2.1;Y.y-=U/2,Y.height+=U,r.push({label:p,labelLine:f,position:v,len:S,len2:M,minTurnAngle:w.get("minTurnAngle"),maxSurfaceAngle:w.get("maxSurfaceAngle"),surfaceNormal:new ve(k,L),linePoints:C,textAlign:D,labelDistance:m,labelAlignTo:x,edgeDistance:_,bleedMargin:b,rect:Y,unconstrainedWidth:Y.width,labelStyleWidth:p.style.width})}s.setTextConfig({inside:P})}})),!o&&t.get("avoidLabelOverlap")&&function(t,e,n,i,r,o,a,s){for(var l=[],u=[],h=Number.MAX_VALUE,c=-Number.MAX_VALUE,p=0;p<t.length;p++){var d=t[p].label;FM(t[p])||(d.x<e?(h=Math.min(h,d.x),l.push(t[p])):(c=Math.max(c,d.x),u.push(t[p])))}for(p=0;p<t.length;p++)if(!FM(y=t[p])&&y.linePoints){if(null!=y.labelStyleWidth)continue;d=y.label;var f=y.linePoints,g=void 0;g="edge"===y.labelAlignTo?d.x<e?f[2][0]-y.labelDistance-a-y.edgeDistance:a+r-y.edgeDistance-f[2][0]-y.labelDistance:"labelLine"===y.labelAlignTo?d.x<e?h-a-y.bleedMargin:a+r-c-y.bleedMargin:d.x<e?d.x-a-y.bleedMargin:a+r-d.x-y.bleedMargin,y.targetTextWidth=g,BM(y,g)}for(VM(u,e,n,i,1,0,o,0,s,c),VM(l,e,n,i,-1,0,o,0,s,h),p=0;p<t.length;p++){var y;if(!FM(y=t[p])&&y.linePoints){d=y.label,f=y.linePoints;var v="edge"===y.labelAlignTo,m=d.style.padding,x=m?m[1]+m[3]:0,_=d.style.backgroundColor?0:x,b=y.rect.width+_,w=f[1][0]-f[2][0];v?d.x<e?f[2][0]=a+y.edgeDistance+b+y.labelDistance:f[2][0]=a+r-y.edgeDistance-b-y.labelDistance:(d.x<e?f[2][0]=d.x+y.labelDistance:f[2][0]=d.x-y.labelDistance,f[1][0]=f[2][0]+w),f[1][1]=f[2][1]=d.y}}}(r,e,n,l,u,p,h,c);for(var f=0;f<r.length;f++){var g=r[f],y=g.label,v=g.labelLine,m=isNaN(y.x)||isNaN(y.y);if(y){y.setStyle({align:g.textAlign}),m&&(R(y.states,d),y.ignore=!0);var x=y.states.select;x&&(x.x+=y.x,x.y+=y.y)}if(v){var _=g.linePoints;m||!_?(R(v.states,d),v.ignore=!0):(Lb(_,g.minTurnAngle),Pb(_,g.surfaceNormal,g.maxSurfaceAngle),v.setShape({points:_}),// Set the anchor to the midpoint of sector
y.__hostTarget.textGuideLineConfig={anchor:new ve(_[0][0],_[0][1])})}}}function WM(t,e,n){var i=t.get("borderRadius");if(null==i)return n?{cornerRadius:0}:null;G(i)||(i=[i,i,i,i]);var r=Math.abs(e.r||0-e.r0||0);return{cornerRadius:N(i,(function(t){return vr(t,r)}))}}
/**
             * Piece of pie including Sector, Label, LabelLine
             */var HM=/** @class */function(t){function e(e,n,i){var r=t.call(this)||this;r.z2=2;var o=new Zs;return r.setTextContent(o),r.updateData(e,n,i,!0),r}return n(e,t),e.prototype.updateData=function(t,e,n,i){var r=this,o=t.hostModel,a=t.getItemModel(e),s=a.getModel("emphasis"),l=t.getItemLayout(e),u=A(WM(a.getModel("itemStyle"),l,!0),l);// Ignore NaN data.
if(isNaN(u.startAngle))// Use NaN shape to avoid drawing shape.
r.setShape(u);else{if(i){r.setShape(u);var h=o.getShallow("animationType");o.ecModel.ssr?(// Use scale animation in SSR mode(opacity?)
// Because CSS SVG animation doesn't support very customized shape animation.
Mh(r,{scaleX:0,scaleY:0},o,{dataIndex:e,isFrom:!0}),r.originX=u.cx,r.originY=u.cy):"scale"===h?(r.shape.r=l.r0,Mh(r,{shape:{r:l.r}},o,e)):null!=n?(r.setShape({startAngle:n,endAngle:n}),Mh(r,{shape:{startAngle:l.startAngle,endAngle:l.endAngle}},o,e)):(r.shape.endAngle=l.startAngle,Sh(r,{shape:{endAngle:l.endAngle}},o,e))}else Ah(r),// Transition animation from the old shape
Sh(r,{shape:u},o,e);r.useStyle(t.getItemVisual(e,"style")),Hl(r,a);var c=(l.startAngle+l.endAngle)/2,p=o.get("selectedOffset"),d=Math.cos(c)*p,f=Math.sin(c)*p,g=a.getShallow("cursor");g&&r.attr("cursor",g),this._updateLabel(o,t,e),r.ensureState("emphasis").shape=A({r:l.r+(s.get("scale")&&s.get("scaleSize")||0)},WM(s.getModel("itemStyle"),l)),A(r.ensureState("select"),{x:d,y:f,shape:WM(a.getModel(["select","itemStyle"]),l)}),A(r.ensureState("blur"),{shape:WM(a.getModel(["blur","itemStyle"]),l)});var y=r.getTextGuideLine(),v=r.getTextContent();y&&A(y.ensureState("select"),{x:d,y:f}),// TODO: needs dx, dy in zrender?
A(v.ensureState("select"),{x:d,y:f}),Bl(this,s.get("focus"),s.get("blurScope"),s.get("disabled"))}},e.prototype._updateLabel=function(t,e,n){var i=this,r=e.getItemModel(n),o=r.getModel("labelLine"),a=e.getItemVisual(n,"style"),s=a&&a.fill,l=a&&a.opacity;ac(i,sc(r),{labelFetcher:e.hostModel,labelDataIndex:n,inheritColor:s,defaultOpacity:l,defaultText:t.getFormattedLabel(n,"normal")||e.getName(n)});var u=i.getTextContent();// Set textConfig on sector.
i.setTextConfig({// reset position, rotation
position:null,rotation:null}),// Make sure update style on labelText after setLabelStyle.
// Because setLabelStyle will replace a new style on it.
u.attr({z2:10});var h=t.get(["label","position"]);if("outside"!==h&&"outer"!==h)i.removeTextGuideLine();else{var c=this.getTextGuideLine();c||(c=new Xu,this.setTextGuideLine(c)),// Default use item visual color
Nb(this,Eb(r),{stroke:s,opacity:tt(o.get(["lineStyle","opacity"]),l,1)})}},e}(Nu),YM=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.ignoreLabelLineUpdate=!0,e}return n(e,t),e.prototype.render=function(t,e,n,i){var r,o=t.getData(),a=this._data,s=this.group;// First render
if(!a&&o.count()>0){for(var l=o.getItemLayout(0),u=1;isNaN(l&&l.startAngle)&&u<o.count();++u)l=o.getItemLayout(u);l&&(r=l.startAngle)}// remove empty-circle if it exists
// when all data are filtered, show lightgray empty circle
if(this._emptyCircleSector&&s.remove(this._emptyCircleSector),0===o.count()&&t.get("showEmptyCircle")){var h=new Nu({shape:RM(t,n)});h.useStyle(t.getModel("emptyCircleStyle").getItemStyle()),this._emptyCircleSector=h,s.add(h)}o.diff(a).add((function(t){var e=new HM(o,t,r);o.setItemGraphicEl(t,e),s.add(e)})).update((function(t,e){var n=a.getItemGraphicEl(e);n.updateData(o,t,r),n.off("click"),s.add(n),o.setItemGraphicEl(t,n)})).remove((function(e){Dh(a.getItemGraphicEl(e),t,e)})).execute(),GM(t),// Always use initial animation.
"expansion"!==t.get("animationTypeUpdate")&&(this._data=o)},e.prototype.dispose=function(){},e.prototype.containPoint=function(t,e){var n=e.getData().getItemLayout(0);if(n){var i=t[0]-n.cx,r=t[1]-n.cy,o=Math.sqrt(i*i+r*r);return o<=n.r&&o>=n.r0}},e.type="pie",e}(qg);// Pie view
const XM=YM;
/**
             * [Usage]:
             * (1)
             * createListSimply(seriesModel, ['value']);
             * (2)
             * createListSimply(seriesModel, {
             *     coordDimensions: ['value'],
             *     dimensionsCount: 5
             * });
             */function UM(t,e,n){e=G(e)&&{coordDimensions:e}||A({encodeDefine:t.getEncode()},e);var i=t.getSource(),r=mx(i,e).dimensions,o=new vx(r,t);return o.initData(i,n),o}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * LegendVisualProvider is an bridge that pick encoded color from data and
             * provide to the legend component.
             */var ZM=/** @class */function(){function t(// Function to get data after filtered. It stores all the encoding info
t,// Function to get raw data before filtered.
e){this._getDataWithEncodedVisual=t,this._getRawData=e}return t.prototype.getAllNames=function(){var t=this._getRawData();// We find the name from the raw data. In case it's filtered by the legend component.
// Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.
return t.mapArray(t.getName)},t.prototype.containName=function(t){return this._getRawData().indexOfName(t)>=0},t.prototype.indexOfName=function(t){return this._getDataWithEncodedVisual().indexOfName(t)},t.prototype.getItemVisual=function(t,e){return this._getDataWithEncodedVisual().getItemVisual(t,e)},t}();const jM=ZM;var qM=bo(),KM=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}
/**
               * @overwrite
               */return n(e,t),e.prototype.init=function(e){t.prototype.init.apply(this,arguments),// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendVisualProvider=new jM(B(this.getData,this),B(this.getRawData,this)),this._defaultLabelLine(e)},
/**
               * @overwrite
               */
e.prototype.mergeOption=function(){t.prototype.mergeOption.apply(this,arguments)},
/**
               * @overwrite
               */
e.prototype.getInitialData=function(){return UM(this,{coordDimensions:["value"],encodeDefaulter:F(ad,this)})},
/**
               * @overwrite
               */
e.prototype.getDataParams=function(e){var n=this.getData(),i=qM(n),r=i.seats;// update seats when data is changed
if(!r){var o=[];n.each(n.mapDimension("value"),(function(t){o.push(t)})),r=i.seats=function(t,e){var n=E(t,(function(t,e){return t+(isNaN(e)?0:e)}),0);if(0===n)return[];// Has remainding votes.
for(var i=Math.pow(10,e),r=N(t,(function(t){return(isNaN(t)?0:t)/n*i*100})),o=100*i,a=N(r,(function(t){// Assign automatic seats.
return Math.floor(t)})),s=E(a,(function(t,e){return t+e}),0),l=N(r,(function(t,e){return t-a[e]}));s<o;){for(// Find next largest remainder.
var u=Number.NEGATIVE_INFINITY,h=null,c=0,p=l.length;c<p;++c)l[c]>u&&(u=l[c],h=c);// Add a vote to max remainder.
++a[h],l[h]=0,++s}return N(a,(function(t){return t/i}))}(o,n.hostModel.get("percentPrecision"))}var a=t.prototype.getDataParams.call(this,e);// seats may be empty when sum is 0
return a.percent=r[e]||0,a.$vars.push("percent"),a},e.prototype._defaultLabelLine=function(t){// Extend labelLine emphasis
uo(t,"labelLine",["show"]);var e=t.labelLine,n=t.emphasis.labelLine;// Not show label line if `label.normal.show = false`
e.show=e.show&&t.label.show,n.show=n.show&&t.emphasis.label.show},e.type="series.pie",e.defaultOption={// zlevel: 0,
z:2,legendHoverLink:!0,colorBy:"data",// 
center:["50%","50%"],radius:[0,"75%"],// 
clockwise:!0,startAngle:90,// 0
minAngle:0,// If the angle of a sector less than `minShowLabelAngle`,
// the label will not be displayed.
minShowLabelAngle:0,// 
selectedOffset:10,// singlemultiple
// selectedMode: false,
// 'radius' | 'area'
// roseType: null,
percentPrecision:2,// If still show when all data zero.
stillShowZeroSum:!0,// cursor: null,
left:0,top:0,right:0,bottom:0,width:null,height:null,label:{// color: 'inherit',
// If rotate around circle
rotate:0,show:!0,overflow:"truncate",// 'outer', 'inside', 'center'
position:"outer",// 'none', 'labelLine', 'edge'. Works only when position is 'outer'
alignTo:"none",// Closest distance between label and chart edge.
// Works only position is 'outer' and alignTo is 'edge'.
edgeDistance:"25%",// Works only position is 'outer' and alignTo is not 'edge'.
bleedMargin:10,// Distance between text and label line.
distanceToLabelLine:5},// Enabled when label.normal.position is 'outer'
labelLine:{show:!0,// 
length:15,// 
length2:15,smooth:!1,minTurnAngle:90,maxSurfaceAngle:90,lineStyle:{// color: ,
width:1,type:"solid"}},itemStyle:{borderWidth:1,borderJoin:"round"},showEmptyCircle:!0,emptyCircleStyle:{color:"lightgray",opacity:1},labelLayout:{// Hide the overlapped label.
hideOverlap:!0},emphasis:{scale:!0,scaleSize:5},// If use strategy to avoid label overlapping
avoidLabelOverlap:!0,// Animation type. Valid values: expansion, scale
animationType:"expansion",animationDuration:1e3,// Animation type when update. Valid values: transition, expansion
animationTypeUpdate:"transition",animationEasingUpdate:"cubicInOut",animationDurationUpdate:500,animationEasing:"cubicInOut"},e}(zg);const $M=KM;var JM=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n}return n(e,t),e.prototype.getInitialData=function(t,e){return Cx(null,this,{useEncodeDefaulter:!0})},e.prototype.getProgressive=function(){var t=this.option.progressive;return null==t?this.option.large?5e3:this.get("progressive"):t},e.prototype.getProgressiveThreshold=function(){var t=this.option.progressiveThreshold;return null==t?this.option.large?1e4:this.get("progressiveThreshold"):t},e.prototype.brushSelector=function(t,e,n){return n.point(e.getItemLayout(t))},e.prototype.getZLevelKey=function(){// Each progressive series has individual key.
return this.getData().count()>this.getProgressiveThreshold()?this.id:""},e.type="series.scatter",e.dependencies=["grid","polar","geo","singleAxis","calendar"],e.defaultOption={coordinateSystem:"cartesian2d",// zlevel: 0,
z:2,legendHoverLink:!0,symbolSize:10,// symbolRotate: null,  // 
large:!1,// Available when large is true
largeThreshold:2e3,// cursor: null,
itemStyle:{opacity:.8},emphasis:{scale:!0},// If clip the overflow graphics
// Works on cartesian / polar series
clip:!0,select:{itemStyle:{borderColor:"#212121"}},universalTransition:{divideShape:"clone"}},e}(zg);const QM=JM;var tI=function(){},eI=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n._off=0,n.hoverDataIdx=-1,n}return n(e,t),e.prototype.getDefaultShape=function(){return new tI},e.prototype.reset=function(){this.notClear=!1,this._off=0},e.prototype.buildPath=function(t,e){var n,i=e.points,r=e.size,o=this.symbolProxy,a=o.shape,s=t.getContext?t.getContext():t,l=s&&r[0]<4,u=this.softClipShape;// Do draw in afterBrush.
if(l)this._ctx=s;else{for(this._ctx=null,n=this._off;n<i.length;){var h=i[n++],c=i[n++];isNaN(h)||isNaN(c)||u&&!u.contain(h,c)||(a.x=h-r[0]/2,a.y=c-r[1]/2,a.width=r[0],a.height=r[1],o.buildPath(t,a,!0))}this.incremental&&(this._off=n,this.notClear=!0)}},e.prototype.afterBrush=function(){var t,e=this.shape,n=e.points,i=e.size,r=this._ctx,o=this.softClipShape;if(r){// PENDING If style or other canvas status changed?
for(t=this._off;t<n.length;){var a=n[t++],s=n[t++];isNaN(a)||isNaN(s)||o&&!o.contain(a,s)||// fillRect is faster than building a rect path and draw.
// And it support light globalCompositeOperation.
r.fillRect(a-i[0]/2,s-i[1]/2,i[0],i[1])}this.incremental&&(this._off=t,this.notClear=!0)}},e.prototype.findDataIndex=function(t,e){// Not consider transform
// Treat each element as a rect
// top down traverse
for(// TODO ???
// Consider transform
var n=this.shape,i=n.points,r=n.size,o=Math.max(r[0],4),a=Math.max(r[1],4),s=i.length/2-1;s>=0;s--){var l=2*s,u=i[l]-o/2,h=i[l+1]-a/2;if(t>=u&&e>=h&&t<=u+o&&e<=h+a)return s}return-1},e.prototype.contain=function(t,e){var n=this.transformCoordToLocal(t,e),i=this.getBoundingRect();return t=n[0],e=n[1],i.contain(t,e)?(this.hoverDataIdx=this.findDataIndex(t,e))>=0:(this.hoverDataIdx=-1,!1)},e.prototype.getBoundingRect=function(){// Ignore stroke for large symbol draw.
var t=this._rect;if(!t){for(var e=this.shape,n=e.points,i=e.size,r=i[0],o=i[1],a=1/0,s=1/0,l=-1/0,u=-1/0,h=0;h<n.length;){var c=n[h++],p=n[h++];a=Math.min(c,a),l=Math.max(c,l),s=Math.min(p,s),u=Math.max(p,u)}t=this._rect=new Ce(a-r/2,s-o/2,l-a+r,u-s+o)}return t},e}(ys),nI=/** @class */function(){function t(){this.group=new Lr}
/**
               * Update symbols draw by new data
               */return t.prototype.updateData=function(t,e){this._clear();var n=this._create();n.setShape({points:t.getLayout("points")}),this._setCommon(n,t,e)},t.prototype.updateLayout=function(t){var e=t.getLayout("points");this.group.eachChild((function(t){if(null!=t.startIndex){var n=2*(t.endIndex-t.startIndex),i=4*t.startIndex*2;e=new Float32Array(e.buffer,i,n)}t.setShape("points",e),// Reset draw cursor.
t.reset()}))},t.prototype.incrementalPrepareUpdate=function(t){this._clear()},t.prototype.incrementalUpdate=function(t,e,n){var i=this._newAdded[0],r=e.getLayout("points"),o=i&&i.shape.points;// Merging the exists. Each element has 1e4 points.
// Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)
if(o&&o.length<2e4){var a=o.length,s=new Float32Array(a+r.length);// Concat two array
s.set(o),s.set(r,a),// Update endIndex
i.endIndex=t.end,i.setShape({points:s})}else{// Clear
this._newAdded=[];var l=this._create();l.startIndex=t.start,l.endIndex=t.end,l.incremental=!0,l.setShape({points:r}),this._setCommon(l,e,n)}},t.prototype.eachRendered=function(t){this._newAdded[0]&&t(this._newAdded[0])},t.prototype._create=function(){var t=new eI({cursor:"default"});return t.ignoreCoarsePointer=!0,this.group.add(t),this._newAdded.push(t),t},t.prototype._setCommon=function(t,e,n){var i=e.hostModel;n=n||{};var r=e.getVisual("symbolSize");t.setShape("size",r instanceof Array?r:[r,r]),t.softClipShape=n.clipShape||null,// Create symbolProxy to build path for each data
t.symbolProxy=ov(e.getVisual("symbol"),0,0,0,0),// Use symbolProxy setColor method
t.setColor=t.symbolProxy.setColor;var o=t.shape.size[0]<4;t.useStyle(// Draw shadow when doing fillRect is extremely slow.
i.getModel("itemStyle").getItemStyle(o?["color","shadowBlur","shadowColor"]:["color"]));var a=e.getVisual("style"),s=a&&a.fill;s&&t.setColor(s);var l=js(t);// Enable tooltip
// PENDING May have performance issue when path is extremely large
l.seriesIndex=i.seriesIndex,t.on("mousemove",(function(e){l.dataIndex=null;var n=t.hoverDataIdx;n>=0&&(// Provide dataIndex for tooltip
l.dataIndex=n+(t.startIndex||0))}))},t.prototype.remove=function(){this._clear()},t.prototype._clear=function(){this._newAdded=[],this.group.removeAll()},t}();const iI=nI;var rI=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.getData();this._updateSymbolDraw(i,t).updateData(i,{// TODO
// If this parameter should be a shape or a bounding volume
// shape will be more general.
// But bounding volume like bounding rect will be much faster in the contain calculation
clipShape:this._getClipShape(t)}),this._finished=!0},e.prototype.incrementalPrepareRender=function(t,e,n){var i=t.getData();this._updateSymbolDraw(i,t).incrementalPrepareUpdate(i),this._finished=!1},e.prototype.incrementalRender=function(t,e,n){this._symbolDraw.incrementalUpdate(t,e.getData(),{clipShape:this._getClipShape(e)}),this._finished=t.end===e.getData().count()},e.prototype.updateTransform=function(t,e,n){var i=t.getData();// Must mark group dirty and make sure the incremental layer will be cleared
// PENDING
if(this.group.dirty(),!this._finished||i.count()>1e4)return{update:!0};var r=QS("").reset(t,e,n);r.progress&&r.progress({start:0,end:i.count(),count:i.count()},i),this._symbolDraw.updateLayout(i)},e.prototype.eachRendered=function(t){this._symbolDraw&&this._symbolDraw.eachRendered(t)},e.prototype._getClipShape=function(t){var e=t.coordinateSystem,n=e&&e.getArea&&e.getArea();return t.get("clip",!0)?n:null},e.prototype._updateSymbolDraw=function(t,e){var n=this._symbolDraw,i=e.pipelineContext.large;return n&&i===this._isLargeDraw||(n&&n.remove(),n=this._symbolDraw=i?new iI:new TS,this._isLargeDraw=i,this.group.removeAll()),this.group.add(n.group),n},e.prototype.remove=function(t,e){this._symbolDraw&&this._symbolDraw.remove(!0),this._symbolDraw=null},e.prototype.dispose=function(){},e.type="scatter",e}(qg);const oI=rI;var aI=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.type="grid",e.dependencies=["xAxis","yAxis"],e.layoutMode="box",e.defaultOption={show:!1,// zlevel: 0,
z:0,left:"10%",top:60,right:"10%",bottom:70,// If grid size contain label
containLabel:!1,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
backgroundColor:"rgba(0,0,0,0)",borderWidth:1,borderColor:"#ccc"},e}(Wp);const sI=aI;var lI=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.getCoordSysModel=function(){return this.getReferringComponents("grid",Io).models[0]},e.type="cartesian2dAxis",e}(Wp);P(lI,F_);var uI={show:!0,// zlevel: 0,
z:0,// Inverse the axis.
inverse:!1,// Axis name displayed.
name:"",// 'start' | 'middle' | 'end'
nameLocation:"end",// By degree. By default auto rotate by nameLocation.
nameRotate:null,nameTruncate:{maxWidth:null,ellipsis:"...",placeholder:"."},// Use global text style by default.
nameTextStyle:{},// The gap between axisName and axisLine.
nameGap:15,// Default `false` to support tooltip.
silent:!1,// Default `false` to avoid legacy user event listener fail.
triggerEvent:!1,tooltip:{show:!1},axisPointer:{},axisLine:{show:!0,onZero:!0,onZeroAxisIndex:null,lineStyle:{color:"#6E7079",width:1,type:"solid"},// The arrow at both ends the the axis.
symbol:["none","none"],symbolSize:[10,15]},axisTick:{show:!0,// Whether axisTick is inside the grid or outside the grid.
inside:!1,// The length of axisTick.
length:5,lineStyle:{width:1}},axisLabel:{show:!0,// Whether axisLabel is inside the grid or outside the grid.
inside:!1,rotate:0,// true | false | null/undefined (auto)
showMinLabel:null,// true | false | null/undefined (auto)
showMaxLabel:null,margin:8,// formatter: null,
fontSize:12},splitLine:{show:!0,lineStyle:{color:["#E0E6F1"],width:1,type:"solid"}},splitArea:{show:!1,areaStyle:{color:["rgba(250,250,250,0.2)","rgba(210,219,238,0.2)"]}}},hI=C({// The gap at both ends of the axis. For categoryAxis, boolean.
boundaryGap:!0,// Set false to faster category collection.
deduplication:null,// splitArea: {
// show: false
// },
splitLine:{show:!1},axisTick:{// If tick is align with label when boundaryGap is true
alignWithLabel:!1,interval:"auto"},axisLabel:{interval:"auto"}},uI),cI=C({boundaryGap:[0,0],axisLine:{// Not shown when other axis is categoryAxis in cartesian
show:"auto"},axisTick:{// Not shown when other axis is categoryAxis in cartesian
show:"auto"},// TODO
// min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
splitNumber:5,minorTick:{// Minor tick, not available for cateogry axis.
show:!1,// Split number of minor ticks. The value should be in range of (0, 100)
splitNumber:5,// Length of minor tick
length:3,// Line style
lineStyle:{}},minorSplitLine:{show:!1,lineStyle:{color:"#F4F7FD",width:1}}},uI);const pI={category:hI,value:cI,time:C({splitNumber:6,axisLabel:{// To eliminate labels that are not nice
showMinLabel:!1,showMaxLabel:!1,rich:{primary:{fontWeight:"bold"}}},splitLine:{show:!1}},cI),log:k({logBase:10},cI)};
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var dI={value:1,category:1,time:1,log:1};
/**
             * Generate sub axis model class
             * @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...
             */function fI(t,e,i,r){R(dI,(function(o,a){var s=C(C({},pI[a],!0),r,!0),l=/** @class */function(t){function i(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e+"Axis."+a,n}return n(i,t),i.prototype.mergeDefaultAndTheme=function(t,e){var n=Ep(this),i=n?Vp(t):{};C(t,e.getTheme().get(a+"Axis")),C(t,this.getDefaultOption()),t.type=gI(t),n&&zp(t,i,n)},i.prototype.optionUpdated=function(){"category"===this.option.type&&(this.__ordinalMeta=Ox.createByAxisModel(this))},
/**
                   * Should not be called before all of 'getInitailData' finished.
                   * Because categories are collected during initializing data.
                   */
i.prototype.getCategories=function(t){var e=this.option;// FIXME
// warning if called before all of 'getInitailData' finished.
if("category"===e.type)return t?e.data:this.__ordinalMeta.categories},i.prototype.getOrdinalMeta=function(){return this.__ordinalMeta},i.type=e+"Axis."+a,i.defaultOption=s,i}(i);t.registerComponentModel(l)})),t.registerSubTypeDefaulter(e+"Axis",gI)}function gI(t){// Default axis with data is category axis
return t.type||(t.data?"category":"value")}var yI=/** @class */function(){function t(t){this.type="cartesian",this._dimList=[],this._axes={},this.name=t||""}return t.prototype.getAxis=function(t){return this._axes[t]},t.prototype.getAxes=function(){return N(this._dimList,(function(t){return this._axes[t]}),this)},t.prototype.getAxesByScale=function(t){return t=t.toLowerCase(),z(this.getAxes(),(function(e){return e.scale.type===t}))},t.prototype.addAxis=function(t){var e=t.dim;this._axes[e]=t,this._dimList.push(e)},t}(),vI=["x","y"];function mI(t){return"interval"===t.type||"time"===t.type}var xI=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="cartesian2d",e.dimensions=vI,e}
/**
               * Calculate an affine transform matrix if two axes are time or value.
               * It's mainly for accelartion on the large time series data.
               */return n(e,t),e.prototype.calcAffineTransform=function(){this._transform=this._invTransform=null;var t=this.getAxis("x").scale,e=this.getAxis("y").scale;if(mI(t)&&mI(e)){var n=t.getExtent(),i=e.getExtent(),r=this.dataToPoint([n[0],i[0]]),o=this.dataToPoint([n[1],i[1]]),a=n[1]-n[0],s=i[1]-i[0];if(a&&s){// Accelerate data to point calculation on the special large time series data.
var l=(o[0]-r[0])/a,u=(o[1]-r[1])/s,h=r[0]-n[0]*l,c=r[1]-i[0]*u,p=this._transform=[l,0,0,u,h,c];this._invTransform=ge([],p)}}},
/**
               * Base axis will be used on stacking.
               */
e.prototype.getBaseAxis=function(){return this.getAxesByScale("ordinal")[0]||this.getAxesByScale("time")[0]||this.getAxis("x")},e.prototype.containPoint=function(t){var e=this.getAxis("x"),n=this.getAxis("y");return e.contain(e.toLocalCoord(t[0]))&&n.contain(n.toLocalCoord(t[1]))},e.prototype.containData=function(t){return this.getAxis("x").containData(t[0])&&this.getAxis("y").containData(t[1])},e.prototype.containZone=function(t,e){var n=this.dataToPoint(t),i=this.dataToPoint(e),r=this.getArea(),o=new Ce(n[0],n[1],i[0]-n[0],i[1]-n[1]);return r.intersect(o)},e.prototype.dataToPoint=function(t,e,n){n=n||[];var i=t[0],r=t[1];// Fast path
if(this._transform&&null!=i&&isFinite(i)&&null!=r&&isFinite(r))return Pt(n,t,this._transform);var o=this.getAxis("x"),a=this.getAxis("y");return n[0]=o.toGlobalCoord(o.dataToCoord(i,e)),n[1]=a.toGlobalCoord(a.dataToCoord(r,e)),n},e.prototype.clampData=function(t,e){var n=this.getAxis("x").scale,i=this.getAxis("y").scale,r=n.getExtent(),o=i.getExtent(),a=n.parse(t[0]),s=i.parse(t[1]);return(e=e||[])[0]=Math.min(Math.max(Math.min(r[0],r[1]),a),Math.max(r[0],r[1])),e[1]=Math.min(Math.max(Math.min(o[0],o[1]),s),Math.max(o[0],o[1])),e},e.prototype.pointToData=function(t,e){var n=[];if(this._invTransform)return Pt(n,t,this._invTransform);var i=this.getAxis("x"),r=this.getAxis("y");return n[0]=i.coordToData(i.toLocalCoord(t[0]),e),n[1]=r.coordToData(r.toLocalCoord(t[1]),e),n},e.prototype.getOtherAxis=function(t){return this.getAxis("x"===t.dim?"y":"x")},
/**
               * Get rect area of cartesian.
               * Area will have a contain function to determine if a point is in the coordinate system.
               */
e.prototype.getArea=function(){var t=this.getAxis("x").getGlobalExtent(),e=this.getAxis("y").getGlobalExtent(),n=Math.min(t[0],t[1]),i=Math.min(e[0],e[1]),r=Math.max(t[0],t[1])-n,o=Math.max(e[0],e[1])-i;return new Ce(n,i,r,o)},e}(yI),_I=/** @class */function(t){function e(e,n,i,r,o){var a=t.call(this,e,n,i)||this;
/**
                 * Index of axis, can be used as key
                 * Injected outside.
                 */return a.index=0,a.type=r||"value",a.position=o||"bottom",a}return n(e,t),e.prototype.isHorizontal=function(){var t=this.position;return"top"===t||"bottom"===t},
/**
               * Each item cooresponds to this.getExtent(), which
               * means globalExtent[0] may greater than globalExtent[1],
               * unless `asc` is input.
               *
               * @param {boolean} [asc]
               * @return {Array.<number>}
               */
e.prototype.getGlobalExtent=function(t){var e=this.getExtent();return e[0]=this.toGlobalCoord(e[0]),e[1]=this.toGlobalCoord(e[1]),t&&e[0]>e[1]&&e.reverse(),e},e.prototype.pointToData=function(t,e){return this.coordToData(this.toLocalCoord(t["x"===this.dim?0:1]),e)},
/**
               * Set ordinalSortInfo
               * @param info new OrdinalSortInfo
               */
e.prototype.setCategorySortInfo=function(t){if("category"!==this.type)return!1;this.model.option.categorySortInfo=t,this.scale.setSortInfo(t)},e}(pb);const bI=_I;
/**
             * Can only be called after coordinate system creation stage.
             * (Can be called before coordinate system update stage).
             */function wI(t,e,n){n=n||{};var i=t.coordinateSystem,r=e.axis,o={},a=r.getAxesOnZeroOf()[0],s=r.position,l=a?"onZero":s,u=r.dim,h=i.getRect(),c=[h.x,h.x+h.width,h.y,h.y+h.height],p={left:0,right:1,top:0,bottom:1,onZero:2},d=e.get("offset")||0,f="x"===u?[c[2]-d,c[3]+d]:[c[0]-d,c[1]+d];if(a){var g=a.toGlobalCoord(a.dataToCoord(0));f[p.onZero]=Math.max(Math.min(g,f[1]),f[0])}// Axis position
o.position=["y"===u?f[p[l]]:c[0],"x"===u?f[p[l]]:c[3]],// Axis rotation
o.rotation=Math.PI/2*("x"===u?0:1),o.labelDirection=o.tickDirection=o.nameDirection={top:-1,bottom:1,left:-1,right:1}[s],o.labelOffset=a?f[p[s]]-f[p.onZero]:0,e.get(["axisTick","inside"])&&(o.tickDirection=-o.tickDirection),J(n.labelInside,e.get(["axisLabel","inside"]))&&(o.labelDirection=-o.labelDirection);// Special label rotation
var y=e.get(["axisLabel","rotate"]);return o.labelRotate="top"===l?-y:y,// Over splitLine and splitArea
o.z2=1,o}function SI(t){return"cartesian2d"===t.get("coordinateSystem")}function MI(t){var e={xAxisModel:null,yAxisModel:null};return R(e,(function(n,i){var r=i.replace(/Model$/,""),o=t.getReferringComponents(r,Io).models[0];e[i]=o})),e}var II=Math.log;function TI(t,e,n){var i=Ux.prototype,r=i.getTicks.call(n),o=i.getTicks.call(n,!0),a=r.length-1,s=i.getInterval.call(n),l=L_(t,e),u=l.extent,h=l.fixMin,c=l.fixMax;// NOTE: There is a precondition for log scale  here:
// In log scale we store _interval and _extent of exponent value.
// So if we use the method of InternalScale to set/get these data.
// It process the exponent value, which is linear and what we want here.
if("log"===t.type){var p=II(t.base);u=[II(u[0])/p,II(u[1])/p]}t.setExtent(u[0],u[1]),t.calcNiceExtent({splitNumber:a,fixMin:h,fixMax:c});var d=i.getExtent.call(t);// Need to update the rawExtent.
// Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'
h&&(u[0]=d[0]),c&&(u[1]=d[1]);var f=i.getInterval.call(t),g=u[0],y=u[1];if(h&&c)// User set min, max, divide to get new interval
f=(y-g)/a;else if(h)// User set min, expand extent on the other side
for(y=u[0]+f*a;y<u[1]&&isFinite(y)&&isFinite(u[1]);)f=Ex(f),y=u[0]+f*a;else if(c)for(// User set max, expand extent on the other side
g=u[1]-f*a;g>u[0]&&isFinite(g)&&isFinite(u[0]);)f=Ex(f),g=u[1]-f*a;else{t.getTicks().length-1>a&&(f=Ex(f));var v=f*a;// Not change the result that crossing zero.
(g=Br((y=Math.ceil(u[1]/f)*f)-v))<0&&u[0]>=0?(g=0,y=Br(v)):y>0&&u[1]<=0&&(y=0,g=-Br(v))}// Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale
var m=(r[0].value-o[0].value)/s,x=(r[a].value-o[a].value)/s;// NOTE: Must in setExtent -> setInterval -> setNiceExtent order.
i.setExtent.call(t,g+f*m,y+f*x),i.setInterval.call(t,f),(m||x)&&i.setNiceExtent.call(t,g+f,y-f)}var CI=/** @class */function(){function t(t,e,n){// FIXME:TS where used (different from registered type 'cartesian2d')?
this.type="grid",this._coordsMap={},this._coordsList=[],this._axesMap={},this._axesList=[],this.axisPointerEnabled=!0,this.dimensions=vI,this._initCartesian(t,e,n),this.model=t}return t.prototype.getRect=function(){return this._rect},t.prototype.update=function(t,e){var n=this._axesMap;function i(t){var e,n=V(t),i=n.length;// Axis is added in order of axisIndex.
if(i){// Process once and calculate the ticks for those don't use alignTicks.
for(var r=[],o=i-1;o>=0;o--){var a=t[+n[o]],s=a.model,l=a.scale;// Convert to number.
// Only value and log axis without interval support alignTicks.
Rx(l)&&s.get("alignTicks")&&null==s.get("interval")?r.push(a):(P_(l,s),Rx(l)&&(// Can only align to interval or log axis.
e=a))}// PENDING. Should we find the axis that both set interval, min, max and align to this one?
r.length&&(e||P_((e=r.pop()).scale,e.model),R(r,(function(t){TI(t.scale,t.model,e.scale)})))}}this._updateScale(t,this.model),i(n.x),i(n.y);// Key: axisDim_axisIndex, value: boolean, whether onZero target.
var r={};R(n.x,(function(t){AI(n,"y",t,r)})),R(n.y,(function(t){AI(n,"x",t,r)})),// Resize again if containLabel is enabled
// FIXME It may cause getting wrong grid size in data processing stage
this.resize(this.model,e)},
/**
               * Resize the grid
               */
t.prototype.resize=function(t,e,n){var i=t.getBoxLayoutParams(),r=!n&&t.get("containLabel"),o=Rp(i,{width:e.getWidth(),height:e.getHeight()});this._rect=o;var a=this._axesList;function s(){R(a,(function(t){var e=t.isHorizontal(),n=e?[0,o.width]:[0,o.height],i=t.inverse?1:0;t.setExtent(n[i],n[1-i]),function(t,e){var n=t.getExtent(),i=n[0]+n[1];// Fast transform
t.toGlobalCoord="x"===t.dim?function(t){return t+e}:function(t){return i-t+e},t.toLocalCoord="x"===t.dim?function(t){return t-e}:function(t){return i-t+e}}(t,e?o.x:o.y)}))}s(),// Minus label size
r&&(R(a,(function(t){if(!t.model.get(["axisLabel","inside"])){var e=function(t){var e=t.model,n=t.scale;if(e.get(["axisLabel","show"])&&!n.isBlank()){var i,r,o=n.getExtent();// Optimize for large category data, avoid call `getTicks()`.
r=n instanceof Hx?n.count():(i=n.getTicks()).length;var a,s=t.getLabelModel(),l=R_(t),u=1;// Simple optimization for large amount of labels
r>40&&(u=Math.ceil(r/40));for(var h=0;h<r;h+=u){var c=l(i?i[h]:{value:o[0]+h},h),p=E_(s.getTextRect(c),s.get("rotate")||0);a?a.union(p):a=p}return a}}(t);if(e){var n=t.isHorizontal()?"height":"width",i=t.model.get(["axisLabel","margin"]);o[n]-=e[n]+i,"top"===t.position?o.y+=e.height+i:"left"===t.position&&(o.x+=e.width+i)}}})),s()),R(this._coordsList,(function(t){// Calculate affine matrix to accelerate the data to point transform.
// If all the axes scales are time or value.
t.calcAffineTransform()}))},t.prototype.getAxis=function(t,e){var n=this._axesMap[t];if(null!=n)return n[e||0]},t.prototype.getAxes=function(){return this._axesList.slice()},t.prototype.getCartesian=function(t,e){if(null!=t&&null!=e){var n="x"+t+"y"+e;return this._coordsMap[n]}U(t)&&(e=t.yAxisIndex,t=t.xAxisIndex);for(var i=0,r=this._coordsList;i<r.length;i++)if(r[i].getAxis("x").index===t||r[i].getAxis("y").index===e)return r[i]},t.prototype.getCartesians=function(){return this._coordsList.slice()},
/**
               * @implements
               */
t.prototype.convertToPixel=function(t,e,n){var i=this._findConvertTarget(e);return i.cartesian?i.cartesian.dataToPoint(n):i.axis?i.axis.toGlobalCoord(i.axis.dataToCoord(n)):null},
/**
               * @implements
               */
t.prototype.convertFromPixel=function(t,e,n){var i=this._findConvertTarget(e);return i.cartesian?i.cartesian.pointToData(n):i.axis?i.axis.coordToData(i.axis.toLocalCoord(n)):null},t.prototype._findConvertTarget=function(t){var e,n,i=t.seriesModel,r=t.xAxisModel||i&&i.getReferringComponents("xAxis",Io).models[0],o=t.yAxisModel||i&&i.getReferringComponents("yAxis",Io).models[0],a=t.gridModel,s=this._coordsList;return i?L(s,e=i.coordinateSystem)<0&&(e=null):r&&o?e=this.getCartesian(r.componentIndex,o.componentIndex):r?n=this.getAxis("x",r.componentIndex):o?n=this.getAxis("y",o.componentIndex):a&&a.coordinateSystem===this&&(e=this._coordsList[0]),{cartesian:e,axis:n}},
/**
               * @implements
               */
t.prototype.containPoint=function(t){var e=this._coordsList[0];if(e)return e.containPoint(t)},
/**
               * Initialize cartesian coordinate systems
               */
t.prototype._initCartesian=function(t,e,n){var i=this,r=this,o={left:!1,right:!1,top:!1,bottom:!1},a={x:{},y:{}},s={x:0,y:0};if(// Create axis
e.eachComponent("xAxis",l("x"),this),e.eachComponent("yAxis",l("y"),this),!s.x||!s.y)// Roll back when there no either x or y axis
return this._axesMap={},void(this._axesList=[]);function l(e){return function(n,i){if(DI(n,t)){var l=n.get("position");"x"===e?// Fix position
"top"!==l&&"bottom"!==l&&(// Default bottom of X
l=o.bottom?"top":"bottom"):// Fix position
"left"!==l&&"right"!==l&&(// Default left of Y
l=o.left?"right":"left"),o[l]=!0;var u=new bI(e,O_(n),[0,0],n.get("type"),l),h="category"===u.type;u.onBand=h&&n.get("boundaryGap"),u.inverse=n.get("inverse"),// Inject axis into axisModel
n.axis=u,// Inject axisModel into axis
u.model=n,// Inject grid info axis
u.grid=r,// Index of axis, can be used as key
u.index=i,r._axesList.push(u),a[e][i]=u,s[e]++}}}this._axesMap=a,// Create cartesian2d
R(a.x,(function(e,n){R(a.y,(function(r,o){var a="x"+n+"y"+o,s=new xI(a);s.master=i,s.model=t,i._coordsMap[a]=s,i._coordsList.push(s),s.addAxis(e),s.addAxis(r)}))}))},
/**
               * Update cartesian properties from series.
               */
t.prototype._updateScale=function(t,e){function n(t,e){R(B_(t,e.dim),(function(n){e.scale.unionExtentFromData(t,n)}))}// Reset scale
R(this._axesList,(function(t){if(t.scale.setExtent(1/0,-1/0),"category"===t.type){var e=t.model.get("categorySortInfo");t.scale.setSortInfo(e)}})),t.eachSeries((function(t){if(SI(t)){var i=MI(t),r=i.xAxisModel,o=i.yAxisModel;if(!DI(r,e)||!DI(o,e))return;var a=this.getCartesian(r.componentIndex,o.componentIndex),s=t.getData(),l=a.getAxis("x"),u=a.getAxis("y");n(s,l),n(s,u)}}),this)},
/**
               * @param dim 'x' or 'y' or 'auto' or null/undefined
               */
t.prototype.getTooltipAxes=function(t){var e=[],n=[];return R(this.getCartesians(),(function(i){var r=null!=t&&"auto"!==t?i.getAxis(t):i.getBaseAxis(),o=i.getOtherAxis(r);L(e,r)<0&&e.push(r),L(n,o)<0&&n.push(o)})),{baseAxes:e,otherAxes:n}},t.create=function(e,n){var i=[];return e.eachComponent("grid",(function(r,o){var a=new t(r,e,n);a.name="grid_"+o,// dataSampling requires axis extent, so resize
// should be performed in create stage.
a.resize(r,n,!0),r.coordinateSystem=a,i.push(a)})),// Inject the coordinateSystems into seriesModel
e.eachSeries((function(t){if(SI(t)){var e=MI(t),n=e.xAxisModel,i=e.yAxisModel,r=n.getCoordSysModel().coordinateSystem;t.coordinateSystem=r.getCartesian(n.componentIndex,i.componentIndex)}})),i},// For deciding which dimensions to use when creating list data
t.dimensions=vI,t}();
/**
             * Check if the axis is used in the specified grid.
             */function DI(t,e){return t.getCoordSysModel()===e}function AI(t,e,n,// Key: see `getOnZeroRecordKey`
i){n.getAxesOnZeroOf=function(){// TODO: onZero of multiple axes.
return r?[r]:[]};// onZero can not be enabled in these two situations:
// 1. When any other axis is a category axis.
// 2. When no axis is cross 0 point.
var r,o=t[e],a=n.model,s=a.get(["axisLine","onZero"]),l=a.get(["axisLine","onZeroAxisIndex"]);if(s){// If target axis is specified.
if(null!=l)kI(o[l])&&(r=o[l]);else// Find the first available other axis.
for(var u in o)if(o.hasOwnProperty(u)&&kI(o[u])&&!i[h(o[u])]){r=o[u];break}r&&(i[h(r)]=!0)}function h(t){return t.dim+"_"+t.index}}function kI(t){return t&&"category"!==t.type&&"time"!==t.type&&function(t){var e=t.scale.getExtent(),n=e[0],i=e[1];return!(n>0&&i>0||n<0&&i<0)}(t)}const LI=CI;var PI=Math.PI,OI=/** @class */function(){function t(t,e){this.group=new Lr,this.opt=e,this.axisModel=t,// Default value
k(e,{labelOffset:0,nameDirection:1,tickDirection:1,labelDirection:1,silent:!0,handleAutoShown:function(){return!0}});// FIXME Not use a seperate text group?
var n=new Lr({x:e.position[0],y:e.position[1],rotation:e.rotation});// this.group.add(transformGroup);
// this._transformGroup = transformGroup;
n.updateTransform(),this._transformGroup=n}return t.prototype.hasBuilder=function(t){return!!RI[t]},t.prototype.add=function(t){RI[t](this.opt,this.axisModel,this.group,this._transformGroup)},t.prototype.getGroup=function(){return this.group},t.innerTextLayout=function(t,e,n){var i,r,o=Xr(e-t);return Ur(o)?(// Label is parallel with axis line.
r=n>0?"top":"bottom",i="center"):Ur(o-PI)?(// Label is inverse parallel with axis line.
r=n>0?"bottom":"top",i="center"):(r="middle",i=o>0&&o<PI?n>0?"right":"left":n>0?"left":"right"),{rotation:o,textAlign:i,textVerticalAlign:r}},t.makeAxisEventDataBase=function(t){var e={componentType:t.mainType,componentIndex:t.componentIndex};return e[t.mainType+"Index"]=t.componentIndex,e},t.isLabelSilent=function(t){var e=t.get("tooltip");return t.get("silent")||!(t.get("triggerEvent")||e&&e.show)},t}(),RI={axisLine:function(t,e,n,i){var r=e.get(["axisLine","show"]);if("auto"===r&&t.handleAutoShown&&(r=t.handleAutoShown("axisLine")),r){var o=e.axis.getExtent(),a=i.transform,s=[o[0],0],l=[o[1],0],u=s[0]>l[0];a&&(Pt(s,s,a),Pt(l,l,a));var h=A({lineCap:"round"},e.getModel(["axisLine","lineStyle"]).getLineStyle()),c=new qu({shape:{x1:s[0],y1:s[1],x2:l[0],y2:l[1]},style:h,strokeContainThreshold:t.strokeContainThreshold||5,silent:!0,z2:1});Gh(c.shape,c.style.lineWidth),c.anid="line",n.add(c);var p=e.get(["axisLine","symbol"]);if(null!=p){var d=e.get(["axisLine","symbolSize"]);H(p)&&(// Use the same arrow for start and end point
p=[p,p]),(H(d)||X(d))&&(// Use the same size for width and height
d=[d,d]);var f=sv(e.get(["axisLine","symbolOffset"])||0,d),g=d[0],y=d[1];R([{rotate:t.rotation+Math.PI/2,offset:f[0],r:0},{rotate:t.rotation-Math.PI/2,offset:f[1],r:Math.sqrt((s[0]-l[0])*(s[0]-l[0])+(s[1]-l[1])*(s[1]-l[1]))}],(function(e,i){if("none"!==p[i]&&null!=p[i]){var r=ov(p[i],-g/2,-y/2,g,y,h.stroke,!0),o=e.r+e.offset,a=u?l:s;// Calculate arrow position with offset
r.attr({rotation:e.rotate,x:a[0]+o*Math.cos(t.rotation),y:a[1]-o*Math.sin(t.rotation),silent:!0,z2:11}),n.add(r)}}))}}},axisTickLabel:function(t,e,n,i){var r=function(t,e,n,i){var r=n.axis,o=n.getModel("axisTick"),a=o.get("show");if("auto"===a&&i.handleAutoShown&&(a=i.handleAutoShown("axisTick")),a&&!r.scale.isBlank()){for(var s=o.getModel("lineStyle"),l=i.tickDirection*o.get("length"),u=VI(r.getTicksCoords(),e.transform,l,k(s.getLineStyle(),{stroke:n.get(["axisLine","lineStyle","color"])}),"ticks"),h=0;h<u.length;h++)t.add(u[h]);return u}}(n,i,e,t),o=function(t,e,n,i){var r=n.axis,o=J(i.axisLabelShow,n.get(["axisLabel","show"]));if(o&&!r.scale.isBlank()){var a=n.getModel("axisLabel"),s=a.get("margin"),l=r.getViewLabels(),u=(J(i.labelRotate,a.get("rotate"))||0)*PI/180,h=OI.innerTextLayout(i.rotation,u,i.labelDirection),c=n.getCategories&&n.getCategories(!0),p=[],d=OI.isLabelSilent(n),f=n.get("triggerEvent");return R(l,(function(o,l){var u="ordinal"===r.scale.type?r.scale.getRawOrdinalNumber(o.tickValue):o.tickValue,g=o.formattedLabel,y=o.rawLabel,v=a;if(c&&c[u]){var m=c[u];U(m)&&m.textStyle&&(v=new Pc(m.textStyle,a,n.ecModel))}var x=v.getTextColor()||n.get(["axisLine","lineStyle","color"]),_=r.dataToCoord(u),b=new Zs({x:_,y:i.labelOffset+i.labelDirection*s,rotation:h.rotation,silent:d,z2:10+(o.level||0),style:lc(v,{text:g,align:v.getShallow("align",!0)||h.textAlign,verticalAlign:v.getShallow("verticalAlign",!0)||v.getShallow("baseline",!0)||h.textVerticalAlign,fill:W(x)?x(// (1) In category axis with data zoom, tick is not the original
// index of axis.data. So tick should not be exposed to user
// in category axis.
// (2) Compatible with previous version, which always use formatted label as
// input. But in interval scale the formatted label is like '223,445', which
// maked user repalce ','. So we modify it to return original val but remain
// it as 'string' to avoid error in replacing.
"category"===r.type?y:"value"===r.type?u+"":u,l):x})});// Pack data for mouse event
if(b.anid="label_"+u,f){var w=OI.makeAxisEventDataBase(n);w.targetType="axisLabel",w.value=y,w.tickIndex=l,"category"===r.type&&(w.dataIndex=u),js(b).eventData=w}// FIXME
e.add(b),b.updateTransform(),p.push(b),t.add(b),b.decomposeTransform()})),p}}(n,i,e,t);(function(t,e,n){if(!V_(t.axis)){// If min or max are user set, we need to check
// If the tick on min(max) are overlap on their neighbour tick
// If they are overlapped, we need to hide the min(max) tick label
var i=t.get(["axisLabel","showMinLabel"]),r=t.get(["axisLabel","showMaxLabel"]);n=n||[];var o=(// FIXME
// Have not consider onBand yet, where tick els is more than label els.
e=e||[])[0],a=e[1],s=e[e.length-1],l=e[e.length-2],u=n[0],h=n[1],c=n[n.length-1],p=n[n.length-2];!1===i?(NI(o),NI(u)):EI(o,a)&&(i?(NI(a),NI(h)):(NI(o),NI(u))),!1===r?(NI(s),NI(c)):EI(l,s)&&(r?(NI(l),NI(p)):(NI(s),NI(c)))}})(e,o,r),function(t,e,n,i){var r=n.axis,o=n.getModel("minorTick");if(o.get("show")&&!r.scale.isBlank()){var a=r.getMinorTicksCoords();if(a.length)for(var s=o.getModel("lineStyle"),l=i*o.get("length"),u=k(s.getLineStyle(),k(n.getModel("axisTick").getLineStyle(),{stroke:n.get(["axisLine","lineStyle","color"])})),h=0;h<a.length;h++)for(var c=VI(a[h],e.transform,l,u,"minorticks_"+h),p=0;p<c.length;p++)t.add(c[p])}}(n,i,e,t.tickDirection),// This bit fixes the label overlap issue for the time chart.
// See https://github.com/apache/echarts/issues/14266 for more.
e.get(["axisLabel","hideOverlap"])&&Fb(zb(N(o,(function(t){return{label:t,priority:t.z2,defaultAttr:{ignore:t.ignore}}}))))},axisName:function(t,e,n,i){var r=J(t.axisName,e.get("name"));if(r){var o,a,s=e.get("nameLocation"),l=t.nameDirection,u=e.getModel("nameTextStyle"),h=e.get("nameGap")||0,c=e.axis.getExtent(),p=c[0]>c[1]?-1:1,d=["start"===s?c[0]-p*h:"end"===s?c[1]+p*h:(c[0]+c[1])/2,// Reuse labelOffset.
zI(s)?t.labelOffset+l*h:0],f=e.get("nameRotate");null!=f&&(f=f*PI/180),zI(s)?o=OI.innerTextLayout(t.rotation,null!=f?f:t.rotation,// Adapt to axis.
l):(o=function(t,e,n,i){var r,o,a=Xr(n-t),s=i[0]>i[1],l="start"===e&&!s||"start"!==e&&s;return Ur(a-PI/2)?(o=l?"bottom":"top",r="center"):Ur(a-1.5*PI)?(o=l?"top":"bottom",r="center"):(o="middle",r=a<1.5*PI&&a>PI/2?l?"left":"right":l?"right":"left"),{rotation:a,textAlign:r,textVerticalAlign:o}}(t.rotation,s,f||0,c),null!=(a=t.axisNameAvailableWidth)&&(a=Math.abs(a/Math.sin(o.rotation)),!isFinite(a)&&(a=null)));var g=u.getFont(),y=e.get("nameTruncate",!0)||{},v=y.ellipsis,m=J(t.nameTruncateMaxWidth,y.maxWidth,a),x=new Zs({x:d[0],y:d[1],rotation:o.rotation,silent:OI.isLabelSilent(e),style:lc(u,{text:r,font:g,overflow:"truncate",width:m,ellipsis:v,fill:u.getTextColor()||e.get(["axisLine","lineStyle","color"]),align:u.get("align")||o.textAlign,verticalAlign:u.get("verticalAlign")||o.textVerticalAlign}),z2:1});if(Qh({el:x,componentModel:e,itemName:r}),x.__fullText=r,// Id for animation
x.anid="name",e.get("triggerEvent")){var _=OI.makeAxisEventDataBase(e);_.targetType="axisName",_.name=r,js(x).eventData=_}// FIXME
i.add(x),x.updateTransform(),n.add(x),x.decomposeTransform()}}};
/**
             * A final axis is translated and rotated from a "standard axis".
             * So opt.position and opt.rotation is required.
             *
             * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
             * for example: (0, 0) ------------> (0, 50)
             *
             * nameDirection or tickDirection or labelDirection is 1 means tick
             * or label is below the standard axis, whereas is -1 means above
             * the standard axis. labelOffset means offset between label and axis,
             * which is useful when 'onZero', where axisLabel is in the grid and
             * label in outside grid.
             *
             * Tips: like always,
             * positive rotation represents anticlockwise, and negative rotation
             * represents clockwise.
             * The direction of position coordinate is the same as the direction
             * of screen coordinate.
             *
             * Do not need to consider axis 'inverse', which is auto processed by
             * axis extent.
             */function NI(t){t&&(t.ignore=!0)}function EI(t,e){// current and next has the same rotation.
var n=t&&t.getBoundingRect().clone(),i=e&&e.getBoundingRect().clone();if(n&&i){// When checking intersect of two rotated labels, we use mRotationBack
// to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.
var r=ue([]);return de(r,r,-t.rotation),n.applyTransform(ce([],r,t.getLocalTransform())),i.applyTransform(ce([],r,e.getLocalTransform())),n.intersect(i)}}function zI(t){return"middle"===t||"center"===t}function VI(t,e,n,i,r){for(var o=[],a=[],s=[],l=0;l<t.length;l++){var u=t[l].coord;a[0]=u,a[1]=0,s[0]=u,s[1]=n,e&&(Pt(a,a,e),Pt(s,s,e));// Tick line, Not use group transform to have better line draw
var h=new qu({shape:{x1:a[0],y1:a[1],x2:s[0],y2:s[1]},style:i,z2:2,autoBatch:!0,silent:!0});Gh(h.shape,h.style.lineWidth),h.anid=r+"_"+t[l].tickValue,o.push(h)}return o}const BI=OI;// allAxesInfo should be updated when setOption performed.
function FI(t,e){var n={
/**
                 * key: makeKey(axis.model)
                 * value: {
                 *      axis,
                 *      coordSys,
                 *      axisPointerModel,
                 *      triggerTooltip,
                 *      involveSeries,
                 *      snap,
                 *      seriesModels,
                 *      seriesDataCount
                 * }
                 */
axesInfo:{},seriesInvolved:!1,
/**
                 * key: makeKey(coordSys.model)
                 * value: Object: key makeKey(axis.model), value: axisInfo
                 */
coordSysAxesInfo:{},coordSysMap:{}};return function(t,e,n){var i=e.getComponent("tooltip"),r=e.getComponent("axisPointer"),o=r.get("link",!0)||[],a=[];// Collect axes info.
R(n.getCoordinateSystems(),(function(n){// Some coordinate system do not support axes, like geo.
if(n.axisPointerEnabled){var s=XI(n.model),l=t.coordSysAxesInfo[s]={};t.coordSysMap[s]=n;// Set tooltip (like 'cross') is a convienent way to show axisPointer
// for user. So we enable seting tooltip on coordSys model.
var u=n.model.getModel("tooltip",i);// If axis tooltip used, choose tooltip axis for each coordSys.
// Notice this case: coordSys is `grid` but not `cartesian2D` here.
if(R(n.getAxes(),F(d,!1,null)),n.getTooltipAxes&&i&&u.get("show")){// Compatible with previous logic. But series.tooltip.trigger: 'axis'
// or series.data[n].tooltip.trigger: 'axis' are not support any more.
var h="axis"===u.get("trigger"),c="cross"===u.get(["axisPointer","type"]),p=n.getTooltipAxes(u.get(["axisPointer","axis"]));(h||c)&&R(p.baseAxes,F(d,!c||"cross",h)),c&&R(p.otherAxes,F(d,"cross",!1))}// fromTooltip: true | false | 'cross'
// triggerTooltip: true | false | null
}function d(i,s,h){var c=h.model.getModel("axisPointer",r),p=c.get("show");if(p&&("auto"!==p||i||YI(c))){null==s&&(s=c.get("triggerTooltip")),c=i?function(t,e,n,i,r,o){var a=e.getModel("axisPointer"),s={};R(["type","snap","lineStyle","shadowStyle","label","animation","animationDurationUpdate","animationEasingUpdate","z"],(function(t){s[t]=T(a.get(t))})),// category axis do not auto snap, otherwise some tick that do not
// has value can not be hovered. value/time/log axis default snap if
// triggered from tooltip and trigger tooltip.
s.snap="category"!==t.type&&!!o,// Compatibel with previous behavior, tooltip axis do not show label by default.
// Only these properties can be overrided from tooltip to axisPointer.
"cross"===a.get("type")&&(s.type="line");var l=s.label||(s.label={});// Follow the convention, do not show label when triggered by tooltip by default.
if(null==l.show&&(l.show=!1),"cross"===r){// When 'cross', both axes show labels.
var u=a.get(["label","show"]);// If triggerTooltip, this is a base axis, which should better not use cross style
// (cross style is dashed by default)
if(l.show=null==u||u,!o){var h=s.lineStyle=a.get("crossStyle");h&&k(l,h.textStyle)}}return t.model.getModel("axisPointer",new Pc(s,n,i))}(h,u,r,e,i,s):c;var d=c.get("snap"),f=XI(h.model),g=s||d||"category"===h.type,y=t.axesInfo[f]={key:f,axis:h,coordSys:n,axisPointerModel:c,triggerTooltip:s,involveSeries:g,snap:d,useHandle:YI(c),seriesModels:[],linkGroup:null};l[f]=y,t.seriesInvolved=t.seriesInvolved||g;var v=
/**
             * For example:
             * {
             *     axisPointer: {
             *         links: [{
             *             xAxisIndex: [2, 4],
             *             yAxisIndex: 'all'
             *         }, {
             *             xAxisId: ['a5', 'a7'],
             *             xAxisName: 'xxx'
             *         }]
             *     }
             * }
             */
function(t,e){for(var n=e.model,i=e.dim,r=0;r<t.length;r++){var o=t[r]||{};if(GI(o[i+"AxisId"],n.id)||GI(o[i+"AxisIndex"],n.componentIndex)||GI(o[i+"AxisName"],n.name))return r}}(o,h);if(null!=v){var m=a[v]||(a[v]={axesInfo:{}});m.axesInfo[f]=y,m.mapper=o[v].mapper,y.linkGroup=m}}}}))}(n,t,e),// Check seriesInvolved for performance, in case too many series in some chart.
n.seriesInvolved&&function(t,e){// Prepare data for axis trigger
e.eachSeries((function(e){// Notice this case: this coordSys is `cartesian2D` but not `grid`.
var n=e.coordinateSystem,i=e.get(["tooltip","trigger"],!0),r=e.get(["tooltip","show"],!0);n&&"none"!==i&&!1!==i&&"item"!==i&&!1!==r&&!1!==e.get(["axisPointer","show"],!0)&&R(t.coordSysAxesInfo[XI(n.model)],(function(t){var i=t.axis;n.getAxis(i.dim)===i&&(t.seriesModels.push(e),null==t.seriesDataCount&&(t.seriesDataCount=0),t.seriesDataCount+=e.getData().count())}))}))}(n,t),n}function GI(t,e){return"all"===t||G(t)&&L(t,e)>=0||t===e}function WI(t){var e=HI(t);if(e){var n=e.axisPointerModel,i=e.axis.scale,r=n.option,o=n.get("status"),a=n.get("value");// Parse init value for category and time axis.
null!=a&&(a=i.parse(a));var s=YI(n);// If `handle` used, `axisPointer` will always be displayed, so value
// and status should be initialized.
null==o&&(r.status=s?"show":"hide");var l=i.getExtent().slice();l[0]>l[1]&&l.reverse(),(// Pick a value on axis when initializing.
null==a||a>l[1])&&(// Make handle displayed on the end of the axis when init, which looks better.
a=l[1]),a<l[0]&&(a=l[0]),r.value=a,s&&(r.status=e.axis.scale.isBlank()?"hide":"show")}}function HI(t){var e=(t.ecModel.getComponent("axisPointer")||{}).coordSysAxesInfo;return e&&e.axesInfo[XI(t)]}function YI(t){return!!t.get(["handle","show"])}
/**
             * @param {module:echarts/model/Model} model
             * @return {string} unique key
             */function XI(t){return t.type+"||"+t.id}var UI={},ZI=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * @override
               */return n(e,t),e.prototype.render=function(e,n,i,r){// FIXME
// This process should proformed after coordinate systems updated
// (axis scale updated), and should be performed each time update.
// So put it here temporarily, although it is not appropriate to
// put a model-writing procedure in `view`.
this.axisPointerClass&&WI(e),t.prototype.render.apply(this,arguments),this._doUpdateAxisPointerClass(e,i,!0)},
/**
               * Action handler.
               */
e.prototype.updateAxisPointer=function(t,e,n,i){this._doUpdateAxisPointerClass(t,n,!1)},
/**
               * @override
               */
e.prototype.remove=function(t,e){var n=this._axisPointer;n&&n.remove(e)},
/**
               * @override
               */
e.prototype.dispose=function(e,n){this._disposeAxisPointer(n),t.prototype.dispose.apply(this,arguments)},e.prototype._doUpdateAxisPointerClass=function(t,n,i){var r=e.getAxisPointerClass(this.axisPointerClass);if(r){var o=function(t){var e=HI(t);return e&&e.axisPointerModel}(t);o?(this._axisPointer||(this._axisPointer=new r)).render(t,o,n,i):this._disposeAxisPointer(n)}},e.prototype._disposeAxisPointer=function(t){this._axisPointer&&this._axisPointer.dispose(t),this._axisPointer=null},e.registerAxisPointerClass=function(t,e){UI[t]=e},e.getAxisPointerClass=function(t){return t&&UI[t]},e.type="axis",e}(Bg);
/**
             * Base class of AxisView.
             */const jI=ZI;var qI=bo();function KI(t,e,n,i){var r=n.axis;if(!r.scale.isBlank()){// TODO: TYPE
var o=n.getModel("splitArea"),a=o.getModel("areaStyle"),s=a.get("color"),l=i.coordinateSystem.getRect(),u=r.getTicksCoords({tickModel:o,clamp:!0});if(u.length){// For Making appropriate splitArea animation, the color and anid
// should be corresponding to previous one if possible.
var h=s.length,c=qI(t).splitAreaColors,p=ct(),d=0;if(c)for(var f=0;f<u.length;f++){var g=c.get(u[f].tickValue);if(null!=g){d=(g+(h-1)*f)%h;break}}var y=r.toGlobalCoord(u[0].coord),v=a.getAreaStyle();for(s=G(s)?s:[s],f=1;f<u.length;f++){var m=r.toGlobalCoord(u[f].coord),x=void 0,_=void 0,b=void 0,w=void 0;r.isHorizontal()?(x=y,_=l.y,b=m-x,w=l.height,y=x+b):(x=l.x,_=y,b=l.width,y=_+(w=m-_));var S=u[f-1].tickValue;null!=S&&p.set(S,d),e.add(new Ls({anid:null!=S?"area_"+S:null,shape:{x:x,y:_,width:b,height:w},style:k({fill:s[d]},v),autoBatch:!0,silent:!0})),d=(d+1)%h}qI(t).splitAreaColors=p}}}function $I(t){qI(t).splitAreaColors=null}var JI=["axisLine","axisTickLabel","axisName"],QI=["splitArea","splitLine","minorSplitLine"],tT=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.axisPointerClass="CartesianAxisPointer",n}
/**
               * @override
               */return n(e,t),e.prototype.render=function(e,n,i,r){this.group.removeAll();var o=this._axisGroup;if(this._axisGroup=new Lr,this.group.add(this._axisGroup),e.get("show")){var a=e.getCoordSysModel(),s=wI(a,e),l=new BI(e,A({handleAutoShown:function(t){for(var n=a.coordinateSystem.getCartesians(),i=0;i<n.length;i++)if(Rx(n[i].getOtherAxis(e.axis).scale))// Still show axis tick or axisLine if other axis is value / log
return!0;// Not show axisTick or axisLine if other axis is category / time
return!1}},s));R(JI,l.add,l),this._axisGroup.add(l.getGroup()),R(QI,(function(t){e.get([t,"show"])&&eT[t](this,this._axisGroup,e,a)}),this),r&&"changeAxisOrder"===r.type&&r.isInitSort||Zh(o,this._axisGroup,e),t.prototype.render.call(this,e,n,i,r)}},e.prototype.remove=function(){$I(this)},e.type="cartesianAxis",e}(jI),eT={splitLine:function(t,e,n,i){var r=n.axis;if(!r.scale.isBlank()){var o=n.getModel("splitLine"),a=o.getModel("lineStyle"),s=a.get("color");s=G(s)?s:[s];for(var l=i.coordinateSystem.getRect(),u=r.isHorizontal(),h=0,c=r.getTicksCoords({tickModel:o}),p=[],d=[],f=a.getLineStyle(),g=0;g<c.length;g++){var y=r.toGlobalCoord(c[g].coord);u?(p[0]=y,p[1]=l.y,d[0]=y,d[1]=l.y+l.height):(p[0]=l.x,p[1]=y,d[0]=l.x+l.width,d[1]=y);var v=h++%s.length,m=c[g].tickValue,x=new qu({anid:null!=m?"line_"+c[g].tickValue:null,autoBatch:!0,shape:{x1:p[0],y1:p[1],x2:d[0],y2:d[1]},style:k({stroke:s[v]},f),silent:!0});Gh(x.shape,f.lineWidth),e.add(x)}}},minorSplitLine:function(t,e,n,i){var r=n.axis,o=n.getModel("minorSplitLine").getModel("lineStyle"),a=i.coordinateSystem.getRect(),s=r.isHorizontal(),l=r.getMinorTicksCoords();if(l.length)for(var u=[],h=[],c=o.getLineStyle(),p=0;p<l.length;p++)for(var d=0;d<l[p].length;d++){var f=r.toGlobalCoord(l[p][d].coord);s?(u[0]=f,u[1]=a.y,h[0]=f,h[1]=a.y+a.height):(u[0]=a.x,u[1]=f,h[0]=a.x+a.width,h[1]=f);var g=new qu({anid:"minor_line_"+l[p][d].tickValue,autoBatch:!0,shape:{x1:u[0],y1:u[1],x2:h[0],y2:h[1]},style:c,silent:!0});Gh(g.shape,c.lineWidth),e.add(g)}},splitArea:function(t,e,n,i){KI(t,e,n,i)}},nT=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="xAxis",e}(tT),iT=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type=nT.type,e}return n(e,t),e.type="yAxis",e}(tT),rT=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="grid",e}return n(e,t),e.prototype.render=function(t,e){this.group.removeAll(),t.get("show")&&this.group.add(new Ls({shape:t.coordinateSystem.getRect(),style:k({fill:t.get("backgroundColor")},t.getItemStyle()),silent:!0,z2:-1}))},e.type="grid",e}(Bg),oT={// gridIndex: 0,
// gridId: '',
offset:0};function aT(t){t.registerComponentView(rT),t.registerComponentModel(sI),t.registerCoordinateSystem("cartesian2d",LI),fI(t,"x",lI,oT),fI(t,"y",lI,oT),t.registerComponentView(nT),t.registerComponentView(iT),t.registerPreprocessor((function(t){// Only create grid when need
t.xAxis&&t.yAxis&&!t.grid&&(t.grid={})}))}function sT(t){t.eachSeriesByType("radar",(function(t){var e=t.getData(),n=[],i=t.coordinateSystem;if(i){var r=i.getIndicatorAxes();R(r,(function(t,o){e.each(e.mapDimension(r[o].dim),(function(t,e){n[e]=n[e]||[];var r=i.dataToPoint(t,o);n[e][o]=lT(r)?r:uT(i)}))})),// Close polygon
e.each((function(t){// TODO
// Is it appropriate to connect to the next data when some data is missing?
// Or, should trade it like `connectNull` in line chart?
var r=function(t,e,n){if(t&&e)for(var i=0,r=t.length;i<r;i++)if(e.call(n,t[i],i,t))return t[i]}(n[t],(function(t){return lT(t)}))||uT(i);// Copy the first actual point to the end of the array
n[t].push(r.slice()),e.setItemLayout(t,n[t])}))}}))}function lT(t){return!isNaN(t[0])&&!isNaN(t[1])}function uT(t){// It is error-prone to input [NaN, NaN] into polygon, polygon.
// (probably cause problem when refreshing or animating)
return[t.cx,t.cy]}function hT(t){var e=t.polar;if(e){G(e)||(e=[e]);var n=[];R(e,(function(e,i){e.indicator?(e.type&&!e.shape&&(e.shape=e.type),t.radar=t.radar||[],G(t.radar)||(t.radar=[t.radar]),t.radar.push(e)):n.push(e)})),t.polar=n}R(t.series,(function(t){t&&"radar"===t.type&&t.polarIndex&&(t.radarIndex=t.polarIndex)}))}var cT=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.coordinateSystem,r=this.group,o=t.getData(),a=this._data;function s(t,e){var n=t.getItemVisual(e,"symbol")||"circle";if("none"!==n){var i=av(t.getItemVisual(e,"symbolSize")),r=ov(n,-1,-1,2,2),o=t.getItemVisual(e,"symbolRotate")||0;return r.attr({style:{strokeNoScale:!0},z2:100,scaleX:i[0]/2,scaleY:i[1]/2,rotation:o*Math.PI/180||0}),r}}function l(e,n,i,r,o,a){// Simply rerender all
i.removeAll();for(var l=0;l<n.length-1;l++){var u=s(r,o);u&&(u.__dimIdx=l,e[l]?(u.setPosition(e[l]),nc[a?"initProps":"updateProps"](u,{x:n[l][0],y:n[l][1]},t,o)):u.setPosition(n[l]),i.add(u))}}function u(t){return N(t,(function(t){return[i.cx,i.cy]}))}o.diff(a).add((function(e){var n=o.getItemLayout(e);if(n){var i=new Wu,r=new Xu,a={shape:{points:n}};i.shape.points=u(n),r.shape.points=u(n),Mh(i,a,t,e),Mh(r,a,t,e);var s=new Lr,h=new Lr;s.add(r),s.add(i),s.add(h),l(r.shape.points,n,h,o,e,!0),o.setItemGraphicEl(e,s)}})).update((function(e,n){var i=a.getItemGraphicEl(n),r=i.childAt(0),s=i.childAt(1),u=i.childAt(2),h={shape:{points:o.getItemLayout(e)}};h.shape.points&&(l(r.shape.points,h.shape.points,u,o,e,!1),Ah(s),Ah(r),Sh(r,h,t),Sh(s,h,t),o.setItemGraphicEl(e,i))})).remove((function(t){r.remove(a.getItemGraphicEl(t))})).execute(),o.eachItemGraphicEl((function(t,e){var n=o.getItemModel(e),i=t.childAt(0),a=t.childAt(1),s=t.childAt(2),l=o.getItemVisual(e,"style"),u=l.fill;r.add(t),i.useStyle(k(n.getModel("lineStyle").getLineStyle(),{fill:"none",stroke:u})),Hl(i,n,"lineStyle"),Hl(a,n,"areaStyle");var h=n.getModel("areaStyle"),c=h.isEmpty()&&h.parentModel.isEmpty();a.ignore=c,R(["emphasis","select","blur"],(function(t){var e=n.getModel([t,"areaStyle"]),i=e.isEmpty()&&e.parentModel.isEmpty();// Won't be ignore if normal state is not ignore.
a.ensureState(t).ignore=i&&c})),a.useStyle(k(h.getAreaStyle(),{fill:u,opacity:.7,decal:l.decal}));var p=n.getModel("emphasis"),d=p.getModel("itemStyle").getItemStyle();s.eachChild((function(t){if(t instanceof Ss){var i=t.style;t.useStyle(A({// TODO other properties like x, y ?
image:i.image,x:i.x,y:i.y,width:i.width,height:i.height},l))}else t.useStyle(l),t.setColor(u),t.style.strokeNoScale=!0;t.ensureState("emphasis").style=T(d);var r=o.getStore().get(o.getDimensionIndex(t.__dimIdx),e);(null==r||isNaN(r))&&(r=""),ac(t,sc(n),{labelFetcher:o.hostModel,labelDataIndex:e,labelDimIndex:t.__dimIdx,defaultText:r,inheritColor:u,defaultOpacity:l.opacity})})),Bl(t,p.get("focus"),p.get("blurScope"),p.get("disabled"))})),this._data=o},e.prototype.remove=function(){this.group.removeAll(),this._data=null},e.type="radar",e}(qg);const pT=cT;var dT=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n}// Overwrite
return n(e,t),e.prototype.init=function(e){t.prototype.init.apply(this,arguments),// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendVisualProvider=new jM(B(this.getData,this),B(this.getRawData,this))},e.prototype.getInitialData=function(t,e){return UM(this,{generateCoord:"indicator_",generateCoordCount:1/0})},e.prototype.formatTooltip=function(t,e,n){var i=this.getData(),r=this.coordinateSystem.getIndicatorAxes(),o=this.getData().getName(t),a=""===o?this.name:o,s=wg(this,t);return dg("section",{header:a,sortBlocks:!0,blocks:N(r,(function(e){var n=i.get(i.mapDimension(e.dim),t);return dg("nameValue",{markerType:"subItem",markerColor:s,name:e.name,value:n,sortParam:n})}))})},e.prototype.getTooltipPosition=function(t){if(null!=t)for(var e=this.getData(),n=this.coordinateSystem,i=e.getValues(N(n.dimensions,(function(t){return e.mapDimension(t)})),t),r=0,o=i.length;r<o;r++)if(!isNaN(i[r])){var a=n.getIndicatorAxes();return n.coordToPoint(a[r].dataToCoord(i[r]),r)}},e.type="series.radar",e.dependencies=["radar"],e.defaultOption={// zlevel: 0,
z:2,colorBy:"data",coordinateSystem:"radar",legendHoverLink:!0,radarIndex:0,lineStyle:{width:2,type:"solid",join:"round"},label:{position:"top"},// areaStyle: {
// },
// itemStyle: {}
symbolSize:8},e}(zg);const fT=dT;var gT=pI.value;function yT(t,e){return k({show:e},t)}var vT=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.optionUpdated=function(){var t=this.get("boundaryGap"),e=this.get("splitNumber"),n=this.get("scale"),i=this.get("axisLine"),r=this.get("axisTick"),o=this.get("axisLabel"),a=this.get("axisName"),s=this.get(["axisName","show"]),l=this.get(["axisName","formatter"]),u=this.get("axisNameGap"),h=this.get("triggerEvent"),c=N(this.get("indicator")||[],(function(c){// PENDING
null!=c.max&&c.max>0&&!c.min?c.min=0:null!=c.min&&c.min<0&&!c.max&&(c.max=0);var p=a;null!=c.color&&(p=k({color:c.color},a));// Use same configuration
var d=C(T(c),{boundaryGap:t,splitNumber:e,scale:n,axisLine:i,axisTick:r,// axisType: axisType,
axisLabel:o,// Compatible with 2 and use text
name:c.text,showName:s,nameLocation:"end",nameGap:u,// min: 0,
nameTextStyle:p,triggerEvent:h},!1);if(H(l)){var f=d.name;d.name=l.replace("{value}",null!=f?f:"")}else W(l)&&(d.name=l(d.name,d));var g=new Pc(d,null,this.ecModel);return P(g,F_.prototype),// For triggerEvent.
g.mainType="radar",g.componentIndex=this.componentIndex,g}),this);this._indicatorModels=c},e.prototype.getIndicatorModels=function(){return this._indicatorModels},e.type="radar",e.defaultOption={// zlevel: 0,
z:0,center:["50%","50%"],radius:"75%",startAngle:90,axisName:{show:!0},boundaryGap:[0,0],splitNumber:5,axisNameGap:15,scale:!1,// Polygon or circle
shape:"polygon",axisLine:C({lineStyle:{color:"#bbb"}},gT.axisLine),axisLabel:yT(gT.axisLabel,!1),axisTick:yT(gT.axisTick,!1),// axisType: 'value',
splitLine:yT(gT.splitLine,!0),splitArea:yT(gT.splitArea,!0),// {text, min, max}
indicator:[]},e}(Wp);const mT=vT;var xT=["axisLine","axisTickLabel","axisName"],_T=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){this.group.removeAll(),this._buildAxes(t),this._buildSplitLineAndArea(t)},e.prototype._buildAxes=function(t){var e=t.coordinateSystem;R(N(e.getIndicatorAxes(),(function(t){var n=t.model.get("showName")?t.name:"";// hide name
return new BI(t.model,{axisName:n,position:[e.cx,e.cy],rotation:t.angle,labelDirection:-1,tickDirection:-1,nameDirection:1})})),(function(t){R(xT,t.add,t),this.group.add(t.getGroup())}),this)},e.prototype._buildSplitLineAndArea=function(t){var e=t.coordinateSystem,n=e.getIndicatorAxes();if(n.length){var i=t.get("shape"),r=t.getModel("splitLine"),o=t.getModel("splitArea"),a=r.getModel("lineStyle"),s=o.getModel("areaStyle"),l=r.get("show"),u=o.get("show"),h=a.get("color"),c=s.get("color"),p=G(h)?h:[h],d=G(c)?c:[c],f=[],g=[];if("circle"===i)for(var y=n[0].getTicksCoords(),v=e.cx,m=e.cy,x=0;x<y.length;x++)l&&f[C(f,p,x)].push(new yu({shape:{cx:v,cy:m,r:y[x].coord}})),u&&x<y.length-1&&g[C(g,d,x)].push(new Vu({shape:{cx:v,cy:m,r0:y[x].coord,r:y[x+1].coord}}));else{var _,b=N(n,(function(t,n){var i=t.getTicksCoords();return _=null==_?i.length-1:Math.min(i.length-1,_),N(i,(function(t){return e.coordToPoint(t.coord,n)}))})),w=[];for(x=0;x<=_;x++){for(var S=[],M=0;M<n.length;M++)S.push(b[M][x]);// Close
S[0]&&S.push(S[0].slice()),l&&f[C(f,p,x)].push(new Xu({shape:{points:S}})),u&&w&&g[C(g,d,x-1)].push(new Wu({shape:{points:S.concat(w)}})),w=S.slice().reverse()}}var I=a.getLineStyle(),T=s.getAreaStyle();// Add splitArea before splitLine
R(g,(function(t,e){this.group.add(Bh(t,{style:k({stroke:"none",fill:d[e%d.length]},T),silent:!0}))}),this),R(f,(function(t,e){this.group.add(Bh(t,{style:k({fill:"none",stroke:p[e%p.length]},I),silent:!0}))}),this)}function C(t,e,n){var i=n%e.length;return t[i]=t[i]||[],i}},e.type="radar",e}(Bg);const bT=_T;var wT=/** @class */function(t){function e(e,n,i){var r=t.call(this,e,n,i)||this;return r.type="value",r.angle=0,r.name="",r}return n(e,t),e}(pb);const ST=wT;var MT=/** @class */function(){function t(t,e,n){
/**
                 *
                 * Radar dimensions
                 */
this.dimensions=[],this._model=t,this._indicatorAxes=N(t.getIndicatorModels(),(function(t,e){var n="indicator_"+e,i=new ST(n,new Ux);return i.name=t.get("name"),// Inject model and axis
i.model=t,t.axis=i,this.dimensions.push(n),i}),this),this.resize(t,n)}return t.prototype.getIndicatorAxes=function(){return this._indicatorAxes},t.prototype.dataToPoint=function(t,e){var n=this._indicatorAxes[e];return this.coordToPoint(n.dataToCoord(t),e)},// TODO: API should be coordToPoint([coord, indicatorIndex])
t.prototype.coordToPoint=function(t,e){var n=this._indicatorAxes[e].angle;return[this.cx+t*Math.cos(n),this.cy-t*Math.sin(n)]},t.prototype.pointToData=function(t){var e=t[0]-this.cx,n=t[1]-this.cy,i=Math.sqrt(e*e+n*n);e/=i,n/=i;for(var r,o=Math.atan2(-n,e),a=1/0,s=-1,l=0// Find the closest angle
// FIXME index can calculated directly
;l<this._indicatorAxes.length;l++){var u=this._indicatorAxes[l],h=Math.abs(o-u.angle);h<a&&(r=u,s=l,a=h)}return[s,+(r&&r.coordToData(i))]},t.prototype.resize=function(t,e){var n=t.get("center"),i=e.getWidth(),r=e.getHeight(),o=Math.min(i,r)/2;this.cx=Vr(n[0],i),this.cy=Vr(n[1],r),this.startAngle=t.get("startAngle")*Math.PI/180;// radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`
var a=t.get("radius");(H(a)||X(a))&&(a=[0,a]),this.r0=Vr(a[0],o),this.r=Vr(a[1],o),R(this._indicatorAxes,(function(t,e){t.setExtent(this.r0,this.r);var n=this.startAngle+e*Math.PI*2/this._indicatorAxes.length;// Normalize to [-PI, PI]
n=Math.atan2(Math.sin(n),Math.cos(n)),t.angle=n}),this)},t.prototype.update=function(t,e){var n=this._indicatorAxes,i=this._model;R(n,(function(t){t.scale.setExtent(1/0,-1/0)})),t.eachSeriesByType("radar",(function(e,r){if("radar"===e.get("coordinateSystem")&&t.getComponent("radar",e.get("radarIndex"))===i){var o=e.getData();R(n,(function(t){t.scale.unionExtentFromData(o,o.mapDimension(t.dim))}))}}),this);var r=i.get("splitNumber"),o=new Ux;o.setExtent(0,r),o.setInterval(1),// Force all the axis fixing the maxSplitNumber.
R(n,(function(t,e){TI(t.scale,t.model,o)}))},t.prototype.convertToPixel=function(t,e,n){return null},t.prototype.convertFromPixel=function(t,e,n){return null},t.prototype.containPoint=function(t){return!1},t.create=function(e,n){var i=[];return e.eachComponent("radar",(function(r){var o=new t(r,e,n);i.push(o),r.coordinateSystem=o})),e.eachSeriesByType("radar",(function(t){"radar"===t.get("coordinateSystem")&&(// Inject coordinate system
// @ts-ignore
t.coordinateSystem=i[t.get("radarIndex")||0])})),i},
/**
               * Radar dimensions is based on the data
               */
t.dimensions=[],t}();const IT=MT;function TT(t){t.registerCoordinateSystem("radar",IT),t.registerComponentModel(mT),t.registerComponentView(bT),t.registerVisual({seriesType:"radar",reset:function(t){var e=t.getData();// itemVisual symbol is for selected data
e.each((function(t){e.setItemVisual(t,"legendIcon","roundRect")})),// visual is for unselected data
e.setVisual("legendIcon","roundRect")}})}var CT="\0_ec_interaction_mutex";function DT(t,e){return!!AT(t)[e]}function AT(t){return t[CT]||(t[CT]={})}
/**
             * payload: {
             *     type: 'takeGlobalCursor',
             *     key: 'dataZoomSelect', or 'brush', or ...,
             *         If no userKey, release global cursor.
             * }
             */
// TODO: SELF REGISTERED.
Om({type:"takeGlobalCursor",event:"globalCursorTaken",update:"update"},yt);var kT=/** @class */function(t){function e(e){var n=t.call(this)||this;n._zr=e;// Avoid two roamController bind the same handler
var i=B(n._mousedownHandler,n),r=B(n._mousemoveHandler,n),o=B(n._mouseupHandler,n),a=B(n._mousewheelHandler,n),s=B(n._pinchHandler,n);
/**
                 * Notice: only enable needed types. For example, if 'zoom'
                 * is not needed, 'zoom' should not be enabled, otherwise
                 * default mousewheel behaviour (scroll page) will be disabled.
                 */return n.enable=function(t,n){// Disable previous first
this.disable(),this._opt=k(T(n)||{},{zoomOnMouseWheel:!0,moveOnMouseMove:!0,// By default, wheel do not trigger move.
moveOnMouseWheel:!1,preventDefaultMouseMove:!0}),null==t&&(t=!0),!0!==t&&"move"!==t&&"pan"!==t||(e.on("mousedown",i),e.on("mousemove",r),e.on("mouseup",o)),!0!==t&&"scale"!==t&&"zoom"!==t||(e.on("mousewheel",a),e.on("pinch",s))},n.disable=function(){e.off("mousedown",i),e.off("mousemove",r),e.off("mouseup",o),e.off("mousewheel",a),e.off("pinch",s)},n}return n(e,t),e.prototype.isDragging=function(){return this._dragging},e.prototype.isPinching=function(){return this._pinching},e.prototype.setPointerChecker=function(t){this.pointerChecker=t},e.prototype.dispose=function(){this.disable()},e.prototype._mousedownHandler=function(t){if(!oe(t)){for(var e=t.target;e;){if(e.draggable)return;// check if host is draggable
e=e.__hostTarget||e.parent}var n=t.offsetX,i=t.offsetY;// Only check on mosedown, but not mousemove.
// Mouse can be out of target when mouse moving.
this.pointerChecker&&this.pointerChecker(t,n,i)&&(this._x=n,this._y=i,this._dragging=!0)}},e.prototype._mousemoveHandler=function(t){if(this._dragging&&OT("moveOnMouseMove",t,this._opt)&&"pinch"!==t.gestureEvent&&!DT(this._zr,"globalPan")){var e=t.offsetX,n=t.offsetY,i=this._x,r=this._y,o=e-i,a=n-r;this._x=e,this._y=n,this._opt.preventDefaultMouseMove&&re(t.event),PT(this,"pan","moveOnMouseMove",t,{dx:o,dy:a,oldX:i,oldY:r,newX:e,newY:n,isAvailableBehavior:null})}},e.prototype._mouseupHandler=function(t){oe(t)||(this._dragging=!1)},e.prototype._mousewheelHandler=function(t){var e=OT("zoomOnMouseWheel",t,this._opt),n=OT("moveOnMouseWheel",t,this._opt),i=t.wheelDelta,r=Math.abs(i),o=t.offsetX,a=t.offsetY;// wheelDelta maybe -0 in chrome mac.
if(0!==i&&(e||n)){// If both `shouldZoom` and `shouldMove` is true, trigger
// their event both, and the final behavior is determined
// by event listener themselves.
if(e){// Convenience:
// Mac and VM Windows on Mac: scroll up: zoom out.
// Windows: scroll up: zoom in.
// FIXME: Should do more test in different environment.
// wheelDelta is too complicated in difference nvironment
// (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
// although it has been normallized by zrender.
// wheelDelta of mouse wheel is bigger than touch pad.
var s=r>3?1.4:r>1?1.2:1.1;LT(this,"zoom","zoomOnMouseWheel",t,{scale:i>0?s:1/s,originX:o,originY:a,isAvailableBehavior:null})}if(n){// FIXME: Should do more test in different environment.
var l=Math.abs(i);// wheelDelta of mouse wheel is bigger than touch pad.
LT(this,"scrollMove","moveOnMouseWheel",t,{scrollDelta:(i>0?1:-1)*(l>3?.4:l>1?.15:.05),originX:o,originY:a,isAvailableBehavior:null})}}},e.prototype._pinchHandler=function(t){DT(this._zr,"globalPan")||LT(this,"zoom",null,t,{scale:t.pinchScale>1?1.1:1/1.1,originX:t.pinchX,originY:t.pinchY,isAvailableBehavior:null})},e}(Bt);function LT(t,e,n,i,r){t.pointerChecker&&t.pointerChecker(i,r.originX,r.originY)&&(// When mouse is out of roamController rect,
// default befavoius should not be be disabled, otherwise
// page sliding is disabled, contrary to expectation.
re(i.event),PT(t,e,n,i,r))}function PT(t,e,n,i,r){// Also provide behavior checker for event listener, for some case that
// multiple components share one listener.
r.isAvailableBehavior=B(OT,null,n,i),// TODO should not have type issue.
t.trigger(e,r)}// settings: {
//     zoomOnMouseWheel
//     moveOnMouseMove
//     moveOnMouseWheel
// }
// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.
function OT(t,e,n){var i=n[t];return!t||i&&(!H(i)||e.event[i+"Key"])}const RT=kT;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * For geo and graph.
             */function NT(t,e,n){var i=t.target;i.x+=e,i.y+=n,i.dirty()}
/**
             * For geo and graph.
             */function ET(t,e,n,i){var r=t.target,o=t.zoomLimit,a=t.zoom=t.zoom||1;if(a*=e,o){var s=o.min||0,l=o.max||1/0;a=Math.max(Math.min(l,a),s)}var u=a/t.zoom;t.zoom=a,// Keep the mouse center when scaling
r.x-=(n-r.x)*(u-1),r.y-=(i-r.y)*(u-1),r.scaleX*=u,r.scaleY*=u,r.dirty()}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var zT,VT={axisPointer:1,tooltip:1,brush:1};
/**
             * Avoid that: mouse click on a elements that is over geo or graph,
             * but roam is triggered.
             */function BT(t,e,n){var i=e.getComponentByElement(t.topTarget),r=i&&i.coordinateSystem;// If model is axisModel, it works only if it is injected with coordinateSystem.
return i&&i!==n&&!VT.hasOwnProperty(i.mainType)&&r&&r.model!==n}function FT(t){H(t)&&(t=(new DOMParser).parseFromString(t,"text/xml"));var e=t;for(9===e.nodeType&&(e=e.firstChild);"svg"!==e.nodeName.toLowerCase()||1!==e.nodeType;)e=e.nextSibling;return e}var GT={fill:"fill",stroke:"stroke","stroke-width":"lineWidth",opacity:"opacity","fill-opacity":"fillOpacity","stroke-opacity":"strokeOpacity","stroke-dasharray":"lineDash","stroke-dashoffset":"lineDashOffset","stroke-linecap":"lineCap","stroke-linejoin":"lineJoin","stroke-miterlimit":"miterLimit","font-family":"fontFamily","font-size":"fontSize","font-style":"fontStyle","font-weight":"fontWeight","text-anchor":"textAlign",visibility:"visibility",display:"display"},WT=V(GT),HT={"alignment-baseline":"textBaseline","stop-color":"stopColor"},YT=V(HT),XT=function(){function t(){this._defs={},this._root=null}return t.prototype.parse=function(t,e){e=e||{};var n=FT(t);this._defsUsePending=[];var i=new Lr;this._root=i;var r=[],o=n.getAttribute("viewBox")||"",a=parseFloat(n.getAttribute("width")||e.width),s=parseFloat(n.getAttribute("height")||e.height);isNaN(a)&&(a=null),isNaN(s)&&(s=null),$T(n,i,null,!0,!1);for(var l,u,h=n.firstChild;h;)this._parseNode(h,i,r,null,!1,!1),h=h.nextSibling;if(function(t,e){for(var n=0;n<e.length;n++){var i=e[n];i[0].style[i[1]]=t[i[2]]}}(this._defs,this._defsUsePending),this._defsUsePending=[],o){var c=eC(o);c.length>=4&&(l={x:parseFloat(c[0]||0),y:parseFloat(c[1]||0),width:parseFloat(c[2]),height:parseFloat(c[3])})}if(l&&null!=a&&null!=s&&(u=aC(l,{x:0,y:0,width:a,height:s}),!e.ignoreViewBox)){var p=i;(i=new Lr).add(p),p.scaleX=p.scaleY=u.scale,p.x=u.x,p.y=u.y}return e.ignoreRootClip||null==a||null==s||i.setClipPath(new Ls({shape:{x:0,y:0,width:a,height:s}})),{root:i,width:a,height:s,viewBoxRect:l,viewBoxTransform:u,named:r}},t.prototype._parseNode=function(t,e,n,i,r,o){var a,s=t.nodeName.toLowerCase(),l=i;if("defs"===s&&(r=!0),"text"===s&&(o=!0),"defs"===s||"switch"===s)a=e;else{if(!r){var u=zT[s];if(u&&gt(zT,s)){a=u.call(this,t,e);var h=t.getAttribute("name");if(h){var c={name:h,namedFrom:null,svgNodeTagLower:s,el:a};n.push(c),"g"===s&&(l=c)}else i&&n.push({name:i.name,namedFrom:i,svgNodeTagLower:s,el:a});e.add(a)}}var p=UT[s];if(p&&gt(UT,s)){var d=p.call(this,t),f=t.getAttribute("id");f&&(this._defs[f]=d)}}if(a&&a.isGroup)for(var g=t.firstChild;g;)1===g.nodeType?this._parseNode(g,a,n,l,r,o):3===g.nodeType&&o&&this._parseText(g,a),g=g.nextSibling},t.prototype._parseText=function(t,e){var n=new xs({style:{text:t.textContent},silent:!0,x:this._textX||0,y:this._textY||0});qT(e,n),$T(t,n,this._defsUsePending,!1,!1),function(t,e){var n=e.__selfStyle;if(n){var i=n.textBaseline,r=i;i&&"auto"!==i?"baseline"===i?r="alphabetic":"before-edge"===i||"text-before-edge"===i?r="top":"after-edge"===i||"text-after-edge"===i?r="bottom":"central"!==i&&"mathematical"!==i||(r="middle"):r="alphabetic",t.style.textBaseline=r}var o=e.__inheritedStyle;if(o){var a=o.textAlign,s=a;a&&("middle"===a&&(s="center"),t.style.textAlign=s)}}(n,e);var i=n.style,r=i.fontSize;r&&r<9&&(i.fontSize=9,n.scaleX*=r/9,n.scaleY*=r/9);var o=(i.fontSize||i.fontFamily)&&[i.fontStyle,i.fontWeight,(i.fontSize||12)+"px",i.fontFamily||"sans-serif"].join(" ");i.font=o;var a=n.getBoundingRect();return this._textX+=a.width,e.add(n),n},t.internalField=void(zT={g:function(t,e){var n=new Lr;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n},rect:function(t,e){var n=new Ls;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.setShape({x:parseFloat(t.getAttribute("x")||"0"),y:parseFloat(t.getAttribute("y")||"0"),width:parseFloat(t.getAttribute("width")||"0"),height:parseFloat(t.getAttribute("height")||"0")}),n.silent=!0,n},circle:function(t,e){var n=new yu;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.setShape({cx:parseFloat(t.getAttribute("cx")||"0"),cy:parseFloat(t.getAttribute("cy")||"0"),r:parseFloat(t.getAttribute("r")||"0")}),n.silent=!0,n},line:function(t,e){var n=new qu;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.setShape({x1:parseFloat(t.getAttribute("x1")||"0"),y1:parseFloat(t.getAttribute("y1")||"0"),x2:parseFloat(t.getAttribute("x2")||"0"),y2:parseFloat(t.getAttribute("y2")||"0")}),n.silent=!0,n},ellipse:function(t,e){var n=new xu;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.setShape({cx:parseFloat(t.getAttribute("cx")||"0"),cy:parseFloat(t.getAttribute("cy")||"0"),rx:parseFloat(t.getAttribute("rx")||"0"),ry:parseFloat(t.getAttribute("ry")||"0")}),n.silent=!0,n},polygon:function(t,e){var n,i=t.getAttribute("points");i&&(n=KT(i));var r=new Wu({shape:{points:n||[]},silent:!0});return qT(e,r),$T(t,r,this._defsUsePending,!1,!1),r},polyline:function(t,e){var n,i=t.getAttribute("points");i&&(n=KT(i));var r=new Xu({shape:{points:n||[]},silent:!0});return qT(e,r),$T(t,r,this._defsUsePending,!1,!1),r},image:function(t,e){var n=new Ss;return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.setStyle({image:t.getAttribute("xlink:href")||t.getAttribute("href"),x:+t.getAttribute("x"),y:+t.getAttribute("y"),width:+t.getAttribute("width"),height:+t.getAttribute("height")}),n.silent=!0,n},text:function(t,e){var n=t.getAttribute("x")||"0",i=t.getAttribute("y")||"0",r=t.getAttribute("dx")||"0",o=t.getAttribute("dy")||"0";this._textX=parseFloat(n)+parseFloat(r),this._textY=parseFloat(i)+parseFloat(o);var a=new Lr;return qT(e,a),$T(t,a,this._defsUsePending,!1,!0),a},tspan:function(t,e){var n=t.getAttribute("x"),i=t.getAttribute("y");null!=n&&(this._textX=parseFloat(n)),null!=i&&(this._textY=parseFloat(i));var r=t.getAttribute("dx")||"0",o=t.getAttribute("dy")||"0",a=new Lr;return qT(e,a),$T(t,a,this._defsUsePending,!1,!0),this._textX+=parseFloat(r),this._textY+=parseFloat(o),a},path:function(t,e){var n=pu(t.getAttribute("d")||"");return qT(e,n),$T(t,n,this._defsUsePending,!1,!1),n.silent=!0,n}}),t}(),UT={lineargradient:function(t){var e=parseInt(t.getAttribute("x1")||"0",10),n=parseInt(t.getAttribute("y1")||"0",10),i=parseInt(t.getAttribute("x2")||"10",10),r=parseInt(t.getAttribute("y2")||"0",10),o=new lh(e,n,i,r);return ZT(t,o),jT(t,o),o},radialgradient:function(t){var e=parseInt(t.getAttribute("cx")||"0",10),n=parseInt(t.getAttribute("cy")||"0",10),i=parseInt(t.getAttribute("r")||"0",10),r=new hh(e,n,i);return ZT(t,r),jT(t,r),r}};function ZT(t,e){"userSpaceOnUse"===t.getAttribute("gradientUnits")&&(e.global=!0)}function jT(t,e){for(var n=t.firstChild;n;){if(1===n.nodeType&&"stop"===n.nodeName.toLocaleLowerCase()){var i=n.getAttribute("offset"),r=void 0;r=i&&i.indexOf("%")>0?parseInt(i,10)/100:i?parseFloat(i):0;var o={};oC(n,o,o);var a=o.stopColor||n.getAttribute("stop-color")||"#000000";e.colorStops.push({offset:r,color:a})}n=n.nextSibling}}function qT(t,e){t&&t.__inheritedStyle&&(e.__inheritedStyle||(e.__inheritedStyle={}),k(e.__inheritedStyle,t.__inheritedStyle))}function KT(t){for(var e=eC(t),n=[],i=0;i<e.length;i+=2){var r=parseFloat(e[i]),o=parseFloat(e[i+1]);n.push([r,o])}return n}function $T(t,e,n,i,r){var o=e,a=o.__inheritedStyle=o.__inheritedStyle||{},s={};1===t.nodeType&&(function(t,e){var n=t.getAttribute("transform");if(n){n=n.replace(/,/g," ");var i=[],r=null;n.replace(nC,(function(t,e,n){return i.push(e,n),""}));for(var o=i.length-1;o>0;o-=2){var a=i[o],s=i[o-1],l=eC(a);switch(r=r||[1,0,0,1,0,0],s){case"translate":pe(r,r,[parseFloat(l[0]),parseFloat(l[1]||"0")]);break;case"scale":fe(r,r,[parseFloat(l[0]),parseFloat(l[1]||l[0])]);break;case"rotate":de(r,r,-parseFloat(l[0])*iC);break;case"skewX":ce(r,[1,0,Math.tan(parseFloat(l[0])*iC),1,0,0],r);break;case"skewY":ce(r,[1,Math.tan(parseFloat(l[0])*iC),0,1,0,0],r);break;case"matrix":r[0]=parseFloat(l[0]),r[1]=parseFloat(l[1]),r[2]=parseFloat(l[2]),r[3]=parseFloat(l[3]),r[4]=parseFloat(l[4]),r[5]=parseFloat(l[5])}}e.setLocalTransform(r)}}(t,e),oC(t,a,s),i||function(t,e,n){for(var i=0;i<WT.length;i++){var r=WT[i];null!=(o=t.getAttribute(r))&&(e[GT[r]]=o)}for(i=0;i<YT.length;i++){var o;r=YT[i],null!=(o=t.getAttribute(r))&&(n[HT[r]]=o)}}(t,a,s)),o.style=o.style||{},null!=a.fill&&(o.style.fill=QT(o,"fill",a.fill,n)),null!=a.stroke&&(o.style.stroke=QT(o,"stroke",a.stroke,n)),R(["lineWidth","opacity","fillOpacity","strokeOpacity","miterLimit","fontSize"],(function(t){null!=a[t]&&(o.style[t]=parseFloat(a[t]))})),R(["lineDashOffset","lineCap","lineJoin","fontWeight","fontFamily","fontStyle","textAlign"],(function(t){null!=a[t]&&(o.style[t]=a[t])})),r&&(o.__selfStyle=s),a.lineDash&&(o.style.lineDash=N(eC(a.lineDash),(function(t){return parseFloat(t)}))),"hidden"!==a.visibility&&"collapse"!==a.visibility||(o.invisible=!0),"none"===a.display&&(o.ignore=!0)}var JT=/^url\(\s*#(.*?)\)/;function QT(t,e,n,i){var r=n&&n.match(JT);if(!r)return"none"===n&&(n=null),n;var o=rt(r[1]);i.push([t,e,o])}var tC=/-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;function eC(t){return t.match(tC)||[]}var nC=/(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g,iC=Math.PI/180,rC=/([^\s:;]+)\s*:\s*([^:;]+)/g;function oC(t,e,n){var i,r=t.getAttribute("style");if(r)for(rC.lastIndex=0;null!=(i=rC.exec(r));){var o=i[1],a=gt(GT,o)?GT[o]:null;a&&(e[a]=i[2]);var s=gt(HT,o)?HT[o]:null;s&&(n[s]=i[2])}}function aC(t,e){var n=e.width/t.width,i=e.height/t.height,r=Math.min(n,i);return{scale:r,x:-(t.x+t.width/2)*r+(e.x+e.width/2),y:-(t.y+t.height/2)*r+(e.y+e.height/2)}}for(
/**
             * "region available" means that: enable users to set attribute `name="xxx"` on those tags
             * to make it be a region.
             * 1. region styles and its label styles can be defined in echarts opton:
             * ```js
             * geo: {
             *     regions: [{
             *         name: 'xxx',
             *         itemStyle: { ... },
             *         label: { ... }
             *     }, {
             *         ...
             *     },
             *     ...]
             * };
             * ```
             * 2. name can be duplicated in different SVG tag. All of the tags with the same name share
             * a region option. For exampel if there are two <path> representing two lung lobes. They have
             * no common parents but both of them need to display label "lung" inside.
             */
var sC=ct(["rect","circle","line","ellipse","polygon","polyline","path",// <text> <tspan> are also enabled because some SVG might paint text itself,
// but still need to trigger events or tooltip.
"text","tspan",// <g> is also enabled because this case: if multiple tags share one name
// and need label displayed, every tags will display the name, which is not
// expected. So we can put them into a <g name="xxx">. Thereby only one label
// displayed and located based on the bounding rect of the <g>.
"g"]),lC=/** @class */function(){function t(t,e){this.type="geoSVG",// All used graphics. key: hostKey, value: root
this._usedGraphicMap=ct(),// All unused graphics.
this._freedGraphics=[],this._mapName=t,// Only perform parse to XML object here, which might be time
// consiming for large SVG.
// Although convert XML to zrender element is also time consiming,
// if we do it here, the clone of zrender elements has to be
// required. So we do it once for each geo instance, util real
// performance issues call for optimizing it.
this._parsedXML=FT(e)}return t.prototype.load=function(){// In the "load" stage, graphic need to be built to
// get boundingRect for geo coordinate system.
var t=this._firstGraphic;// Create the return data structure only when first graphic created.
// Because they will be used in geo coordinate system update stage,
// and `regions` will be mounted at `geo` coordinate system,
// in which there is no "view" info, so that it should better not to
// make references to graphic elements.
if(!t){t=this._firstGraphic=this._buildGraphic(this._parsedXML),this._freedGraphics.push(t),this._boundingRect=this._firstGraphic.boundingRect.clone();// PENDING: `nameMap` will not be supported until some real requirement come.
// if (nameMap) {
//     named = applyNameMap(named, nameMap);
// }
var e=function(t){var e=[],n=ct();// Create resions only for the first graphic.
return R(t,(function(t){// Region has feature to calculate center for tooltip or other features.
// If there is a <g name="xxx">, the center should be the center of the
// bounding rect of the g.
if(null==t.namedFrom){var i=new K_(t.name,t.el);// PENDING: if `nameMap` supported, this region can not be mounted on
// `this`, but can only be created each time `load()` called.
e.push(i),// PENDING: if multiple tag named with the same name, only one will be
// found by `_regionsMap`. `_regionsMap` is used to find a coordinate
// by name. We use `region.getCenter()` as the coordinate.
n.set(t.name,i)}})),{regions:e,regionsMap:n}}// PENDING: `nameMap` will not be supported until some real requirement come.
// /**
//  * Use the alias in geoNameMap.
//  * The input `named` must not be modified.
//  */
// function applyNameMap(
//     named: GeoSVGGraphicRecord['named'],
//     nameMap: NameMap
// ): GeoSVGGraphicRecord['named'] {
//     const result = [] as GeoSVGGraphicRecord['named'];
//     for (let i = 0; i < named.length; i++) {
//         let regionGraphic = named[i];
//         const name = regionGraphic.name;
//         if (nameMap && nameMap.hasOwnProperty(name)) {
//             regionGraphic = extend({}, regionGraphic);
//             regionGraphic.name = name;
//         }
//         result.push(regionGraphic);
//     }
//     return result;
// }
(t.named),n=e.regions,i=e.regionsMap;this._regions=n,this._regionsMap=i}return{boundingRect:this._boundingRect,regions:this._regions,regionsMap:this._regionsMap}},t.prototype._buildGraphic=function(t){var e,n,i,r;try{it(null!=(n=(e=t&&(i=t,r={ignoreViewBox:!0,ignoreRootClip:!0},(new XT).parse(i,r))||{}).root))}catch(ku){throw new Error("Invalid svg format\n"+ku.message)}// Note: we keep the covenant that the root has no transform. So always add an extra root.
var o=new Lr;o.add(n),o.isGeoSVGGraphicRoot=!0;// [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]
// Consider: `<svg width="..." height="..." viewBox="...">`
// - the `width/height` we call it `svgWidth/svgHeight` for short.
// - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,
//   "viewport boundingRect", or `boundingRect` for short.
// - `viewBox` defines the transform from the real content ot the viewport.
//   `viewBox` has the same unit as the content of SVG.
//   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become
//   different from the content of SVG. Otherwise, they are the same.
// If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:
// 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).
// 1. Make a transform from `viewBox` to `boundingRect`.
//    Note: only support `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve
//    the aspect ratio.
// 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])
//    (`Geo`/`View` will do this job).
//    Note: this transform might not preserve aspect radio, which depending on how users specify
//    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,
//    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).
// If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG
// layout look good.
// If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect
// of the SVG content and use them to make SVG layout look good.
var a=e.width,s=e.height,l=e.viewBoxRect,u=this._boundingRect;if(!u){var h=void 0,c=void 0,p=void 0,d=void 0;// If both viewBox and svgWidth/svgHeight not specified,
// we have to determine how to layout those element to make them look good.
if(null!=a?(h=0,p=a):l&&(h=l.x,p=l.width),null!=s?(c=0,d=s):l&&(c=l.y,d=l.height),null==h||null==c){var f=n.getBoundingRect();null==h&&(h=f.x,p=f.width),null==c&&(c=f.y,d=f.height)}u=this._boundingRect=new Ce(h,c,p,d)}if(l){var g=aC(l,u);// Only support `preserveAspectRatio 'xMidYMid'`
n.scaleX=n.scaleY=g.scale,n.x=g.x,n.y=g.y}// SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.
// They do not strictly confine all of the content inside a display rect, but deliberately
// use a `viewBox` to define a displayable rect.
// PENDING:
// The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the
// edge might also be clipped, because region labels are put as `textContent` of the SVG path.
o.setClipPath(new Ls({shape:u.plain()}));var y=[];return R(e.named,(function(t){var e;null!=sC.get(t.svgNodeTagLower)&&(y.push(t),// Only named element has silent: false, other elements should
// act as background and has no user interaction.
(e=t.el).silent=!1,// text|tspan will be converted to group.
e.isGroup&&e.traverse((function(t){t.silent=!1})))})),{root:o,boundingRect:u,named:y}},
/**
               * Consider:
               * (1) One graphic element can not be shared by different `geoView` running simultaneously.
               *     Notice, also need to consider multiple echarts instances share a `mapRecord`.
               * (2) Converting SVG to graphic elements is time consuming.
               * (3) In the current architecture, `load` should be called frequently to get boundingRect,
               *     and it is called without view info.
               * So we maintain graphic elements in this module, and enables `view` to use/return these
               * graphics from/to the pool with it's uid.
               */
t.prototype.useGraphic=function(t/* , nameMap: NameMap */){var e=this._usedGraphicMap,n=e.get(t);return n||(n=this._freedGraphics.pop()||this._buildGraphic(this._parsedXML),e.set(t,n),n)},t.prototype.freeGraphic=function(t){var e=this._usedGraphicMap,n=e.get(t);n&&(e.removeKey(t),this._freedGraphics.push(n))},t}(),uC=[126,25],hC="",cC=[[[0,3.5],[7,11.2],[15,11.9],[30,7],[42,.7],[52,.7],[56,7.7],[59,.7],[64,.7],[64,0],[5,0],[0,3.5]],[[13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]],[[12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]],[[16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]],[[6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]],[[23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]],[[37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]],[[48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]],[[51,35],[51,28.7],[53,28.7],[53,35],[51,35]],[[52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]],[[58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]],[[0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],[1,92.4],[1,3.5],[0,3.5]]],pC=0;pC<cC.length;pC++)for(var dC=0;dC<cC[pC].length;dC++)cC[pC][dC][0]/=10.5,cC[pC][dC][1]/=-14,cC[pC][dC][0]+=uC[0],cC[pC][dC][1]+=uC[1];
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
var fC={"":[32,80],// 
"":[0,-10],"":[10,5],"":[-10,10],// '': [-10, 0],
"":[5,5]},gC=[[[123.45165252685547,25.73527164402261],[123.49731445312499,25.73527164402261],[123.49731445312499,25.750734064600884],[123.45165252685547,25.750734064600884],[123.45165252685547,25.73527164402261]]],yC=/** @class */function(){function t(t,e,n){var i;this.type="geoJSON",this._parsedMap=ct(),this._mapName=t,this._specialAreas=n,// PENDING: delay the parse to the first usage to rapid up the FMP?
this._geoJSON=H(i=e)?"undefined"!=typeof JSON&&JSON.parse?JSON.parse(i):new Function("return ("+i+");")():i}
/**
               * @param nameMap can be null/undefined
               * @param nameProperty can be null/undefined
               */return t.prototype.load=function(t,e){e=e||"name";var n=this._parsedMap.get(e);if(!n){var i=this._parseToRegions(e);n=this._parsedMap.set(e,{regions:i,boundingRect:vC(i)})}var r=ct(),o=[];return R(n.regions,(function(e){var n=e.name;// Try use the alias in geoNameMap
t&&gt(t,n)&&(e=e.cloneShallow(n=t[n])),o.push(e),r.set(n,e)})),{regions:o,boundingRect:n.boundingRect||new Ce(0,0,0,0),regionsMap:r}},t.prototype._parseToRegions=function(t){var e,n=this._mapName,i=this._geoJSON;// https://jsperf.com/try-catch-performance-overhead
try{e=i?Q_(i,t):[]}catch(ku){throw new Error("Invalid geoJson format\n"+ku.message)}return function(t,e){if("china"===t){for(var n=0;n<e.length;n++)// Already exists.
if(e[n].name===hC)return;e.push(new q_(hC,N(cC,(function(t){return{type:"polygon",exterior:t}})),uC))}}(n,e),R(e,(function(t){var e=t.name;!function(t,e){if("china"===t){var n=fC[e.name];if(n){var i=e.getCenter();i[0]+=n[0]/10.5,i[1]+=-n[1]/14,e.setCenter(i)}}}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
// Fix for 
// let Region = require('../Region');
// let zrUtil = require('zrender/lib/core/util');
// let geoCoord = [126, 25];
(n,t),function(t,e){"china"===t&&""===e.name&&e.geometries.push({type:"polygon",exterior:gC[0]})}(n,t);// Some area like Alaska in USA map needs to be tansformed
// to look better
var i=this._specialAreas&&this._specialAreas[e];i&&t.transformTo(i.left,i.top,i.width,i.height)}),this),e},
/**
               * Only for exporting to users.
               * **MUST NOT** used internally.
               */
t.prototype.getMapForUser=function(){return{// For backward compatibility, use geoJson
// PENDING: it has been returning them without clone.
// do we need to avoid outsite modification?
geoJson:this._geoJSON,geoJSON:this._geoJSON,specialAreas:this._specialAreas}},t}();function vC(t){for(var e,n=0;n<t.length;n++){var i=t[n].getBoundingRect();(e=e||i.clone()).union(i)}return e}var mC=ct();const xC=function(t,e,n){if(e.svg){var i=new lC(t,e.svg);mC.set(t,i)}else{// Recommend:
//     echarts.registerMap('eu', { geoJSON: xxx, specialAreas: xxx });
// Backward compatibility:
//     echarts.registerMap('eu', geoJSON, specialAreas);
//     echarts.registerMap('eu', { geoJson: xxx, specialAreas: xxx });
var r=e.geoJson||e.geoJSON;r&&!e.features?n=e.specialAreas:r=e,i=new yC(t,r,n),mC.set(t,i)}},_C=function(t){return mC.get(t)},bC=function(t){var e=mC.get(t);// Do not support return SVG until some real requirement come.
return e&&"geoJSON"===e.type&&e.getMapForUser()},wC=function(t,e,n){var i=mC.get(t);if(i)return i.load(e,n)};
/**
             * Only these tags enable use `itemStyle` if they are named in SVG.
             * Other tags like <text> <tspan> <image> might not suitable for `itemStyle`.
             * They will not be considered to be styled until some requirements come.
             */var SC=["rect","circle","line","ellipse","polygon","polyline","path"],MC=ct(SC),IC=ct(SC.concat(["g"])),TC=ct(SC.concat(["g"])),CC=bo();function DC(t){var e=t.getItemStyle(),n=t.get("areaColor");// If user want the color not to be changed when hover,
// they should both set areaColor and color to be null.
return null!=n&&(e.fill=n),e}// Only stroke can be used for line.
// Using fill in style if stroke not exits.
// TODO Not sure yet. Perhaps a separate `lineStyle`?
function AC(t){var e=t.style;e&&(e.stroke=e.stroke||e.fill,e.fill=null)}var kC=/** @class */function(){function t(t){var e=new Lr;this.uid=Rc("ec_map_draw"),this._controller=new RT(t.getZr()),this._controllerHost={target:e},this.group=e,e.add(this._regionsGroup=new Lr),e.add(this._svgGroup=new Lr)}return t.prototype.draw=function(t,e,n,i,r){var o="geo"===t.mainType,a=t.getData&&t.getData();// Map series has data. GEO model that controlled by map series
// will be assigned with map data. Other GEO model has no data.
o&&e.eachComponent({mainType:"series",subType:"map"},(function(e){a||e.getHostGeoModel()!==t||(a=e.getData())}));var s=t.coordinateSystem,l=this._regionsGroup,u=this.group,h=s.getTransformInfo(),c=h.raw,p=h.roam;!l.childAt(0)||r?(u.x=p.x,u.y=p.y,u.scaleX=p.scaleX,u.scaleY=p.scaleY,u.dirty()):Sh(u,p,t);var d=a&&a.getVisual("visualMeta")&&a.getVisual("visualMeta").length>0,f={api:n,geo:s,mapOrGeoModel:t,data:a,isVisualEncodedByVisualMap:d,isGeo:o,transformInfoRaw:c};"geoJSON"===s.resourceType?this._buildGeoJSON(f):"geoSVG"===s.resourceType&&this._buildSVG(f),this._updateController(t,e,n),this._updateMapSelectHandler(t,l,n,i)},t.prototype._buildGeoJSON=function(t){var e=this._regionsGroupByName=ct(),n=ct(),i=this._regionsGroup,r=t.transformInfoRaw,o=t.mapOrGeoModel,a=t.data,s=t.geo.projection,l=s&&s.stream;function u(t,e){return e&&(// projection may return null point.
t=e(t)),t&&[t[0]*r.scaleX+r.x,t[1]*r.scaleY+r.y]}function h(t){for(var e=[],n=!l&&s&&s.project,i=0// If projectionStream is provided. Use it instead of single point project.
;i<t.length;++i){var r=u(t[i],n);r&&e.push(r)}return e}function c(t){return{shape:{points:h(t)}}}i.removeAll(),// Only when the resource is GeoJSON, there is `geo.regions`.
R(t.geo.regions,(function(r){var h=r.name,p=e.get(h),d=n.get(h)||{},f=d.dataIdx,g=d.regionModel;// Consider in GeoJson properties.name may be duplicated, for example,
// there is multiple region named "United Kindom" or "France" (so many
// colonies). And it is not appropriate to merge them in geo, which
// will make them share the same label and bring trouble in label
// location calculation.
p||(p=e.set(h,new Lr),i.add(p),f=a?a.indexOfName(h):null,g=t.isGeo?o.getRegionModel(h):a?a.getItemModel(f):null,n.set(h,{dataIdx:f,regionModel:g}));var y=[],v=[];R(r.geometries,(function(t){// Polygon and MultiPolygon
if("polygon"===t.type){var e=[t.exterior].concat(t.interiors||[]);l&&(e=EC(e,l)),R(e,(function(t){y.push(new Wu(c(t)))}))}// LineString and MultiLineString
else{var n=t.points;l&&(n=EC(n,l,!0)),R(n,(function(t){v.push(new Xu(c(t)))}))}}));var m=u(r.getCenter(),s&&s.project);function x(e,n){if(e.length){var i=new oh({culling:!0,segmentIgnoreThreshold:1,shape:{paths:e}});p.add(i),LC(t,i,f,g),PC(t,i,h,g,o,f,m),n&&(AC(i),R(i.states,AC))}}x(y),x(v,!0)})),// Ensure children have been added to `regionGroup` before calling them.
e.each((function(e,i){var r=n.get(i),a=r.dataIdx,s=r.regionModel;OC(t,e,i,s,o,a),RC(t,e,i,s,o),NC(t,e,i,s,o)}),this)},t.prototype._buildSVG=function(t){var e=t.geo.map,n=t.transformInfoRaw;this._svgGroup.x=n.x,this._svgGroup.y=n.y,this._svgGroup.scaleX=n.scaleX,this._svgGroup.scaleY=n.scaleY,this._svgResourceChanged(e)&&(this._freeSVG(),this._useSVG(e));var i=this._svgDispatcherMap=ct(),r=!1;R(this._svgGraphicRecord.named,(function(e){// Note that we also allow different elements have the same name.
// For example, a glyph of a city and the label of the city have
// the same name and their tooltip info can be defined in a single
// region option.
var n=e.name,o=t.mapOrGeoModel,a=t.data,s=e.svgNodeTagLower,l=e.el,u=a?a.indexOfName(n):null,h=o.getRegionModel(n);null!=MC.get(s)&&l instanceof fa&&LC(t,l,u,h),l instanceof fa&&(l.culling=!0),// We do not know how the SVG like so we'd better not to change z2.
// Otherwise it might bring some unexpected result. For example,
// an area hovered that make some inner city can not be clicked.
l.z2EmphasisLift=0,// If self named:
e.namedFrom||(// label should batter to be displayed based on the center of <g>
// if it is named rather than displayed on each child.
null!=TC.get(s)&&PC(t,l,n,h,o,u,null),OC(t,l,n,h,o,u),RC(t,l,n,h,o),null!=IC.get(s)&&("self"===NC(t,l,n,h,o)&&(r=!0),(i.get(n)||i.set(n,[])).push(l)))}),this),this._enableBlurEntireSVG(r,t)},t.prototype._enableBlurEntireSVG=function(t,e){// It's a little complicated to support blurring the entire geoSVG in series-map.
// So do not suport it until some requirements come.
// At present, in series-map, only regions can be blurred.
if(t&&e.isGeo){var n=e.mapOrGeoModel.getModel(["blur","itemStyle"]).getItemStyle().opacity;// Only suport `opacity` here. Because not sure that other props are suitable for
// all of the elements generated by SVG (especially for Text/TSpan/Image/... ).
this._svgGraphicRecord.root.traverse((function(t){if(!t.isGroup){// PENDING: clear those settings to SVG elements when `_freeSVG`.
// (Currently it happen not to be needed.)
wl(t);var e=t.ensureState("blur").style||{};// Do not overwrite the region style that already set from region option.
null==e.opacity&&null!=n&&(e.opacity=n),// If `ensureState('blur').style = {}`, there will be default opacity.
// Enable `stateTransition` (animation).
t.ensureState("emphasis")}}))}},t.prototype.remove=function(){this._regionsGroup.removeAll(),this._regionsGroupByName=null,this._svgGroup.removeAll(),this._freeSVG(),this._controller.dispose(),this._controllerHost=null},t.prototype.findHighDownDispatchers=function(t,e){if(null==t)return[];var n=e.coordinateSystem;if("geoJSON"===n.resourceType){var i=this._regionsGroupByName;if(i){var r=i.get(t);return r?[r]:[]}}else if("geoSVG"===n.resourceType)return this._svgDispatcherMap&&this._svgDispatcherMap.get(t)||[]},t.prototype._svgResourceChanged=function(t){return this._svgMapName!==t},t.prototype._useSVG=function(t){var e=_C(t);if(e&&"geoSVG"===e.type){var n=e.useGraphic(this.uid);this._svgGroup.add(n.root),this._svgGraphicRecord=n,this._svgMapName=t}},t.prototype._freeSVG=function(){var t=this._svgMapName;if(null!=t){var e=_C(t);e&&"geoSVG"===e.type&&e.freeGraphic(this.uid),this._svgGraphicRecord=null,this._svgDispatcherMap=null,this._svgGroup.removeAll(),this._svgMapName=null}},t.prototype._updateController=function(t,e,n){var i=t.coordinateSystem,r=this._controller,o=this._controllerHost;// @ts-ignore FIXME:TS
o.zoomLimit=t.get("scaleLimit"),o.zoom=i.getZoom(),// roamType is will be set default true if it is null
// @ts-ignore FIXME:TS
r.enable(t.get("roam")||!1);var a=t.mainType;function s(){var e={type:"geoRoam",componentType:a};return e[a+"Id"]=t.id,e}r.off("pan").on("pan",(function(t){this._mouseDownFlag=!1,NT(o,t.dx,t.dy),n.dispatchAction(A(s(),{dx:t.dx,dy:t.dy,animation:{duration:0}}))}),this),r.off("zoom").on("zoom",(function(t){this._mouseDownFlag=!1,ET(o,t.scale,t.originX,t.originY),n.dispatchAction(A(s(),{zoom:t.scale,originX:t.originX,originY:t.originY,animation:{duration:0}}))}),this),r.setPointerChecker((function(e,r,o){return i.containPoint([r,o])&&!BT(e,n,t)}))},
/**
               * FIXME: this is a temporarily workaround.
               * When `geoRoam` the elements need to be reset in `MapView['render']`, because the props like
               * `ignore` might have been modified by `LabelManager`, and `LabelManager#addLabelsOfSeries`
               * will subsequently cache `defaultAttr` like `ignore`. If do not do this reset, the modified
               * props will have no chance to be restored.
               * Note: This reset should be after `clearStates` in `renderSeries` because `useStates` in
               * `renderSeries` will cache the modified `ignore` to `el._normalState`.
               * TODO:
               * Use clone/immutable in `LabelManager`?
               */
t.prototype.resetForLabelLayout=function(){this.group.traverse((function(t){var e=t.getTextContent();e&&(e.ignore=CC(e).ignore)}))},t.prototype._updateMapSelectHandler=function(t,e,n,i){var r=this;e.off("mousedown"),e.off("click"),// @ts-ignore FIXME:TS resolve type conflict
t.get("selectedMode")&&(e.on("mousedown",(function(){r._mouseDownFlag=!0})),e.on("click",(function(t){r._mouseDownFlag&&(r._mouseDownFlag=!1)})))},t}();function LC(t,e,n,i){// All of the path are using `itemStyle`, because
// (1) Some SVG also use fill on polyline (The different between
// polyline and polygon is "open" or "close" but not fill or not).
// (2) For the common props like opacity, if some use itemStyle
// and some use `lineStyle`, it might confuse users.
// (3) Most SVG use <path>, where can not detect wether draw a "line"
// or a filled shape, so use `itemStyle` for <path>.
var r=i.getModel("itemStyle"),o=i.getModel(["emphasis","itemStyle"]),a=i.getModel(["blur","itemStyle"]),s=i.getModel(["select","itemStyle"]),l=DC(r),u=DC(o),h=DC(s),c=DC(a),p=t.data;if(p){// Only visual color of each item will be used. It can be encoded by visualMap
// But visual color of series is used in symbol drawing
// Visual color for each series is for the symbol draw
var d=p.getItemVisual(n,"style"),f=p.getItemVisual(n,"decal");t.isVisualEncodedByVisualMap&&d.fill&&(l.fill=d.fill),f&&(l.decal=Pv(f,t.api))}// SVG text, tspan and image can be named but not supporeted
// to be styled by region option yet.
e.setStyle(l),e.style.strokeNoScale=!0,e.ensureState("emphasis").style=u,e.ensureState("select").style=h,e.ensureState("blur").style=c,// Enable blur
wl(e)}function PC(t,e,n,i,r,// Exist only if `viewBuildCtx.data` exists.
o,// If labelXY not provided, use `textConfig.position: 'inside'`
a){var s=t.data,l=t.isGeo,u=s&&isNaN(s.get(s.mapDimension("value"),o)),h=s&&s.getItemLayout(o);// In the following cases label will be drawn
// 1. In map series and data value is NaN
// 2. In geo component
// 3. Region has no series legendIcon, which will be add a showLabel flag in mapSymbolLayout
if(l||u||h&&h.showLabel){var c=l?n:o,p=void 0;// Consider dataIdx not found.
(!s||o>=0)&&(p=r);var d=a?{normal:{align:"center",verticalAlign:"middle"}}:null;// Caveat: must be called after `setDefaultStateProxy(el);` called.
// because textContent will be assign with `el.stateProxy` inside.
ac(e,sc(i),{labelFetcher:p,labelDataIndex:c,defaultText:n},d);var f=e.getTextContent();if(f&&(CC(f).ignore=f.ignore,e.textConfig&&a)){// Compute a relative offset based on the el bounding rect.
var g=e.getBoundingRect().clone();// Need to make sure the percent position base on the same rect in normal and
// emphasis state. Otherwise if using boundingRect of el, but the emphasis state
// has borderWidth (even 0.5px), the text position will be changed obviously
// if the position is very big like ['1234%', '1345%'].
e.textConfig.layoutRect=g,e.textConfig.position=[(a[0]-g.x)/g.width*100+"%",(a[1]-g.y)/g.height*100+"%"]}// PENDING:
// If labelLayout is enabled (test/label-layout.html), el.dataIndex should be specified.
// But el.dataIndex is also used to determine whether user event should be triggered,
// where el.seriesIndex or el.dataModel must be specified. At present for a single el
// there is not case that "only label layout enabled but user event disabled", so here
// we depends `resetEventTriggerForRegion` to do the job of setting `el.dataIndex`.
e.disableLabelAnimation=!0}else e.removeTextContent(),e.removeTextConfig(),e.disableLabelAnimation=null}function OC(t,e,n,i,r,// Exist only if `viewBuildCtx.data` exists.
o){// setItemGraphicEl, setHoverStyle after all polygons and labels
// are added to the regionGroup
t.data?// FIXME: when series-map use a SVG map, and there are duplicated name specified
// on different SVG elements, after `data.setItemGraphicEl(...)`:
// (1) all of them will be mounted with `dataIndex`, `seriesIndex`, so that tooltip
// can be triggered only mouse hover. That's correct.
// (2) only the last element will be kept in `data`, so that if trigger tooltip
// by `dispatchAction`, only the last one can be found and triggered. That might be
// not correct. We will fix it in future if anyone demanding that.
t.data.setItemGraphicEl(o,e):// Package custom mouse event for geo component
js(e).eventData={componentType:"geo",componentIndex:r.componentIndex,geoIndex:r.componentIndex,name:n,region:i&&i.option||{}}}function RC(t,e,n,i,r){t.data||Qh({el:e,componentModel:r,itemName:n,// @ts-ignore FIXME:TS fix the "compatible with each other"?
itemTooltipOption:i.get("tooltip")})}function NC(t,e,n,i,r){// @ts-ignore FIXME:TS fix the "compatible with each other"?
e.highDownSilentOnTouch=!!r.get("selectedMode");// @ts-ignore FIXME:TS fix the "compatible with each other"?
var o=i.getModel("emphasis"),a=o.get("focus");return Bl(e,a,o.get("blurScope"),o.get("disabled")),t.isGeo&&function(t,e,n){var i=js(t);i.componentMainType=e.mainType,i.componentIndex=e.componentIndex,i.componentHighDownName=n}(e,r,n),a}function EC(t,// Polygons include exterior and interiors. Or polylines.
e,n){var i,r=[];function o(){i=[]}function a(){i.length&&(r.push(i),i=[])}var s=e({polygonStart:o,polygonEnd:a,lineStart:o,lineEnd:a,point:function(t,e){// May have NaN values from stream.
isFinite(t)&&isFinite(e)&&i.push([t,e])},sphere:function(){}});return!n&&s.polygonStart(),R(t,(function(t){s.lineStart();for(var e=0;e<t.length;e++)s.point(t[e][0],t[e][1]);s.lineEnd()})),!n&&s.polygonEnd(),r}const zC=kC;// @ts-ignore FIXME:TS fix the "compatible with each other"?
var VC=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n,i){// Not render if it is an toggleSelect action from self
if(!i||"mapToggleSelect"!==i.type||i.from!==this.uid){var r=this.group;if(r.removeAll(),!t.getHostGeoModel()){// Not update map if it is an roam action from self
if(this._mapDraw&&i&&"geoRoam"===i.type&&this._mapDraw.resetForLabelLayout(),i&&"geoRoam"===i.type&&"series"===i.componentType&&i.seriesId===t.id)(o=this._mapDraw)&&r.add(o.group);else if(t.needsDrawMap){var o=this._mapDraw||new zC(n);r.add(o.group),o.draw(t,e,n,this,i),this._mapDraw=o}else// Remove drawn map
this._mapDraw&&this._mapDraw.remove(),this._mapDraw=null;t.get("showLegendSymbol")&&e.getComponent("legend")&&this._renderSymbols(t,e,n)}}},e.prototype.remove=function(){this._mapDraw&&this._mapDraw.remove(),this._mapDraw=null,this.group.removeAll()},e.prototype.dispose=function(){this._mapDraw&&this._mapDraw.remove(),this._mapDraw=null},e.prototype._renderSymbols=function(t,e,n){var i=t.originalData,r=this.group;i.each(i.mapDimension("value"),(function(e,n){if(!isNaN(e)){var o=i.getItemLayout(n);if(o&&o.point){var a=o.point,s=o.offset,l=new yu({style:{// Because the special of map draw.
// Which needs statistic of multiple series and draw on one map.
// And each series also need a symbol with legend color
// Layout and visual are put one the different data
// TODO
fill:t.getData().getVisual("style").fill},shape:{cx:a[0]+9*s,cy:a[1],r:3},silent:!0,// Do not overlap the first series, on which labels are displayed.
z2:8+(s?0:11)});// Only the series that has the first value on the same region is in charge of rendering the label.
// But consider the case:
// series: [
//     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},
//     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}
// ]
// The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.
// For backward compatibility, we follow the rule that render label `A` by the
// settings on series `X` but render label `C` by the settings on series `Y`.
if(!s){var u=t.mainSeries.getData(),h=i.getName(n),c=u.indexOfName(h),p=i.getItemModel(n),d=p.getModel("label"),f=u.getItemGraphicEl(c);// `getFormattedLabel` needs to use `getData` inside. Here
// `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.
// FIXME
// If this is not the `mainSeries`, the item model (like label formatter)
// set on original data item will never get. But it has been working
// like that from the beginning, and this scenario is rarely encountered.
// So it won't be fixed until we have to.
ac(l,sc(p),{labelFetcher:{getFormattedLabel:function(e,n){return t.getFormattedLabel(c,n)}},defaultText:h}),l.disableLabelAnimation=!0,d.get("position")||l.setTextConfig({position:"bottom"}),f.onHoverStateChange=function(t){_l(l,t)}}r.add(l)}}}))},e.type="map",e}(qg);const BC=VC;var FC=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,// Only first map series of same mapType will drawMap.
n.needsDrawMap=!1,// Group of all map series with same mapType
n.seriesGroup=[],n.getTooltipPosition=function(t){if(null!=t){var e=this.getData().getName(t),n=this.coordinateSystem,i=n.getRegion(e);return i&&n.dataToPoint(i.getCenter())}},n}return n(e,t),e.prototype.getInitialData=function(t){for(var e=UM(this,{coordDimensions:["value"],encodeDefaulter:F(ad,this)}),n=ct(),i=[],r=0,o=e.count();r<o;r++){var a=e.getName(r);n.set(a,!0)}return R(wC(this.getMapType(),this.option.nameMap,this.option.nameProperty).regions,(function(t){var e=t.name;n.get(e)||i.push(e)})),// Complete data with missing regions. The consequent processes (like visual
// map and render) can not be performed without a "full data". For example,
// find `dataIndex` by name.
e.appendValues([],i),e},
/**
               * If no host geo model, return null, which means using a
               * inner exclusive geo model.
               */
e.prototype.getHostGeoModel=function(){var t=this.option.geoIndex;return null!=t?this.ecModel.getComponent("geo",t):null},e.prototype.getMapType=function(){return(this.getHostGeoModel()||this).option.map},// _fillOption(option, mapName) {
// Shallow clone
// option = zrUtil.extend({}, option);
// option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
// return option;
// }
e.prototype.getRawValue=function(t){// Use value stored in data instead because it is calculated from multiple series
// FIXME Provide all value of multiple series ?
var e=this.getData();return e.get(e.mapDimension("value"),t)},
/**
               * Get model of region
               */
e.prototype.getRegionModel=function(t){var e=this.getData();return e.getItemModel(e.indexOfName(t))},
/**
               * Map tooltip formatter
               */
e.prototype.formatTooltip=function(t,e,n){for(// FIXME orignalData and data is a bit confusing
var i=this.getData(),r=this.getRawValue(t),o=i.getName(t),a=this.seriesGroup,s=[],l=0;l<a.length;l++){var u=a[l].originalData.indexOfName(o),h=i.mapDimension("value");isNaN(a[l].originalData.get(h,u))||s.push(a[l].name)}return dg("section",{header:s.join(", "),noHeader:!s.length,blocks:[dg("nameValue",{name:o,value:r})]})},e.prototype.setZoom=function(t){this.option.zoom=t},e.prototype.setCenter=function(t){this.option.center=t},e.prototype.getLegendIcon=function(t){var e=t.icon||"roundRect",n=ov(e,0,0,t.itemWidth,t.itemHeight,t.itemStyle.fill);return n.setStyle(t.itemStyle),// Map do not use itemStyle.borderWidth as border width
n.style.stroke="none",// No rotation because no series visual symbol for map
e.indexOf("empty")>-1&&(n.style.stroke=n.style.fill,n.style.fill="#fff",n.style.lineWidth=2),n},e.type="series.map",e.dependencies=["geo"],e.layoutMode="box",e.defaultOption={// 
// zlevel: 0,
// 
z:2,coordinateSystem:"geo",// map should be explicitly specified since ec3.
map:"",// If `geoIndex` is not specified, a exclusive geo will be
// created. Otherwise use the specified geo component, and
// `map` and `mapType` are ignored.
// geoIndex: 0,
// 'center' | 'left' | 'right' | 'x%' | {number}
left:"center",// 'center' | 'top' | 'bottom' | 'x%' | {number}
top:"center",// right
// bottom
// width:
// height
// Aspect is width / height. Inited to be geoJson bbox aspect
// This parameter is used for scale this aspect
// Default value:
// for geoSVG source: 1,
// for geoJSON source: 0.75.
aspectScale:null,// Layout with center and size
// If you want to put map in a fixed size box with right aspect ratio
// This two properties may be more convenient.
// layoutCenter: [50%, 50%]
// layoutSize: 100
showLegendSymbol:!0,// Define left-top, right-bottom coords to control view
// For example, [ [180, 90], [-180, -90] ],
// higher priority than center and zoom
boundingCoords:null,// Default on center of map
center:null,zoom:1,scaleLimit:null,selectedMode:!0,label:{show:!1,color:"#000"},// scaleLimit: null,
itemStyle:{borderWidth:.5,borderColor:"#444",areaColor:"#eee"},emphasis:{label:{show:!0,color:"rgb(100,0,0)"},itemStyle:{areaColor:"rgba(255,215,0,0.8)"}},select:{label:{show:!0,color:"rgb(100,0,0)"},itemStyle:{color:"rgba(255,215,0,0.8)"}},nameProperty:"name"},e}(zg);const GC=FC;function WC(t){var e={};t.eachSeriesByType("map",(function(t){var n=t.getHostGeoModel(),i=n?"o"+n.id:"i"+t.getMapType();(e[i]=e[i]||[]).push(t)})),R(e,(function(t,e){for(var n,i,r,o=(n=N(t,(function(t){return t.getData()})),i=t[0].get("mapValueCalculation"),r={},R(n,(function(t){t.each(t.mapDimension("value"),(function(e,n){// Add prefix to avoid conflict with Object.prototype.
var i="ec-"+t.getName(n);r[i]=r[i]||[],isNaN(e)||r[i].push(e)}))})),n[0].map(n[0].mapDimension("value"),(function(t,e){for(var o="ec-"+n[0].getName(e),a=0,s=1/0,l=-1/0,u=r[o].length,h=0;h<u;h++)s=Math.min(s,r[o][h]),l=Math.max(l,r[o][h]),a+=r[o][h];return 0===u?NaN:"min"===i?s:"max"===i?l:"average"===i?a/u:a}))),a=0;a<t.length;a++)t[a].originalData=t[a].getData();// FIXME Put where?
for(a=0;a<t.length;a++)t[a].seriesGroup=t,t[a].needsDrawMap=0===a&&!t[a].getHostGeoModel(),t[a].setData(o.cloneShallow()),t[a].mainSeries=t[0]}))}function HC(t){var e={};t.eachSeriesByType("map",(function(n){var i=n.getMapType();if(!n.getHostGeoModel()&&!e[i]){var r={};R(n.seriesGroup,(function(e){var n=e.coordinateSystem,i=e.originalData;e.get("showLegendSymbol")&&t.getComponent("legend")&&i.each(i.mapDimension("value"),(function(t,e){var o=i.getName(e),a=n.getRegion(o);// If input series.data is [11, 22, '-'/null/undefined, 44],
// it will be filled with NaN: [11, 22, NaN, 44] and NaN will
// not be drawn. So here must validate if value is NaN.
if(a&&!isNaN(t)){var s=r[o]||0,l=n.dataToPoint(a.getCenter());r[o]=s+1,i.setItemLayout(e,{point:l,offset:s})}}))}));// Show label of those region not has legendIcon (which is offset 0)
var o=n.getData();o.each((function(t){var e=o.getName(t),n=o.getItemLayout(t)||{};n.showLabel=!r[e],o.setItemLayout(t,n)})),e[i]=!0}}))}var YC=Pt,XC=/** @class */function(t){function e(e){var n=t.call(this)||this;return n.type="view",n.dimensions=["x","y"],
/**
                 * Represents the transform brought by roam/zoom.
                 * If `View['_viewRect']` applies roam transform,
                 * we can get the final displayed rect.
                 */
n._roamTransformable=new sr,
/**
                 * Represents the transform from `View['_rect']` to `View['_viewRect']`.
                 */
n._rawTransformable=new sr,n.name=e,n}return n(e,t),e.prototype.setBoundingRect=function(t,e,n,i){return this._rect=new Ce(t,e,n,i),this._rect},
/**
               * @return {module:zrender/core/BoundingRect}
               */
e.prototype.getBoundingRect=function(){return this._rect},e.prototype.setViewRect=function(t,e,n,i){this._transformTo(t,e,n,i),this._viewRect=new Ce(t,e,n,i)},
/**
               * Transformed to particular position and size
               */
e.prototype._transformTo=function(t,e,n,i){var r=this.getBoundingRect(),o=this._rawTransformable;o.transform=r.calculateTransform(new Ce(t,e,n,i));var a=o.parent;o.parent=null,o.decomposeTransform(),o.parent=a,this._updateTransform()},
/**
               * Set center of view
               */
e.prototype.setCenter=function(t,e){t&&(this._center=[Vr(t[0],e.getWidth()),Vr(t[1],e.getHeight())],this._updateCenterAndZoom())},e.prototype.setZoom=function(t){t=t||1;var e=this.zoomLimit;e&&(null!=e.max&&(t=Math.min(e.max,t)),null!=e.min&&(t=Math.max(e.min,t))),this._zoom=t,this._updateCenterAndZoom()},
/**
               * Get default center without roam
               */
e.prototype.getDefaultCenter=function(){// Rect before any transform
var t=this.getBoundingRect();return[t.x+t.width/2,t.y+t.height/2]},e.prototype.getCenter=function(){return this._center||this.getDefaultCenter()},e.prototype.getZoom=function(){return this._zoom||1},e.prototype.getRoamTransform=function(){return this._roamTransformable.getLocalTransform()},
/**
               * Remove roam
               */
e.prototype._updateCenterAndZoom=function(){// Must update after view transform updated
var t=this._rawTransformable.getLocalTransform(),e=this._roamTransformable,n=this.getDefaultCenter(),i=this.getCenter(),r=this.getZoom();i=Pt([],i,t),n=Pt([],n,t),e.originX=i[0],e.originY=i[1],e.x=n[0]-i[0],e.y=n[1]-i[1],e.scaleX=e.scaleY=r,this._updateTransform()},
/**
               * Update transform props on `this` based on the current
               * `this._roamTransformable` and `this._rawTransformable`.
               */
e.prototype._updateTransform=function(){var t=this._roamTransformable,e=this._rawTransformable;e.parent=t,t.updateTransform(),e.updateTransform(),he(this.transform||(this.transform=[]),e.transform||[1,0,0,1,0,0]),this._rawTransform=e.getLocalTransform(),this.invTransform=this.invTransform||[],ge(this.invTransform,this.transform),this.decomposeTransform()},e.prototype.getTransformInfo=function(){var t=this._rawTransformable,e=this._roamTransformable,n=new sr;return n.transform=e.transform,n.decomposeTransform(),{roam:{x:n.x,y:n.y,scaleX:n.scaleX,scaleY:n.scaleY},raw:{x:t.x,y:t.y,scaleX:t.scaleX,scaleY:t.scaleY}}},e.prototype.getViewRect=function(){return this._viewRect},
/**
               * Get view rect after roam transform
               */
e.prototype.getViewRectAfterRoam=function(){var t=this.getBoundingRect().clone();return t.applyTransform(this.transform),t},
/**
               * Convert a single (lon, lat) data item to (x, y) point.
               */
e.prototype.dataToPoint=function(t,e,n){var i=e?this._rawTransform:this.transform;return n=n||[],i?YC(n,t,i):xt(n,t)},
/**
               * Convert a (x, y) point to (lon, lat) data
               */
e.prototype.pointToData=function(t){var e=this.invTransform;return e?YC([],t,e):[t[0],t[1]]},e.prototype.convertToPixel=function(t,e,n){var i=UC(e);return i===this?i.dataToPoint(n):null},e.prototype.convertFromPixel=function(t,e,n){var i=UC(e);return i===this?i.pointToData(n):null},
/**
               * @implements
               */
e.prototype.containPoint=function(t){return this.getViewRectAfterRoam().contain(t[0],t[1])},e.dimensions=["x","y"],e}(sr);function UC(t){var e=t.seriesModel;return e?e.coordinateSystem:null;// e.g., graph.
}const ZC=XC;var jC={geoJSON:{aspectScale:.75,invertLongitute:!0},geoSVG:{aspectScale:1,invertLongitute:!1}},qC=["lng","lat"],KC=/** @class */function(t){function e(e,n,i){var r=t.call(this,e)||this;r.dimensions=qC,r.type="geo",// Only store specified name coord via `addGeoCoord`.
r._nameCoordMap=ct(),r.map=n;var o=i.projection,a=wC(n,i.nameMap,i.nameProperty),s=_C(n);r.resourceType=s?s.type:null;var l,u=r.regions=a.regions,h=jC[s.type];if(r._regionsMap=a.regionsMap,r.regions=a.regions,r.projection=o,o)// Can't reuse the raw bounding rect
for(var c=0;c<u.length;c++){var p=u[c].getBoundingRect(o);(l=l||p.clone()).union(p)}else l=a.boundingRect;return r.setBoundingRect(l.x,l.y,l.width,l.height),// aspectScale and invertLongitute actually is the parameters default raw projection.
// So we ignore them if projection is given.
// Ignore default aspect scale if projection exits.
r.aspectScale=o?1:Q(i.aspectScale,h.aspectScale),// Not invert longitude if projection exits.
r._invertLongitute=!o&&h.invertLongitute,r}return n(e,t),e.prototype._transformTo=function(t,e,n,i){var r=this.getBoundingRect(),o=this._invertLongitute;r=r.clone(),o&&(// Longitude is inverted.
r.y=-r.y-r.height);var a=this._rawTransformable;a.transform=r.calculateTransform(new Ce(t,e,n,i));var s=a.parent;a.parent=null,a.decomposeTransform(),a.parent=s,o&&(a.scaleY=-a.scaleY),this._updateTransform()},e.prototype.getRegion=function(t){return this._regionsMap.get(t)},e.prototype.getRegionByCoord=function(t){for(var e=this.regions,n=0;n<e.length;n++){var i=e[n];if("geoJSON"===i.type&&i.contain(t))return e[n]}},
/**
               * Add geoCoord for indexing by name
               */
e.prototype.addGeoCoord=function(t,e){this._nameCoordMap.set(t,e)},
/**
               * Get geoCoord by name
               */
e.prototype.getGeoCoord=function(t){var e=this._regionsMap.get(t);// Calculate center only on demand.
return this._nameCoordMap.get(t)||e&&e.getCenter()},e.prototype.dataToPoint=function(t,e,n){if(H(t)&&(// Map area name to geoCoord
t=this.getGeoCoord(t)),t){var i=this.projection;return i&&(// projection may return null point.
t=i.project(t)),t&&this.projectedToPoint(t,e,n)}},e.prototype.pointToData=function(t){var e=this.projection;return e&&(// projection may return null point.
t=e.unproject(t)),t&&this.pointToProjected(t)},
/**
               * Point to projected data. Same with pointToData when projection is used.
               */
e.prototype.pointToProjected=function(e){return t.prototype.pointToData.call(this,e)},e.prototype.projectedToPoint=function(e,n,i){return t.prototype.dataToPoint.call(this,e,n,i)},e.prototype.convertToPixel=function(t,e,n){var i=$C(e);return i===this?i.dataToPoint(n):null},e.prototype.convertFromPixel=function(t,e,n){var i=$C(e);return i===this?i.pointToData(n):null},e}(ZC);function $C(t){var e=t.geoModel,n=t.seriesModel;return e?e.coordinateSystem:n?n.coordinateSystem||(n.getReferringComponents("geo",Io).models[0]||{}).coordinateSystem:null}P(KC,ZC);const JC=KC;
/**
             * Resize method bound to the geo
             */function QC(t,e){var n=t.get("boundingCoords");if(null!=n){var i=n[0],r=n[1];if(isFinite(i[0])&&isFinite(i[1])&&isFinite(r[0])&&isFinite(r[1])){// Sample around the lng/lat rect and use projection to calculate actual bounding rect.
var o=this.projection;if(o){var a=i[0],s=i[1],l=r[0],u=r[1];i=[1/0,1/0],r=[-1/0,-1/0];// TODO better way?
var h=function(t,e,n,a){for(var s=n-t,l=a-e,u=0;u<=100;u++){var h=u/100,c=o.project([t+s*h,e+l*h]);Ot(i,i,c),Rt(r,r,c)}};// Top
h(a,s,l,s),// Right
h(l,s,l,u),// Bottom
h(l,u,a,u),// Left
h(a,u,l,s)}this.setBoundingRect(i[0],i[1],r[0]-i[0],r[1]-i[1])}}var c,p,d,f=this.getBoundingRect(),g=t.get("layoutCenter"),y=t.get("layoutSize"),v=e.getWidth(),m=e.getHeight(),x=f.width/f.height*this.aspectScale,_=!1;if(g&&y&&(c=[Vr(g[0],v),Vr(g[1],m)],p=Vr(y,Math.min(v,m)),isNaN(c[0])||isNaN(c[1])||isNaN(p)||(_=!0)),_)d={},x>1?(// Width is same with size
d.width=p,d.height=p/x):(d.height=p,d.width=p*x),d.y=c[1]-d.height/2,d.x=c[0]-d.width/2;else{// Use left/top/width/height
var b=t.getBoxLayoutParams();b.aspect=x,d=Rp(b,{width:v,height:m})}this.setViewRect(d.x,d.y,d.width,d.height),this.setCenter(t.get("center"),e),this.setZoom(t.get("zoom"))}// Back compat for ECharts2, where the coord map is set on map series:
// {type: 'map', geoCoord: {'cityA': [116.46,39.92], 'cityA': [119.12,24.61]}},
var tD=/** @class */function(){function t(){// For deciding which dimensions to use when creating list data
this.dimensions=qC}return t.prototype.create=function(t,e){var n=[];function i(t){return{nameProperty:t.get("nameProperty"),aspectScale:t.get("aspectScale"),projection:t.get("projection")}}// FIXME Create each time may be slow
t.eachComponent("geo",(function(t,r){var o=t.get("map"),a=new JC(o+r,o,A({nameMap:t.get("nameMap")},i(t)));a.zoomLimit=t.get("scaleLimit"),n.push(a),// setGeoCoords(geo, geoModel);
t.coordinateSystem=a,a.model=t,// Inject resize method
a.resize=QC,a.resize(t,e)})),t.eachSeries((function(t){if("geo"===t.get("coordinateSystem")){var e=t.get("geoIndex")||0;t.coordinateSystem=n[e]}}));// If has map series
var r={};return t.eachSeriesByType("map",(function(t){if(!t.getHostGeoModel()){var e=t.getMapType();r[e]=r[e]||[],r[e].push(t)}})),R(r,(function(t,r){var o=N(t,(function(t){return t.get("nameMap")})),a=new JC(r,r,A({nameMap:D(o)},i(t[0])));a.zoomLimit=J.apply(null,N(t,(function(t){return t.get("scaleLimit")}))),n.push(a),// Inject resize method
a.resize=QC,a.resize(t[0],e),R(t,(function(t){t.coordinateSystem=a,function(t,e){R(e.get("geoCoord"),(function(e,n){t.addGeoCoord(n,e)}))}(a,t)}))})),n},
/**
               * Fill given regions array
               */
t.prototype.getFilledRegions=function(t,e,n,i){for(// Not use the original
var r=(t||[]).slice(),o=ct(),a=0;a<r.length;a++)o.set(r[a].name,r[a]);return R(wC(e,n,i).regions,(function(t){var e=t.name;!o.get(e)&&r.push({name:e})})),r},t}();const eD=new tD;var nD=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(t,e,n){var i=_C(t.map);if(i&&"geoJSON"===i.type){var r=t.itemStyle=t.itemStyle||{};"color"in r||(r.color="#eee")}this.mergeDefaultAndTheme(t,n),// Default label emphasis `show`
uo(t,"label",["show"])},e.prototype.optionUpdated=function(){var t=this,e=this.option;e.regions=eD.getFilledRegions(e.regions,e.map,e.nameMap,e.nameProperty);var n={};this._optionModelMap=E(e.regions||[],(function(e,i){var r=i.name;return r&&(e.set(r,new Pc(i,t,t.ecModel)),i.selected&&(n[r]=!0)),e}),ct()),e.selectedMap||(e.selectedMap=n)},
/**
               * Get model of region.
               */
e.prototype.getRegionModel=function(t){return this._optionModelMap.get(t)||new Pc(null,this,this.ecModel)},
/**
               * Format label
               * @param name Region name
               */
e.prototype.getFormattedLabel=function(t,e){var n=this.getRegionModel(t),i="normal"===e?n.get(["label","formatter"]):n.get(["emphasis","label","formatter"]),r={name:t};return W(i)?(r.status=e,i(r)):H(i)?i.replace("{a}",null!=t?t:""):void 0},e.prototype.setZoom=function(t){this.option.zoom=t},e.prototype.setCenter=function(t){this.option.center=t},// PENGING If selectedMode is null ?
e.prototype.select=function(t){var e=this.option,n=e.selectedMode;n&&("multiple"!==n&&(e.selectedMap=null),(e.selectedMap||(e.selectedMap={}))[t]=!0)},e.prototype.unSelect=function(t){var e=this.option.selectedMap;e&&(e[t]=!1)},e.prototype.toggleSelected=function(t){this[this.isSelected(t)?"unSelect":"select"](t)},e.prototype.isSelected=function(t){var e=this.option.selectedMap;return!(!e||!e[t])},e.type="geo",e.layoutMode="box",e.defaultOption={// zlevel: 0,
z:0,show:!0,left:"center",top:"center",// Default value:
// for geoSVG source: 1,
// for geoJSON source: 0.75.
aspectScale:null,// /// Layout with center and size
// If you want to put map in a fixed size box with right aspect ratio
// This two properties may be more convenient
// layoutCenter: [50%, 50%]
// layoutSize: 100
silent:!1,// Map type
map:"",// Define left-top, right-bottom coords to control view
// For example, [ [180, 90], [-180, -90] ]
boundingCoords:null,// Default on center of map
center:null,zoom:1,scaleLimit:null,// selectedMode: false
label:{show:!1,color:"#000"},itemStyle:{borderWidth:.5,borderColor:"#444"},emphasis:{label:{show:!0,color:"rgb(100,0,0)"},itemStyle:{color:"rgba(255,215,0,0.8)"}},select:{label:{show:!0,color:"rgb(100,0,0)"},itemStyle:{color:"rgba(255,215,0,0.8)"}},regions:[]},e}(Wp);const iD=nD;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function rD(t,e){// Use projected coord as center because it's linear.
return t.pointToProjected?t.pointToProjected(e):t.pointToData(e)}function oD(t,e,n,i){var r=t.getZoom(),o=t.getCenter(),a=e.zoom,s=t.projectedToPoint?t.projectedToPoint(o):t.dataToPoint(o);if(null!=e.dx&&null!=e.dy&&(s[0]-=e.dx,s[1]-=e.dy,t.setCenter(rD(t,s),i)),null!=a){if(n){var l=n.min||0,u=n.max||1/0;a=Math.max(Math.min(r*a,u),l)/r}// Zoom on given point(originX, originY)
t.scaleX*=a,t.scaleY*=a;var h=(e.originX-t.x)*(a-1),c=(e.originY-t.y)*(a-1);t.x-=h,t.y-=c,t.updateTransform(),// Get the new center
t.setCenter(rD(t,s),i),t.setZoom(a*r)}return{center:t.getCenter(),zoom:t.getZoom()}}var aD=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.focusBlurEnabled=!0,n}return n(e,t),e.prototype.init=function(t,e){this._api=e},e.prototype.render=function(t,e,n,i){if(this._model=t,!t.get("show"))return this._mapDraw&&this._mapDraw.remove(),void(this._mapDraw=null);this._mapDraw||(this._mapDraw=new zC(n));var r=this._mapDraw;r.draw(t,e,n,this,i),r.group.on("click",this._handleRegionClick,this),r.group.silent=t.get("silent"),this.group.add(r.group),this.updateSelectStatus(t,e,n)},e.prototype._handleRegionClick=function(t){var e;Uy(t.target,(function(t){return null!=(e=js(t).eventData)}),!0),e&&this._api.dispatchAction({type:"geoToggleSelect",geoId:this._model.id,name:e.name})},e.prototype.updateSelectStatus=function(t,e,n){var i=this;this._mapDraw.group.traverse((function(t){var e=js(t).eventData;if(e)// No need to traverse children.
return i._model.isSelected(e.name)?n.enterSelect(t):n.leaveSelect(t),!0}))},e.prototype.findHighDownDispatchers=function(t){return this._mapDraw&&this._mapDraw.findHighDownDispatchers(t,this._model)},e.prototype.dispose=function(){this._mapDraw&&this._mapDraw.remove()},e.type="geo",e}(Bg);const sD=aD;function lD(t,e,n){xC(t,e,n)}function uD(t){function e(e,n){n.update="geo:updateSelectStatus",t.registerAction(n,(function(t,n){var i={},r=[];return n.eachComponent({mainType:"geo",query:t},(function(n){n[e](t.name),R(n.coordinateSystem.regions,(function(t){i[t.name]=n.isSelected(t.name)||!1}));// Notice: there might be duplicated name in different regions.
var o=[];R(i,(function(t,e){i[e]&&o.push(e)})),r.push({geoIndex:n.componentIndex,// Use singular, the same naming convention as the event `selectchanged`.
name:o})})),{selected:i,allSelected:r,name:t.name}}))}t.registerCoordinateSystem("geo",eD),t.registerComponentModel(iD),t.registerComponentView(sD),t.registerImpl("registerMap",lD),t.registerImpl("getMap",(function(t){return bC(t)})),e("toggleSelected",{type:"geoToggleSelect",event:"geoselectchanged"}),e("select",{type:"geoSelect",event:"geoselected"}),e("unSelect",{type:"geoUnSelect",event:"geounselected"}),
/**
               * @payload
               * @property {string} [componentType=series]
               * @property {number} [dx]
               * @property {number} [dy]
               * @property {number} [zoom]
               * @property {number} [originX]
               * @property {number} [originY]
               */
t.registerAction({type:"geoRoam",event:"geoRoam",update:"updateTransform"},(function(t,e,n){var i=t.componentType||"series";e.eachComponent({mainType:i,query:t},(function(e){var r=e.coordinateSystem;if("geo"===r.type){var o=oD(r,t,e.get("scaleLimit"),n);e.setCenter&&e.setCenter(o.center),e.setZoom&&e.setZoom(o.zoom),// All map series with same `map` use the same geo coordinate system
// So the center and zoom must be in sync. Include the series not selected by legend
"series"===i&&R(e.seriesGroup,(function(t){t.setCenter(o.center),t.setZoom(o.zoom)}))}}))}))}
/**
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             *
             * Computes a preliminary x coordinate for node. Before that, this function is
             * applied recursively to the children of node, as well as the function
             * apportion(). After spacing out the children by calling executeShifts(), the
             * node is placed to the midpoint of its outermost children.
             */
function hD(t,e){var n=t.isExpand?t.children:[],i=t.parentNode.children,r=t.hierNode.i?i[t.hierNode.i-1]:null;if(n.length){!
/**
             * All other shifts, applied to the smaller subtrees between w- and w+, are
             * performed by this function.
             *
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             */
function(t){for(var e=t.children,n=e.length,i=0,r=0;--n>=0;){var o=e[n];o.hierNode.prelim+=i,o.hierNode.modifier+=i,r+=o.hierNode.change,i+=o.hierNode.shift+r}}
/**
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             *
             * The core of the algorithm. Here, a new subtree is combined with the
             * previous subtrees. Threads are used to traverse the inside and outside
             * contours of the left and right subtree up to the highest common level.
             * Whenever two nodes of the inside contours conflict, we compute the left
             * one of the greatest uncommon ancestors using the function nextAncestor()
             * and call moveSubtree() to shift the subtree and prepare the shifts of
             * smaller subtrees. Finally, we add a new thread (if necessary).
             */(t);var o=(n[0].hierNode.prelim+n[n.length-1].hierNode.prelim)/2;r?(t.hierNode.prelim=r.hierNode.prelim+e(t,r),t.hierNode.modifier=t.hierNode.prelim-o):t.hierNode.prelim=o}else r&&(t.hierNode.prelim=r.hierNode.prelim+e(t,r));t.parentNode.hierNode.defaultAncestor=function(t,e,n,i){if(e){for(var r=t,o=t,a=o.parentNode.children[0],s=e,l=r.hierNode.modifier,u=o.hierNode.modifier,h=a.hierNode.modifier,c=s.hierNode.modifier;s=fD(s),o=gD(o),s&&o;){r=fD(r),a=gD(a),r.hierNode.ancestor=t;var p=s.hierNode.prelim+c-o.hierNode.prelim-u+i(s,o);p>0&&(vD(yD(s,t,n),t,p),u+=p,l+=p),c+=s.hierNode.modifier,u+=o.hierNode.modifier,l+=r.hierNode.modifier,h+=a.hierNode.modifier}s&&!fD(r)&&(r.hierNode.thread=s,r.hierNode.modifier+=c-l),o&&!gD(a)&&(a.hierNode.thread=o,a.hierNode.modifier+=u-h,n=t)}return n}
/**
             * This function is used to traverse the right contour of a subtree.
             * It returns the rightmost child of node or the thread of node. The function
             * returns null if and only if node is on the highest depth of its subtree.
             */(t,r,t.parentNode.hierNode.defaultAncestor||i[0],e)}
/**
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             *
             * Computes all real x-coordinates by summing up the modifiers recursively.
             */function cD(t){var e=t.hierNode.prelim+t.parentNode.hierNode.modifier;t.setLayout({x:e},!0),t.hierNode.modifier+=t.parentNode.hierNode.modifier}function pD(t){return arguments.length?t:mD}
/**
             * Transform the common coordinate to radial coordinate.
             */function dD(t,e){return t-=Math.PI/2,{x:e*Math.cos(t),y:e*Math.sin(t)}}
/**
             * Get the layout position of the whole view.
             */function fD(t){var e=t.children;return e.length&&t.isExpand?e[e.length-1]:t.hierNode.thread}
/**
             * This function is used to traverse the left contour of a subtree (or a subforest).
             * It returns the leftmost child of node or the thread of node. The function
             * returns null if and only if node is on the highest depth of its subtree.
             */function gD(t){var e=t.children;return e.length&&t.isExpand?e[0]:t.hierNode.thread}
/**
             * If nodeInLefts ancestor is a sibling of node, returns nodeInLefts ancestor.
             * Otherwise, returns the specified ancestor.
             */function yD(t,e,n){return t.hierNode.ancestor.parentNode===e.parentNode?t.hierNode.ancestor:n}
/**
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             *
             * Shifts the current subtree rooted at wr.
             * This is done by increasing prelim(w+) and modifier(w+) by shift.
             */function vD(t,e,n){var i=n/(e.hierNode.i-t.hierNode.i);e.hierNode.change-=i,e.hierNode.shift+=n,e.hierNode.modifier+=n,e.hierNode.prelim+=n,t.hierNode.change+=i}
/**
             * The implementation of this function was originally copied from "d3.js"
             * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             */function mD(t,e){return t.parentNode===e.parentNode?1:2}var xD=function(){this.parentPoint=[],this.childPoints=[]},_D=/** @class */function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new xD},e.prototype.buildPath=function(t,e){var n=e.childPoints,i=n.length,r=e.parentPoint,o=n[0],a=n[i-1];if(1===i)return t.moveTo(r[0],r[1]),void t.lineTo(o[0],o[1]);var s=e.orient,l="TB"===s||"BT"===s?0:1,u=1-l,h=Vr(e.forkPosition,1),c=[];c[l]=r[l],c[u]=r[u]+(a[u]-r[u])*h,t.moveTo(r[0],r[1]),t.lineTo(c[0],c[1]),t.moveTo(o[0],o[1]),c[l]=o[l],t.lineTo(c[0],c[1]),c[l]=a[l],t.lineTo(c[0],c[1]),t.lineTo(a[0],a[1]);for(var p=1;p<i-1;p++){var d=n[p];t.moveTo(d[0],d[1]),c[l]=d[l],t.lineTo(c[0],c[1])}},e}(ys),bD=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._mainGroup=new Lr,n}return n(e,t),e.prototype.init=function(t,e){this._controller=new RT(e.getZr()),this._controllerHost={target:this.group},this.group.add(this._mainGroup)},e.prototype.render=function(t,e,n){var i=t.getData(),r=t.layoutInfo,o=this._mainGroup;"radial"===t.get("layout")?(o.x=r.x+r.width/2,o.y=r.y+r.height/2):(o.x=r.x,o.y=r.y),this._updateViewCoordSys(t,n),this._updateController(t,e,n);var a=this._data;i.diff(a).add((function(e){wD(i,e)&&// Create node and edge
SD(i,e,null,o,t)})).update((function(e,n){var r=a.getItemGraphicEl(n);wD(i,e)?// Update node and edge
SD(i,e,r,o,t):r&&TD(a,n,r,o,t)})).remove((function(e){var n=a.getItemGraphicEl(e);// When remove a collapsed node of subtree, since the collapsed
// node haven't been initialized with a symbol element,
// you can't found it's symbol element through index.
// so if we want to remove the symbol element we should insure
// that the symbol element is not null.
n&&TD(a,e,n,o,t)})).execute(),this._nodeScaleRatio=t.get("nodeScaleRatio"),this._updateNodeAndLinkScale(t),!0===t.get("expandAndCollapse")&&i.eachItemGraphicEl((function(e,i){e.off("click").on("click",(function(){n.dispatchAction({type:"treeExpandAndCollapse",seriesId:t.id,dataIndex:i})}))})),this._data=i},e.prototype._updateViewCoordSys=function(t,e){var n=t.getData(),i=[];n.each((function(t){var e=n.getItemLayout(t);!e||isNaN(e.x)||isNaN(e.y)||i.push([+e.x,+e.y])}));var r=[],o=[];Sa(i,r,o);// If don't Store min max when collapse the root node after roam,
// the root node will disappear.
var a=this._min,s=this._max;// If width or height is 0
o[0]-r[0]==0&&(r[0]=a?a[0]:r[0]-1,o[0]=s?s[0]:o[0]+1),o[1]-r[1]==0&&(r[1]=a?a[1]:r[1]-1,o[1]=s?s[1]:o[1]+1);var l=t.coordinateSystem=new ZC;l.zoomLimit=t.get("scaleLimit"),l.setBoundingRect(r[0],r[1],o[0]-r[0],o[1]-r[1]),l.setCenter(t.get("center"),e),l.setZoom(t.get("zoom")),// Here we use viewCoordSys just for computing the 'position' and 'scale' of the group
this.group.attr({x:l.x,y:l.y,scaleX:l.scaleX,scaleY:l.scaleY}),this._min=r,this._max=o},e.prototype._updateController=function(t,e,n){var i=this,r=this._controller,o=this._controllerHost,a=this.group;r.setPointerChecker((function(e,i,r){var o=a.getBoundingRect();return o.applyTransform(a.transform),o.contain(i,r)&&!BT(e,n,t)})),r.enable(t.get("roam")),o.zoomLimit=t.get("scaleLimit"),o.zoom=t.coordinateSystem.getZoom(),r.off("pan").off("zoom").on("pan",(function(e){NT(o,e.dx,e.dy),n.dispatchAction({seriesId:t.id,type:"treeRoam",dx:e.dx,dy:e.dy})})).on("zoom",(function(e){ET(o,e.scale,e.originX,e.originY),n.dispatchAction({seriesId:t.id,type:"treeRoam",zoom:e.scale,originX:e.originX,originY:e.originY}),i._updateNodeAndLinkScale(t),// Only update label layout on zoom
n.updateLabelLayout()}))},e.prototype._updateNodeAndLinkScale=function(t){var e=t.getData(),n=this._getNodeGlobalScale(t);e.eachItemGraphicEl((function(t,e){t.setSymbolScale(n)}))},e.prototype._getNodeGlobalScale=function(t){var e=t.coordinateSystem;if("view"!==e.type)return 1;var n=this._nodeScaleRatio,i=e.scaleX||1;return((e.getZoom()-1)*n+1)/i},e.prototype.dispose=function(){this._controller&&this._controller.dispose(),this._controllerHost=null},e.prototype.remove=function(){this._mainGroup.removeAll(),this._data=null},e.type="tree",e}(qg);function wD(t,e){var n=t.getItemLayout(e);return n&&!isNaN(n.x)&&!isNaN(n.y)}function SD(t,e,n,i,r){var o=!n,a=t.tree.getNodeByDataIndex(e),s=a.getModel(),l=a.getVisual("style").fill,u=!1===a.isExpand&&0!==a.children.length?l:"#fff",h=t.tree.root,c=a.parentNode===h?a:a.parentNode||a,p=t.getItemGraphicEl(c.dataIndex),d=c.getLayout(),f=p?{x:p.__oldX,y:p.__oldY,rawX:p.__radialOldRawX,rawY:p.__radialOldRawY}:d,g=a.getLayout();o?((n=new bS(t,e,null,{symbolInnerColor:u,useNameLabel:!0})).x=f.x,n.y=f.y):n.updateData(t,e,null,{symbolInnerColor:u,useNameLabel:!0}),n.__radialOldRawX=n.__radialRawX,n.__radialOldRawY=n.__radialRawY,n.__radialRawX=g.rawX,n.__radialRawY=g.rawY,i.add(n),t.setItemGraphicEl(e,n),n.__oldX=n.x,n.__oldY=n.y,Sh(n,{x:g.x,y:g.y},r);var y=n.getSymbolPath();if("radial"===r.get("layout")){var v=h.children[0],m=v.getLayout(),x=v.children.length,_=void 0,b=void 0;if(g.x===m.x&&!0===a.isExpand&&v.children.length){var w={x:(v.children[0].getLayout().x+v.children[x-1].getLayout().x)/2,y:(v.children[0].getLayout().y+v.children[x-1].getLayout().y)/2};(_=Math.atan2(w.y-m.y,w.x-m.x))<0&&(_=2*Math.PI+_),(b=w.x<m.x)&&(_-=Math.PI)}else(_=Math.atan2(g.y-m.y,g.x-m.x))<0&&(_=2*Math.PI+_),0===a.children.length||0!==a.children.length&&!1===a.isExpand?(b=g.x<m.x)&&(_-=Math.PI):(b=g.x>m.x)||(_-=Math.PI);var S=b?"left":"right",M=s.getModel("label"),I=M.get("rotate"),T=I*(Math.PI/180),C=y.getTextContent();C&&(y.setTextConfig({position:M.get("position")||S,rotation:null==I?-_:T,origin:"center"}),C.setStyle("verticalAlign","middle"))}// Handle status
var D=s.get(["emphasis","focus"]),A="relative"===D?pt(a.getAncestorsIndices(),a.getDescendantIndices()):"ancestor"===D?a.getAncestorsIndices():"descendant"===D?a.getDescendantIndices():null;A&&(// Modify the focus to data indices.
js(n).focus=A),function(t,e,n,i,r,o,a,s){var l=e.getModel(),u=t.get("edgeShape"),h=t.get("layout"),c=t.getOrient(),p=t.get(["lineStyle","curveness"]),d=t.get("edgeForkPosition"),f=l.getModel("lineStyle").getLineStyle(),g=i.__edge;// curve edge from node -> parent
// polyline edge from node -> children
if("curve"===u)e.parentNode&&e.parentNode!==n&&(g||(g=i.__edge=new th({shape:CD(h,c,p,r,r)})),Sh(g,{shape:CD(h,c,p,o,a)},t));else if("polyline"===u&&"orthogonal"===h&&e!==n&&e.children&&0!==e.children.length&&!0===e.isExpand){for(var y=e.children,v=[],m=0;m<y.length;m++){var x=y[m].getLayout();v.push([x.x,x.y])}g||(g=i.__edge=new _D({shape:{parentPoint:[a.x,a.y],childPoints:[[a.x,a.y]],orient:c,forkPosition:d}})),Sh(g,{shape:{parentPoint:[a.x,a.y],childPoints:v}},t)}// show all edge when edgeShape is 'curve', filter node `isExpand` is false when edgeShape is 'polyline'
g&&("polyline"!==u||e.isExpand)&&(g.useStyle(k({strokeNoScale:!0,fill:null},f)),Hl(g,l,"lineStyle"),wl(g),s.add(g))}(r,a,h,n,f,d,g,i),n.__edge&&(n.onHoverStateChange=function(e){if("blur"!==e){// NOTE: Ensure the parent elements will been blurred firstly.
// According to the return of getAncestorsIndices and getDescendantIndices
// TODO: A bit tricky.
var i=a.parentNode&&t.getItemGraphicEl(a.parentNode.dataIndex);i&&1===i.hoverState||_l(n.__edge,e)}})}function MD(t,e,n,i,r){var o=ID(e.tree.root,t),a=o.source,s=o.sourceLayout,l=e.getItemGraphicEl(t.dataIndex);if(l){var u=e.getItemGraphicEl(a.dataIndex).__edge,h=l.__edge||(!1===a.isExpand||1===a.children.length?u:void 0),c=i.get("edgeShape"),p=i.get("layout"),d=i.get("orient"),f=i.get(["lineStyle","curveness"]);h&&("curve"===c?Th(h,{shape:CD(p,d,f,s,s),style:{opacity:0}},i,{cb:function(){n.remove(h)},removeOpt:r}):"polyline"===c&&"orthogonal"===i.get("layout")&&Th(h,{shape:{parentPoint:[s.x,s.y],childPoints:[[s.x,s.y]]},style:{opacity:0}},i,{cb:function(){n.remove(h)},removeOpt:r}))}}function ID(t,e){for(var n,i=e.parentNode===t?e:e.parentNode||e;null==(n=i.getLayout());)i=i.parentNode===t?i:i.parentNode||i;return{source:i,sourceLayout:n}}function TD(t,e,n,i,r){var o=t.tree.getNodeByDataIndex(e),a=ID(t.tree.root,o).sourceLayout,s={duration:r.get("animationDurationUpdate"),easing:r.get("animationEasingUpdate")};Th(n,{x:a.x+1,y:a.y+1},r,{cb:function(){i.remove(n),t.setItemGraphicEl(e,null)},removeOpt:s}),n.fadeOut(null,t.hostModel,{fadeLabel:!0,animation:s}),// remove edge as parent node
o.children.forEach((function(e){MD(e,t,i,r,s)})),// remove edge as child node
MD(o,t,i,r,s)}function CD(t,e,n,i,r){var o,a,s,l,u,h,c,p;if("radial"===t){u=i.rawX,c=i.rawY,h=r.rawX,p=r.rawY;var d=dD(u,c),f=dD(u,c+(p-c)*n),g=dD(h,p+(c-p)*n),y=dD(h,p);return{x1:d.x||0,y1:d.y||0,x2:y.x||0,y2:y.y||0,cpx1:f.x||0,cpy1:f.y||0,cpx2:g.x||0,cpy2:g.y||0}}return u=i.x,c=i.y,h=r.x,p=r.y,"LR"!==e&&"RL"!==e||(o=u+(h-u)*n,a=c,s=h+(u-h)*n,l=p),"TB"!==e&&"BT"!==e||(o=u,a=c+(p-c)*n,s=h,l=p+(c-p)*n),{x1:u,y1:c,x2:h,y2:p,cpx1:o,cpy1:a,cpx2:s,cpy2:l}}const DD=bD;var AD=bo();function kD(t){var e=t.mainData,n=t.datas;n||(n={main:e},t.datasAttr={main:"data"}),t.datas=t.mainData=null,ED(e,n,t),// Porxy data original methods.
R(n,(function(n){R(e.TRANSFERABLE_METHODS,(function(e){n.wrapMethod(e,F(LD,t))}))})),// Beyond transfer, additional features should be added to `cloneShallow`.
e.wrapMethod("cloneShallow",F(OD,t)),// Only mainData trigger change, because struct.update may trigger
// another changable methods, which may bring about dead lock.
R(e.CHANGABLE_METHODS,(function(n){e.wrapMethod(n,F(PD,t))})),// Make sure datas contains mainData.
it(n[e.dataType]===e)}function LD(t,e){if(AD(i=this).mainData===i){// Transfer datas to new main data.
var n=A({},AD(this).datas);n[this.dataType]=e,ED(e,n,t)}else// Modify the reference in main data to point newData.
zD(e,this.dataType,AD(this).mainData,t);var i;return e}function PD(t,e){return t.struct&&t.struct.update(),e}function OD(t,e){// cloneShallow, which brings about some fragilities, may be inappropriate
// to be exposed as an API. So for implementation simplicity we can make
// the restriction that cloneShallow of not-mainData should not be invoked
// outside, but only be invoked here.
return R(AD(e).datas,(function(n,i){n!==e&&zD(n.cloneShallow(),i,e,t)})),e}
/**
             * Supplement method to List.
             *
             * @public
             * @param [dataType] If not specified, return mainData.
             */function RD(t){var e=AD(this).mainData;return null==t||null==e?e:AD(e).datas[t]}
/**
             * Get list of all linked data
             */function ND(){var t=AD(this).mainData;return null==t?[{data:t}]:N(V(AD(t).datas),(function(e){return{type:e,data:AD(t).datas[e]}}))}function ED(t,e,n){AD(t).datas={},R(e,(function(e,i){zD(e,i,t,n)}))}function zD(t,e,n,i){AD(n).datas[e]=t,AD(t).mainData=n,t.dataType=e,i.struct&&(t[i.structAttr]=i.struct,i.struct[i.datasAttr[e]]=t),// Supplement method.
t.getLinkedData=RD,t.getLinkedDataAll=ND}var VD=/** @class */function(){function t(t,e){this.depth=0,this.height=0,
/**
                 * Reference to list item.
                 * Do not persistent dataIndex outside,
                 * besause it may be changed by list.
                 * If dataIndex -1,
                 * this node is logical deleted (filtered) in list.
                 */
this.dataIndex=-1,this.children=[],this.viewChildren=[],this.isExpand=!1,this.name=t||"",this.hostTree=e}
/**
               * The node is removed.
               */return t.prototype.isRemoved=function(){return this.dataIndex<0},t.prototype.eachNode=function(t,e,n){W(t)&&(n=e,e=t,t=null),H(t=t||{})&&(t={order:t});var i,r=t.order||"preorder",o=this[t.attr||"children"];"preorder"===r&&(i=e.call(n,this));for(var a=0;!i&&a<o.length;a++)o[a].eachNode(t,e,n);"postorder"===r&&e.call(n,this)},
/**
               * Update depth and height of this subtree.
               */
t.prototype.updateDepthAndHeight=function(t){var e=0;this.depth=t;for(var n=0;n<this.children.length;n++){var i=this.children[n];i.updateDepthAndHeight(t+1),i.height>e&&(e=i.height)}this.height=e+1},t.prototype.getNodeById=function(t){if(this.getId()===t)return this;for(var e=0,n=this.children,i=n.length;e<i;e++){var r=n[e].getNodeById(t);if(r)return r}},t.prototype.contains=function(t){if(t===this)return!0;for(var e=0,n=this.children,i=n.length;e<i;e++){var r=n[e].contains(t);if(r)return r}},
/**
               * @param includeSelf Default false.
               * @return order: [root, child, grandchild, ...]
               */
t.prototype.getAncestors=function(t){for(var e=[],n=t?this:this.parentNode;n;)e.push(n),n=n.parentNode;return e.reverse(),e},t.prototype.getAncestorsIndices=function(){for(var t=[],e=this;e;)t.push(e.dataIndex),e=e.parentNode;return t.reverse(),t},t.prototype.getDescendantIndices=function(){var t=[];return this.eachNode((function(e){t.push(e.dataIndex)})),t},t.prototype.getValue=function(t){var e=this.hostTree.data;return e.getStore().get(e.getDimensionIndex(t||"value"),this.dataIndex)},t.prototype.setLayout=function(t,e){this.dataIndex>=0&&this.hostTree.data.setItemLayout(this.dataIndex,t,e)},
/**
               * @return {Object} layout
               */
t.prototype.getLayout=function(){return this.hostTree.data.getItemLayout(this.dataIndex)},// @depcrecated
// getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>
// eslint-disable-next-line @typescript-eslint/no-unused-vars
t.prototype.getModel=function(t){if(!(this.dataIndex<0))return this.hostTree.data.getItemModel(this.dataIndex).getModel(t)},// TODO: TYPE More specific model
t.prototype.getLevelModel=function(){return(this.hostTree.levelModels||[])[this.depth]},t.prototype.setVisual=function(t,e){this.dataIndex>=0&&this.hostTree.data.setItemVisual(this.dataIndex,t,e)},
/**
               * Get item visual
               * FIXME: make return type better
               */
t.prototype.getVisual=function(t){return this.hostTree.data.getItemVisual(this.dataIndex,t)},t.prototype.getRawIndex=function(){return this.hostTree.data.getRawIndex(this.dataIndex)},t.prototype.getId=function(){return this.hostTree.data.getId(this.dataIndex)},
/**
               * index in parent's children
               */
t.prototype.getChildIndex=function(){if(this.parentNode){for(var t=this.parentNode.children,e=0;e<t.length;++e)if(t[e]===this)return e;return-1}return-1},
/**
               * if this is an ancestor of another node
               *
               * @param node another node
               * @return if is ancestor
               */
t.prototype.isAncestorOf=function(t){for(var e=t.parentNode;e;){if(e===this)return!0;e=e.parentNode}return!1},
/**
               * if this is an descendant of another node
               *
               * @param node another node
               * @return if is descendant
               */
t.prototype.isDescendantOf=function(t){return t!==this&&t.isAncestorOf(this)},t}(),BD=/** @class */function(){function t(t){this.type="tree",this._nodes=[],this.hostModel=t}return t.prototype.eachNode=function(t,e,n){this.root.eachNode(t,e,n)},t.prototype.getNodeByDataIndex=function(t){var e=this.data.getRawIndex(t);return this._nodes[e]},t.prototype.getNodeById=function(t){return this.root.getNodeById(t)},
/**
               * Update item available by list,
               * when list has been performed options like 'filterSelf' or 'map'.
               */
t.prototype.update=function(){for(var t=this.data,e=this._nodes,n=0,i=e.length;n<i;n++)e[n].dataIndex=-1;for(n=0,i=t.count();n<i;n++)e[t.getRawIndex(n)].dataIndex=n},
/**
               * Clear all layouts
               */
t.prototype.clearLayouts=function(){this.data.clearItemLayouts()},
/**
               * data node format:
               * {
               *     name: ...
               *     value: ...
               *     children: [
               *         {
               *             name: ...
               *             value: ...
               *             children: ...
               *         },
               *         ...
               *     ]
               * }
               */
t.createTree=function(e,n,i){var r=new t(n),o=[],a=1;!function t(e,n){var i=e.value;a=Math.max(a,G(i)?i.length:1),o.push(e);var s=new VD(vo(e.name,""),r);n?
/**
             * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
             * so this function is not ready and not necessary to be public.
             */
function(t,e){var n=e.children;t.parentNode!==e&&(n.push(t),t.parentNode=e)}(s,n):r.root=s,r._nodes.push(s);var l=e.children;if(l)for(var u=0;u<l.length;u++)t(l[u],s)}(e),r.root.updateDepthAndHeight(0);var s=mx(o,{coordDimensions:["value"],dimensionsCount:a}).dimensions,l=new vx(s,n);return l.initData(o),i&&i(l),kD({mainData:l,struct:r,structAttr:"tree"}),r.update(),r},t}();const FD=BD;function GD(t,e,n){if(t&&L(e,t.type)>=0){var i=n.getData().tree.root,r=t.targetNode;if(H(r)&&(r=i.getNodeById(r)),r&&i.contains(r))return{node:r};var o=t.targetNodeId;if(null!=o&&(r=i.getNodeById(o)))return{node:r}}}// Not includes the given node at the last item.
function WD(t){for(var e=[];t;)(t=t.parentNode)&&e.push(t);return e.reverse()}function HD(t,e){return L(WD(t),e)>=0}// From root to the input node (the input node will be included).
function YD(t,e){for(var n=[];t;){var i=t.dataIndex;n.push({name:t.name,dataIndex:i,value:e.getRawValue(i)}),t=t.parentNode}return n.reverse(),n}var XD=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.hasSymbolVisual=!0,// Do it self.
e.ignoreStyleOnData=!0,e}
/**
               * Init a tree data structure from data in option series
               */return n(e,t),e.prototype.getInitialData=function(t){// create a virtual root
var e={name:t.name,children:t.data},n=t.leaves||{},i=new Pc(n,this,this.ecModel),r=FD.createTree(e,this,(function(t){t.wrapMethod("getItemModel",(function(t,e){var n=r.getNodeByDataIndex(e);return n&&n.children.length&&n.isExpand||(t.parentModel=i),t}))})),o=0;r.eachNode("preorder",(function(t){t.depth>o&&(o=t.depth)}));var a=t.expandAndCollapse&&t.initialTreeDepth>=0?t.initialTreeDepth:o;return r.root.eachNode("preorder",(function(t){var e=t.hostTree.data.getRawDataItem(t.dataIndex);// Add item.collapsed != null, because users can collapse node original in the series.data.
t.isExpand=e&&null!=e.collapsed?!e.collapsed:t.depth<=a})),r.data},
/**
               * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
               * @returns {string} orient
               */
e.prototype.getOrient=function(){var t=this.get("orient");return"horizontal"===t?t="LR":"vertical"===t&&(t="TB"),t},e.prototype.setZoom=function(t){this.option.zoom=t},e.prototype.setCenter=function(t){this.option.center=t},e.prototype.formatTooltip=function(t,e,n){for(var i=this.getData().tree,r=i.root.children[0],o=i.getNodeByDataIndex(t),a=o.getValue(),s=o.name;o&&o!==r;)s=o.parentNode.name+"."+s,o=o.parentNode;return dg("nameValue",{name:s,value:a,noValue:isNaN(a)||null==a})},// Add tree path to tooltip param
e.prototype.getDataParams=function(e){var n=t.prototype.getDataParams.apply(this,arguments),i=this.getData().tree.getNodeByDataIndex(e);return n.treeAncestors=YD(i,this),n.collapsed=!i.isExpand,n},e.type="series.tree",// can support the position parameters 'left', 'top','right','bottom', 'width',
// 'height' in the setOption() with 'merge' mode normal.
e.layoutMode="box",e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"view",// the position of the whole view
left:"12%",top:"12%",right:"12%",bottom:"12%",// the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
layout:"orthogonal",// value can be 'polyline'
edgeShape:"curve",edgeForkPosition:"50%",// true | false | 'move' | 'scale', see module:component/helper/RoamController.
roam:!1,// Symbol size scale ratio in roam
nodeScaleRatio:.4,// Default on center of graph
center:null,zoom:1,orient:"LR",symbol:"emptyCircle",symbolSize:7,expandAndCollapse:!0,initialTreeDepth:2,lineStyle:{color:"#ccc",width:1.5,curveness:.5},itemStyle:{color:"lightsteelblue",// borderColor: '#c23531',
borderWidth:1.5},label:{show:!0},animationEasing:"linear",animationDuration:700,animationDurationUpdate:500},e}(zg);const UD=XD;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * Traverse the tree from bottom to top and do something
             */
/**
             * Traverse the tree from top to bottom and do something
             */
function ZD(t,e){for(var n,i=[t];n=i.pop();)if(// jshint ignore:line
e(n),n.isExpand){var r=n.children;if(r.length)for(var o=r.length-1;o>=0;o--)i.push(r[o])}}function jD(t,e){t.eachSeriesByType("tree",(function(t){!function(t,e){var n=function(t,e){return Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()})}(t,e);t.layoutInfo=n;var i=t.get("layout"),r=0,o=0,a=null;"radial"===i?(r=2*Math.PI,o=Math.min(n.height,n.width)/2,a=pD((function(t,e){return(t.parentNode===e.parentNode?1:2)/t.depth}))):(r=n.width,o=n.height,a=pD());var s=t.getData().tree.root,l=s.children[0];if(l){!
/**
             * Initialize all computational message for following algorithm.
             */
function(t){var e=t;e.hierNode={defaultAncestor:null,ancestor:e,prelim:0,modifier:0,change:0,shift:0,i:0,thread:null};for(var n,i,r=[e];n=r.pop();)if(// jshint ignore:line
i=n.children,n.isExpand&&i.length)for(var o=i.length-1;o>=0;o--){var a=i[o];a.hierNode={defaultAncestor:null,ancestor:a,prelim:0,modifier:0,change:0,shift:0,i:o,thread:null},r.push(a)}}(s),function(t,e,n){for(var i,r=[t],o=[];i=r.pop();)if(// jshint ignore:line
o.push(i),i.isExpand){var a=i.children;if(a.length)for(var s=0;s<a.length;s++)r.push(a[s])}for(;i=o.pop();)// jshint ignore:line
e(i,n)}(l,hD,a),s.hierNode.modifier=-l.hierNode.prelim,ZD(l,cD);var u=l,h=l,c=l;ZD(l,(function(t){var e=t.getLayout().x;e<u.getLayout().x&&(u=t),e>h.getLayout().x&&(h=t),t.depth>c.depth&&(c=t)}));var p=u===h?1:a(u,h)/2,d=p-u.getLayout().x,f=0,g=0,y=0,v=0;if("radial"===i)f=r/(h.getLayout().x+p+d),// here we use (node.depth - 1), bucause the real root's depth is 1
g=o/(c.depth-1||1),ZD(l,(function(t){y=(t.getLayout().x+d)*f,v=(t.depth-1)*g;var e=dD(y,v);t.setLayout({x:e.x,y:e.y,rawX:y,rawY:v},!0)}));else{var m=t.getOrient();"RL"===m||"LR"===m?(g=o/(h.getLayout().x+p+d),f=r/(c.depth-1||1),ZD(l,(function(t){v=(t.getLayout().x+d)*g,y="LR"===m?(t.depth-1)*f:r-(t.depth-1)*f,t.setLayout({x:y,y:v},!0)}))):"TB"!==m&&"BT"!==m||(f=r/(h.getLayout().x+p+d),g=o/(c.depth-1||1),ZD(l,(function(t){y=(t.getLayout().x+d)*f,v="TB"===m?(t.depth-1)*g:o-(t.depth-1)*g,t.setLayout({x:y,y:v},!0)})))}}}(t,e)}))}function qD(t){t.eachSeriesByType("tree",(function(t){var e=t.getData();e.tree.eachNode((function(t){var n=t.getModel().getModel("itemStyle").getItemStyle();// TODO Optimize
A(e.ensureUniqueItemVisual(t.dataIndex,"style"),n)}))}))}var KD=["treemapZoomToNode","treemapRender","treemapMove"];function $D(t){var e=t.getData().tree,n={};e.eachNode((function(e){for(// Use decal of level 1 node
var i=e;i&&i.depth>1;)i=i.parentNode;var r=vd(t.ecModel,i.name||i.dataIndex+"",n);e.setVisual("decal",r)}))}var JD=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.preventUsingHoverLayer=!0,n}
/**
               * @override
               */return n(e,t),e.prototype.getInitialData=function(t,e){// Create a virtual root.
var n={name:t.name,children:t.data};QD(n);var i=t.levels||[],r=this.designatedVisualItemStyle={},o=new Pc({itemStyle:r},this,e);// Used in "visual priority" in `treemapVisual.js`.
// This way is a little tricky, must satisfy the precondition:
//   1. There is no `treeNode.getModel('itemStyle.xxx')` used.
//   2. The `Model.prototype.getModel()` will not use any clone-like way.
i=t.levels=
/**
             * set default to level configuration
             */
function(t,e){var n,i,r=lo(e.get("color")),o=lo(e.get(["aria","decal","decals"]));if(r){R(t=t||[],(function(t){var e=new Pc(t),r=e.get("color"),o=e.get("decal");(e.get(["itemStyle","color"])||r&&"none"!==r)&&(n=!0),(e.get(["itemStyle","decal"])||o&&"none"!==o)&&(i=!0)}));var a=t[0]||(t[0]={});return n||(a.color=r.slice()),!i&&o&&(a.decal=o.slice()),t}}(i,e);var a=N(i||[],(function(t){return new Pc(t,o,e)}),this),s=FD.createTree(n,this,(function(t){t.wrapMethod("getItemModel",(function(t,e){var n=s.getNodeByDataIndex(e),i=n?a[n.depth]:null;// If no levelModel, we also need `designatedVisualModel`.
return t.parentModel=i||o,t}))}));// Make sure always a new tree is created when setOption,
// in TreemapView, we check whether oldTree === newTree
// to choose mappings approach among old shapes and new shapes.
return s.data},e.prototype.optionUpdated=function(){this.resetViewRoot()},
/**
               * @override
               * @param {number} dataIndex
               * @param {boolean} [mutipleSeries=false]
               */
e.prototype.formatTooltip=function(t,e,n){var i=this.getData(),r=this.getRawValue(t);return dg("nameValue",{name:i.getName(t),value:r})},
/**
               * Add tree path to tooltip param
               *
               * @override
               * @param {number} dataIndex
               * @return {Object}
               */
e.prototype.getDataParams=function(e){var n=t.prototype.getDataParams.apply(this,arguments),i=this.getData().tree.getNodeByDataIndex(e);return n.treeAncestors=YD(i,this),// compatitable the previous code.
n.treePathInfo=n.treeAncestors,n},
/**
               * @public
               * @param {Object} layoutInfo {
               *                                x: containerGroup x
               *                                y: containerGroup y
               *                                width: containerGroup width
               *                                height: containerGroup height
               *                            }
               */
e.prototype.setLayoutInfo=function(t){
/**
                 * @readOnly
                 * @type {Object}
                 */
this.layoutInfo=this.layoutInfo||{},A(this.layoutInfo,t)},
/**
               * @param  {string} id
               * @return {number} index
               */
e.prototype.mapIdToIndex=function(t){// A feature is implemented:
// index is monotone increasing with the sequence of
// input id at the first time.
// This feature can make sure that each data item and its
// mapped color have the same index between data list and
// color list at the beginning, which is useful for user
// to adjust data-color mapping.
/**
                 * @private
                 * @type {Object}
                 */
var e=this._idIndexMap;e||(e=this._idIndexMap=ct(),
/**
                   * @private
                   * @type {number}
                   */
this._idIndexMapCount=0);var n=e.get(t);return null==n&&e.set(t,n=this._idIndexMapCount++),n},e.prototype.getViewRoot=function(){return this._viewRoot},e.prototype.resetViewRoot=function(t){t?this._viewRoot=t:t=this._viewRoot;var e=this.getRawData().tree.root;t&&(t===e||e.contains(t))||(this._viewRoot=e)},e.prototype.enableAriaDecal=function(){$D(this)},e.type="series.treemap",e.layoutMode="box",e.defaultOption={// Disable progressive rendering
progressive:0,// size: ['80%', '80%'],            // deprecated, compatible with ec2.
left:"center",top:"middle",width:"80%",height:"80%",sort:!0,clipWindow:"origin",squareRatio:.5*(1+Math.sqrt(5)),leafDepth:null,drillDownIcon:"",// to align specialized icon. 
zoomToNodeRatio:.1024,roam:!0,nodeClick:"zoomToNode",animation:!0,animationDurationUpdate:900,animationEasing:"quinticInOut",breadcrumb:{show:!0,height:22,left:"center",top:"bottom",// right
// bottom
emptyItemWidth:25,itemStyle:{color:"rgba(0,0,0,0.7)",textStyle:{color:"#fff"}},emphasis:{itemStyle:{color:"rgba(0,0,0,0.9)"}}},label:{show:!0,// Do not use textDistance, for ellipsis rect just the same as treemap node rect.
distance:0,padding:5,position:"inside",// formatter: null,
color:"#fff",overflow:"truncate"},upperLabel:{show:!1,position:[0,"50%"],height:20,// formatter: null,
// color: '#fff',
overflow:"truncate",// align: null,
verticalAlign:"middle"},itemStyle:{color:null,colorAlpha:null,colorSaturation:null,borderWidth:0,gapWidth:0,borderColor:"#fff",borderColorSaturation:null},emphasis:{upperLabel:{show:!0,position:[0,"50%"],overflow:"truncate",verticalAlign:"middle"}},visualDimension:0,visualMin:null,visualMax:null,color:[],// level[n].color (if necessary).
// + Specify color list of each level. level[0].color would be global
// color list if not specified. (see method `setDefault`).
// + But set as a empty array to forbid fetch color from global palette
// when using nodeModel.get('color'), otherwise nodes on deep level
// will always has color palette set and are not able to inherit color
// from parent node.
// + TreemapSeries.color can not be set as 'none', otherwise effect
// legend color fetching (see seriesColor.js).
colorAlpha:null,colorSaturation:null,colorMappingBy:"index",visibleMin:10,// be rendered. Only works when sort is 'asc' or 'desc'.
childrenVisibleMin:null,// grandchildren will not show.
// Why grandchildren? If not grandchildren but children,
// some siblings show children and some not,
// the appearance may be mess and not consistent,
levels:[]},e}(zg);
/**
             * @param {Object} dataNode
             */function QD(t){// Postorder travel tree.
// If value of none-leaf node is not set,
// calculate it by suming up the value of all children.
var e=0;R(t.children,(function(t){QD(t);var n=t.value;G(n)&&(n=n[0]),e+=n}));var n=t.value;G(n)&&(n=n[0]),(null==n||isNaN(n))&&(n=e),// Value should not less than 0.
n<0&&(n=0),G(t.value)?t.value[0]=n:t.value=n}const tA=JD;var eA=/** @class */function(){function t(t){this.group=new Lr,t.add(this.group)}return t.prototype.render=function(t,e,n,i){var r=t.getModel("breadcrumb"),o=this.group;if(o.removeAll(),r.get("show")&&n){var a=r.getModel("itemStyle"),s=r.getModel("emphasis"),l=a.getModel("textStyle"),u=s.getModel(["itemStyle","textStyle"]),h={pos:{left:r.get("left"),right:r.get("right"),top:r.get("top"),bottom:r.get("bottom")},box:{width:e.getWidth(),height:e.getHeight()},emptyItemWidth:r.get("emptyItemWidth"),totalWidth:0,renderList:[]};this._prepare(n,h,l),this._renderContent(t,h,a,s,l,u,i),Np(o,h.pos,h.box)}},
/**
               * Prepare render list and total width
               * @private
               */
t.prototype._prepare=function(t,e,n){for(var i=t;i;i=i.parentNode){var r=vo(i.getModel().get("name"),""),o=n.getTextRect(r),a=Math.max(o.width+16,e.emptyItemWidth);e.totalWidth+=a+8,e.renderList.push({node:i,text:r,width:a})}},
/**
               * @private
               */
t.prototype._renderContent=function(t,e,n,i,r,o,a){for(// Start rendering.
var s,l,u,h,c,p,d,f,g,y=0,v=e.emptyItemWidth,m=t.get(["breadcrumb","height"]),x=(s=e.pos,l=e.box,h=l.width,c=l.height,p=Vr(s.left,h),d=Vr(s.top,c),f=Vr(s.right,h),g=Vr(s.bottom,c),(isNaN(p)||isNaN(parseFloat(s.left)))&&(p=0),(isNaN(f)||isNaN(parseFloat(s.right)))&&(f=h),(isNaN(d)||isNaN(parseFloat(s.top)))&&(d=0),(isNaN(g)||isNaN(parseFloat(s.bottom)))&&(g=c),u=wp(u||0),{width:Math.max(f-p-u[1]-u[3],0),height:Math.max(g-d-u[0]-u[2],0)}),_=e.totalWidth,b=e.renderList,w=i.getModel("itemStyle").getItemStyle(),S=b.length-1;S>=0;S--){var M=b[S],I=M.node,T=M.width,C=M.text;// Hdie text and shorten width if necessary.
_>x.width&&(_-=T-v,T=v,C=null);var D=new Wu({shape:{points:nA(y,0,T,m,S===b.length-1,0===S)},style:k(n.getItemStyle(),{lineJoin:"bevel"}),textContent:new Zs({style:lc(r,{text:C})}),textConfig:{position:"inside"},z2:1e5,onclick:F(a,I)});D.disableLabelAnimation=!0,D.getTextContent().ensureState("emphasis").style=lc(o,{text:C}),D.ensureState("emphasis").style=w,Bl(D,i.get("focus"),i.get("blurScope"),i.get("disabled")),this.group.add(D),iA(D,t,I),y+=T+8}},t.prototype.remove=function(){this.group.removeAll()},t}();function nA(t,e,n,i,r,o){var a=[[r?t:t-5,e],[t+n,e],[t+n,e+i],[r?t:t-5,e+i]];return!o&&a.splice(2,0,[t+n+5,e+i/2]),!r&&a.push([t,e+i/2]),a}// Package custom mouse event.
function iA(t,e,n){js(t).eventData={componentType:"series",componentSubType:"treemap",componentIndex:e.componentIndex,seriesIndex:e.seriesIndex,seriesName:e.name,seriesType:"treemap",selfType:"breadcrumb",nodeData:{dataIndex:n&&n.dataIndex,name:n&&n.name},treePathInfo:n&&YD(n,e)}}const rA=eA;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * Animate multiple elements with a single done-callback.
             *
             * @example
             *  animation
             *      .createWrap()
             *      .add(el1, {x: 10, y: 10})
             *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
             *      .done(function () { // done })
             *      .start('cubicOut');
             */var oA=/** @class */function(){function t(){this._storage=[],this._elExistsMap={}}
/**
               * Caution: a el can only be added once, otherwise 'done'
               * might not be called. This method checks this (by el.id),
               * suppresses adding and returns false when existing el found.
               *
               * @return Whether adding succeeded.
               */return t.prototype.add=function(t,e,n,i,r){return!this._elExistsMap[t.id]&&(this._elExistsMap[t.id]=!0,this._storage.push({el:t,target:e,duration:n,delay:i,easing:r}),!0)},
/**
               * Only execute when animation done/aborted.
               */
t.prototype.finished=function(t){return this._finishedCallback=t,this},
/**
               * Will stop exist animation firstly.
               */
t.prototype.start=function(){for(var t=this,e=this._storage.length,n=function(){--e<=0&&(// Guard.
t._storage.length=0,t._elExistsMap={},t._finishedCallback&&t._finishedCallback())},i=0,r=this._storage.length;i<r;i++){var o=this._storage[i];o.el.animateTo(o.target,{duration:o.duration,delay:o.delay,easing:o.easing,setToFinal:!0,done:n,aborted:n})}return this},t}(),aA=Lr,sA=Ls,lA="label",uA="upperLabel",hA=Fo([["fill","color"],// `borderColor` and `borderWidth` has been occupied,
// so use `stroke` to indicate the stroke of the rect.
["stroke","strokeColor"],["lineWidth","strokeWidth"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"]]),cA=function(t){// Normal style props should include emphasis style props.
var e=hA(t);// Clear styles set by emphasis.
return e.stroke=e.fill=e.lineWidth=null,e},pA=bo(),dA=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._state="ready",n._storage={nodeGroup:[],background:[],content:[]},n}
/**
               * @override
               */return n(e,t),e.prototype.render=function(t,e,n,i){if(!(L(e.findComponents({mainType:"series",subType:"treemap",query:i}),t)<0)){this.seriesModel=t,this.api=n,this.ecModel=e;var r=GD(i,["treemapZoomToNode","treemapRootToNode"],t),o=i&&i.type,a=t.layoutInfo,s=!this._oldTree,l=this._storage,u="treemapRootToNode"===o&&r&&l?{rootNodeGroup:l.nodeGroup[r.node.getRawIndex()],direction:i.direction}:null,h=this._giveContainerGroup(a),c=t.get("animation"),p=this._doRender(h,t,u);!c||s||o&&"treemapZoomToNode"!==o&&"treemapRootToNode"!==o?p.renderFinally():this._doAnimation(h,p,t,u),this._resetController(n),this._renderBreadcrumb(t,n,r)}},e.prototype._giveContainerGroup=function(t){var e=this._containerGroup;return e||(// FIXME
// containerGroupclipclip
e=this._containerGroup=new aA,this._initEvents(e),this.group.add(e)),e.x=t.x,e.y=t.y,e},e.prototype._doRender=function(t,e,n){var i=e.getData().tree,r=this._oldTree,o={nodeGroup:[],background:[],content:[]},a={nodeGroup:[],background:[],content:[]},s=this._storage,l=[];function u(t,i,r,u){
/**
             * @inner
             * @return Return undefined means do not travel further.
             */return function(t,e,n,i,r,o,a,s,l,u){// Whether under viewRoot.
if(a){// -------------------------------------------------------------------
// Start of closure variables available in "Procedures in renderNode".
var h=a.getLayout(),c=t.getData(),p=a.getModel();if(// Only for enabling highlight/downplay. Clear firstly.
// Because some node will not be rendered.
c.setItemGraphicEl(a.dataIndex,null),h&&h.isInView){var d=h.width,f=h.height,g=h.borderWidth,y=h.invisible,v=a.getRawIndex(),m=s&&s.getRawIndex(),x=a.viewChildren,_=h.upperHeight,b=x&&x.length,w=p.getModel("itemStyle"),S=p.getModel(["emphasis","itemStyle"]),M=p.getModel(["blur","itemStyle"]),I=p.getModel(["select","itemStyle"]),T=w.get("borderRadius")||0,C=G("nodeGroup",aA);if(C){if(l.add(C),// x,y are not set when el is above view root.
C.x=h.x||0,C.y=h.y||0,C.markRedraw(),pA(C).nodeWidth=d,pA(C).nodeHeight=f,h.isAboveViewRoot)return C;// Background
var D=G("background",sA,u,20);D&&E(C,D,b&&h.upperLabelHeight);var k=p.getModel("emphasis"),L=k.get("focus"),P=k.get("blurScope"),O=k.get("disabled"),R="ancestor"===L?a.getAncestorsIndices():"descendant"===L?a.getDescendantIndices():L;// No children, render content.
if(b)// Because of the implementation about "traverse" in graphic hover style, we
// can not set hover listener on the "group" of non-leaf node. Otherwise the
// hover event from the descendents will be listenered.
Xl(C)&&Yl(C,!1),D&&(Yl(D,!O),// Only for enabling highlight/downplay.
c.setItemGraphicEl(a.dataIndex,D),Fl(D,R,P));else{var N=G("content",sA,u,30);N&&z(C,N),D.disableMorphing=!0,D&&Xl(D)&&Yl(D,!1),Yl(C,!O),// Only for enabling highlight/downplay.
c.setItemGraphicEl(a.dataIndex,C),Fl(C,R,P)}return C;// ----------------------------
// | Procedures in renderNode |
// ----------------------------
}}}function E(e,n,i){var r=js(n);// For tooltip.
if(r.dataIndex=a.dataIndex,r.seriesIndex=t.seriesIndex,n.setShape({x:0,y:0,width:d,height:f,r:T}),y)// If invisible, do not set visual, otherwise the element will
// change immediately before animation. We think it is OK to
// remain its origin color when moving out of the view window.
V(n);else{n.invisible=!1;var o=a.getVisual("style"),s=o.stroke,l=cA(w);l.fill=s;var u=hA(S);u.fill=S.get("borderColor");var h=hA(M);h.fill=M.get("borderColor");var c=hA(I);if(c.fill=I.get("borderColor"),i){var p=d-2*g;B(// PENDING: convert ZRColor to ColorString for text.
n,s,o.opacity,{x:g,y:0,width:p,height:_})}// For old bg.
else n.removeTextContent();n.setStyle(l),n.ensureState("emphasis").style=u,n.ensureState("blur").style=h,n.ensureState("select").style=c,wl(n)}e.add(n)}function z(e,n){var i=js(n);// For tooltip.
i.dataIndex=a.dataIndex,i.seriesIndex=t.seriesIndex;var r=Math.max(d-2*g,0),o=Math.max(f-2*g,0);if(n.culling=!0,n.setShape({x:g,y:g,width:r,height:o,r:T}),y)// If invisible, do not set visual, otherwise the element will
// change immediately before animation. We think it is OK to
// remain its origin color when moving out of the view window.
V(n);else{n.invisible=!1;var s=a.getVisual("style"),l=s.fill,u=cA(w);u.fill=l,u.decal=s.decal;var h=hA(S),c=hA(M),p=hA(I);// PENDING: convert ZRColor to ColorString for text.
B(n,l,s.opacity,null),n.setStyle(u),n.ensureState("emphasis").style=h,n.ensureState("blur").style=c,n.ensureState("select").style=p,wl(n)}e.add(n)}function V(t){// Delay invisible setting utill animation finished,
// avoid element vanish suddenly before animation.
!t.invisible&&o.push(t)}function B(e,n,i,// Can be null/undefined
r){var o=p.getModel(r?uA:lA),s=vo(p.get("name"),null),l=o.getShallow("show");ac(e,sc(p,r?uA:lA),{defaultText:l?s:null,inheritColor:n,defaultOpacity:i,labelFetcher:t,labelDataIndex:a.dataIndex});var u=e.getTextContent();if(u){var c=u.style,d=nt(c.padding||0);r&&(e.setTextConfig({layoutRect:r}),u.disableLabelLayout=!0),u.beforeUpdate=function(){var t=Math.max((r?r.width:e.shape.width)-d[1]-d[3],0),n=Math.max((r?r.height:e.shape.height)-d[0]-d[2],0);c.width===t&&c.height===n||u.setStyle({width:t,height:n})},c.truncateMinChar=2,c.lineOverflow="truncate",F(c,r,h);var f=u.getState("emphasis");F(f?f.style:null,r,h)}}function F(e,n,i){var r=e?e.text:null;if(!n&&i.isLeafRoot&&null!=r){var o=t.get("drillDownIcon",!0);e.text=o?o+" "+r:r}}function G(t,i,o,a){var s=null!=m&&n[t][m],l=r[t];// Set to thisStorage
return s?(// Remove from oldStorage
n[t][m]=null,W(l,s)):y||((s=new i)instanceof fa&&(s.z2=// We cannot set all background with the same z, because the behaviour of
// drill down and roll up differ background creation sequence from tree
// hierarchy sequence, which cause lower background elements to overlap
// upper ones. So we calculate z based on depth.
// Moreover, we try to shrink down z interval to [0, 1] to avoid that
// treemap with large z overlaps other components.
function(t,e){return 100*t+e}(o,a)),H(l,s)),e[t][v]=s}function W(t,e){var n=t[v]={};e instanceof aA?(n.oldX=e.x,n.oldY=e.y):n.oldShape=A({},e.shape)}// If a element is new, we need to find the animation start point carefully,
// otherwise it will looks strange when 'zoomToNode'.
function H(t,e){var n=t[v]={},o=a.parentNode,s=e instanceof Lr;if(o&&(!i||"drillDown"===i.direction)){var l=0,u=0,h=r.background[o.getRawIndex()];!i&&h&&h.oldShape&&(l=h.oldShape.width,u=h.oldShape.height),// When no parent old shape found, its parent is new too,
// so we can just use {x:0, y:0}.
s?(n.oldX=0,n.oldY=u):n.oldShape={x:l,y:u,width:0,height:0}}// Fade in, user can be aware that these nodes are new.
n.fadein=!s}}(e,a,s,n,o,l,t,i,r,u)}// Notice: When thisTree and oldTree are the same tree (see list.cloneShallow),
// the oldTree is actually losted, so we cannot find all of the old graphic
// elements from tree. So we use this strategy: make element storage, move
// from old storage to new storage, clear old storage.
!function t(e,n,i,r,o){function a(t){// Identify by name or raw index.
return t.getId()}function s(a,s){var l=null!=a?e[a]:null,h=null!=s?n[s]:null,c=u(l,h,i,o);c&&t(l&&l.viewChildren||[],h&&h.viewChildren||[],c,r,o+1)}// When 'render' is triggered by action,
// 'this' and 'old' may be the same tree,
// we use rawIndex in that case.
r?(n=e,R(e,(function(t,e){!t.isRemoved()&&s(e,e)}))):new Um(n,e,a,a).add(s).update(s).remove(F(s,null)).execute()}(i.root?[i.root]:[],r&&r.root?[r.root]:[],t,i===r||!r,0);// Process all removing.
var h=function(t){var e={nodeGroup:[],background:[],content:[]};return t&&R(t,(function(t,n){var i=e[n];R(t,(function(t){t&&(i.push(t),pA(t).willDelete=!0)}))})),e}(s);return this._oldTree=i,this._storage=a,{lastsForAnimation:o,willDeleteEls:h,renderFinally:function(){R(h,(function(t){R(t,(function(t){t.parent&&t.parent.remove(t)}))})),R(l,(function(t){t.invisible=!0,// Setting invisible is for optimizing, so no need to set dirty,
// just mark as invisible.
t.dirty()}))}}},e.prototype._doAnimation=function(t,e,n,i){var r=n.get("animationDurationUpdate"),o=n.get("animationEasing"),a=(W(r)?0:r)||0,s=(W(o)?null:o)||"cubicOut",l=new oA;// Make delete animations.
R(e.willDeleteEls,(function(t,e){R(t,(function(t,n){if(!t.invisible){var r,o=t.parent,u=pA(o);// Always has parent, and parent is nodeGroup.
if(i&&"drillDown"===i.direction)r=o===i.rootNodeGroup?{shape:{x:0,y:0,width:u.nodeWidth,height:u.nodeHeight},style:{opacity:0}}:{style:{opacity:0}};else{var h=0,c=0;u.willDelete||(// Let node animate to right-bottom corner, cooperating with fadeout,
// which is appropriate for user understanding.
// Divided by 2 for reRoot rolling up effect.
h=u.nodeWidth/2,c=u.nodeHeight/2),r="nodeGroup"===e?{x:h,y:c,style:{opacity:0}}:{shape:{x:h,y:c,width:0,height:0},style:{opacity:0}}}// TODO: do not support delay until necessary.
r&&l.add(t,r,a,0,s)}}))})),// Make other animations
R(this._storage,(function(t,n){R(t,(function(t,i){var r=e.lastsForAnimation[n][i],o={};r&&(t instanceof Lr?null!=r.oldX&&(o.x=t.x,o.y=t.y,t.x=r.oldX,t.y=r.oldY):(r.oldShape&&(o.shape=A({},t.shape),t.setShape(r.oldShape)),r.fadein?(t.setStyle("opacity",0),o.style={opacity:1}):1!==t.style.opacity&&(o.style={opacity:1})),l.add(t,o,a,0,s))}))}),this),this._state="animating",l.finished(B((function(){this._state="ready",e.renderFinally()}),this)).start()},e.prototype._resetController=function(t){var e=this._controller;// Init controller.
e||((e=this._controller=new RT(t.getZr())).enable(this.seriesModel.get("roam")),e.on("pan",B(this._onPan,this)),e.on("zoom",B(this._onZoom,this)));var n=new Ce(0,0,t.getWidth(),t.getHeight());e.setPointerChecker((function(t,e,i){return n.contain(e,i)}))},e.prototype._clearController=function(){var t=this._controller;t&&(t.dispose(),t=null)},e.prototype._onPan=function(t){if("animating"!==this._state&&(Math.abs(t.dx)>3||Math.abs(t.dy)>3)){// These param must not be cached.
var e=this.seriesModel.getData().tree.root;if(!e)return;var n=e.getLayout();if(!n)return;this.api.dispatchAction({type:"treemapMove",from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:n.x+t.dx,y:n.y+t.dy,width:n.width,height:n.height}})}},e.prototype._onZoom=function(t){var e=t.originX,n=t.originY;if("animating"!==this._state){// These param must not be cached.
var i=this.seriesModel.getData().tree.root;if(!i)return;var r=i.getLayout();if(!r)return;var o=new Ce(r.x,r.y,r.width,r.height),a=this.seriesModel.layoutInfo,s=[1,0,0,1,0,0];pe(s,s,[-(// Transform mouse coord from global to containerGroup.
e-=a.x),-(n-=a.y)]),fe(s,s,[t.scale,t.scale]),pe(s,s,[e,n]),o.applyTransform(s),this.api.dispatchAction({type:"treemapRender",from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:o.x,y:o.y,width:o.width,height:o.height}})}},e.prototype._initEvents=function(t){var e=this;t.on("click",(function(t){if("ready"===e._state){var n=e.seriesModel.get("nodeClick",!0);if(n){var i=e.findTarget(t.offsetX,t.offsetY);if(i){var r=i.node;if(r.getLayout().isLeafRoot)e._rootToNode(i);else if("zoomToNode"===n)e._zoomToNode(i);else if("link"===n){var o=r.hostTree.data.getItemModel(r.dataIndex),a=o.get("link",!0),s=o.get("target",!0)||"blank";a&&Dp(a,s)}}}}}),this)},e.prototype._renderBreadcrumb=function(t,e,n){var i=this;n||(n=null!=t.get("leafDepth",!0)?{node:t.getViewRoot()}:this.findTarget(e.getWidth()/2,e.getHeight()/2))||(n={node:t.getData().tree.root}),(this._breadcrumb||(this._breadcrumb=new rA(this.group))).render(t,e,n.node,(function(e){"animating"!==i._state&&(HD(t.getViewRoot(),e)?i._rootToNode({node:e}):i._zoomToNode({node:e}))}))},
/**
               * @override
               */
e.prototype.remove=function(){this._clearController(),this._containerGroup&&this._containerGroup.removeAll(),this._storage={nodeGroup:[],background:[],content:[]},this._state="ready",this._breadcrumb&&this._breadcrumb.remove()},e.prototype.dispose=function(){this._clearController()},e.prototype._zoomToNode=function(t){this.api.dispatchAction({type:"treemapZoomToNode",from:this.uid,seriesId:this.seriesModel.id,targetNode:t.node})},e.prototype._rootToNode=function(t){this.api.dispatchAction({type:"treemapRootToNode",from:this.uid,seriesId:this.seriesModel.id,targetNode:t.node})},
/**
               * @public
               * @param {number} x Global coord x.
               * @param {number} y Global coord y.
               * @return {Object} info If not found, return undefined;
               * @return {number} info.node Target node.
               * @return {number} info.offsetX x refer to target node.
               * @return {number} info.offsetY y refer to target node.
               */
e.prototype.findTarget=function(t,e){var n;return this.seriesModel.getViewRoot().eachNode({attr:"viewChildren",order:"preorder"},(function(i){var r=this._storage.background[i.getRawIndex()];// If invisible, there might be no element.
if(r){var o=r.transformCoordToLocal(t,e),a=r.shape;// For performance consideration, don't use 'getBoundingRect'.
if(!(a.x<=o[0]&&o[0]<=a.x+a.width&&a.y<=o[1]&&o[1]<=a.y+a.height))return!1;// Suppress visit subtree.
n={node:i,offsetX:o[0],offsetY:o[1]}}}),this),n},e.type="treemap",e}(qg);const fA=dA;var gA=R,yA=U,vA=-1,mA=/** @class */function(){function t(e){var n=e.mappingMethod,i=e.type,r=this.option=T(e);this.type=i,this.mappingMethod=n,this._normalizeData=DA[n];var o=t.visualHandlers[i];this.applyVisual=o.applyVisual,this.getColorMapper=o.getColorMapper,this._normalizedToVisual=o._normalizedToVisual[n],"piecewise"===n?(xA(r),function(t){var e=t.pieceList;t.hasSpecialVisual=!1,R(e,(function(e,n){e.originIndex=n,// piece.visual is "result visual value" but not
// a visual range, so it does not need to be normalized.
null!=e.visual&&(t.hasSpecialVisual=!0)}))}(r)):"category"===n?r.categories?function(t){// Hash categories.
var e=t.categories,n=t.categoryMap={},i=t.visual;// Process visual map input.
if(gA(e,(function(t,e){n[t]=e})),!G(i)){var r=[];U(i)?gA(i,(function(t,e){var i=n[e];r[null!=i?i:vA]=t})):// Is primary type, represents default visual.
r[-1]=i,i=CA(t,r)}// Remove categories that has no visual,
// then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.
for(var o=e.length-1;o>=0;o--)null==i[o]&&(delete n[e[o]],e.pop())}(r):xA(r,!0):(// mappingMethod === 'linear' or 'fixed'
it("linear"!==n||r.dataExtent),xA(r))}return t.prototype.mapValueToVisual=function(t){var e=this._normalizeData(t);return this._normalizedToVisual(e,t)},t.prototype.getNormalizer=function(){return B(this._normalizeData,this)},
/**
               * List available visual types.
               *
               * @public
               * @return {Array.<string>}
               */
t.listVisualTypes=function(){return V(t.visualHandlers)},// /**
//  * @public
//  */
// static addVisualHandler(name, handler) {
//     visualHandlers[name] = handler;
// }
/**
               * @public
               */
t.isValidType=function(e){return t.visualHandlers.hasOwnProperty(e)},
/**
               * Convenient method.
               * Visual can be Object or Array or primary type.
               */
t.eachVisual=function(t,e,n){U(t)?R(t,e,n):e.call(n,t)},t.mapVisual=function(e,n,i){var r,o=G(e)?[]:U(e)?{}:(r=!0,null);return t.eachVisual(e,(function(t,e){var a=n.call(i,t,e);r?o=a:o[e]=a})),o},
/**
               * Retrieve visual properties from given object.
               */
t.retrieveVisuals=function(e){var n,i={};return e&&gA(t.visualHandlers,(function(t,r){e.hasOwnProperty(r)&&(i[r]=e[r],n=!0)})),n?i:null},
/**
               * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
               *
               * @public
               * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
               *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
               * @return {Array.<string>} Sorted visual types.
               */
t.prepareVisualTypes=function(t){if(G(t))t=t.slice();else{if(!yA(t))return[];var e=[];gA(t,(function(t,n){e.push(n)})),t=e}return t.sort((function(t,e){// color should be front of colorSaturation, colorAlpha, ...
// symbol and symbolSize do not matter.
return"color"===e&&"color"!==t&&0===t.indexOf("color")?1:-1})),t},
/**
               * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
               * Other visuals are only depends on themself.
               */
t.dependsOn=function(t,e){return"color"===e?!(!t||0!==t.indexOf(e)):t===e},
/**
               * @param value
               * @param pieceList [{value: ..., interval: [min, max]}, ...]
               *                         Always from small to big.
               * @param findClosestWhenOutside Default to be false
               * @return index
               */
t.findPieceIndex=function(t,e,n){// value has the higher priority.
for(var i,r=1/0,o=0,a=e.length;o<a;o++){var s=e[o].value;if(null!=s){if(s===t||H(s)&&s===t+"")return o;n&&c(s,o)}}for(o=0,a=e.length;o<a;o++){var l=e[o],u=l.interval,h=l.close;if(u){if(u[0]===-1/0){if(AA(h[1],t,u[1]))return o}else if(u[1]===1/0){if(AA(h[0],u[0],t))return o}else if(AA(h[0],u[0],t)&&AA(h[1],t,u[1]))return o;n&&c(u[0],o),n&&c(u[1],o)}}if(n)return t===1/0?e.length-1:t===-1/0?0:i;function c(e,n){var o=Math.abs(e-t);o<r&&(r=o,i=n)}},t.visualHandlers={color:{applyVisual:wA("color"),getColorMapper:function(){var t=this.option;return B("category"===t.mappingMethod?function(t,e){return!e&&(t=this._normalizeData(t)),SA.call(this,t)}:function(e,n,i){// If output rgb array
// which will be much faster and useful in pixel manipulation
var r=!!i;return!n&&(e=this._normalizeData(e)),i=Un(e,t.parsedVisual,i),r?i:qn(i,"rgba")},this)},_normalizedToVisual:{linear:function(t){return qn(Un(t,this.option.parsedVisual),"rgba")},category:SA,piecewise:function(t,e){var n=TA.call(this,e);return null==n&&(n=qn(Un(t,this.option.parsedVisual),"rgba")),n},fixed:MA}},colorHue:_A((function(t,e){return Zn(t,e)})),colorSaturation:_A((function(t,e){return Zn(t,null,e)})),colorLightness:_A((function(t,e){return Zn(t,null,null,e)})),colorAlpha:_A((function(t,e){return jn(t,e)})),decal:{applyVisual:wA("decal"),_normalizedToVisual:{linear:null,category:SA,piecewise:null,fixed:null}},opacity:{applyVisual:wA("opacity"),_normalizedToVisual:IA([0,1])},liftZ:{applyVisual:wA("liftZ"),_normalizedToVisual:{linear:MA,category:MA,piecewise:MA,fixed:MA}},symbol:{applyVisual:function(t,e,n){n("symbol",this.mapValueToVisual(t))},_normalizedToVisual:{linear:bA,category:SA,piecewise:function(t,e){var n=TA.call(this,e);return null==n&&(n=bA.call(this,t)),n},fixed:MA}},symbolSize:{applyVisual:wA("symbolSize"),_normalizedToVisual:IA([0,1])}},t}();function xA(t,e){var n=t.visual,i=[];U(n)?gA(n,(function(t){i.push(t)})):null!=n&&i.push(n),e||1!==i.length||{color:1,symbol:1}.hasOwnProperty(t.type)||(// Do not care visualArr.length === 0, which is illegal.
i[1]=i[0]),CA(t,i)}function _A(t){return{applyVisual:function(e,n,i){// Only used in HSL
var r=this.mapValueToVisual(e);// Must not be array value
i("color",t(n("color"),r))},_normalizedToVisual:IA([0,1])}}function bA(t){var e=this.option.visual;return e[Math.round(zr(t,[0,1],[0,e.length-1],!0))]||{};// TODO {}?
}function wA(t){return function(e,n,i){i(t,this.mapValueToVisual(e))}}function SA(t){var e=this.option.visual;return e[this.option.loop&&t!==vA?t%e.length:t]}function MA(){// visual will be convert to array.
return this.option.visual[0]}
/**
             * Create mapped to numeric visual
             */function IA(t){return{linear:function(e){return zr(e,t,this.option.visual,!0)},category:SA,piecewise:function(e,n){var i=TA.call(this,n);return null==i&&(i=zr(e,t,this.option.visual,!0)),i},fixed:MA}}function TA(t){var e=this.option,n=e.pieceList;if(e.hasSpecialVisual){var i=n[mA.findPieceIndex(t,n)];if(i&&i.visual)return i.visual[this.type]}}function CA(t,e){return t.visual=e,"color"===t.type&&(t.parsedVisual=N(e,(function(t){var e=Hn(t);return e||[0,0,0,1]}))),e}
/**
             * Normalizers by mapping methods.
             */var DA={linear:function(t){return zr(t,this.option.dataExtent,[0,1],!0)},piecewise:function(t){var e=this.option.pieceList,n=mA.findPieceIndex(t,e,!0);if(null!=n)return zr(n,[0,e.length-1],[0,1],!0)},category:function(t){var e=this.option.categories?this.option.categoryMap[t]:t;// ordinal value
return null==e?vA:e},fixed:yt};function AA(t,e,n){return t?e<=n:e<n}const kA=mA;var LA=bo();const PA={seriesType:"treemap",reset:function(t){var e=t.getData().tree.root;e.isRemoved()||OA(e,// Visual should calculate from tree root but not view root.
{},t.getViewRoot().getAncestors(),t)}};function OA(t,e,n,i){var r=t.getModel(),o=t.getLayout(),a=t.hostTree.data;// Optimize
if(o&&!o.invisible&&o.isInView){var s,l=r.getModel("itemStyle"),u=function(t,e,n){var i=A({},e),r=n.designatedVisualItemStyle;return R(["color","colorAlpha","colorSaturation"],(function(n){// Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
r[n]=e[n];var o=t.get(n);r[n]=null,null!=o&&(i[n]=o)})),i}(l,e,i),h=a.ensureUniqueItemVisual(t.dataIndex,"style"),c=l.get("borderColor"),p=l.get("borderColorSaturation");null!=p&&(c=function(t,e){return null!=e?Zn(e,null,null,t):null}(p,// For performance, do not always execute 'calculateColor'.
s=RA(u))),h.stroke=c;var d=t.viewChildren;if(d&&d.length){var f=function(t,e,n,i,r,o){if(o&&o.length){var a=EA(e,"color")||null!=r.color&&"none"!==r.color&&(EA(e,"colorAlpha")||EA(e,"colorSaturation"));if(a){var s=e.get("visualMin"),l=e.get("visualMax"),u=n.dataExtent.slice();null!=s&&s<u[0]&&(u[0]=s),null!=l&&l>u[1]&&(u[1]=l);var h=e.get("colorMappingBy"),c={type:a.name,dataExtent:u,visual:a.range};"color"!==c.type||"index"!==h&&"id"!==h?c.mappingMethod="linear":(c.mappingMethod="category",c.loop=!0);var p=new kA(c);return LA(p).drColorMappingBy=h,p}}}// Notice: If we don't have the attribute 'colorRange', but only use
// attribute 'color' to represent both concepts of 'colorRange' and 'color',
// (It means 'colorRange' when 'color' is Array, means 'color' when not array),
// this problem will be encountered:
// If a level-1 node doesn't have children, and its siblings have children,
// and colorRange is set on level-1, then the node cannot be colored.
// So we separate 'colorRange' and 'color' to different attributes.
(0,r,o,0,u,d);// Designate visual to children.
R(d,(function(t,e){// If higher than viewRoot, only ancestors of viewRoot is needed to visit.
if(t.depth>=n.length||t===n[t.depth]){var o=function(t,e,n,i,r,o){var a=A({},e);if(r){// Only support color, colorAlpha, colorSaturation.
var s=r.type,l="color"===s&&LA(r).drColorMappingBy,u="index"===l?i:"id"===l?o.mapIdToIndex(n.getId()):n.getValue(t.get("visualDimension"));a[s]=r.mapValueToVisual(u)}return a}(r,u,t,e,f,i);OA(t,o,n,i)}}))}else s=RA(u),// Apply visual to this node.
h.fill=s}}function RA(t){var e=NA(t,"color");if(e){var n=NA(t,"colorAlpha"),i=NA(t,"colorSaturation");return i&&(e=Zn(e,null,null,i)),n&&(e=jn(e,n)),e}}function NA(t,e){var n=t[e];if(null!=n&&"none"!==n)return n}function EA(t,e){// 'colorRange', 'colorARange', 'colorSRange'.
// If not exists on this node, fetch from levels and series.
var n=t.get(e);return G(n)&&n.length?{name:e,range:n}:null}var zA=Math.max,VA=Math.min,BA=J,FA=R,GA=["itemStyle","borderWidth"],WA=["itemStyle","gapWidth"],HA=["upperLabel","show"],YA=["upperLabel","height"];
/**
             * @public
             */
const XA={seriesType:"treemap",reset:function(t,e,n,i){// Layout result in each node:
// {x, y, width, height, area, borderWidth}
var r=n.getWidth(),o=n.getHeight(),a=t.option,s=Rp(t.getBoxLayoutParams(),{width:n.getWidth(),height:n.getHeight()}),l=a.size||[],u=Vr(BA(s.width,l[0]),r),h=Vr(BA(s.height,l[1]),o),c=i&&i.type,p=GD(i,["treemapZoomToNode","treemapRootToNode"],t),d="treemapRender"===c||"treemapMove"===c?i.rootRect:null,f=t.getViewRoot(),g=WD(f);if("treemapMove"!==c){var y="treemapZoomToNode"===c?// Return [containerWidth, containerHeight] as default.
function(t,e,n,i,r){// If targetInfo.node exists, we zoom to the node,
// so estimate whole width and height by target node.
var o,a=(e||{}).node,s=[i,r];if(!a||a===n)return s;for(var l=i*r,u=l*t.option.zoomToNodeRatio;o=a.parentNode;){for(// jshint ignore:line
var h=0,c=o.children,p=0,d=c.length;p<d;p++)h+=c[p].getValue();var f=a.getValue();if(0===f)return s;u*=h/f;// Considering border, suppose aspect ratio is 1.
var g=o.getModel(),y=g.get(GA);(u+=4*y*y+(3*y+Math.max(y,KA(g)))*Math.pow(u,.5))>Yr&&(u=Yr),a=o}u<l&&(u=l);var v=Math.pow(u/l,.5);return[i*v,r*v]}// Root position based on coord of containerGroup
(t,p,f,u,h):d?[d.width,d.height]:[u,h],v=a.sort;v&&"asc"!==v&&"desc"!==v&&(// Default to be desc order.
v="desc");var m={squareRatio:a.squareRatio,sort:v,leafDepth:a.leafDepth};// layout should be cleared because using updateView but not update.
f.hostTree.clearLayouts();// TODO
// optimize: if out of view clip, do not layout.
// But take care that if do not render node out of view clip,
// how to calculate start po
var x={x:0,y:0,width:y[0],height:y[1],area:y[0]*y[1]};f.setLayout(x),UA(f,m,!1,0),// Supplement layout.
x=f.getLayout(),FA(g,(function(t,e){var n=(g[e+1]||f).getValue();t.setLayout(A({dataExtent:[n,n],borderWidth:0,upperHeight:0},x))}))}var _=t.getData().tree.root;_.setLayout(function(t,e,n){if(e)return{x:e.x,y:e.y};var i={x:0,y:0};if(!n)return i;// If targetInfo is fetched by 'retrieveTargetInfo',
// old tree and new tree are the same tree,
// so the node still exists and we can visit it.
var r=n.node,o=r.getLayout();if(!o)return i;// Transform coord from local to container.
for(var a=[o.width/2,o.height/2],s=r;s;){var l=s.getLayout();a[0]+=l.x,a[1]+=l.y,s=s.parentNode}return{x:t.width/2-a[0],y:t.height/2-a[1]}}// Mark nodes visible for prunning when visual coding and rendering.
// Prunning depends on layout and root position, so we have to do it after layout.
(s,d,p),!0),t.setLayoutInfo(s),// FIXME
// clipec
qA(_,// Transform to base element coordinate system.
new Ce(-s.x,-s.y,r,o),g,f,0)}};
/**
             * Layout treemap with squarify algorithm.
             * The original presentation of this algorithm
             * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
             * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
             * The implementation of this algorithm was originally copied from "d3.js"
             * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
             * with some modifications made for this program.
             * See the license statement at the head of this file.
             *
             * @protected
             * @param {module:echarts/data/Tree~TreeNode} node
             * @param {Object} options
             * @param {string} options.sort 'asc' or 'desc'
             * @param {number} options.squareRatio
             * @param {boolean} hideChildren
             * @param {number} depth
             */function UA(t,e,n,i){var r,o;if(!t.isRemoved()){var a=t.getLayout();r=a.width,o=a.height;// Considering border and gap
var s=t.getModel(),l=s.get(GA),u=s.get(WA)/2,h=KA(s),c=Math.max(l,h),p=l-u,d=c-u;t.setLayout({borderWidth:l,upperHeight:c,upperLabelHeight:h},!0);var f=(r=zA(r-2*p,0))*(o=zA(o-p-d,0)),g=
/**
             * Set area to each child, and calculate data extent for visual coding.
             */
function(t,e,n,i,r,o){var a=t.children||[],s=i.sort;"asc"!==s&&"desc"!==s&&(s=null);var l=null!=i.leafDepth&&i.leafDepth<=o;// leafDepth has higher priority.
if(r&&!l)return t.viewChildren=[];// Sort children, order by desc.
a=z(a,(function(t){return!t.isRemoved()})),
/**
             * Sort
             */
function(t,e){e&&t.sort((function(t,n){var i="asc"===e?t.getValue()-n.getValue():n.getValue()-t.getValue();return 0===i?"asc"===e?t.dataIndex-n.dataIndex:n.dataIndex-t.dataIndex:i}))}
/**
             * Statistic
             */(a,s);var u=function(t,e,n){for(// Calculate sum.
var i=0,r=0,o=e.length;r<o;r++)i+=e[r].getValue();// Statistic data extent for latter visual coding.
// Notice: data extent should be calculate based on raw children
// but not filtered view children, otherwise visual mapping will not
// be stable when zoom (where children is filtered by visibleMin).
var a,s=t.get("visualDimension");// The same as area dimension.
return e&&e.length?"value"===s&&n?(a=[e[e.length-1].getValue(),e[0].getValue()],"asc"===n&&a.reverse()):(a=[1/0,-1/0],FA(e,(function(t){var e=t.getValue(s);e<a[0]&&(a[0]=e),e>a[1]&&(a[1]=e)}))):a=[NaN,NaN],{sum:i,dataExtent:a}}
/**
             * Computes the score for the specified row,
             * as the worst aspect ratio.
             */(e,a,s);if(0===u.sum)return t.viewChildren=[];if(u.sum=
/**
             * Consider 'visibleMin'. Modify viewChildren and get new sum.
             */
function(t,e,n,i,r){// visibleMin is not supported yet when no option.sort.
if(!i)return n;// Always travel from little value to big value.
for(var o=t.get("visibleMin"),a=r.length,s=a,l=a-1;l>=0;l--){var u=r["asc"===i?a-l-1:l].getValue();u/n*e<o&&(s=l,n-=u)}return"asc"===i?r.splice(0,a-s):r.splice(s,a-s),n}(e,n,u.sum,s,a),0===u.sum)return t.viewChildren=[];// Set area to each child.
for(var h=0,c=a.length;h<c;h++){var p=a[h].getValue()/u.sum*n;// Do not use setLayout({...}, true), because it is needed to clear last layout.
a[h].setLayout({area:p})}return l&&(a.length&&t.setLayout({isLeafRoot:!0},!0),a.length=0),t.viewChildren=a,t.setLayout({dataExtent:u.dataExtent},!0),a}(t,s,f,e,n,i);if(g.length){var y={x:p,y:d,width:r,height:o},v=VA(r,o),m=1/0,x=[];x.area=0;for(var _=0,b=g.length;_<b;){var w=g[_];x.push(w),x.area+=w.getLayout().area;var S=ZA(x,v,e.squareRatio);// continue with this orientation
S<=m?(_++,m=S):(x.area-=x.pop().getLayout().area,jA(x,v,y,u,!1),v=VA(y.width,y.height),x.length=x.area=0,m=1/0)}if(x.length&&jA(x,v,y,u,!0),!n){var M=s.get("childrenVisibleMin");null!=M&&f<M&&(n=!0)}for(_=0,b=g.length;_<b;_++)UA(g[_],e,n,i+1)}}}function ZA(t,e,n){for(var i=0,r=1/0,o=0,a=void 0,s=t.length;o<s;o++)(a=t[o].getLayout().area)&&(a<r&&(r=a),a>i&&(i=a));var l=t.area*t.area,u=e*e*n;return l?zA(u*i/l,l/(u*r)):1/0}
/**
             * Positions the specified row of nodes. Modifies `rect`.
             */function jA(t,e,n,i,r){// When rowFixedLength === rect.width,
// it is horizontal subdivision,
// rowFixedLength is the width of the subdivision,
// rowOtherLength is the height of the subdivision,
// and nodes will be positioned from left to right.
// wh[idx0WhenH] means: when horizontal,
//      wh[idx0WhenH] => wh[0] => 'width'.
//      xy[idx1WhenH] => xy[1] => 'y'.
var o=e===n.width?0:1,a=1-o,s=["x","y"],l=["width","height"],u=n[s[o]],h=e?t.area/e:0;(r||h>n[l[a]])&&(h=n[l[a]]);for(var c=0,p=t.length;c<p;c++){var d=t[c],f={},g=h?d.getLayout().area/h:0,y=f[l[a]]=zA(h-2*i,0),v=n[s[o]]+n[l[o]]-u,m=c===p-1||v<g?v:g,x=f[l[o]]=zA(m-2*i,0);f[s[a]]=n[s[a]]+VA(i,y/2),f[s[o]]=u+VA(i,x/2),u+=m,d.setLayout(f,!0)}n[s[a]]+=h,n[l[a]]-=h}function qA(t,e,n,i,r){var o=t.getLayout(),a=n[r],s=a&&a===t;if(!(a&&!s||r===n.length&&t!==i)){t.setLayout({// isInView means: viewRoot sub tree + viewAbovePath
isInView:!0,// invisible only means: outside view clip so that the node can not
// see but still layout for animation preparation but not render.
invisible:!s&&!e.intersect(o),isAboveViewRoot:s},!0);// Transform to child coordinate.
var l=new Ce(e.x-o.x,e.y-o.y,e.width,e.height);FA(t.viewChildren||[],(function(t){qA(t,l,n,i,r+1)}))}}function KA(t){return t.get(HA)?t.get(YA):0}function $A(t){var e=t.findComponents({mainType:"legend"});e&&e.length&&t.eachSeriesByType("graph",(function(t){var n=t.getCategoriesData(),i=t.getGraph().data,r=n.mapArray(n.getName);i.filterSelf((function(t){var n=i.getItemModel(t).getShallow("category");if(null!=n){X(n)&&(n=r[n]);// If in any legend component the status is not selected.
for(var o=0;o<e.length;o++)if(!e[o].isSelected(n))return!1}return!0}))}))}function JA(t){var e={};t.eachSeriesByType("graph",(function(t){var n=t.getCategoriesData(),i=t.getData(),r={};n.each((function(i){var o=n.getName(i);// Add prefix to avoid conflict with Object.prototype.
r["ec-"+o]=i;var a=n.getItemModel(i),s=a.getModel("itemStyle").getItemStyle();s.fill||(// Get color from palette.
s.fill=t.getColorFromPalette(o,e)),n.setItemVisual(i,"style",s);for(var l=["symbol","symbolSize","symbolKeepAspect"],u=0;u<l.length;u++){var h=a.getShallow(l[u],!0);null!=h&&n.setItemVisual(i,l[u],h)}})),// Assign category color to visual
n.count()&&i.each((function(t){var e=i.getItemModel(t).getShallow("category");if(null!=e){H(e)&&(e=r["ec-"+e]);var o=n.getItemVisual(e,"style");A(i.ensureUniqueItemVisual(t,"style"),o);for(var a=["symbol","symbolSize","symbolKeepAspect"],s=0;s<a.length;s++)i.setItemVisual(t,a[s],n.getItemVisual(e,a[s]))}}))}))}function QA(t){return t instanceof Array||(t=[t,t]),t}function tk(t){t.eachSeriesByType("graph",(function(t){var e=t.getGraph(),n=t.getEdgeData(),i=QA(t.get("edgeSymbol")),r=QA(t.get("edgeSymbolSize"));// const colorQuery = ['lineStyle', 'color'] as const;
// const opacityQuery = ['lineStyle', 'opacity'] as const;
n.setVisual("fromSymbol",i&&i[0]),n.setVisual("toSymbol",i&&i[1]),n.setVisual("fromSymbolSize",r&&r[0]),n.setVisual("toSymbolSize",r&&r[1]),n.setVisual("style",t.getModel("lineStyle").getLineStyle()),n.each((function(t){var i=n.getItemModel(t),r=e.getEdgeByIndex(t),o=QA(i.getShallow("symbol",!0)),a=QA(i.getShallow("symbolSize",!0)),s=i.getModel("lineStyle").getLineStyle(),l=n.ensureUniqueItemVisual(t,"style");switch(A(l,s),l.stroke){case"source":var u=r.node1.getVisual("style");l.stroke=u&&u.fill;break;case"target":u=r.node2.getVisual("style"),l.stroke=u&&u.fill}o[0]&&r.setVisual("fromSymbol",o[0]),o[1]&&r.setVisual("toSymbol",o[1]),a[0]&&r.setVisual("fromSymbolSize",a[0]),a[1]&&r.setVisual("toSymbolSize",a[1])}))}))}var ek="--\x3e",nk=function(t){return t.get("autoCurveness")||null},ik=function(t,e){var n=nk(t),i=20,r=[];// handler the function set
if(X(n))i=n;else if(G(n))return void(t.__curvenessList=n);// append length
e>i&&(i=e);// make sure the length is even
var o=i%2?i+2:i+3;r=[];for(var a=0;a<o;a++)r.push((a%2?a+1:a)/10*(a%2?-1:1));t.__curvenessList=r},rk=function(t,e,n){var i=[t.id,t.dataIndex].join("."),r=[e.id,e.dataIndex].join(".");return[n.uid,i,r].join(ek)},ok=function(t){var e=t.split(ek);return[e[0],e[2],e[1]].join(ek)},ak=function(t,e){var n=e.__edgeMap;return n[t]?n[t].length:0};
/**
             * params handler
             * @param {module:echarts/model/SeriesModel} seriesModel
             * @returns {*}
             */
/**
             * get curvature for edge
             * @param edge
             * @param {module:echarts/model/SeriesModel} seriesModel
             * @param index
             */
function sk(t,e,n,i){var r=nk(e),o=G(r);if(!r)return null;var a=function(t,e){var n=rk(t.node1,t.node2,e);return e.__edgeMap[n]}(t,e);if(!a)return null;for(var s=-1,l=0;l<a.length;l++)if(a[l]===n){s=l;break}// if totalLen is Longer createCurveness
var u=function(t,e){return ak(rk(t.node1,t.node2,e),e)+ak(rk(t.node2,t.node1,e),e)}(t,e);ik(e,u),t.lineStyle=t.lineStyle||{};// if is opposite edge, must set curvenss to opposite number
var h=rk(t.node1,t.node2,e),c=e.__curvenessList,p=o||u%2?0:1;if(a.isForward)return c[p+s];// the opposite edge show outside
var d=ok(h),f=ak(d,e),g=c[s+f+p];// isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite
return i?// set as array may make the parity handle with the len of opposite
o?r&&0===r[0]?(f+p)%2?g:-g:((f%2?0:1)+p)%2?g:-g:(f+p)%2?g:-g:c[s+f+p]}function lk(t){var e=t.coordinateSystem;if(!e||"view"===e.type){var n=t.getGraph();n.eachNode((function(t){var e=t.getModel();t.setLayout([+e.get("x"),+e.get("y")])})),uk(n,t)}}function uk(t,e){t.eachEdge((function(t,n){var i=tt(t.getModel().get(["lineStyle","curveness"]),-sk(t,e,n,!0),0),r=_t(t.node1.getLayout()),o=_t(t.node2.getLayout()),a=[r,o];+i&&a.push([(r[0]+o[0])/2-(r[1]-o[1])*i,(r[1]+o[1])/2-(o[0]-r[0])*i]),t.setLayout(a)}))}function hk(t,e){t.eachSeriesByType("graph",(function(t){var e=t.get("layout"),n=t.coordinateSystem;if(n&&"view"!==n.type){var i=t.getData(),r=[];R(n.dimensions,(function(t){r=r.concat(i.mapDimensionsAll(t))}));for(var o=0;o<i.count();o++){for(var a=[],s=!1,l=0;l<r.length;l++){var u=i.get(r[l],o);isNaN(u)||(s=!0),a.push(u)}s?i.setItemLayout(o,n.dataToPoint(a)):// Also {Array.<number>}, not undefined to avoid if...else... statement
i.setItemLayout(o,[NaN,NaN])}uk(i.graph,t)}else e&&"none"!==e||lk(t)}))}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function ck(t){var e=t.coordinateSystem;if("view"!==e.type)return 1;var n=t.option.nodeScaleRatio,i=e.scaleX;return((e.getZoom()-1)*n+1)/i}function pk(t){var e=t.getVisual("symbolSize");return e instanceof Array&&(e=(e[0]+e[1])/2),+e}var dk=Math.PI,fk=[];
/**
             * `basedOn` can be:
             * 'value':
             *     This layout is not accurate and have same bad case. For example,
             *     if the min value is very smaller than the max value, the nodes
             *     with the min value probably overlap even though there is enough
             *     space to layout them. So we only use this approach in the as the
             *     init layout of the force layout.
             *     FIXME
             *     Probably we do not need this method any more but use
             *     `basedOn: 'symbolSize'` in force layout if
             *     delay its init operations to GraphView.
             * 'symbolSize':
             *     This approach work only if all of the symbol size calculated.
             *     That is, the progressive rendering is not applied to graph.
             *     FIXME
             *     If progressive rendering is applied to graph some day,
             *     probably we have to use `basedOn: 'value'`.
             */
function gk(t,e,n,i){var r=t.coordinateSystem;if(!r||"view"===r.type){var o=r.getBoundingRect(),a=t.getData(),s=a.graph,l=o.width/2+o.x,u=o.height/2+o.y,h=Math.min(o.width,o.height)/2,c=a.count();if(a.setLayout({cx:l,cy:u}),c){if(n){var p=r.pointToData(i),d=p[0],f=p[1],g=[d-l,f-u];Ct(g,g),Tt(g,g,h),n.setLayout([l+g[0],u+g[1]],!0),vk(n,t.get(["circular","rotateLabel"]),l,u)}yk[e](t,s,a,h,l,u,c),s.eachEdge((function(e,n){var i,r=tt(e.getModel().get(["lineStyle","curveness"]),sk(e,t,n),0),o=_t(e.node1.getLayout()),a=_t(e.node2.getLayout()),s=(o[0]+a[0])/2,h=(o[1]+a[1])/2;+r&&(i=[l*(r*=3)+s*(1-r),u*r+h*(1-r)]),e.setLayout([o,a,i])}))}}}var yk={value:function(t,e,n,i,r,o,a){var s=0,l=n.getSum("value"),u=2*Math.PI/(l||a);e.eachNode((function(t){var e=t.getValue("value"),n=u*(l?e:1)/2;s+=n,t.setLayout([i*Math.cos(s)+r,i*Math.sin(s)+o]),s+=n}))},symbolSize:function(t,e,n,i,r,o,a){var s=0;fk.length=a;var l=ck(t);e.eachNode((function(t){var e=pk(t);// Normally this case will not happen, but we still add
// some the defensive code (2px is an arbitrary value).
isNaN(e)&&(e=2),e<0&&(e=0),e*=l;var n=Math.asin(e/2/i);// when `symbolSize / 2` is bigger than `r`.
isNaN(n)&&(n=dk/2),fk[t.dataIndex]=n,s+=2*n}));var u=(2*dk-s)/a/2,h=0;e.eachNode((function(t){var e=u+fk[t.dataIndex];h+=e,// init circular layout for
// 1. layout undefined node
// 2. not fixed node
(!t.getLayout()||!t.getLayout().fixed)&&t.setLayout([i*Math.cos(h)+r,i*Math.sin(h)+o]),h+=e}))}};function vk(t,e,n,i){var r=t.getGraphicEl();// need to check if el exists. '-' value may not create node element.
if(r){var o=t.getModel().get(["label","rotate"])||0,a=r.getSymbolPath();if(e){var s=t.getLayout(),l=Math.atan2(s[1]-i,s[0]-n);l<0&&(l=2*Math.PI+l);var u=s[0]<n;u&&(l-=Math.PI);var h=u?"left":"right";a.setTextConfig({rotation:-l,position:h,origin:"center"});var c=a.ensureState("emphasis");A(c.textConfig||(c.textConfig={}),{position:h})}else a.setTextConfig({rotation:o*=Math.PI/180})}}function mk(t){t.eachSeriesByType("graph",(function(t){"circular"===t.get("layout")&&gk(t,"symbolSize")}))}var xk=St;// function adjacentNode(n, e) {
//     return e.n1 === n ? e.n2 : e.n1;
// }
function _k(t){t.eachSeriesByType("graph",(function(t){var e=t.coordinateSystem;if(!e||"view"===e.type)if("force"===t.get("layout")){var n=t.preservedPoints||{},i=t.getGraph(),r=i.data,o=i.edgeData,a=t.getModel("force"),s=a.get("initLayout");t.preservedPoints?r.each((function(t){var e=r.getId(t);r.setItemLayout(t,n[e]||[NaN,NaN])})):s&&"none"!==s?"circular"===s&&gk(t,"value"):lk(t);var l=r.getDataExtent("value"),u=o.getDataExtent("value"),h=a.get("repulsion"),c=a.get("edgeLength"),p=G(h)?h:[h,h],d=G(c)?c:[c,c];// Larger value has smaller length
d=[d[1],d[0]];var f=r.mapArray("value",(function(t,e){var n=r.getItemLayout(e),i=zr(t,l,p);return isNaN(i)&&(i=(p[0]+p[1])/2),{w:i,rep:i,fixed:r.getItemModel(e).get("fixed"),p:!n||isNaN(n[0])||isNaN(n[1])?null:n}})),g=o.mapArray("value",(function(e,n){var r=i.getEdgeByIndex(n),o=zr(e,u,d);isNaN(o)&&(o=(d[0]+d[1])/2);var a=r.getModel(),s=tt(r.getModel().get(["lineStyle","curveness"]),-sk(r,t,n,!0),0);return{n1:f[r.node1.dataIndex],n2:f[r.node2.dataIndex],d:o,curveness:s,ignoreForceLayout:a.get("ignoreForceLayout")}})),y=e.getBoundingRect(),v=function(t,e,n){// for (let i = 0; i < edges.length; i++) {
//     let e = edges[i];
//     let n1 = e.n1;
//     let n2 = e.n2;
//     n1.edges = n1.edges || [];
//     n2.edges = n2.edges || [];
//     n1.edges.push(e);
//     n2.edges.push(e);
// }
// Init position
for(var i=t,r=e,o=n.rect,a=o.width,s=o.height,l=[o.x+a/2,o.y+s/2],u=null==n.gravity?.1:n.gravity,h=0;h<i.length;h++){var c=i[h];c.p||(c.p=mt(a*(Math.random()-.5)+l[0],s*(Math.random()-.5)+l[1])),c.pp=_t(c.p),c.edges=null}// Formula in 'Graph Drawing by Force-directed Placement'
// let k = scale * Math.sqrt(width * height / nodes.length);
// let k2 = k * k;
var p,d,f=null==n.friction?.6:n.friction,g=f;return{warmUp:function(){g=.8*f},setFixed:function(t){i[t].fixed=!0},setUnfixed:function(t){i[t].fixed=!1},
/**
                 * Before step hook
                 */
beforeStep:function(t){p=t},
/**
                 * After step hook
                 */
afterStep:function(t){d=t},
/**
                 * Some formulas were originally copied from "d3.js"
                 * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
                 * with some modifications made for this project.
                 * See the license statement at the head of this file.
                 */
step:function(t){p&&p(i,r);for(var e=[],n=i.length,o=0;o<r.length;o++){var a=r[o];if(!a.ignoreForceLayout){var s=a.n1;Mt(e,(y=a.n2).p,s.p);var h=It(e)-a.d,c=y.w/(s.w+y.w);isNaN(c)&&(c=0),Ct(e,e),!s.fixed&&xk(s.p,s.p,e,c*h*g),!y.fixed&&xk(y.p,y.p,e,-(1-c)*h*g)}}// Gravity
for(o=0;o<n;o++)(x=i[o]).fixed||(Mt(e,l,x.p),// let d = vec2.len(v12);
// vec2.scale(v12, v12, 1 / d);
// let gravityFactor = gravity;
xk(x.p,x.p,e,u*g));// Repulsive
// PENDING
for(o=0;o<n;o++){s=i[o];for(var f=o+1;f<n;f++){var y;Mt(e,(y=i[f]).p,s.p),0===(h=It(e))&&(// Random repulse
bt(e,Math.random()-.5,Math.random()-.5),h=1);var v=(s.rep+y.rep)/h/h;!s.fixed&&xk(s.pp,s.pp,e,v),!y.fixed&&xk(y.pp,y.pp,e,-v)}}var m=[];for(o=0;o<n;o++){var x;(x=i[o]).fixed||(Mt(m,x.p,x.pp),xk(x.p,x.p,m,g),xt(x.pp,x.p))}var _=(g*=.992)<.01;d&&d(i,r,_),t&&t(_)}}}(f,g,{rect:y,gravity:a.get("gravity"),friction:a.get("friction")});v.beforeStep((function(t,e){for(var n=0,r=t.length;n<r;n++)t[n].fixed&&// Write back to layout instance
xt(t[n].p,i.getNodeByIndex(n).getLayout())})),v.afterStep((function(t,e,o){for(var a=0,s=t.length;a<s;a++)t[a].fixed||i.getNodeByIndex(a).setLayout(t[a].p),n[r.getId(a)]=t[a].p;for(a=0,s=e.length;a<s;a++){var l=e[a],u=i.getEdgeByIndex(a),h=l.n1.p,c=l.n2.p,p=u.getLayout();(p=p?p.slice():[])[0]=p[0]||[],p[1]=p[1]||[],xt(p[0],h),xt(p[1],c),+l.curveness&&(p[2]=[(h[0]+c[0])/2-(h[1]-c[1])*l.curveness,(h[1]+c[1])/2-(c[0]-h[0])*l.curveness]),u.setLayout(p)}})),t.forceLayout=v,t.preservedPoints=n,// Step to get the layout
v.step()}else// Remove prev injected forceLayout instance
t.forceLayout=null}))}function bk(t,e){var n=[];return t.eachSeriesByType("graph",(function(t){var i=t.get("coordinateSystem");if(!i||"view"===i){var r=t.getData(),o=[],a=[];Sa(r.mapArray((function(t){var e=r.getItemModel(t);return[+e.get("x"),+e.get("y")]})),o,a),// If width or height is 0
a[0]-o[0]==0&&(a[0]+=1,o[0]-=1),a[1]-o[1]==0&&(a[1]+=1,o[1]-=1);var s=(a[0]-o[0])/(a[1]-o[1]),l=function(t,e,n){return Rp(A(t.getBoxLayoutParams(),{aspect:n}),{width:e.getWidth(),height:e.getHeight()})}(t,e,s);// FIXME If get view rect after data processed?
// Position may be NaN, use view rect instead
isNaN(s)&&(o=[l.x,l.y],a=[l.x+l.width,l.y+l.height]);var u=a[0]-o[0],h=a[1]-o[1],c=l.width,p=l.height,d=t.coordinateSystem=new ZC;d.zoomLimit=t.get("scaleLimit"),d.setBoundingRect(o[0],o[1],u,h),d.setViewRect(l.x,l.y,c,p),// Update roam info
d.setCenter(t.get("center"),e),d.setZoom(t.get("zoom")),n.push(d)}})),n}var wk=qu.prototype,Sk=th.prototype,Mk=function(){// Start point
this.x1=0,this.y1=0,// End point
this.x2=0,this.y2=0,this.percent=1};function Ik(t){return isNaN(+t.cpx1)||isNaN(+t.cpy1)}/** @class */!function(t){function e(){return null!==t&&t.apply(this,arguments)||this}n(e,t)}(Mk);const Tk=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="ec-line",n}return n(e,t),e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new Mk},e.prototype.buildPath=function(t,e){Ik(e)?wk.buildPath.call(this,t,e):Sk.buildPath.call(this,t,e)},e.prototype.pointAt=function(t){return Ik(this.shape)?wk.pointAt.call(this,t):Sk.pointAt.call(this,t)},e.prototype.tangentAt=function(t){var e=this.shape,n=Ik(e)?[e.x2-e.x1,e.y2-e.y1]:Sk.tangentAt.call(this,t);return Ct(n,n)},e}(ys);var Ck=["fromSymbol","toSymbol"];function Dk(t){return"_"+t+"Type"}
/**
             * @inner
             */function Ak(t,e,n){var i=e.getItemVisual(n,t);if(i&&"none"!==i){var r=e.getItemVisual(n,t+"Size"),o=e.getItemVisual(n,t+"Rotate"),a=e.getItemVisual(n,t+"Offset"),s=e.getItemVisual(n,t+"KeepAspect"),l=av(r),u=sv(a||0,l),h=ov(i,-l[0]/2+u[0],-l[1]/2+u[1],l[0],l[1],null,s);return h.__specifiedRotation=null==o||isNaN(o)?void 0:+o*Math.PI/180||0,h.name=t,h}}function kk(t,e){t.x1=e[0][0],t.y1=e[0][1],t.x2=e[1][0],t.y2=e[1][1],t.percent=1;var n=e[2];n?(t.cpx1=n[0],t.cpy1=n[1]):(t.cpx1=NaN,t.cpy1=NaN)}var Lk=/** @class */function(t){function e(e,n,i){var r=t.call(this)||this;return r._createLine(e,n,i),r}return n(e,t),e.prototype._createLine=function(t,e,n){var i=t.hostModel,r=function(t){var e=new Tk({name:"line",subPixelOptimize:!0});return kk(e.shape,t),e}(t.getItemLayout(e));r.shape.percent=0,Mh(r,{shape:{percent:1}},i,e),this.add(r),R(Ck,(function(n){var i=Ak(n,t,e);// symbols must added after line to make sure
// it will be updated after line#update.
// Or symbol position and rotation update in line#beforeUpdate will be one frame slow
this.add(i),this[Dk(n)]=t.getItemVisual(e,n)}),this),this._updateCommonStl(t,e,n)},// TODO More strict on the List type in parameters?
e.prototype.updateData=function(t,e,n){var i=t.hostModel,r=this.childOfName("line"),o=t.getItemLayout(e),a={shape:{}};kk(a.shape,o),Sh(r,a,i,e),R(Ck,(function(n){var i=t.getItemVisual(e,n),r=Dk(n);// Symbol changed
if(this[r]!==i){this.remove(this.childOfName(n));var o=Ak(n,t,e);this.add(o)}this[r]=i}),this),this._updateCommonStl(t,e,n)},e.prototype.getLinePath=function(){return this.childAt(0)},e.prototype._updateCommonStl=function(t,e,n){var i=t.hostModel,r=this.childOfName("line"),o=n&&n.emphasisLineStyle,a=n&&n.blurLineStyle,s=n&&n.selectLineStyle,l=n&&n.labelStatesModels,u=n&&n.emphasisDisabled,h=n&&n.focus,c=n&&n.blurScope;// Optimization for large dataset
if(!n||t.hasItemOption){var p=t.getItemModel(e),d=p.getModel("emphasis");o=d.getModel("lineStyle").getLineStyle(),a=p.getModel(["blur","lineStyle"]).getLineStyle(),s=p.getModel(["select","lineStyle"]).getLineStyle(),u=d.get("disabled"),h=d.get("focus"),c=d.get("blurScope"),l=sc(p)}var f=t.getItemVisual(e,"style"),g=f.stroke;r.useStyle(f),r.style.fill=null,r.style.strokeNoScale=!0,r.ensureState("emphasis").style=o,r.ensureState("blur").style=a,r.ensureState("select").style=s,// Update symbol
R(Ck,(function(t){var e=this.childOfName(t);if(e){// Share opacity and color with line.
e.setColor(g),e.style.opacity=f.opacity;for(var n=0;n<tl.length;n++){var i=tl[n],o=r.getState(i);if(o){var a=o.style||{},s=e.ensureState(i),l=s.style||(s.style={});null!=a.stroke&&(l[e.__isEmptyBrush?"stroke":"fill"]=a.stroke),null!=a.opacity&&(l.opacity=a.opacity)}}e.markRedraw()}}),this);var y=i.getRawValue(e);ac(this,l,{labelDataIndex:e,labelFetcher:{getFormattedLabel:function(e,n){return i.getFormattedLabel(e,n,t.dataType)}},inheritColor:g||"#000",defaultOpacity:f.opacity,defaultText:(null==y?t.getName(e):isFinite(y)?Br(y):y)+""});var v=this.getTextContent();// Always set `textStyle` even if `normalStyle.text` is null, because default
// values have to be set on `normalStyle`.
if(v){var m=l.normal;v.__align=v.style.align,v.__verticalAlign=v.style.verticalAlign,// 'start', 'middle', 'end'
v.__position=m.get("position")||"middle";var x=m.get("distance");G(x)||(x=[x,x]),v.__labelDistance=x}this.setTextConfig({position:null,local:!0,inside:!1}),Bl(this,h,c,u)},e.prototype.highlight=function(){Il(this)},e.prototype.downplay=function(){Tl(this)},e.prototype.updateLayout=function(t,e){this.setLinePoints(t.getItemLayout(e))},e.prototype.setLinePoints=function(t){var e=this.childOfName("line");kk(e.shape,t),e.dirty()},e.prototype.beforeUpdate=function(){var t=this,e=t.childOfName("fromSymbol"),n=t.childOfName("toSymbol"),i=t.getTextContent();// Quick reject
if(e||n||i&&!i.ignore){for(var r=1,o=this.parent;o;)o.scaleX&&(r/=o.scaleX),o=o.parent;var a=t.childOfName("line");// If line not changed
// FIXME Parent scale changed
if(this.__dirty||a.__dirty){var s=a.shape.percent,l=a.pointAt(0),u=a.pointAt(s),h=Mt([],u,l);if(Ct(h,h),e&&(e.setPosition(l),S(e,0),e.scaleX=e.scaleY=r*s,e.markRedraw()),n&&(n.setPosition(u),S(n,1),n.scaleX=n.scaleY=r*s,n.markRedraw()),i&&!i.ignore){i.x=i.y=0,i.originX=i.originY=0;var c=void 0,p=void 0,d=i.__labelDistance,f=d[0]*r,g=d[1]*r,y=s/2,v=a.tangentAt(y),m=[v[1],-v[0]],x=a.pointAt(y);m[1]>0&&(m[0]=-m[0],m[1]=-m[1]);var _=v[0]<0?-1:1;if("start"!==i.__position&&"end"!==i.__position){var b=-Math.atan2(v[1],v[0]);u[0]<l[0]&&(b=Math.PI+b),i.rotation=b}var w=void 0;switch(i.__position){case"insideStartTop":case"insideMiddleTop":case"insideEndTop":case"middle":w=-g,p="bottom";break;case"insideStartBottom":case"insideMiddleBottom":case"insideEndBottom":w=g,p="top";break;default:w=0,p="middle"}switch(i.__position){case"end":i.x=h[0]*f+u[0],i.y=h[1]*g+u[1],c=h[0]>.8?"left":h[0]<-.8?"right":"center",p=h[1]>.8?"top":h[1]<-.8?"bottom":"middle";break;case"start":i.x=-h[0]*f+l[0],i.y=-h[1]*g+l[1],c=h[0]>.8?"right":h[0]<-.8?"left":"center",p=h[1]>.8?"bottom":h[1]<-.8?"top":"middle";break;case"insideStartTop":case"insideStart":case"insideStartBottom":i.x=f*_+l[0],i.y=l[1]+w,c=v[0]<0?"right":"left",i.originX=-f*_,i.originY=-w;break;case"insideMiddleTop":case"insideMiddle":case"insideMiddleBottom":case"middle":i.x=x[0],i.y=x[1]+w,c="center",i.originY=-w;break;case"insideEndTop":case"insideEnd":case"insideEndBottom":i.x=-f*_+u[0],i.y=u[1]+w,c=v[0]>=0?"right":"left",i.originX=f*_,i.originY=-w}i.scaleX=i.scaleY=r,i.setStyle({// Use the user specified text align and baseline first
verticalAlign:i.__verticalAlign||p,align:i.__align||c})}}}function S(t,e){// Fix #12388
// when symbol is set to be 'arrow' in markLine,
// symbolRotate value will be ignored, and compulsively use tangent angle.
// rotate by default if symbol rotation is not specified
var n=t.__specifiedRotation;if(null==n){var i=a.tangentAt(e);t.attr("rotation",(1===e?-1:1)*Math.PI/2-Math.atan2(i[1],i[0]))}else t.attr("rotation",n)}},e}(Lr);const Pk=Lk;function Ok(t){var e=t.hostModel,n=e.getModel("emphasis");return{lineStyle:e.getModel("lineStyle").getLineStyle(),emphasisLineStyle:n.getModel(["lineStyle"]).getLineStyle(),blurLineStyle:e.getModel(["blur","lineStyle"]).getLineStyle(),selectLineStyle:e.getModel(["select","lineStyle"]).getLineStyle(),emphasisDisabled:n.get("disabled"),blurScope:n.get("blurScope"),focus:n.get("focus"),labelStatesModels:sc(e)}}function Rk(t){return isNaN(t[0])||isNaN(t[1])}function Nk(t){return t&&!Rk(t[0])&&!Rk(t[1])}const Ek=/** @class */function(){function t(t){this.group=new Lr,this._LineCtor=t||Pk}return t.prototype.updateData=function(t){var e=this;// Remove progressive els.
this._progressiveEls=null;var n=this,i=n.group,r=n._lineData;n._lineData=t,// There is no oldLineData only when first rendering or switching from
// stream mode to normal mode, where previous elements should be removed.
r||i.removeAll();var o=Ok(t);t.diff(r).add((function(n){e._doAdd(t,n,o)})).update((function(n,i){e._doUpdate(r,t,i,n,o)})).remove((function(t){i.remove(r.getItemGraphicEl(t))})).execute()},t.prototype.updateLayout=function(){var t=this._lineData;// Do not support update layout in incremental mode.
t&&t.eachItemGraphicEl((function(e,n){e.updateLayout(t,n)}),this)},t.prototype.incrementalPrepareUpdate=function(t){this._seriesScope=Ok(t),this._lineData=null,this.group.removeAll()},t.prototype.incrementalUpdate=function(t,e){function n(t){t.isGroup||function(t){return t.animators&&t.animators.length>0}(t)||(t.incremental=!0,t.ensureState("emphasis").hoverLayer=!0)}this._progressiveEls=[];for(var i=t.start;i<t.end;i++)if(Nk(e.getItemLayout(i))){var r=new this._LineCtor(e,i,this._seriesScope);r.traverse(n),this.group.add(r),e.setItemGraphicEl(i,r),this._progressiveEls.push(r)}},t.prototype.remove=function(){this.group.removeAll()},t.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},t.prototype._doAdd=function(t,e,n){if(Nk(t.getItemLayout(e))){var i=new this._LineCtor(t,e,n);t.setItemGraphicEl(e,i),this.group.add(i)}},t.prototype._doUpdate=function(t,e,n,i,r){var o=t.getItemGraphicEl(n);Nk(e.getItemLayout(i))?(o?o.updateData(e,i,r):o=new this._LineCtor(e,i,r),e.setItemGraphicEl(i,o),this.group.add(o)):this.group.remove(o)},t}();var zk=[],Vk=[],Bk=[],Fk=mn,Gk=kt,Wk=Math.abs;function Hk(t,e,n){for(var i,r=t[0],o=t[1],a=t[2],s=1/0,l=n*n,u=.1,h=.1;h<=.9;h+=.1)zk[0]=Fk(r[0],o[0],a[0],h),zk[1]=Fk(r[1],o[1],a[1],h),(d=Wk(Gk(zk,e)-l))<s&&(s=d,i=h);// Assume the segment is monotoneFind root through Bisection method
// At most 32 iteration
for(var c=0;c<32;c++){// let prev = t - interval;
var p=i+u;// v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
// v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);
Vk[0]=Fk(r[0],o[0],a[0],i),Vk[1]=Fk(r[1],o[1],a[1],i),Bk[0]=Fk(r[0],o[0],a[0],p),Bk[1]=Fk(r[1],o[1],a[1],p);var d=Gk(Vk,e)-l;if(Wk(d)<.01)break;// let prevDiff = v2DistSquare(v1, center) - radiusSquare;
var f=Gk(Bk,e)-l;u/=2,d<0?f>=0?i+=u:i-=u:f>=0?i-=u:i+=u}return i}// Adjust edge to avoid
function Yk(t,e){var n=[],i=bn,r=[[],[],[]],o=[[],[]],a=[];e/=2,t.eachEdge((function(t,s){var l=t.getLayout(),u=t.getVisual("fromSymbol"),h=t.getVisual("toSymbol");l.__original||(l.__original=[_t(l[0]),_t(l[1])],l[2]&&l.__original.push(_t(l[2])));var c=l.__original;// Quadratic curve
if(null!=l[2]){if(xt(r[0],c[0]),xt(r[1],c[2]),xt(r[2],c[1]),u&&"none"!==u){var p=pk(t.node1),d=Hk(r,c[0],p*e);// Subdivide and get the second
i(r[0][0],r[1][0],r[2][0],d,n),r[0][0]=n[3],r[1][0]=n[4],i(r[0][1],r[1][1],r[2][1],d,n),r[0][1]=n[3],r[1][1]=n[4]}h&&"none"!==h&&(p=pk(t.node2),d=Hk(r,c[1],p*e),// Subdivide and get the first
i(r[0][0],r[1][0],r[2][0],d,n),r[1][0]=n[1],r[2][0]=n[2],i(r[0][1],r[1][1],r[2][1],d,n),r[1][1]=n[1],r[2][1]=n[2]),// Copy back to layout
xt(l[0],r[0]),xt(l[1],r[2]),xt(l[2],r[1])}// Line
else xt(o[0],c[0]),xt(o[1],c[1]),Mt(a,o[1],o[0]),Ct(a,a),u&&"none"!==u&&(p=pk(t.node1),St(o[0],o[0],a,p*e)),h&&"none"!==h&&(p=pk(t.node2),St(o[1],o[1],a,-p*e)),xt(l[0],o[0]),xt(l[1],o[1])}))}function Xk(t){return"view"===t.type}var Uk=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(t,e){var n=new TS,i=new Ek,r=this.group;this._controller=new RT(e.getZr()),this._controllerHost={target:r},r.add(n.group),r.add(i.group),this._symbolDraw=n,this._lineDraw=i,this._firstRender=!0},e.prototype.render=function(t,e,n){var i=this,r=t.coordinateSystem;this._model=t;var o=this._symbolDraw,a=this._lineDraw,s=this.group;if(Xk(r)){var l={x:r.x,y:r.y,scaleX:r.scaleX,scaleY:r.scaleY};this._firstRender?s.attr(l):Sh(s,l,t)}// Fix edge contact point with node
Yk(t.getGraph(),ck(t));var u=t.getData();o.updateData(u);var h=t.getEdgeData();// TODO: TYPE
a.updateData(h),this._updateNodeAndLinkScale(),this._updateController(t,e,n),clearTimeout(this._layoutTimeout);var c=t.forceLayout,p=t.get(["force","layoutAnimation"]);c&&this._startForceLayoutIteration(c,p);var d=t.get("layout");u.graph.eachNode((function(e){var n=e.dataIndex,r=e.getGraphicEl(),o=e.getModel();if(r){// Update draggable
r.off("drag").off("dragend");var a=o.get("draggable");a&&r.on("drag",(function(o){switch(d){case"force":c.warmUp(),!i._layouting&&i._startForceLayoutIteration(c,p),c.setFixed(n),// Write position back to layout
u.setItemLayout(n,[r.x,r.y]);break;case"circular":u.setItemLayout(n,[r.x,r.y]),// mark node fixed
e.setLayout({fixed:!0},!0),// recalculate circular layout
gk(t,"symbolSize",e,[o.offsetX,o.offsetY]),i.updateLayout(t);break;default:u.setItemLayout(n,[r.x,r.y]),// update edge
uk(t.getGraph(),t),i.updateLayout(t)}})).on("dragend",(function(){c&&c.setUnfixed(n)})),r.setDraggable(a,!!o.get("cursor")),"adjacency"===o.get(["emphasis","focus"])&&(js(r).focus=e.getAdjacentDataIndices())}})),u.graph.eachEdge((function(t){var e=t.getGraphicEl(),n=t.getModel().get(["emphasis","focus"]);e&&"adjacency"===n&&(js(e).focus={edge:[t.dataIndex],node:[t.node1.dataIndex,t.node2.dataIndex]})}));var f="circular"===t.get("layout")&&t.get(["circular","rotateLabel"]),g=u.getLayout("cx"),y=u.getLayout("cy");u.graph.eachNode((function(t){vk(t,f,g,y)})),this._firstRender=!1},e.prototype.dispose=function(){this._controller&&this._controller.dispose(),this._controllerHost=null},e.prototype._startForceLayoutIteration=function(t,e){var n=this;!function i(){t.step((function(t){n.updateLayout(n._model),(n._layouting=!t)&&(e?n._layoutTimeout=setTimeout(i,16):i())}))}()},e.prototype._updateController=function(t,e,n){var i=this,r=this._controller,o=this._controllerHost,a=this.group;r.setPointerChecker((function(e,i,r){var o=a.getBoundingRect();return o.applyTransform(a.transform),o.contain(i,r)&&!BT(e,n,t)})),Xk(t.coordinateSystem)?(r.enable(t.get("roam")),o.zoomLimit=t.get("scaleLimit"),o.zoom=t.coordinateSystem.getZoom(),r.off("pan").off("zoom").on("pan",(function(e){NT(o,e.dx,e.dy),n.dispatchAction({seriesId:t.id,type:"graphRoam",dx:e.dx,dy:e.dy})})).on("zoom",(function(e){ET(o,e.scale,e.originX,e.originY),n.dispatchAction({seriesId:t.id,type:"graphRoam",zoom:e.scale,originX:e.originX,originY:e.originY}),i._updateNodeAndLinkScale(),Yk(t.getGraph(),ck(t)),i._lineDraw.updateLayout(),// Only update label layout on zoom
n.updateLabelLayout()}))):r.disable()},e.prototype._updateNodeAndLinkScale=function(){var t=this._model,e=t.getData(),n=ck(t);e.eachItemGraphicEl((function(t,e){t&&t.setSymbolScale(n)}))},e.prototype.updateLayout=function(t){Yk(t.getGraph(),ck(t)),this._symbolDraw.updateLayout(),this._lineDraw.updateLayout()},e.prototype.remove=function(t,e){this._symbolDraw&&this._symbolDraw.remove(),this._lineDraw&&this._lineDraw.remove()},e.type="graph",e}(qg);const Zk=Uk;function jk(t){return"_EC_"+t}var qk=/** @class */function(){function t(t){this.type="graph",this.nodes=[],this.edges=[],this._nodesMap={},
/**
                 * @type {Object.<string, module:echarts/data/Graph.Edge>}
                 * @private
                 */
this._edgesMap={},this._directed=t||!1}
/**
               * If is directed graph
               */return t.prototype.isDirected=function(){return this._directed},
/**
               * Add a new node
               */
t.prototype.addNode=function(t,e){t=null==t?""+e:""+t;var n=this._nodesMap;if(!n[jk(t)]){var i=new Kk(t,e);return i.hostGraph=this,this.nodes.push(i),n[jk(t)]=i,i}},
/**
               * Get node by data index
               */
t.prototype.getNodeByIndex=function(t){var e=this.data.getRawIndex(t);return this.nodes[e]},
/**
               * Get node by id
               */
t.prototype.getNodeById=function(t){return this._nodesMap[jk(t)]},
/**
               * Add a new edge
               */
t.prototype.addEdge=function(t,e,n){var i=this._nodesMap,r=this._edgesMap;if(// PNEDING
X(t)&&(t=this.nodes[t]),X(e)&&(e=this.nodes[e]),t instanceof Kk||(t=i[jk(t)]),e instanceof Kk||(e=i[jk(e)]),t&&e){var o=t.id+"-"+e.id,a=new $k(t,e,n);return a.hostGraph=this,this._directed&&(t.outEdges.push(a),e.inEdges.push(a)),t.edges.push(a),t!==e&&e.edges.push(a),this.edges.push(a),r[o]=a,a}},
/**
               * Get edge by data index
               */
t.prototype.getEdgeByIndex=function(t){var e=this.edgeData.getRawIndex(t);return this.edges[e]},
/**
               * Get edge by two linked nodes
               */
t.prototype.getEdge=function(t,e){t instanceof Kk&&(t=t.id),e instanceof Kk&&(e=e.id);var n=this._edgesMap;return this._directed?n[t+"-"+e]:n[t+"-"+e]||n[e+"-"+t]},
/**
               * Iterate all nodes
               */
t.prototype.eachNode=function(t,e){for(var n=this.nodes,i=n.length,r=0;r<i;r++)n[r].dataIndex>=0&&t.call(e,n[r],r)},
/**
               * Iterate all edges
               */
t.prototype.eachEdge=function(t,e){for(var n=this.edges,i=n.length,r=0;r<i;r++)n[r].dataIndex>=0&&n[r].node1.dataIndex>=0&&n[r].node2.dataIndex>=0&&t.call(e,n[r],r)},
/**
               * Breadth first traverse
               * Return true to stop traversing
               */
t.prototype.breadthFirstTraverse=function(t,e,n,i){if(e instanceof Kk||(e=this._nodesMap[jk(e)]),e){for(var r="out"===n?"outEdges":"in"===n?"inEdges":"edges",o=0;o<this.nodes.length;o++)this.nodes[o].__visited=!1;if(!t.call(i,e,null))for(var a=[e];a.length;){var s=a.shift(),l=s[r];for(o=0;o<l.length;o++){var u=l[o],h=u.node1===s?u.node2:u.node1;if(!h.__visited){if(t.call(i,h,s))// Stop traversing
return;a.push(h),h.__visited=!0}}}}},// depthFirstTraverse(
//     cb, startNode, direction, context
// ) {
// };
// Filter update
t.prototype.update=function(){for(var t=this.data,e=this.edgeData,n=this.nodes,i=this.edges,r=0,o=n.length;r<o;r++)n[r].dataIndex=-1;for(r=0,o=t.count();r<o;r++)n[t.getRawIndex(r)].dataIndex=r;// Update edge
for(e.filterSelf((function(t){var n=i[e.getRawIndex(t)];return n.node1.dataIndex>=0&&n.node2.dataIndex>=0})),r=0,o=i.length;r<o;r++)i[r].dataIndex=-1;for(r=0,o=e.count();r<o;r++)i[e.getRawIndex(r)].dataIndex=r},
/**
               * @return {module:echarts/data/Graph}
               */
t.prototype.clone=function(){for(var e=new t(this._directed),n=this.nodes,i=this.edges,r=0;r<n.length;r++)e.addNode(n[r].id,n[r].dataIndex);for(r=0;r<i.length;r++){var o=i[r];e.addEdge(o.node1.id,o.node2.id,o.dataIndex)}return e},t}(),Kk=/** @class */function(){function t(t,e){this.inEdges=[],this.outEdges=[],this.edges=[],this.dataIndex=-1,this.id=null==t?"":t,this.dataIndex=null==e?-1:e}
/**
               * @return {number}
               */return t.prototype.degree=function(){return this.edges.length},
/**
               * @return {number}
               */
t.prototype.inDegree=function(){return this.inEdges.length},
/**
              * @return {number}
              */
t.prototype.outDegree=function(){return this.outEdges.length},t.prototype.getModel=function(t){if(!(this.dataIndex<0))return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t)},t.prototype.getAdjacentDataIndices=function(){for(var t={edge:[],node:[]},e=0;e<this.edges.length;e++){var n=this.edges[e];n.dataIndex<0||(t.edge.push(n.dataIndex),t.node.push(n.node1.dataIndex,n.node2.dataIndex))}return t},t}(),$k=/** @class */function(){function t(t,e,n){this.dataIndex=-1,this.node1=t,this.node2=e,this.dataIndex=null==n?-1:n}// eslint-disable-next-line @typescript-eslint/no-unused-vars
return t.prototype.getModel=function(t){if(!(this.dataIndex<0))return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t)},t.prototype.getAdjacentDataIndices=function(){return{edge:[this.dataIndex],node:[this.node1.dataIndex,this.node2.dataIndex]}},t}();function Jk(t,e){return{
/**
                 * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
                 */
getValue:function(n){var i=this[t][e];return i.getStore().get(i.getDimensionIndex(n||"value"),this.dataIndex)},// TODO: TYPE stricter type.
setVisual:function(n,i){this.dataIndex>=0&&this[t][e].setItemVisual(this.dataIndex,n,i)},getVisual:function(n){return this[t][e].getItemVisual(this.dataIndex,n)},setLayout:function(n,i){this.dataIndex>=0&&this[t][e].setItemLayout(this.dataIndex,n,i)},getLayout:function(){return this[t][e].getItemLayout(this.dataIndex)},getGraphicEl:function(){return this[t][e].getItemGraphicEl(this.dataIndex)},getRawIndex:function(){return this[t][e].getRawIndex(this.dataIndex)}}}P(Kk,Jk("hostGraph","data")),P($k,Jk("hostGraph","edgeData"));const Qk=qk;function tL(t,e,n,i,r){for(// ??? TODO
// support dataset?
var o=new Qk(i),a=0;a<t.length;a++)o.addNode(J(// Id, name, dataIndex
t[a].id,t[a].name,a),a);var s=[],l=[],u=0;for(a=0;a<e.length;a++){var h=e[a],c=h.source,p=h.target;// addEdge may fail when source or target not exists
o.addEdge(c,p,u)&&(l.push(h),s.push(J(vo(h.id,null),c+" > "+p)),u++)}var d,f=n.get("coordinateSystem");if("cartesian2d"===f||"polar"===f)d=Cx(t,n);else{var g=Ad.get(f),y=g&&g.dimensions||[];// FIXME: Some geo do not need `value` dimenson, whereas `calendar` needs
// `value` dimension, but graph need `value` dimension. It's better to
// uniform this behavior.
L(y,"value")<0&&y.concat(["value"]);var v=mx(t,{coordDimensions:y,encodeDefine:n.getEncode()}).dimensions;(d=new vx(v,n)).initData(t)}var m=new vx(["value"],n);return m.initData(l,s),r&&r(d,m),kD({mainData:d,struct:o,structAttr:"graph",datas:{node:d,edge:m},datasAttr:{node:"data",edge:"edgeData"}}),// Update dataIndex of nodes and edges because invalid edge may be removed
o.update(),o}var eL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n}return n(e,t),e.prototype.init=function(e){t.prototype.init.apply(this,arguments);var n=this;function i(){return n._categoriesData}// Provide data for legend select
this.legendVisualProvider=new jM(i,i),this.fillDataTextStyle(e.edges||e.links),this._updateCategoriesData()},e.prototype.mergeOption=function(e){t.prototype.mergeOption.apply(this,arguments),this.fillDataTextStyle(e.edges||e.links),this._updateCategoriesData()},e.prototype.mergeDefaultAndTheme=function(e){t.prototype.mergeDefaultAndTheme.apply(this,arguments),uo(e,"edgeLabel",["show"])},e.prototype.getInitialData=function(t,e){var n,i=t.edges||t.links||[],r=t.data||t.nodes||[],o=this;if(r&&i){nk(// auto curveness
n=this)&&(n.__curvenessList=[],n.__edgeMap={},// calc the array of curveness List
ik(n));var a=tL(r,i,this,!0,(function(t,e){// Overwrite nodeData.getItemModel to
t.wrapMethod("getItemModel",(function(t){var e=o._categoriesModels[t.getShallow("category")];return e&&(e.parentModel=t.parentModel,t.parentModel=e),t}));// TODO Inherit resolveParentPath by default in Model#getModel?
var n=Pc.prototype.getModel;function i(t,e){var i=n.call(this,t,e);return i.resolveParentPath=r,i}function r(t){if(t&&("label"===t[0]||"label"===t[1])){var e=t.slice();return"label"===t[0]?e[0]="edgeLabel":"label"===t[1]&&(e[1]="edgeLabel"),e}return t}e.wrapMethod("getItemModel",(function(t){return t.resolveParentPath=r,t.getModel=i,t}))}));return R(a.edges,(function(t){!
/**
             * set edgeMap with key
             * @param {number|string|module:echarts/data/Graph.Node} n1
             * @param {number|string|module:echarts/data/Graph.Node} n2
             * @param {module:echarts/model/SeriesModel} seriesModel
             * @param {number} index
             */
function(t,e,n,i){if(nk(n)){var r=rk(t,e,n),o=n.__edgeMap,a=o[ok(r)];// set direction
o[r]&&!a?o[r].isForward=!0:a&&o[r]&&(a.isForward=!0,o[r].isForward=!1),o[r]=o[r]||[],o[r].push(i)}}(t.node1,t.node2,this,t.dataIndex)}),this),a.data}},e.prototype.getGraph=function(){return this.getData().graph},e.prototype.getEdgeData=function(){return this.getGraph().edgeData},e.prototype.getCategoriesData=function(){return this._categoriesData},e.prototype.formatTooltip=function(t,e,n){if("edge"===n){var i=this.getData(),r=this.getDataParams(t,n),o=i.graph.getEdgeByIndex(t),a=i.getName(o.node1.dataIndex),s=i.getName(o.node2.dataIndex),l=[];return null!=a&&l.push(a),null!=s&&l.push(s),dg("nameValue",{name:l.join(" > "),value:r.value,noValue:null==r.value})}// dataType === 'node' or empty
return Ig({series:this,dataIndex:t,multipleSeries:e})},e.prototype._updateCategoriesData=function(){var t=N(this.option.categories||[],(function(t){// Data must has value
return null!=t.value?t:A({value:0},t)})),e=new vx(["value"],this);e.initData(t),this._categoriesData=e,this._categoriesModels=e.mapArray((function(t){return e.getItemModel(t)}))},e.prototype.setZoom=function(t){this.option.zoom=t},e.prototype.setCenter=function(t){this.option.center=t},e.prototype.isAnimationEnabled=function(){return t.prototype.isAnimationEnabled.call(this)&&!("force"===this.get("layout")&&this.get(["force","layoutAnimation"]))},e.type="series.graph",e.dependencies=["grid","polar","geo","singleAxis","calendar"],e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"view",// Default option for all coordinate systems
// xAxisIndex: 0,
// yAxisIndex: 0,
// polarIndex: 0,
// geoIndex: 0,
legendHoverLink:!0,layout:null,// Configuration of circular layout
circular:{rotateLabel:!1},// Configuration of force directed layout
force:{initLayout:null,// Node repulsion. Can be an array to represent range.
repulsion:[0,50],gravity:.1,// Initial friction
friction:.6,// Edge length. Can be an array to represent range.
edgeLength:30,layoutAnimation:!0},left:"center",top:"center",// right: null,
// bottom: null,
// width: '80%',
// height: '80%',
symbol:"circle",symbolSize:10,edgeSymbol:["none","none"],edgeSymbolSize:10,edgeLabel:{position:"middle",distance:5},draggable:!1,roam:!1,// Default on center of graph
center:null,zoom:1,// Symbol size scale ratio in roam
nodeScaleRatio:.6,// cursor: null,
// categories: [],
// data: []
// Or
// nodes: []
// links: []
// Or
// edges: []
label:{show:!1,formatter:"{b}"},itemStyle:{},lineStyle:{color:"#aaa",width:1,opacity:.5},emphasis:{scale:!0,label:{show:!0}},select:{itemStyle:{borderColor:"#212121"}}},e}(zg);const nL=eL;var iL={type:"graphRoam",event:"graphRoam",update:"none"},rL=function(){this.angle=0,this.width=10,this.r=10,this.x=0,this.y=0},oL=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="pointer",n}return n(e,t),e.prototype.getDefaultShape=function(){return new rL},e.prototype.buildPath=function(t,e){var n=Math.cos,i=Math.sin,r=e.r,o=e.width,a=e.angle,s=e.x-n(a)*o*(o>=r/3?1:2),l=e.y-i(a)*o*(o>=r/3?1:2);a=e.angle-Math.PI/2,t.moveTo(s,l),t.lineTo(e.x+n(a)*o,e.y+i(a)*o),t.lineTo(e.x+n(e.angle)*r,e.y+i(e.angle)*r),t.lineTo(e.x-n(a)*o,e.y-i(a)*o),t.lineTo(s,l)},e}(ys);const aL=oL;function sL(t,e){var n=null==t?"":t+"";return e&&(H(e)?n=e.replace("{value}",n):W(e)&&(n=e(t))),n}var lL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){this.group.removeAll();var i=t.get(["axisLine","lineStyle","color"]),r=function(t,e){var n=t.get("center"),i=e.getWidth(),r=e.getHeight(),o=Math.min(i,r);return{cx:Vr(n[0],e.getWidth()),cy:Vr(n[1],e.getHeight()),r:Vr(t.get("radius"),o/2)}}(t,n);this._renderMain(t,e,n,i,r),this._data=t.getData()},e.prototype.dispose=function(){},e.prototype._renderMain=function(t,e,n,i,r){var o=this.group,a=t.get("clockwise"),s=-t.get("startAngle")/180*Math.PI,l=-t.get("endAngle")/180*Math.PI,u=t.getModel("axisLine"),h=u.get("roundCap")?uM:Nu,c=u.get("show"),p=u.getModel("lineStyle"),d=p.get("width"),f=[s,l];Za(f,!a);for(var g=(l=f[1])-(s=f[0]),y=s,v=[],m=0;c&&m<i.length;m++){// Clamp
var x=new h({shape:{startAngle:y,endAngle:l=s+g*Math.min(Math.max(i[m][0],0),1),cx:r.cx,cy:r.cy,clockwise:a,r0:r.r-d,r:r.r},silent:!0});x.setStyle({fill:i[m][1]}),x.setStyle(p.getLineStyle(// Because we use sector to simulate arc
// so the properties for stroking are useless
["color","width"])),v.push(x),y=l}v.reverse(),R(v,(function(t){return o.add(t)}));var _=function(t){// Less than 0
if(t<=0)return i[0][1];var e;for(e=0;e<i.length;e++)if(i[e][0]>=t&&(0===e?0:i[e-1][0])<t)return i[e][1];// More than 1
return i[e-1][1]};this._renderTicks(t,e,n,_,r,s,l,a,d),this._renderTitleAndDetail(t,e,n,_,r),this._renderAnchor(t,r),this._renderPointer(t,e,n,_,r,s,l,a,d)},e.prototype._renderTicks=function(t,e,n,i,r,o,a,s,l){for(var u,h,c=this.group,p=r.cx,d=r.cy,f=r.r,g=+t.get("min"),y=+t.get("max"),v=t.getModel("splitLine"),m=t.getModel("axisTick"),x=t.getModel("axisLabel"),_=t.get("splitNumber"),b=m.get("splitNumber"),w=Vr(v.get("length"),f),S=Vr(m.get("length"),f),M=o,I=(a-o)/_,T=I/b,C=v.getModel("lineStyle").getLineStyle(),D=m.getModel("lineStyle").getLineStyle(),A=v.get("distance"),k=0;k<=_;k++){// Split line
if(u=Math.cos(M),h=Math.sin(M),v.get("show")){var L=new qu({shape:{x1:u*(f-(P=A?A+l:l))+p,y1:h*(f-P)+d,x2:u*(f-w-P)+p,y2:h*(f-w-P)+d},style:C,silent:!0});"auto"===C.stroke&&L.setStyle({stroke:i(k/_)}),c.add(L)}// Label
if(x.get("show")){var P=x.get("distance")+A,O=sL(Br(k/_*(y-g)+g),x.get("formatter")),R=i(k/_),N=u*(f-w-P)+p,E=h*(f-w-P)+d,z=x.get("rotate"),V=0;"radial"===z?(V=-M+2*Math.PI)>Math.PI/2&&(V+=Math.PI):"tangential"===z?V=-M-Math.PI/2:X(z)&&(V=z*Math.PI/180),0===V?c.add(new Zs({style:lc(x,{text:O,x:N,y:E,verticalAlign:h<-.8?"top":h>.8?"bottom":"middle",align:u<-.4?"left":u>.4?"right":"center"},{inheritColor:R}),silent:!0})):c.add(new Zs({style:lc(x,{text:O,x:N,y:E,verticalAlign:"middle",align:"center"},{inheritColor:R}),silent:!0,originX:N,originY:E,rotation:V}))}// Axis tick
if(m.get("show")&&k!==_){P=(P=m.get("distance"))?P+l:l;for(var B=0;B<=b;B++){u=Math.cos(M),h=Math.sin(M);var F=new qu({shape:{x1:u*(f-P)+p,y1:h*(f-P)+d,x2:u*(f-S-P)+p,y2:h*(f-S-P)+d},silent:!0,style:D});"auto"===D.stroke&&F.setStyle({stroke:i((k+B/b)/_)}),c.add(F),M+=T}M-=T}else M+=I}},e.prototype._renderPointer=function(t,e,n,i,r,o,a,s,l){var u=this.group,h=this._data,c=this._progressEls,p=[],d=t.get(["pointer","show"]),f=t.getModel("progress"),g=f.get("show"),y=t.getData(),v=y.mapDimension("value"),m=+t.get("min"),x=+t.get("max"),_=[m,x],b=[o,a];function w(e,n){var i,o=y.getItemModel(e).getModel("pointer"),a=Vr(o.get("width"),r.r),s=Vr(o.get("length"),r.r),l=t.get(["pointer","icon"]),u=o.get("offsetCenter"),h=Vr(u[0],r.r),c=Vr(u[1],r.r),p=o.get("keepAspect");// not exist icon type will be set 'rect'
return(i=l?ov(l,h-a/2,c-s,a,s,null,p):new aL({shape:{angle:-Math.PI/2,width:a,r:s,x:h,y:c}})).rotation=-(n+Math.PI/2),i.x=r.cx,i.y=r.cy,i}function S(t,e){var n=f.get("roundCap")?uM:Nu,i=f.get("overlap"),a=i?f.get("width"):l/y.count(),u=i?r.r-a:r.r-(t+1)*a,h=i?r.r:r.r-t*a,c=new n({shape:{startAngle:o,endAngle:e,cx:r.cx,cy:r.cy,clockwise:s,r0:u,r:h}});return i&&(c.z2=x-y.get(v,t)%x),c}(g||d)&&(y.diff(h).add((function(e){var n=y.get(v,e);if(d){var i=w(e,o);// TODO hide pointer on NaN value?
Mh(i,{rotation:-((isNaN(+n)?b[0]:zr(n,_,b,!0))+Math.PI/2)},t),u.add(i),y.setItemGraphicEl(e,i)}if(g){var r=S(e,o),a=f.get("clip");Mh(r,{shape:{endAngle:zr(n,_,b,a)}},t),u.add(r),// Add data index and series index for indexing the data by element
// Useful in tooltip
qs(t.seriesIndex,y.dataType,e,r),p[e]=r}})).update((function(e,n){var i=y.get(v,e);if(d){var r=h.getItemGraphicEl(n),a=r?r.rotation:o,s=w(e,a);s.rotation=a,Sh(s,{rotation:-((isNaN(+i)?b[0]:zr(i,_,b,!0))+Math.PI/2)},t),u.add(s),y.setItemGraphicEl(e,s)}if(g){var l=c[n],m=S(e,l?l.shape.endAngle:o),x=f.get("clip");Sh(m,{shape:{endAngle:zr(i,_,b,x)}},t),u.add(m),// Add data index and series index for indexing the data by element
// Useful in tooltip
qs(t.seriesIndex,y.dataType,e,m),p[e]=m}})).execute(),y.each((function(t){var e=y.getItemModel(t),n=e.getModel("emphasis"),r=n.get("focus"),o=n.get("blurScope"),a=n.get("disabled");if(d){var s=y.getItemGraphicEl(t),l=y.getItemVisual(t,"style"),u=l.fill;if(s instanceof Ss){var h=s.style;s.useStyle(A({image:h.image,x:h.x,y:h.y,width:h.width,height:h.height},l))}else s.useStyle(l),"pointer"!==s.type&&s.setColor(u);s.setStyle(e.getModel(["pointer","itemStyle"]).getItemStyle()),"auto"===s.style.fill&&s.setStyle("fill",i(zr(y.get(v,t),_,[0,1],!0))),s.z2EmphasisLift=0,Hl(s,e),Bl(s,r,o,a)}if(g){var c=p[t];c.useStyle(y.getItemVisual(t,"style")),c.setStyle(e.getModel(["progress","itemStyle"]).getItemStyle()),c.z2EmphasisLift=0,Hl(c,e),Bl(c,r,o,a)}})),this._progressEls=p)},e.prototype._renderAnchor=function(t,e){var n=t.getModel("anchor");if(n.get("show")){var i=n.get("size"),r=n.get("icon"),o=n.get("offsetCenter"),a=n.get("keepAspect"),s=ov(r,e.cx-i/2+Vr(o[0],e.r),e.cy-i/2+Vr(o[1],e.r),i,i,null,a);s.z2=n.get("showAbove")?1:0,s.setStyle(n.getModel("itemStyle").getItemStyle()),this.group.add(s)}},e.prototype._renderTitleAndDetail=function(t,e,n,i,r){var o=this,a=t.getData(),s=a.mapDimension("value"),l=+t.get("min"),u=+t.get("max"),h=new Lr,c=[],p=[],d=t.isAnimationEnabled(),f=t.get(["pointer","showAbove"]);a.diff(this._data).add((function(t){c[t]=new Zs({silent:!0}),p[t]=new Zs({silent:!0})})).update((function(t,e){c[t]=o._titleEls[e],p[t]=o._detailEls[e]})).execute(),a.each((function(e){var n=a.getItemModel(e),o=a.get(s,e),g=new Lr,y=i(zr(o,[l,u],[0,1],!0)),v=n.getModel("title");if(v.get("show")){var m=v.get("offsetCenter"),x=r.cx+Vr(m[0],r.r),_=r.cy+Vr(m[1],r.r);(D=c[e]).attr({z2:f?0:2,style:lc(v,{x:x,y:_,text:a.getName(e),align:"center",verticalAlign:"middle"},{inheritColor:y})}),g.add(D)}var b=n.getModel("detail");if(b.get("show")){var w=b.get("offsetCenter"),S=r.cx+Vr(w[0],r.r),M=r.cy+Vr(w[1],r.r),I=Vr(b.get("width"),r.r),T=Vr(b.get("height"),r.r),C=t.get(["progress","show"])?a.getItemVisual(e,"style").fill:y,D=p[e],A=b.get("formatter");D.attr({z2:f?0:2,style:lc(b,{x:S,y:M,text:sL(o,A),width:isNaN(I)?null:I,height:isNaN(T)?null:T,align:"center",verticalAlign:"middle"},{inheritColor:C})}),yc(D,{normal:b},o,(function(t){return sL(t,A)})),d&&vc(D,e,a,t,{getFormattedLabel:function(t,e,n,i,r,a){return sL(a?a.interpolatedValue:o,A)}}),g.add(D)}h.add(g)})),this.group.add(h),this._titleEls=c,this._detailEls=p},e.type="gauge",e}(qg);const uL=lL;var hL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.visualStyleAccessPath="itemStyle",n}return n(e,t),e.prototype.getInitialData=function(t,e){return UM(this,["value"])},e.type="series.gauge",e.defaultOption={// zlevel: 0,
z:2,colorBy:"data",// 
center:["50%","50%"],legendHoverLink:!0,radius:"75%",startAngle:225,endAngle:-45,clockwise:!0,// 
min:0,// 
max:100,// 10
splitNumber:10,// 
axisLine:{// show
show:!0,roundCap:!1,lineStyle:{color:[[1,"#E6EBF8"]],width:10}},// 
progress:{// show
show:!1,overlap:!0,width:10,roundCap:!1,clip:!0},// 
splitLine:{// show
show:!0,// length
length:10,distance:10,// lineStylelineStyle
lineStyle:{color:"#63677A",width:3,type:"solid"}},// 
axisTick:{// show
show:!0,// split
splitNumber:5,// length
length:6,distance:10,// lineStyle
lineStyle:{color:"#63677A",width:1,type:"solid"}},axisLabel:{show:!0,distance:15,// formatter: null,
color:"#464646",fontSize:12,rotate:0},pointer:{icon:null,offsetCenter:[0,0],show:!0,showAbove:!0,length:"60%",width:6,keepAspect:!1},anchor:{show:!1,showAbove:!1,size:6,icon:"circle",offsetCenter:[0,0],keepAspect:!1,itemStyle:{color:"#fff",borderWidth:0,borderColor:"#5470c6"}},title:{show:!0,// x, ypx
offsetCenter:[0,"20%"],// TEXTSTYLE
color:"#464646",fontSize:16,valueAnimation:!1},detail:{show:!0,backgroundColor:"rgba(0,0,0,0)",borderWidth:0,borderColor:"#ccc",width:100,height:null,padding:[5,10],// x, ypx
offsetCenter:[0,"40%"],// formatter: null,
// TEXTSTYLE
color:"#464646",fontSize:30,fontWeight:"bold",lineHeight:30,valueAnimation:!1}},e}(zg);const cL=hL;var pL=["itemStyle","opacity"],dL=/** @class */function(t){function e(e,n){var i=t.call(this)||this,r=i,o=new Xu,a=new Zs;return r.setTextContent(a),i.setTextGuideLine(o),i.updateData(e,n,!0),i}return n(e,t),e.prototype.updateData=function(t,e,n){var i=this,r=t.hostModel,o=t.getItemModel(e),a=t.getItemLayout(e),s=o.getModel("emphasis"),l=o.get(pL);l=null==l?1:l,n||Ah(i),// Update common style
i.useStyle(t.getItemVisual(e,"style")),i.style.lineJoin="round",n?(i.setShape({points:a.points}),i.style.opacity=0,Mh(i,{style:{opacity:l}},r,e)):Sh(i,{style:{opacity:l},shape:{points:a.points}},r,e),Hl(i,o),this._updateLabel(t,e),Bl(this,s.get("focus"),s.get("blurScope"),s.get("disabled"))},e.prototype._updateLabel=function(t,e){var n=this,i=this.getTextGuideLine(),r=n.getTextContent(),o=t.hostModel,a=t.getItemModel(e),s=t.getItemLayout(e).label,l=t.getItemVisual(e,"style"),u=l.fill;ac(// position will not be used in setLabelStyle
r,sc(a),{labelFetcher:t.hostModel,labelDataIndex:e,defaultOpacity:l.opacity,defaultText:t.getName(e)},{normal:{align:s.textAlign,verticalAlign:s.verticalAlign}}),n.setTextConfig({local:!0,inside:!!s.inside,insideStroke:u,// insideFill: 'auto',
outsideFill:u});var h=s.linePoints;i.setShape({points:h}),n.textGuideLineConfig={anchor:h?new ve(h[0][0],h[0][1]):null},// Make sure update style on labelText after setLabelStyle.
// Because setLabelStyle will replace a new style on it.
Sh(r,{style:{x:s.x,y:s.y}},o,e),r.attr({rotation:s.rotation,originX:s.x,originY:s.y,z2:10}),Nb(n,Eb(a),{// Default use item visual color
stroke:u})},e}(Wu),fL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.ignoreLabelLineUpdate=!0,n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.getData(),r=this._data,o=this.group;i.diff(r).add((function(t){var e=new dL(i,t);i.setItemGraphicEl(t,e),o.add(e)})).update((function(t,e){var n=r.getItemGraphicEl(e);n.updateData(i,t),o.add(n),i.setItemGraphicEl(t,n)})).remove((function(e){Dh(r.getItemGraphicEl(e),t,e)})).execute(),this._data=i},e.prototype.remove=function(){this.group.removeAll(),this._data=null},e.prototype.dispose=function(){},e.type="funnel",e}(qg);
/**
             * Piece of pie including Sector, Label, LabelLine
             */const gL=fL;var yL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(e){t.prototype.init.apply(this,arguments),// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendVisualProvider=new jM(B(this.getData,this),B(this.getRawData,this)),// Extend labelLine emphasis
this._defaultLabelLine(e)},e.prototype.getInitialData=function(t,e){return UM(this,{coordDimensions:["value"],encodeDefaulter:F(ad,this)})},e.prototype._defaultLabelLine=function(t){// Extend labelLine emphasis
uo(t,"labelLine",["show"]);var e=t.labelLine,n=t.emphasis.labelLine;// Not show label line if `label.normal.show = false`
e.show=e.show&&t.label.show,n.show=n.show&&t.emphasis.label.show},// Overwrite
e.prototype.getDataParams=function(e){var n=this.getData(),i=t.prototype.getDataParams.call(this,e),r=n.mapDimension("value"),o=n.getSum(r);// Percent is 0 if sum is 0
return i.percent=o?+(n.get(r,e)/o*100).toFixed(2):0,i.$vars.push("percent"),i},e.type="series.funnel",e.defaultOption={// zlevel: 0,                  // 
z:2,legendHoverLink:!0,colorBy:"data",left:80,top:60,right:80,bottom:60,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
// 
// min: 0,
// max: 100,
minSize:"0%",maxSize:"100%",sort:"descending",orient:"vertical",gap:0,funnelAlign:"center",label:{show:!0,position:"outer"},labelLine:{show:!0,length:20,lineStyle:{// color: ,
width:1}},itemStyle:{// color: ,
borderColor:"#fff",borderWidth:1},emphasis:{label:{show:!0}},select:{itemStyle:{borderColor:"#212121"}}},e}(zg);const vL=yL;function mL(t,e){t.eachSeriesByType("funnel",(function(t){var n=t.getData(),i=n.mapDimension("value"),r=t.get("sort"),o=function(t,e){return Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()})}(t,e),a=t.get("orient"),s=o.width,l=o.height,u=function(t,e){for(var n=t.mapDimension("value"),i=t.mapArray(n,(function(t){return t})),r=[],o="ascending"===e,a=0,s=t.count();a<s;a++)r[a]=a;// Add custom sortable function & none sortable opetion by "options.sort"
return W(e)?r.sort(e):"none"!==e&&r.sort((function(t,e){return o?i[t]-i[e]:i[e]-i[t]})),r}(n,r),h=o.x,c=o.y,p="horizontal"===a?[Vr(t.get("minSize"),l),Vr(t.get("maxSize"),l)]:[Vr(t.get("minSize"),s),Vr(t.get("maxSize"),s)],d=n.getDataExtent(i),f=t.get("min"),g=t.get("max");null==f&&(f=Math.min(d[0],0)),null==g&&(g=d[1]);var y=t.get("funnelAlign"),v=t.get("gap"),m=(("horizontal"===a?s:l)-v*(n.count()-1))/n.count(),x=function(t,e){// End point index is data.count() and we assign it 0
if("horizontal"===a){var r=zr(n.get(i,t)||0,[f,g],p,!0),o=void 0;switch(y){case"top":o=c;break;case"center":o=c+(l-r)/2;break;case"bottom":o=c+(l-r)}return[[e,o],[e,o+r]]}var u,d=zr(n.get(i,t)||0,[f,g],p,!0);switch(y){case"left":u=h;break;case"center":u=h+(s-d)/2;break;case"right":u=h+s-d}return[[u,e],[u+d,e]]};"ascending"===r&&(// From bottom to top
m=-m,v=-v,"horizontal"===a?h+=s:c+=l,u=u.reverse());for(var _=0;_<u.length;_++){var b=u[_],w=u[_+1],S=n.getItemModel(b);if("horizontal"===a){var M=S.get(["itemStyle","width"]);null==M?M=m:(M=Vr(M,s),"ascending"===r&&(M=-M));var I=x(b,h),T=x(w,h+M);h+=M+v,n.setItemLayout(b,{points:I.concat(T.slice().reverse())})}else{var C=S.get(["itemStyle","height"]);null==C?C=m:(C=Vr(C,l),"ascending"===r&&(C=-C)),I=x(b,c),T=x(w,c+C),c+=C+v,n.setItemLayout(b,{points:I.concat(T.slice().reverse())})}}!function(t){var e=t.hostModel.get("orient");t.each((function(n){var i,r,o,a,s=t.getItemModel(n),l=s.getModel("label").get("position"),u=s.getModel("labelLine"),h=t.getItemLayout(n),c=h.points,p="inner"===l||"inside"===l||"center"===l||"insideLeft"===l||"insideRight"===l;if(p)"insideLeft"===l?(r=(c[0][0]+c[3][0])/2+5,o=(c[0][1]+c[3][1])/2,i="left"):"insideRight"===l?(r=(c[1][0]+c[2][0])/2-5,o=(c[1][1]+c[2][1])/2,i="right"):(r=(c[0][0]+c[1][0]+c[2][0]+c[3][0])/4,o=(c[0][1]+c[1][1]+c[2][1]+c[3][1])/4,i="center"),a=[[r,o],[r,o]];else{var d=void 0,f=void 0,g=void 0,y=void 0,v=u.get("length");"left"===l?(// Left side
d=(c[3][0]+c[0][0])/2,f=(c[3][1]+c[0][1])/2,r=(g=d-v)-5,i="right"):"right"===l?(// Right side
d=(c[1][0]+c[2][0])/2,f=(c[1][1]+c[2][1])/2,r=(g=d+v)+5,i="left"):"top"===l?(// Top side
d=(c[3][0]+c[0][0])/2,o=(y=(f=(c[3][1]+c[0][1])/2)-v)-5,i="center"):"bottom"===l?(// Bottom side
d=(c[1][0]+c[2][0])/2,o=(y=(f=(c[1][1]+c[2][1])/2)+v)+5,i="center"):"rightTop"===l?(// RightTop side
d="horizontal"===e?c[3][0]:c[1][0],f="horizontal"===e?c[3][1]:c[1][1],"horizontal"===e?(o=(y=f-v)-5,i="center"):(r=(g=d+v)+5,i="top")):"rightBottom"===l?(// RightBottom side
d=c[2][0],f=c[2][1],"horizontal"===e?(o=(y=f+v)+5,i="center"):(r=(g=d+v)+5,i="bottom")):"leftTop"===l?(// LeftTop side
d=c[0][0],f="horizontal"===e?c[0][1]:c[1][1],"horizontal"===e?(o=(y=f-v)-5,i="center"):(r=(g=d-v)-5,i="right")):"leftBottom"===l?(// LeftBottom side
d="horizontal"===e?c[1][0]:c[3][0],f="horizontal"===e?c[1][1]:c[2][1],"horizontal"===e?(o=(y=f+v)+5,i="center"):(r=(g=d-v)-5,i="right")):(// Right side or Bottom side
d=(c[1][0]+c[2][0])/2,f=(c[1][1]+c[2][1])/2,"horizontal"===e?(o=(y=f+v)+5,i="center"):(r=(g=d+v)+5,i="left")),"horizontal"===e?r=g=d:o=y=f,a=[[d,f],[g,y]]}h.label={linePoints:a,x:r,y:o,verticalAlign:"middle",textAlign:i,inside:p}}))}(n)}))}var xL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._dataGroup=new Lr,n._initialized=!1,n}return n(e,t),e.prototype.init=function(){this.group.add(this._dataGroup)},
/**
               * @override
               */
e.prototype.render=function(t,e,n,i){// Clear previously rendered progressive elements.
this._progressiveEls=null;var r=this._dataGroup,o=t.getData(),a=this._data,s=t.coordinateSystem,l=s.dimensions,u=wL(t);// First create
if(o.diff(a).add((function(t){SL(bL(o,r,t,l,s),o,t,u)})).update((function(e,n){var i=a.getItemGraphicEl(n),r=_L(o,e,l,s);o.setItemGraphicEl(e,i),Sh(i,{shape:{points:r}},t,e),Ah(i),SL(i,o,e,u)})).remove((function(t){var e=a.getItemGraphicEl(t);r.remove(e)})).execute(),!this._initialized){this._initialized=!0;var h=function(t,e,n){var i=t.model,r=t.getRect(),o=new Ls({shape:{x:r.x,y:r.y,width:r.width,height:r.height}}),a="horizontal"===i.get("layout")?"width":"height";return o.setShape(a,0),Mh(o,{shape:{width:r.width,height:r.height}},e,n),o}(s,t,(function(){// Callback will be invoked immediately if there is no animation
setTimeout((function(){r.removeClipPath()}))}));r.setClipPath(h)}this._data=o},e.prototype.incrementalPrepareRender=function(t,e,n){this._initialized=!0,this._data=null,this._dataGroup.removeAll()},e.prototype.incrementalRender=function(t,e,n){for(var i=e.getData(),r=e.coordinateSystem,o=r.dimensions,a=wL(e),s=this._progressiveEls=[],l=t.start;l<t.end;l++){var u=bL(i,this._dataGroup,l,o,r);u.incremental=!0,SL(u,i,l,a),s.push(u)}},e.prototype.remove=function(){this._dataGroup&&this._dataGroup.removeAll(),this._data=null},e.type="parallel",e}(qg);function _L(t,e,n,i){for(var r,o=[],a=0;a<n.length;a++){var s=n[a],l=t.get(t.mapDimension(s),e);r=l,("category"===i.getAxis(s).type?null==r:null==r||isNaN(r))||o.push(i.dataToPoint(l,s))}return o}function bL(t,e,n,i,r){var o=_L(t,n,i,r),a=new Xu({shape:{points:o},// silent: true,
z2:10});return e.add(a),t.setItemGraphicEl(n,a),a}function wL(t){var e=t.get("smooth",!0);return!0===e&&(e=.3),$(e=Qr(e))&&(e=0),{smooth:e}}function SL(t,e,n,i){t.useStyle(e.getItemVisual(n,"style")),t.style.fill=null,t.setShape("smooth",i.smooth);var r=e.getItemModel(n),o=r.getModel("emphasis");Hl(t,r,"lineStyle"),Bl(t,o.get("focus"),o.get("blurScope"),o.get("disabled"))}// function simpleDiff(oldData, newData, dimensions) {
//     let oldLen;
//     if (!oldData
//         || !oldData.__plProgressive
//         || (oldLen = oldData.count()) !== newData.count()
//     ) {
//         return true;
//     }
//     let dimLen = dimensions.length;
//     for (let i = 0; i < oldLen; i++) {
//         for (let j = 0; j < dimLen; j++) {
//             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
//                 return true;
//             }
//         }
//     }
//     return false;
// }
// FIXME put in common util?
const ML=xL;var IL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.visualStyleAccessPath="lineStyle",n.visualDrawType="stroke",n}return n(e,t),e.prototype.getInitialData=function(t,e){return Cx(null,this,{useEncodeDefaulter:B(TL,null,this)})},
/**
               * User can get data raw indices on 'axisAreaSelected' event received.
               *
               * @return Raw indices
               */
e.prototype.getRawIndicesByActiveState=function(t){var e=this.coordinateSystem,n=this.getData(),i=[];return e.eachActiveState(n,(function(e,r){t===e&&i.push(n.getRawIndex(r))})),i},e.type="series.parallel",e.dependencies=["parallel"],e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"parallel",parallelIndex:0,label:{show:!1},inactiveOpacity:.05,activeOpacity:1,lineStyle:{width:1,opacity:.45,type:"solid"},emphasis:{label:{show:!1}},progressive:500,smooth:!1,animationEasing:"linear"},e}(zg);function TL(t){// The mapping of parallelAxis dimension to data dimension can
// be specified in parallelAxis.option.dim. For example, if
// parallelAxis.option.dim is 'dim3', it mapping to the third
// dimension of data. But `data.encode` has higher priority.
// Moreover, parallelModel.dimension should not be regarded as data
// dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];
var e=t.ecModel.getComponent("parallel",t.get("parallelIndex"));if(e){var n={};return R(e.dimensions,(function(t){var e=+t.replace("dim","");n[t]=e})),n}}const CL=IL;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var DL=["lineStyle","opacity"];const AL={seriesType:"parallel",reset:function(t,e){var n=t.coordinateSystem,i={normal:t.get(["lineStyle","opacity"]),active:t.get("activeOpacity"),inactive:t.get("inactiveOpacity")};return{progress:function(t,e){n.eachActiveState(e,(function(t,n){var r=i[t];if("normal"===t&&e.hasItemOption){var o=e.getItemModel(n).get(DL,!0);null!=o&&(r=o)}e.ensureUniqueItemVisual(n,"style").opacity=r}),t.start,t.end)}}}};function kL(t){!
/**
             * Create a parallel coordinate if not exists.
             * @inner
             */
function(t){if(!t.parallel){var e=!1;R(t.series,(function(t){t&&"parallel"===t.type&&(e=!0)})),e&&(t.parallel=[{}])}}
/**
             * Merge aixs definition from parallel option (if exists) to axis option.
             * @inner
             */(t),function(t){var e=lo(t.parallelAxis);R(e,(function(e){if(U(e)){var n=e.parallelIndex||0,i=lo(t.parallel)[n];i&&i.parallelAxisDefault&&C(e,i.parallelAxisDefault,!1)}}))}(t)}var LL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){this._model=t,this._api=n,this._handlers||(this._handlers={},R(PL,(function(t,e){n.getZr().on(e,this._handlers[e]=B(t,this))}),this)),ty(this,"_throttledDispatchExpand",t.get("axisExpandRate"),"fixRate")},e.prototype.dispose=function(t,e){ey(this,"_throttledDispatchExpand"),R(this._handlers,(function(t,n){e.getZr().off(n,t)})),this._handlers=null},
/**
               * @internal
               * @param {Object} [opt] If null, cancel the last action triggering for debounce.
               */
e.prototype._throttledDispatchExpand=function(t){this._dispatchExpand(t)},
/**
               * @internal
               */
e.prototype._dispatchExpand=function(t){t&&this._api.dispatchAction(A({type:"parallelAxisExpand"},t))},e.type="parallel",e}(Bg),PL={mousedown:function(t){OL(this,"click")&&(this._mouseDownPoint=[t.offsetX,t.offsetY])},mouseup:function(t){var e=this._mouseDownPoint;if(OL(this,"click")&&e){var n=[t.offsetX,t.offsetY];if(Math.pow(e[0]-n[0],2)+Math.pow(e[1]-n[1],2)>5)return;var i=this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX,t.offsetY]);"none"!==i.behavior&&this._dispatchExpand({axisExpandWindow:i.axisExpandWindow})}this._mouseDownPoint=null},mousemove:function(t){// Should do nothing when brushing.
if(!this._mouseDownPoint&&OL(this,"mousemove")){var e=this._model,n=e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX,t.offsetY]),i=n.behavior;"jump"===i&&this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")),this._throttledDispatchExpand("none"===i?null:{axisExpandWindow:n.axisExpandWindow,// Jumping uses animation, and sliding suppresses animation.
animation:"jump"===i?null:{duration:0}})}}};// > 4
function OL(t,e){var n=t._model;return n.get("axisExpandable")&&n.get("axisExpandTriggerOn")===e}const RL=LL;var NL=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(){t.prototype.init.apply(this,arguments),this.mergeOption({})},e.prototype.mergeOption=function(t){var e=this.option;t&&C(e,t,!0),this._initDimensions()},
/**
               * Whether series or axis is in this coordinate system.
               */
e.prototype.contains=function(t,e){var n=t.get("parallelIndex");return null!=n&&e.getComponent("parallel",n)===this},e.prototype.setAxisExpand=function(t){R(["axisExpandable","axisExpandCenter","axisExpandCount","axisExpandWidth","axisExpandWindow"],(function(e){t.hasOwnProperty(e)&&(// @ts-ignore FIXME: why "never" inferred in this.option[name]?
this.option[e]=t[e])}),this)},e.prototype._initDimensions=function(){var t=this.dimensions=[],e=this.parallelAxisIndex=[];R(z(this.ecModel.queryComponents({mainType:"parallelAxis"}),(function(t){// Can not use this.contains here, because
// initialization has not been completed yet.
return(t.get("parallelIndex")||0)===this.componentIndex}),this),(function(n){t.push("dim"+n.get("dim")),e.push(n.componentIndex)}))},e.type="parallel",e.dependencies=["parallelAxis"],e.layoutMode="box",e.defaultOption={// zlevel: 0,
z:0,left:80,top:60,right:80,bottom:60,// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
layout:"horizontal",// FIXME
// naming?
axisExpandable:!1,axisExpandCenter:null,axisExpandCount:0,axisExpandWidth:50,axisExpandRate:17,axisExpandDebounce:50,// [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
// Do not doc to user until necessary.
axisExpandSlideTriggerArea:[-.15,.05,.4],axisExpandTriggerOn:"click",parallelAxisDefault:null},e}(Wp);const EL=NL;var zL=/** @class */function(t){function e(e,n,i,r,o){var a=t.call(this,e,n,i)||this;return a.type=r||"value",a.axisIndex=o,a}return n(e,t),e.prototype.isHorizontal=function(){return"horizontal"!==this.coordinateSystem.getModel().get("layout")},e}(pb);const VL=zL;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * Calculate slider move result.
             * Usage:
             * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
             * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
             * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
             *
             * @param delta Move length.
             * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].
             *              handleEnds will be modified in this method.
             * @param extent handleEnds is restricted by extent.
             *              extent[0] should less or equals than extent[1].
             * @param handleIndex Can be 'all', means that both move the two handleEnds.
             * @param minSpan The range of dataZoom can not be smaller than that.
             *              If not set, handle0 and cross handle1. If set as a non-negative
             *              number (including `0`), handles will push each other when reaching
             *              the minSpan.
             * @param maxSpan The range of dataZoom can not be larger than that.
             * @return The input handleEnds.
             */function BL(t,e,n,i,r,o){t=t||0;var a=n[1]-n[0];// Notice maxSpan and minSpan can be null/undefined.
if(null!=r&&(r=GL(r,[0,a])),null!=o&&(o=Math.max(o,null!=r?r:0)),"all"===i){var s=Math.abs(e[1]-e[0]);s=GL(s,[0,a]),r=o=GL(s,[r,o]),i=0}e[0]=GL(e[0],n),e[1]=GL(e[1],n);var l=FL(e,i);e[i]+=t;// Restrict in extent.
var u,h=r||0,c=n.slice();return l.sign<0?c[0]+=h:c[1]-=h,e[i]=GL(e[i],c),u=FL(e,i),null!=r&&(u.sign!==l.sign||u.span<r)&&(// If minSpan exists, 'cross' is forbidden.
e[1-i]=e[i]+l.sign*r),// Shrink span.
u=FL(e,i),null!=o&&u.span>o&&(e[1-i]=e[i]+u.sign*o),e}function FL(t,e){var n=t[e]-t[1-e];// If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
// is at left of handleEnds[1] for non-cross case.
return{span:Math.abs(n),sign:n>0?-1:n<0?1:e?-1:1}}function GL(t,e){return Math.min(null!=e[1]?e[1]:1/0,Math.max(null!=e[0]?e[0]:-1/0,t))}var WL=R,HL=Math.min,YL=Math.max,XL=Math.floor,UL=Math.ceil,ZL=Br,jL=Math.PI,qL=/** @class */function(){function t(t,e,n){this.type="parallel",
/**
                 * key: dimension
                 */
this._axesMap=ct(),
/**
                 * key: dimension
                 * value: {position: [], rotation, }
                 */
this._axesLayout={},this.dimensions=t.dimensions,this._model=t,this._init(t,e,n)}return t.prototype._init=function(t,e,n){var i=t.dimensions,r=t.parallelAxisIndex;WL(i,(function(t,n){var i=r[n],o=e.getComponent("parallelAxis",i),a=this._axesMap.set(t,new VL(t,O_(o),[0,0],o.get("type"),i)),s="category"===a.type;a.onBand=s&&o.get("boundaryGap"),a.inverse=o.get("inverse"),// Injection
o.axis=a,a.model=o,a.coordinateSystem=o.coordinateSystem=this}),this)},
/**
               * Update axis scale after data processed
               */
t.prototype.update=function(t,e){this._updateAxesFromSeries(this._model,t)},t.prototype.containPoint=function(t){var e=this._makeLayoutInfo(),n=e.axisBase,i=e.layoutBase,r=e.pixelDimIndex,o=t[1-r],a=t[r];return o>=n&&o<=n+e.axisLength&&a>=i&&a<=i+e.layoutLength},t.prototype.getModel=function(){return this._model},
/**
               * Update properties from series
               */
t.prototype._updateAxesFromSeries=function(t,e){e.eachSeries((function(n){if(t.contains(n,e)){var i=n.getData();WL(this.dimensions,(function(t){var e=this._axesMap.get(t);e.scale.unionExtentFromData(i,i.mapDimension(t)),P_(e.scale,e.model)}),this)}}),this)},
/**
               * Resize the parallel coordinate system.
               */
t.prototype.resize=function(t,e){this._rect=Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()}),this._layoutAxes()},t.prototype.getRect=function(){return this._rect},t.prototype._makeLayoutInfo=function(){var t,e=this._model,n=this._rect,i=["x","y"],r=["width","height"],o=e.get("layout"),a="horizontal"===o?0:1,s=n[r[a]],l=[0,s],u=this.dimensions.length,h=KL(e.get("axisExpandWidth"),l),c=KL(e.get("axisExpandCount")||0,[0,u]),p=e.get("axisExpandable")&&u>3&&u>c&&c>1&&h>0&&s>0,d=e.get("axisExpandWindow");d?(t=KL(d[1]-d[0],l),d[1]=d[0]+t):(t=KL(h*(c-1),l),(d=[h*(e.get("axisExpandCenter")||XL(u/2))-t/2])[1]=d[0]+t);var f=(s-t)/(u-c);// Avoid axisCollapseWidth is too small.
f<3&&(f=0);// Find the first and last indices > ewin[0] and < ewin[1].
var g=[XL(ZL(d[0]/h,1))+1,UL(ZL(d[1]/h,1))-1],y=f/h*d[0];// Pos in ec coordinates.
return{layout:o,pixelDimIndex:a,layoutBase:n[i[a]],layoutLength:s,axisBase:n[i[1-a]],axisLength:n[r[1-a]],axisExpandable:p,axisExpandWidth:h,axisCollapseWidth:f,axisExpandWindow:d,axisCount:u,winInnerIndices:g,axisExpandWindow0Pos:y}},t.prototype._layoutAxes=function(){var t=this._rect,e=this._axesMap,n=this.dimensions,i=this._makeLayoutInfo(),r=i.layout;e.each((function(t){var e=[0,i.axisLength],n=t.inverse?1:0;t.setExtent(e[n],e[1-n])})),WL(n,(function(e,n){var o=(i.axisExpandable?JL:$L)(n,i),a={horizontal:{x:o.position,y:i.axisLength},vertical:{x:0,y:o.position}},s={horizontal:jL/2,vertical:0},l=[a[r].x+t.x,a[r].y+t.y],u=s[r],h=[1,0,0,1,0,0];de(h,h,u),pe(h,h,l),// TODO
// tick layout info
// TODO
// update dimensions info based on axis order.
this._axesLayout[e]={position:l,rotation:u,transform:h,axisNameAvailableWidth:o.axisNameAvailableWidth,axisLabelShow:o.axisLabelShow,nameTruncateMaxWidth:o.nameTruncateMaxWidth,tickDirection:1,labelDirection:1}}),this)},
/**
               * Get axis by dim.
               */
t.prototype.getAxis=function(t){return this._axesMap.get(t)},
/**
               * Convert a dim value of a single item of series data to Point.
               */
t.prototype.dataToPoint=function(t,e){return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t),e)},
/**
               * Travel data for one time, get activeState of each data item.
               * @param start the start dataIndex that travel from.
               * @param end the next dataIndex of the last dataIndex will be travel.
               */
t.prototype.eachActiveState=function(t,e,n,i){null==n&&(n=0),null==i&&(i=t.count());var r=this._axesMap,o=this.dimensions,a=[],s=[];R(o,(function(e){a.push(t.mapDimension(e)),s.push(r.get(e).model)}));for(var l=this.hasAxisBrushed(),u=n;u<i;u++){var h=void 0;if(l){h="active";for(var c=t.getValues(a,u),p=0,d=o.length;p<d;p++)if("inactive"===s[p].getActiveState(c[p])){h="inactive";break}}else h="normal";e(h,u)}},
/**
               * Whether has any activeSet.
               */
t.prototype.hasAxisBrushed=function(){for(var t=this.dimensions,e=this._axesMap,n=!1,i=0,r=t.length;i<r;i++)"normal"!==e.get(t[i]).model.getActiveState()&&(n=!0);return n},
/**
               * Convert coords of each axis to Point.
               *  Return point. For example: [10, 20]
               */
t.prototype.axisCoordToPoint=function(t,e){return Yh([t,0],this._axesLayout[e].transform)},
/**
               * Get axis layout.
               */
t.prototype.getAxisLayout=function(t){return T(this._axesLayout[t])},
/**
               * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
               */
t.prototype.getSlidedAxisExpandWindow=function(t){var e=this._makeLayoutInfo(),n=e.pixelDimIndex,i=e.axisExpandWindow.slice(),r=i[1]-i[0],o=[0,e.axisExpandWidth*(e.axisCount-1)];// Out of the area of coordinate system.
if(!this.containPoint(t))return{behavior:"none",axisExpandWindow:i};// Convert the point from global to expand coordinates.
var a,s=t[n]-e.layoutBase-e.axisExpandWindow0Pos,l="slide",u=e.axisCollapseWidth,h=this._model.get("axisExpandSlideTriggerArea"),c=null!=h[0];// For dragging operation convenience, the window should not be
// slided when mouse is the center area of the window.
if(u)c&&u&&s<r*h[0]?(l="jump",a=s-r*h[2]):c&&u&&s>r*(1-h[0])?(l="jump",a=s-r*(1-h[2])):(a=s-r*h[1])>=0&&(a=s-r*(1-h[1]))<=0&&(a=0),(a*=e.axisExpandWidth/u)?BL(a,i,o,"all"):l="none";else{var p=i[1]-i[0];(i=[YL(0,o[1]*s/p-p/2)])[1]=HL(o[1],i[0]+p),i[0]=i[1]-p}return{axisExpandWindow:i,behavior:l}},t}();function KL(t,e){return HL(YL(t,e[0]),e[1])}function $L(t,e){var n=e.layoutLength/(e.axisCount-1);return{position:n*t,axisNameAvailableWidth:n,axisLabelShow:!0}}function JL(t,e){var n,i,r=e.layoutLength,o=e.axisExpandWidth,a=e.axisCount,s=e.axisCollapseWidth,l=e.winInnerIndices,u=s,h=!1;return t<l[0]?(n=t*s,i=s):t<=l[1]?(n=e.axisExpandWindow0Pos+t*o-e.axisExpandWindow[0],u=o,h=!0):(n=r-(a-1-t)*s,i=s),{position:n,axisNameAvailableWidth:u,axisLabelShow:h,nameTruncateMaxWidth:i}}const QL=qL,tP={create:function(t,e){var n=[];return t.eachComponent("parallel",(function(i,r){var o=new QL(i,t,e);o.name="parallel_"+r,o.resize(i,e),i.coordinateSystem=o,o.model=i,n.push(o)})),// Inject the coordinateSystems into seriesModel
t.eachSeries((function(t){if("parallel"===t.get("coordinateSystem")){var e=t.getReferringComponents("parallel",Io).models[0];t.coordinateSystem=e.coordinateSystem}})),n}};var eP=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,
/**
                 * @readOnly
                 */
n.activeIntervals=[],n}return n(e,t),e.prototype.getAreaSelectStyle=function(){return Fo([["fill","color"],["lineWidth","borderWidth"],["stroke","borderColor"],["width","width"],["opacity","opacity"]])(this.getModel("areaSelectStyle"))},
/**
               * The code of this feature is put on AxisModel but not ParallelAxis,
               * because axisModel can be alive after echarts updating but instance of
               * ParallelAxis having been disposed. this._activeInterval should be kept
               * when action dispatched (i.e. legend click).
               *
               * @param intervals `interval.length === 0` means set all active.
               */
e.prototype.setActiveIntervals=function(t){var e=this.activeIntervals=T(t);// Normalize
if(e)for(var n=e.length-1;n>=0;n--)Fr(e[n])},
/**
               * @param value When only attempting detect whether 'no activeIntervals set',
               *        `value` is not needed to be input.
               */
e.prototype.getActiveState=function(t){var e=this.activeIntervals;if(!e.length)return"normal";if(null==t||isNaN(+t))return"inactive";// Simple optimization
if(1===e.length){var n=e[0];if(n[0]<=t&&t<=n[1])return"active"}else for(var i=0,r=e.length;i<r;i++)if(e[i][0]<=t&&t<=e[i][1])return"active";return"inactive"},e}(Wp);P(eP,F_);const nP=eP;var iP=!0,rP=Math.min,oP=Math.max,aP=Math.pow,sP="globalPan",lP={w:[0,0],e:[0,1],n:[1,0],s:[1,1]},uP={w:"ew",e:"ew",n:"ns",s:"ns",ne:"nesw",sw:"nesw",nw:"nwse",se:"nwse"},hP={brushStyle:{lineWidth:2,stroke:"rgba(210,219,238,0.3)",fill:"#D2DBEE"},transformable:!0,brushMode:"single",removeOnClick:!1},cP=0,pP=/** @class */function(t){function e(e){var n=t.call(this)||this;
/**
                 * @internal
                 */return n._track=[],
/**
                 * @internal
                 */
n._covers=[],n._handlers={},n._zr=e,n.group=new Lr,n._uid="brushController_"+cP++,R(BP,(function(t,e){this._handlers[e]=B(t,this)}),n),n}
/**
               * If set to `false`, select disabled.
               */return n(e,t),e.prototype.enableBrush=function(t){return this._brushType&&this._doDisableBrush(),t.brushType&&this._doEnableBrush(t),this},e.prototype._doEnableBrush=function(t){var e=this._zr;// Consider roam, which takes globalPan too.
this._enableGlobalPan||function(t,e,n){AT(t)[e]=n}(e,sP,this._uid),R(this._handlers,(function(t,n){e.on(n,t)})),this._brushType=t.brushType,this._brushOption=C(T(hP),t,!0)},e.prototype._doDisableBrush=function(){var t=this._zr;!function(t,e,n){var i=AT(t);i[e]===n&&(i[e]=null)}(t,sP,this._uid),R(this._handlers,(function(e,n){t.off(n,e)})),this._brushType=this._brushOption=null},
/**
               * @param panelOpts If not pass, it is global brush.
               */
e.prototype.setPanels=function(t){if(t&&t.length){var e=this._panels={};R(t,(function(t){e[t.panelId]=T(t)}))}else this._panels=null;return this},e.prototype.mount=function(t){t=t||{},this._enableGlobalPan=t.enableGlobalPan;var e=this.group;return this._zr.add(e),e.attr({x:t.x||0,y:t.y||0,rotation:t.rotation||0,scaleX:t.scaleX||1,scaleY:t.scaleY||1}),this._transform=e.getLocalTransform(),this},// eachCover(cb, context): void {
//     each(this._covers, cb, context);
// }
/**
               * Update covers.
               * @param coverConfigList
               *        If coverConfigList is null/undefined, all covers removed.
               */
e.prototype.updateCovers=function(t){t=N(t,(function(t){return C(T(hP),t,!0)}));var e=this._covers,n=this._covers=[],i=this,r=this._creatingCover;return new Um(e,t,(function(t,e){return o(t.__brushOption,e)}),o).add(a).update(a).remove((function(t){e[t]!==r&&i.group.remove(e[t])})).execute(),this;function o(t,e){return(null!=t.id?t.id:"\0-brush-index-"+e)+"-"+t.brushType}function a(o,a){var s=t[o];// Consider setOption in event listener of brushSelect,
// where updating cover when creating should be forbiden.
if(null!=a&&e[a]===r)n[o]=e[a];else{var l=n[o]=null!=a?(e[a].__brushOption=s,e[a]):fP(i,dP(i,s));vP(i,l)}}},e.prototype.unmount=function(){return this.enableBrush(!1),// container may 'removeAll' outside.
bP(this),this._zr.remove(this.group),this},e.prototype.dispose=function(){this.unmount(),this.off()},e}(Bt);function dP(t,e){var n=GP[e.brushType].createCover(t,e);return n.__brushOption=e,yP(n,e),t.group.add(n),n}function fP(t,e){var n=mP(e);return n.endCreating&&(n.endCreating(t,e),yP(e,e.__brushOption)),e}function gP(t,e){var n=e.__brushOption;mP(e).updateCoverShape(t,e,n.range,n)}function yP(t,e){var n=e.z;null==n&&(n=1e4),t.traverse((function(t){t.z=n,t.z2=n}))}function vP(t,e){mP(e).updateCommon(t,e),gP(t,e)}function mP(t){return GP[t.__brushOption.brushType]}// return target panel or `true` (means global panel)
function xP(t,e,n){var i,r=t._panels;if(!r)return iP;// Global panel
var o=t._transform;return R(r,(function(t){t.isTargetByCursor(e,n,o)&&(i=t)})),i}// Return a panel or true
function _P(t,e){var n=t._panels;if(!n)return iP;// Global panel
var i=e.__brushOption.panelId;// User may give cover without coord sys info,
// which is then treated as global panel.
return null!=i?n[i]:iP}function bP(t){var e=t._covers,n=e.length;return R(e,(function(e){t.group.remove(e)}),t),e.length=0,!!n}function wP(t,e){var n=N(t._covers,(function(t){var e=t.__brushOption,n=T(e.range);return{brushType:e.brushType,panelId:e.panelId,range:n}}));t.trigger("brush",{areas:n,isEnd:!!e.isEnd,removeOnClick:!!e.removeOnClick})}function SP(t){var e=t.length-1;return e<0&&(e=0),[t[0],t[e]]}function MP(t,e,n,i){var r=new Lr;return r.add(new Ls({name:"main",style:DP(n),silent:!0,draggable:!0,cursor:"move",drift:F(LP,t,e,r,["n","s","w","e"]),ondragend:F(wP,e,{isEnd:!0})})),R(i,(function(n){r.add(new Ls({name:n.join(""),style:{opacity:0},draggable:!0,silent:!0,invisible:!0,drift:F(LP,t,e,r,n),ondragend:F(wP,e,{isEnd:!0})}))})),r}function IP(t,e,n,i){var r=i.brushStyle.lineWidth||0,o=oP(r,6),a=n[0][0],s=n[1][0],l=a-r/2,u=s-r/2,h=n[0][1],c=n[1][1],p=h-o+r/2,d=c-o+r/2,f=h-a,g=c-s,y=f+r,v=g+r;CP(t,e,"main",a,s,f,g),i.transformable&&(CP(t,e,"w",l,u,o,v),CP(t,e,"e",p,u,o,v),CP(t,e,"n",l,u,y,o),CP(t,e,"s",l,d,y,o),CP(t,e,"nw",l,u,o,o),CP(t,e,"ne",p,u,o,o),CP(t,e,"sw",l,d,o,o),CP(t,e,"se",p,d,o,o))}function TP(t,e){var n=e.__brushOption,i=n.transformable,r=e.childAt(0);r.useStyle(DP(n)),r.attr({silent:!i,cursor:i?"move":"default"}),R([["w"],["e"],["n"],["s"],["s","e"],["s","w"],["n","e"],["n","w"]],(function(n){var r=e.childOfName(n.join("")),o=1===n.length?kP(t,n[0]):function(t,e){var n=[kP(t,e[0]),kP(t,e[1])];return("e"===n[0]||"w"===n[0])&&n.reverse(),n.join("")}(t,n);r&&r.attr({silent:!i,invisible:!i,cursor:i?uP[o]+"-resize":null})}))}function CP(t,e,n,i,r,o,a){var s=e.childOfName(n);s&&s.setShape(function(t){var e=rP(t[0][0],t[1][0]),n=rP(t[0][1],t[1][1]),i=oP(t[0][0],t[1][0]),r=oP(t[0][1],t[1][1]);return{x:e,y:n,width:i-e,height:r-n}}(RP(t,e,[[i,r],[i+o,r+a]])))}function DP(t){return k({strokeNoScale:!0},t.brushStyle)}function AP(t,e,n,i){var r=[rP(t,n),rP(e,i)],o=[oP(t,n),oP(e,i)];return[[r[0],o[0]],[r[1],o[1]]]}function kP(t,e){var n=Xh({w:"left",e:"right",n:"top",s:"bottom"}[e],function(t){return Hh(t.group)}(t));return{left:"w",right:"e",top:"n",bottom:"s"}[n]}function LP(t,e,n,i,r,o){var a=n.__brushOption,s=t.toRectRange(a.range),l=OP(e,r,o);R(i,(function(t){var e=lP[t];s[e[0]][e[1]]+=l[e[0]]})),a.range=t.fromRectRange(AP(s[0][0],s[1][0],s[0][1],s[1][1])),vP(e,n),wP(e,{isEnd:!1})}function PP(t,e,n,i){var r=e.__brushOption.range,o=OP(t,n,i);R(r,(function(t){t[0]+=o[0],t[1]+=o[1]})),vP(t,e),wP(t,{isEnd:!1})}function OP(t,e,n){var i=t.group,r=i.transformCoordToLocal(e,n),o=i.transformCoordToLocal(0,0);return[r[0]-o[0],r[1]-o[1]]}function RP(t,e,n){var i=_P(t,e);return i&&i!==iP?i.clipPath(n,t._transform):T(n)}function NP(t){var e=t.event;e.preventDefault&&e.preventDefault()}function EP(t,e,n){return t.childOfName("main").contain(e,n)}function zP(t,e,n,i){var r,o=t._creatingCover,a=t._creatingPanel,s=t._brushOption;if(t._track.push(n.slice()),function(t){var e=t._track;if(!e.length)return!1;var n=e[e.length-1],i=e[0],r=n[0]-i[0],o=n[1]-i[1];return aP(r*r+o*o,.5)>6}(t)||o){if(a&&!o){"single"===s.brushMode&&bP(t);var l=T(s);l.brushType=VP(l.brushType,a),l.panelId=a===iP?null:a.panelId,o=t._creatingCover=dP(t,l),t._covers.push(o)}if(o){var u=GP[VP(t._brushType,a)];o.__brushOption.range=u.getCreatingRange(RP(t,o,t._track)),i&&(fP(t,o),u.updateCommon(t,o)),gP(t,o),r={isEnd:i}}}else i&&"single"===s.brushMode&&s.removeOnClick&&xP(t,e,n)&&bP(t)&&(r={isEnd:i,removeOnClick:!0});return r}function VP(t,e){return"auto"===t?e.defaultBrushType:t}var BP={mousedown:function(t){if(this._dragging)// In case some browser do not support globalOut,
// and release mouse out side the browser.
FP(this,t);else if(!t.target||!t.target.draggable){NP(t);var e=this.group.transformCoordToLocal(t.offsetX,t.offsetY);this._creatingCover=null,(this._creatingPanel=xP(this,t,e))&&(this._dragging=!0,this._track=[e.slice()])}},mousemove:function(t){var e=t.offsetX,n=t.offsetY,i=this.group.transformCoordToLocal(e,n);if(function(t,e,n){if(// Check active
t._brushType&&!function(t,e,n){var i=t._zr;return e<0||e>i.getWidth()||n<0||n>i.getHeight()}
/**
             * key: brushType
             */(t,e.offsetX,e.offsetY)){var i=t._zr,r=t._covers,o=xP(t,e,n);// Check whether in covers.
if(!t._dragging)for(var a=0;a<r.length;a++){var s=r[a].__brushOption;if(o&&(o===iP||s.panelId===o.panelId)&&GP[s.brushType].contain(r[a],n[0],n[1]))// Use cursor style set on cover.
return}o&&i.setCursorStyle("crosshair")}}(this,t,i),this._dragging){NP(t);var r=zP(this,t,i,!1);r&&wP(this,r)}},mouseup:function(t){FP(this,t)}};function FP(t,e){if(t._dragging){NP(e);var n=e.offsetX,i=e.offsetY,r=t.group.transformCoordToLocal(n,i),o=zP(t,e,r,!0);t._dragging=!1,t._track=[],t._creatingCover=null,// trigger event shoule be at final, after procedure will be nested.
o&&wP(t,o)}}var GP={lineX:WP(0),lineY:WP(1),rect:{createCover:function(t,e){function n(t){return t}return MP({toRectRange:n,fromRectRange:n},t,e,[["w"],["e"],["n"],["s"],["s","e"],["s","w"],["n","e"],["n","w"]])},getCreatingRange:function(t){var e=SP(t);return AP(e[1][0],e[1][1],e[0][0],e[0][1])},updateCoverShape:function(t,e,n,i){IP(t,e,n,i)},updateCommon:TP,contain:EP},polygon:{createCover:function(t,e){var n=new Lr;// Do not use graphic.Polygon because graphic.Polyline do not close the
// border of the shape when drawing, which is a better experience for user.
return n.add(new Xu({name:"main",style:DP(e),silent:!0})),n},getCreatingRange:function(t){return t},endCreating:function(t,e){e.remove(e.childAt(0)),// Use graphic.Polygon close the shape.
e.add(new Wu({name:"main",draggable:!0,drift:F(PP,t,e),ondragend:F(wP,t,{isEnd:!0})}))},updateCoverShape:function(t,e,n,i){e.childAt(0).setShape({points:RP(t,e,n)})},updateCommon:TP,contain:EP}};function WP(t){return{createCover:function(e,n){return MP({toRectRange:function(e){var n=[e,[0,100]];return t&&n.reverse(),n},fromRectRange:function(e){return e[t]}},e,n,[[["w"],["e"]],[["n"],["s"]]][t])},getCreatingRange:function(e){var n=SP(e);return[rP(n[0][t],n[1][t]),oP(n[0][t],n[1][t])]},updateCoverShape:function(e,n,i,r){var o,a=_P(e,n);// If brushWidth not specified, fit the panel.
if(a!==iP&&a.getLinearBrushOtherExtent)o=a.getLinearBrushOtherExtent(t);else{var s=e._zr;o=[0,[s.getWidth(),s.getHeight()][1-t]]}var l=[i,o];t&&l.reverse(),IP(e,n,l,r)},updateCommon:TP,contain:EP}}const HP=pP;function YP(t){return t=ZP(t),function(e){return jh(e,t)}}function XP(t,e){return t=ZP(t),function(n){var i=null!=e?e:n,r=i?t.width:t.height,o=i?t.x:t.y;return[o,o+(r||0)]}}function UP(t,e,n){var i=ZP(t);return function(t,r){return i.contain(r[0],r[1])&&!BT(t,e,n)}}// Consider width/height is negative.
function ZP(t){return Ce.create(t)}var jP=["axisLine","axisTickLabel","axisName"],qP=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(e,n){t.prototype.init.apply(this,arguments),(this._brushController=new HP(n.getZr())).on("brush",B(this._onBrush,this))},e.prototype.render=function(t,e,n,i){if(!function(t,e,n){return n&&"axisAreaSelect"===n.type&&e.findComponents({mainType:"parallelAxis",query:n})[0]===t}(t,e,i)){this.axisModel=t,this.api=n,this.group.removeAll();var r=this._axisGroup;if(this._axisGroup=new Lr,this.group.add(this._axisGroup),t.get("show")){var o=function(t,e){return e.getComponent("parallel",t.get("parallelIndex"))}(t,e),a=o.coordinateSystem,s=t.getAreaSelectStyle(),l=s.width,u=t.axis.dim,h=A({strokeContainThreshold:l},a.getAxisLayout(u)),c=new BI(t,h);R(jP,c.add,c),this._axisGroup.add(c.getGroup()),this._refreshBrushController(h,s,t,o,l,n),Zh(r,this._axisGroup,t)}}},// /**
//  * @override
//  */
// updateVisual(axisModel, ecModel, api, payload) {
//     this._brushController && this._brushController
//         .updateCovers(getCoverInfoList(axisModel));
// }
e.prototype._refreshBrushController=function(t,e,n,i,r,o){// After filtering, axis may change, select area needs to be update.
var a=n.axis.getExtent(),s=a[1]-a[0],l=Math.min(30,.1*Math.abs(s)),u=Ce.create({x:a[0],y:-r/2,width:s,height:r});u.x-=l,u.width+=2*l,this._brushController.mount({enableGlobalPan:!0,rotation:t.rotation,x:t.position[0],y:t.position[1]}).setPanels([{panelId:"pl",clipPath:YP(u),isTargetByCursor:UP(u,o,i),getLinearBrushOtherExtent:XP(u,0)}]).enableBrush({brushType:"lineX",brushStyle:e,removeOnClick:!0}).updateCovers(function(t){var e=t.axis;return N(t.activeIntervals,(function(t){return{brushType:"lineX",panelId:"pl",range:[e.dataToCoord(t[0],!0),e.dataToCoord(t[1],!0)]}}))}(n))},e.prototype._onBrush=function(t){var e=t.areas,n=this.axisModel,i=n.axis,r=N(e,(function(t){return[i.coordToData(t.range[0],!0),i.coordToData(t.range[1],!0)]}));// Do not cache these object, because the mey be changed.
// If realtime is true, action is not dispatched on drag end, because
// the drag end emits the same params with the last drag move event,
// and may have some delay when using touch pad.
(!n.option.realtime===t.isEnd||t.removeOnClick)&&// jshint ignore:line
this.api.dispatchAction({type:"axisAreaSelect",parallelAxisId:n.id,intervals:r})},e.prototype.dispose=function(){this._brushController.dispose()},e.type="parallelAxis",e}(Bg);const KP=qP;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var $P={type:"axisAreaSelect",event:"axisAreaSelected"},JP={type:"value",areaSelectStyle:{width:20,borderWidth:1,borderColor:"rgba(160,197,232)",color:"rgba(160,197,232)",opacity:.3},realtime:!0,z:10};function QP(t){t.registerComponentView(RL),t.registerComponentModel(EL),t.registerCoordinateSystem("parallel",tP),t.registerPreprocessor(kL),t.registerComponentModel(nP),t.registerComponentView(KP),fI(t,"parallel",nP,JP),function(t){t.registerAction($P,(function(t,e){e.eachComponent({mainType:"parallelAxis",query:t},(function(e){e.axis.model.setActiveIntervals(t.intervals)}))})),
/**
               * @payload
               */
t.registerAction("parallelAxisExpand",(function(t,e){e.eachComponent({mainType:"parallel",query:t},(function(e){e.setAxisExpand(t)}))}))}(t)}var tO=function(){this.x1=0,this.y1=0,this.x2=0,this.y2=0,this.cpx1=0,this.cpy1=0,this.cpx2=0,this.cpy2=0,this.extent=0},eO=/** @class */function(t){function e(e){return t.call(this,e)||this}return n(e,t),e.prototype.getDefaultShape=function(){return new tO},e.prototype.buildPath=function(t,e){var n=e.extent;t.moveTo(e.x1,e.y1),t.bezierCurveTo(e.cpx1,e.cpy1,e.cpx2,e.cpy2,e.x2,e.y2),"vertical"===e.orient?(t.lineTo(e.x2+n,e.y2),t.bezierCurveTo(e.cpx2+n,e.cpy2,e.cpx1+n,e.cpy1,e.x1+n,e.y1)):(t.lineTo(e.x2,e.y2+n),t.bezierCurveTo(e.cpx2,e.cpy2+n,e.cpx1,e.cpy1+n,e.x1,e.y1+n)),t.closePath()},e.prototype.highlight=function(){Il(this)},e.prototype.downplay=function(){Tl(this)},e}(ys),nO=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._focusAdjacencyDisabled=!1,n}return n(e,t),e.prototype.render=function(t,e,n){var i=this,r=t.getGraph(),o=this.group,a=t.layoutInfo,s=a.width,l=a.height,u=t.getData(),h=t.getData("edge"),c=t.get("orient");this._model=t,o.removeAll(),o.x=a.x,o.y=a.y,// generate a bezire Curve for each edge
r.eachEdge((function(e){var n=new eO,i=js(n);i.dataIndex=e.dataIndex,i.seriesIndex=t.seriesIndex,i.dataType="edge";var r,a,u,p,d,f,g,y,v=e.getModel(),m=v.getModel("lineStyle"),x=m.get("curveness"),_=e.node1.getLayout(),b=e.node1.getModel(),w=b.get("localX"),S=b.get("localY"),M=e.node2.getLayout(),I=e.node2.getModel(),T=I.get("localX"),C=I.get("localY"),D=e.getLayout();// Special color, use source node color or target node color
switch(n.shape.extent=Math.max(1,D.dy),n.shape.orient=c,"vertical"===c?(r=(null!=w?w*s:_.x)+D.sy,a=(null!=S?S*l:_.y)+_.dy,u=(null!=T?T*s:M.x)+D.ty,d=r,f=a*(1-x)+(p=null!=C?C*l:M.y)*x,g=u,y=a*x+p*(1-x)):(r=(null!=w?w*s:_.x)+_.dx,a=(null!=S?S*l:_.y)+D.sy,d=r*(1-x)+(u=null!=T?T*s:M.x)*x,f=a,g=r*x+u*(1-x),y=p=(null!=C?C*l:M.y)+D.ty),n.setShape({x1:r,y1:a,x2:u,y2:p,cpx1:d,cpy1:f,cpx2:g,cpy2:y}),n.useStyle(m.getItemStyle()),n.style.fill){case"source":n.style.fill=e.node1.getVisual("color"),n.style.decal=e.node1.getVisual("style").decal;break;case"target":n.style.fill=e.node2.getVisual("color"),n.style.decal=e.node2.getVisual("style").decal;break;case"gradient":var A=e.node1.getVisual("color"),k=e.node2.getVisual("color");H(A)&&H(k)&&(n.style.fill=new lh(0,0,+("horizontal"===c),+("vertical"===c),[{color:A,offset:0},{color:k,offset:1}]))}ac(n,sc(v,"edgeLabel"),{labelFetcher:t,labelDataIndex:e.dataIndex,defaultText:""+v.get("value")}),n.setTextConfig({position:"inside"});var L=v.getModel("emphasis");Hl(n,v,"lineStyle",(function(t){return t.getItemStyle()})),o.add(n),h.setItemGraphicEl(e.dataIndex,n);var P=L.get("focus");Bl(n,"adjacency"===P?e.getAdjacentDataIndices():P,L.get("blurScope"),L.get("disabled")),js(n).dataType="edge"})),// Generate a rect for each node
r.eachNode((function(e){var n=e.getLayout(),i=e.getModel(),r=i.get("localX"),a=i.get("localY"),h=i.getModel("emphasis"),c=new Ls({shape:{x:null!=r?r*s:n.x,y:null!=a?a*l:n.y,width:n.dx,height:n.dy},style:i.getModel("itemStyle").getItemStyle(),z2:10});ac(c,sc(i),{labelFetcher:t,labelDataIndex:e.dataIndex,defaultText:e.id}),c.disableLabelAnimation=!0,c.setStyle("fill",e.getVisual("color")),c.setStyle("decal",e.getVisual("style").decal),Hl(c,i),o.add(c),u.setItemGraphicEl(e.dataIndex,c),js(c).dataType="node";var p=h.get("focus");Bl(c,"adjacency"===p?e.getAdjacentDataIndices():p,h.get("blurScope"),h.get("disabled"))})),u.eachItemGraphicEl((function(e,r){u.getItemModel(r).get("draggable")&&(e.drift=function(e,o){i._focusAdjacencyDisabled=!0,this.shape.x+=e,this.shape.y+=o,this.dirty(),n.dispatchAction({type:"dragNode",seriesId:t.id,dataIndex:u.getRawIndex(r),localX:this.shape.x/s,localY:this.shape.y/l})},e.ondragend=function(){i._focusAdjacencyDisabled=!1},e.draggable=!0,e.cursor="move")})),!this._data&&t.isAnimationEnabled()&&o.setClipPath(// Add animation to the view
function(t,e,n){var i=new Ls({shape:{x:t.x-10,y:t.y-10,width:0,height:t.height+20}});return Mh(i,{shape:{width:t.width+20}},e,n),i}(o.getBoundingRect(),t,(function(){o.removeClipPath()}))),this._data=t.getData()},e.prototype.dispose=function(){},e.type="sankey",e}(qg);const iO=nO;var rO=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * Init a graph data structure from data in option series
               */return n(e,t),e.prototype.getInitialData=function(t,e){var n=t.edges||t.links,i=t.data||t.nodes,r=t.levels;this.levelModels=[];for(var o=this.levelModels,a=0;a<r.length;a++)null!=r[a].depth&&r[a].depth>=0&&(o[r[a].depth]=new Pc(r[a],this,e));if(i&&n){var s=tL(i,n,this,!0,(function(t,e){t.wrapMethod("getItemModel",(function(t,e){var n=t.parentModel,i=n.getData().getItemLayout(e);if(i){var r=i.depth,o=n.levelModels[r];o&&(t.parentModel=o)}return t})),e.wrapMethod("getItemModel",(function(t,e){var n=t.parentModel,i=n.getGraph().getEdgeByIndex(e).node1.getLayout();if(i){var r=i.depth,o=n.levelModels[r];o&&(t.parentModel=o)}return t}))}));return s.data}},e.prototype.setNodePosition=function(t,e){var n=(this.option.data||this.option.nodes)[t];n.localX=e[0],n.localY=e[1]},
/**
               * Return the graphic data structure
               *
               * @return graphic data structure
               */
e.prototype.getGraph=function(){return this.getData().graph},
/**
               * Get edge data of graphic data structure
               *
               * @return data structure of list
               */
e.prototype.getEdgeData=function(){return this.getGraph().edgeData},e.prototype.formatTooltip=function(t,e,n){function i(t){return isNaN(t)||null==t}// dataType === 'node' or empty do not show tooltip by default
if("edge"===n){var r=this.getDataParams(t,n),o=r.data,a=r.value;return dg("nameValue",{name:o.source+" -- "+o.target,value:a,noValue:i(a)})}// dataType === 'node'
var s=this.getGraph().getNodeByIndex(t).getLayout().value,l=this.getDataParams(t,n).data.name;return dg("nameValue",{name:null!=l?l+"":null,value:s,noValue:i(s)})},e.prototype.optionUpdated=function(){},// Override Series.getDataParams()
e.prototype.getDataParams=function(e,n){var i=t.prototype.getDataParams.call(this,e,n);if(null==i.value&&"node"===n){var r=this.getGraph().getNodeByIndex(e).getLayout().value;i.value=r}return i},e.type="series.sankey",e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"view",left:"5%",top:"5%",right:"20%",bottom:"5%",orient:"horizontal",nodeWidth:20,nodeGap:8,draggable:!0,layoutIterations:32,label:{show:!0,position:"right",fontSize:12},edgeLabel:{show:!1,fontSize:12},levels:[],nodeAlign:"justify",lineStyle:{color:"#314656",opacity:.2,curveness:.5},emphasis:{label:{show:!0},lineStyle:{opacity:.5}},select:{itemStyle:{borderColor:"#212121"}},animationEasing:"linear",animationDuration:1e3},e}(zg);const oO=rO;function aO(t,e){t.eachSeriesByType("sankey",(function(t){var n=t.get("nodeWidth"),i=t.get("nodeGap"),r=
/**
             * Get the layout position of the whole view
             */
function(t,e){return Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()})}(t,e);t.layoutInfo=r;var o=r.width,a=r.height,s=t.getGraph(),l=s.nodes,u=s.edges;!
/**
             * Compute the value of each node by summing the associated edge's value
             */
function(t){R(t,(function(t){var e=yO(t.outEdges,gO),n=yO(t.inEdges,gO),i=t.getValue()||0,r=Math.max(e,n,i);t.setLayout({value:r},!0)}))}
/**
             * Compute the x-position for each node.
             *
             * Here we use Kahn algorithm to detect cycle when we traverse
             * the node to computer the initial x position.
             */(l),function(t,e,n,i,r,o,a,s,l){(function(t,e,n,i,r,o,a){// let kx = 0;
for(// Used to mark whether the edge is deleted. if it is deleted,
// the value is 0, otherwise it is 1.
var s=[],l=[],u=[],h=[],c=0,p=0// Storage each node's indegree.
;p<e.length;p++)s[p]=1;for(p=0;p<t.length;p++)l[p]=t[p].inEdges.length,0===l[p]&&u.push(t[p]);// Traversing nodes using topological sorting to calculate the
// horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')
// position of the nodes.
for(var d=-1;u.length;){for(var f=0;f<u.length;f++){var g=u[f],y=g.hostGraph.data.getRawDataItem(g.dataIndex),v=null!=y.depth&&y.depth>=0;v&&y.depth>d&&(d=y.depth),g.setLayout({depth:v?y.depth:c},!0),"vertical"===o?g.setLayout({dy:n},!0):g.setLayout({dx:n},!0);for(var m=0;m<g.outEdges.length;m++){var x=g.outEdges[m];s[e.indexOf(x)]=0;var _=x.node2;0==--l[t.indexOf(_)]&&h.indexOf(_)<0&&h.push(_)}}++c,u=h,h=[]}for(p=0;p<s.length;p++)if(1===s[p])throw new Error("Sankey is a DAG, the original data has cycle!");var b=d>c-1?d:c-1;a&&"left"!==a&&function(t,e,n,i){if("right"===e){for(var r=[],o=t,a=0;o.length;){for(var s=0;s<o.length;s++){var l=o[s];l.setLayout({skNodeHeight:a},!0);for(var u=0;u<l.inEdges.length;u++){var h=l.inEdges[u];r.indexOf(h.node1)<0&&r.push(h.node1)}}o=r,r=[],++a}R(t,(function(t){sO(t)||t.setLayout({depth:Math.max(0,i-t.getLayout().skNodeHeight)},!0)}))}else"justify"===e&&
/**
             * All the node without outEgdes are assigned maximum x-position and
             *     be aligned in the last column.
             *
             * @param nodes.  node of sankey view.
             * @param maxDepth.  use to assign to node without outEdges as x-position.
             */
function(t,e){R(t,(function(t){sO(t)||t.outEdges.length||t.setLayout({depth:e},!0)}))}
/**
             * Scale node x-position to the width
             *
             * @param nodes  node of sankey view
             * @param kx   multiple used to scale nodes
             */(t,i)}(t,a,0,b);var w="vertical"===o?(r-n)/b:(i-n)/b;!function(t,e,n){R(t,(function(t){var i=t.getLayout().depth*e;"vertical"===n?t.setLayout({y:i},!0):t.setLayout({x:i},!0)}))}
/**
             * Using Gauss-Seidel iterations method to compute the node depth(y-position)
             *
             * @param nodes  node of sankey view
             * @param edges  edge of sankey view
             * @param height  the whole height of the area to draw the view
             * @param nodeGap  the vertical distance between two nodes
             *     in the same column.
             * @param iterations  the number of iterations for the algorithm
             */(t,w,o)})(t,e,n,r,o,s,l),function(t,e,n,i,r,o,a){var s=function(t,e){var n=[],i="vertical"===e?"y":"x",r=Ao(t,(function(t){return t.getLayout()[i]}));return r.keys.sort((function(t,e){return t-e})),R(r.keys,(function(t){n.push(r.buckets.get(t))})),n}
/**
             * Compute the original y-position for each node
             */(t,a);(function(t,e,n,i,r,o){var a=1/0;R(t,(function(t){var e=t.length,s=0;R(t,(function(t){s+=t.getLayout().value}));var l="vertical"===o?(i-(e-1)*r)/s:(n-(e-1)*r)/s;l<a&&(a=l)})),R(t,(function(t){R(t,(function(t,e){var n=t.getLayout().value*a;"vertical"===o?(t.setLayout({x:e},!0),t.setLayout({dx:n},!0)):(t.setLayout({y:e},!0),t.setLayout({dy:n},!0))}))})),R(e,(function(t){var e=+t.getValue()*a;t.setLayout({dy:e},!0)}))}
/**
             * Resolve the collision of initialized depth (y-position)
             */)(s,e,n,i,r,a),lO(s,r,n,i,a);for(var l=1;o>0;o--)// 0.99 is a experience parameter, ensure that each iterations of
// changes as small as possible.
uO(s,l*=.99,a),lO(s,r,n,i,a),vO(s,l,a),lO(s,r,n,i,a)}(t,e,o,r,i,a,s),
/**
             * Compute the depth(y-position) of each edge
             */
function(t,e){var n="vertical"===e?"x":"y";R(t,(function(t){t.outEdges.sort((function(t,e){return t.node2.getLayout()[n]-e.node2.getLayout()[n]})),t.inEdges.sort((function(t,e){return t.node1.getLayout()[n]-e.node1.getLayout()[n]}))})),R(t,(function(t){var e=0,n=0;R(t.outEdges,(function(t){t.setLayout({sy:e},!0),e+=t.getLayout().dy})),R(t.inEdges,(function(t){t.setLayout({ty:n},!0),n+=t.getLayout().dy}))}))}(t,s)}(l,u,n,i,o,a,0!==z(l,(function(t){return 0===t.getLayout().value})).length?0:t.get("layoutIterations"),t.get("orient"),t.get("nodeAlign"))}))}function sO(t){var e=t.hostGraph.data.getRawDataItem(t.dataIndex);return null!=e.depth&&e.depth>=0}function lO(t,e,n,i,r){var o="vertical"===r?"x":"y";R(t,(function(t){var a,s,l;t.sort((function(t,e){return t.getLayout()[o]-e.getLayout()[o]}));for(var u=0,h=t.length,c="vertical"===r?"dx":"dy",p=0;p<h;p++)(l=u-(s=t[p]).getLayout()[o])>0&&(a=s.getLayout()[o]+l,"vertical"===r?s.setLayout({x:a},!0):s.setLayout({y:a},!0)),u=s.getLayout()[o]+s.getLayout()[c]+e;if((// If the bottommost node goes outside the bounds, push it back up
l=u-e-("vertical"===r?i:n))>0)for(a=s.getLayout()[o]-l,"vertical"===r?s.setLayout({x:a},!0):s.setLayout({y:a},!0),u=a,p=h-2;p>=0;--p)(l=(s=t[p]).getLayout()[o]+s.getLayout()[c]+e-u)>0&&(a=s.getLayout()[o]-l,"vertical"===r?s.setLayout({x:a},!0):s.setLayout({y:a},!0)),u=s.getLayout()[o]}))}
/**
             * Change the y-position of the nodes, except most the right side nodes
             * @param nodesByBreadth
             * @param alpha  parameter used to adjust the nodes y-position
             */function uO(t,e,n){R(t.slice().reverse(),(function(t){R(t,(function(t){if(t.outEdges.length){var i=yO(t.outEdges,hO,n)/yO(t.outEdges,gO);if(isNaN(i)){var r=t.outEdges.length;i=r?yO(t.outEdges,cO,n)/r:0}if("vertical"===n){var o=t.getLayout().x+(i-fO(t,n))*e;t.setLayout({x:o},!0)}else{var a=t.getLayout().y+(i-fO(t,n))*e;t.setLayout({y:a},!0)}}}))}))}function hO(t,e){return fO(t.node2,e)*t.getValue()}function cO(t,e){return fO(t.node2,e)}function pO(t,e){return fO(t.node1,e)*t.getValue()}function dO(t,e){return fO(t.node1,e)}function fO(t,e){return"vertical"===e?t.getLayout().x+t.getLayout().dx/2:t.getLayout().y+t.getLayout().dy/2}function gO(t){return t.getValue()}function yO(t,e,n){for(var i=0,r=t.length,o=-1;++o<r;){var a=+e(t[o],n);isNaN(a)||(i+=a)}return i}
/**
             * Change the y-position of the nodes, except most the left side nodes
             */function vO(t,e,n){R(t,(function(t){R(t,(function(t){if(t.inEdges.length){var i=yO(t.inEdges,pO,n)/yO(t.inEdges,gO);if(isNaN(i)){var r=t.inEdges.length;i=r?yO(t.inEdges,dO,n)/r:0}if("vertical"===n){var o=t.getLayout().x+(i-fO(t,n))*e;t.setLayout({x:o},!0)}else{var a=t.getLayout().y+(i-fO(t,n))*e;t.setLayout({y:a},!0)}}}))}))}function mO(t){t.eachSeriesByType("sankey",(function(t){var e=t.getGraph(),n=e.nodes,i=e.edges;if(n.length){var r=1/0,o=-1/0;R(n,(function(t){var e=t.getLayout().value;e<r&&(r=e),e>o&&(o=e)})),R(n,(function(e){var n=new kA({type:"color",mappingMethod:"linear",dataExtent:[r,o],visual:t.get("color")}).mapValueToVisual(e.getLayout().value),i=e.getModel().get(["itemStyle","color"]);null!=i?(e.setVisual("color",i),e.setVisual("style",{fill:i})):(e.setVisual("color",n),e.setVisual("style",{fill:n}))}))}i.length&&R(i,(function(t){var e=t.getModel().get("lineStyle");t.setVisual("style",e)}))}))}var xO=/** @class */function(){function t(){}
/**
               * @override
               */return t.prototype.getInitialData=function(t,e){// When both types of xAxis and yAxis are 'value', layout is
// needed to be specified by user. Otherwise, layout can be
// judged by which axis is category.
var n,i,r=e.getComponent("xAxis",this.get("xAxisIndex")),o=e.getComponent("yAxis",this.get("yAxisIndex")),a=r.get("type"),s=o.get("type");// FIXME
// Consider time axis.
"category"===a?(t.layout="horizontal",n=r.getOrdinalMeta(),i=!0):"category"===s?(t.layout="vertical",n=o.getOrdinalMeta(),i=!0):t.layout=t.layout||"horizontal";var l=["x","y"],u="horizontal"===t.layout?0:1,h=this._baseAxisDim=l[u],c=l[1-u],p=[r,o],d=p[u].get("type"),f=p[1-u].get("type"),g=t.data;// Clone a new data for next setOption({}) usage.
// Avoid modifying current data will affect further update.
if(g&&i){var y=[];R(g,(function(t,e){var n;G(t)?(n=t.slice(),// Modify current using data.
t.unshift(e)):G(t.value)?((n=A({},t)).value=n.value.slice(),// Modify current using data.
t.value.unshift(e)):n=t,y.push(n)})),t.data=y}var v=this.defaultValueDimensions,m=[{name:h,type:qm(d),ordinalMeta:n,otherDims:{tooltip:!1,itemName:0},dimsDef:["base"]},{name:c,type:qm(f),dimsDef:v.slice()}];return UM(this,{coordDimensions:m,dimensionsCount:v.length+1,encodeDefaulter:F(od,m,this)})},
/**
               * If horizontal, base axis is x, otherwise y.
               * @override
               */
t.prototype.getBaseAxis=function(){var t=this._baseAxisDim;return this.ecModel.getComponent(t+"Axis",this.get(t+"AxisIndex")).axis},t}(),_O=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,// TODO
// box width represents group size, so dimension should have 'size'.
/**
                 * @see <https://en.wikipedia.org/wiki/Box_plot>
                 * The meanings of 'min' and 'max' depend on user,
                 * and echarts do not need to know it.
                 * @readOnly
                 */
n.defaultValueDimensions=[{name:"min",defaultTooltip:!0},{name:"Q1",defaultTooltip:!0},{name:"median",defaultTooltip:!0},{name:"Q3",defaultTooltip:!0},{name:"max",defaultTooltip:!0}],n.visualDrawType="stroke",n}return n(e,t),e.type="series.boxplot",e.dependencies=["xAxis","yAxis","grid"],e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"cartesian2d",legendHoverLink:!0,layout:null,boxWidth:[7,50],itemStyle:{color:"#fff",borderWidth:1},emphasis:{scale:!0,itemStyle:{borderWidth:2,shadowBlur:5,shadowOffsetX:1,shadowOffsetY:1,shadowColor:"rgba(0,0,0,0.2)"}},animationDuration:800},e}(zg);P(_O,xO,!0);const bO=_O;var wO=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.getData(),r=this.group,o=this._data;// There is no old data only when first rendering or switching from
// stream mode to normal mode, where previous elements should be removed.
this._data||r.removeAll();var a="horizontal"===t.get("layout")?1:0;i.diff(o).add((function(t){if(i.hasValue(t)){var e=IO(i.getItemLayout(t),i,t,a,!0);i.setItemGraphicEl(t,e),r.add(e)}})).update((function(t,e){var n=o.getItemGraphicEl(e);// Empty data
if(i.hasValue(t)){var s=i.getItemLayout(t);n?(Ah(n),TO(s,n,i,t)):n=IO(s,i,t,a),r.add(n),i.setItemGraphicEl(t,n)}else r.remove(n)})).remove((function(t){var e=o.getItemGraphicEl(t);e&&r.remove(e)})).execute(),this._data=i},e.prototype.remove=function(t){var e=this.group,n=this._data;this._data=null,n&&n.eachItemGraphicEl((function(t){t&&e.remove(t)}))},e.type="boxplot",e}(qg),SO=function(){},MO=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="boxplotBoxPath",n}return n(e,t),e.prototype.getDefaultShape=function(){return new SO},e.prototype.buildPath=function(t,e){var n=e.points,i=0;for(t.moveTo(n[i][0],n[i][1]),i++;i<4;i++)t.lineTo(n[i][0],n[i][1]);for(t.closePath();i<n.length;i++)t.moveTo(n[i][0],n[i][1]),i++,t.lineTo(n[i][0],n[i][1])},e}(ys);function IO(t,e,n,i,r){var o=t.ends,a=new MO({shape:{points:r?CO(o,i,t):o}});return TO(t,a,e,n,r),a}function TO(t,e,n,i,r){var o=n.hostModel;(0,nc[r?"initProps":"updateProps"])(e,{shape:{points:t.ends}},o,i),e.useStyle(n.getItemVisual(i,"style")),e.style.strokeNoScale=!0,e.z2=100;var a=n.getItemModel(i),s=a.getModel("emphasis");Hl(e,a),Bl(e,s.get("focus"),s.get("blurScope"),s.get("disabled"))}function CO(t,e,n){return N(t,(function(t){return(t=t.slice())[e]=n.initBaseline,t}))}const DO=wO;var AO=R;function kO(t){var e=
/**
             * Group series by axis.
             */
function(t){var e=[],n=[];return t.eachSeriesByType("boxplot",(function(t){var i=t.getBaseAxis(),r=L(n,i);r<0&&(r=n.length,n[r]=i,e[r]={axis:i,seriesModels:[]}),e[r].seriesModels.push(t)})),e}
/**
             * Calculate offset and box width for each series.
             */(t);AO(e,(function(t){var e=t.seriesModels;e.length&&(function(t){var e,n=t.axis,i=t.seriesModels,r=i.length,o=t.boxWidthList=[],a=t.boxOffsetList=[],s=[];if("category"===n.type)e=n.getBandWidth();else{var l=0;AO(i,(function(t){l=Math.max(l,t.getData().count())}));var u=n.getExtent();e=Math.abs(u[1]-u[0])/l}AO(i,(function(t){var n=t.get("boxWidth");G(n)||(n=[n,n]),s.push([Vr(n[0],e)||0,Vr(n[1],e)||0])}));var h=.8*e-2,c=h/r*.3,p=(h-c*(r-1))/r,d=p/2-h/2;AO(i,(function(t,e){a.push(d),d+=c+p,o.push(Math.min(Math.max(p,s[e][0]),s[e][1]))}))}
/**
             * Calculate points location for each series.
             */(t),AO(e,(function(e,n){!function(t,e,n){var i=t.coordinateSystem,r=t.getData(),o=n/2,a="horizontal"===t.get("layout")?0:1,s=1-a,l=["x","y"],u=r.mapDimension(l[a]),h=r.mapDimensionsAll(l[s]);if(!(null==u||h.length<5))for(var c=0;c<r.count();c++){var p=r.get(u,c),d=x(p,h[2],c),f=x(p,h[0],c),g=x(p,h[1],c),y=x(p,h[3],c),v=x(p,h[4],c),m=[];_(m,g,!1),_(m,y,!0),m.push(f,g,v,y),b(m,f),b(m,v),b(m,d),r.setItemLayout(c,{initBaseline:d[s],ends:m})}function x(t,n,o){var l,u=r.get(n,o),h=[];return h[a]=t,h[s]=u,isNaN(t)||isNaN(u)?l=[NaN,NaN]:(l=i.dataToPoint(h))[a]+=e,l}function _(t,e,n){var i=e.slice(),r=e.slice();i[a]+=o,r[a]-=o,n?t.push(i,r):t.push(r,i)}function b(t,e){var n=e.slice(),i=e.slice();n[a]-=o,i[a]+=o,t.push(n,i)}}
/**
             * See:
             *  <https://en.wikipedia.org/wiki/Box_plot#cite_note-frigge_hoaglin_iglewicz-2>
             *  <http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html>
             *
             * Helper method for preparing data.
             *
             * @param rawData like
             *        [
             *            [12,232,443], (raw data set for the first box)
             *            [3843,5545,1232], (raw data set for the second box)
             *            ...
             *        ]
             * @param opt.boundIQR=1.5 Data less than min bound is outlier.
             *      default 1.5, means Q1 - 1.5 * (Q3 - Q1).
             *      If 'none'/0 passed, min bound will not be used.
             */(e,t.boxOffsetList[n],t.boxWidthList[n])})))}))}var LO={type:"echarts:boxplot",transform:function(t){var e=t.upstream;e.sourceFormat!==jp&&ro("");var n=function(t,e){for(var n=[],i=[],r=(e=e||{}).boundIQR,o="none"===r||0===r,a=0;a<t.length;a++){var s=Fr(t[a].slice()),l=$r(s,.25),u=$r(s,.5),h=$r(s,.75),c=s[0],p=s[s.length-1],d=(null==r?1.5:r)*(h-l),f=o?c:Math.max(c,l-d),g=o?p:Math.min(p,h+d),y=e.itemNameFormatter,v=W(y)?y({value:a}):H(y)?y.replace("{value}",a+""):a+"";n.push([v,f,l,u,h,g]);for(var m=0;m<s.length;m++){var x=s[m];if(x<f||x>g){var _=[v,x];i.push(_)}}}return{boxData:n,outliers:i}}(e.getRawData(),t.config);return[{dimensions:["ItemName","Low","Q1","Q2","Q3","High"],data:n.boxData},{data:n.outliers}]}},PO=["color","borderColor"],OO=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){// If there is clipPath created in large mode. Remove it.
this.group.removeClipPath(),// Clear previously rendered progressive elements.
this._progressiveEls=null,this._updateDrawMode(t),this._isLargeDraw?this._renderLarge(t):this._renderNormal(t)},e.prototype.incrementalPrepareRender=function(t,e,n){this._clear(),this._updateDrawMode(t)},e.prototype.incrementalRender=function(t,e,n,i){this._progressiveEls=[],this._isLargeDraw?this._incrementalRenderLarge(t,e):this._incrementalRenderNormal(t,e)},e.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},e.prototype._updateDrawMode=function(t){var e=t.pipelineContext.large;null!=this._isLargeDraw&&e===this._isLargeDraw||(this._isLargeDraw=e,this._clear())},e.prototype._renderNormal=function(t){var e=t.getData(),n=this._data,i=this.group,r=e.getLayout("isSimpleBox"),o=t.get("clip",!0),a=t.coordinateSystem,s=a.getArea&&a.getArea();// There is no old data only when first rendering or switching from
// stream mode to normal mode, where previous elements should be removed.
this._data||i.removeAll(),e.diff(n).add((function(n){if(e.hasValue(n)){var a=e.getItemLayout(n);if(o&&zO(s,a))return;var l=EO(a,0,!0);Mh(l,{shape:{points:a.ends}},t,n),VO(l,e,n,r),i.add(l),e.setItemGraphicEl(n,l)}})).update((function(a,l){var u=n.getItemGraphicEl(l);// Empty data
if(e.hasValue(a)){var h=e.getItemLayout(a);o&&zO(s,h)?i.remove(u):(u?(Sh(u,{shape:{points:h.ends}},t,a),Ah(u)):u=EO(h),VO(u,e,a,r),i.add(u),e.setItemGraphicEl(a,u))}else i.remove(u)})).remove((function(t){var e=n.getItemGraphicEl(t);e&&i.remove(e)})).execute(),this._data=e},e.prototype._renderLarge=function(t){this._clear(),WO(t,this.group);var e=t.get("clip",!0)?BS(t.coordinateSystem,!1,t):null;e?this.group.setClipPath(e):this.group.removeClipPath()},e.prototype._incrementalRenderNormal=function(t,e){for(var n,i=e.getData(),r=i.getLayout("isSimpleBox");null!=(n=t.next());){var o=EO(i.getItemLayout(n));VO(o,i,n,r),o.incremental=!0,this.group.add(o),this._progressiveEls.push(o)}},e.prototype._incrementalRenderLarge=function(t,e){WO(e,this.group,this._progressiveEls,!0)},e.prototype.remove=function(t){this._clear()},e.prototype._clear=function(){this.group.removeAll(),this._data=null},e.type="candlestick",e}(qg),RO=function(){},NO=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="normalCandlestickBox",n}return n(e,t),e.prototype.getDefaultShape=function(){return new RO},e.prototype.buildPath=function(t,e){var n=e.points;this.__simpleBox?(t.moveTo(n[4][0],n[4][1]),t.lineTo(n[6][0],n[6][1])):(t.moveTo(n[0][0],n[0][1]),t.lineTo(n[1][0],n[1][1]),t.lineTo(n[2][0],n[2][1]),t.lineTo(n[3][0],n[3][1]),t.closePath(),t.moveTo(n[4][0],n[4][1]),t.lineTo(n[5][0],n[5][1]),t.moveTo(n[6][0],n[6][1]),t.lineTo(n[7][0],n[7][1]))},e}(ys);function EO(t,e,n){var i=t.ends;return new NO({shape:{points:n?BO(i,t):i},z2:100})}function zO(t,e){for(var n=!0,i=0;i<e.ends.length;i++)// If any point are in the region.
if(t.contain(e.ends[i][0],e.ends[i][1])){n=!1;break}return n}function VO(t,e,n,i){var r=e.getItemModel(n);t.useStyle(e.getItemVisual(n,"style")),t.style.strokeNoScale=!0,t.__simpleBox=i,Hl(t,r)}function BO(t,e){return N(t,(function(t){return(t=t.slice())[1]=e.initBaseline,t}))}var FO=function(){},GO=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n.type="largeCandlestickBox",n}return n(e,t),e.prototype.getDefaultShape=function(){return new FO},e.prototype.buildPath=function(t,e){for(// Drawing lines is more efficient than drawing
// a whole line or drawing rects.
var n=e.points,i=0;i<n.length;)if(this.__sign===n[i++]){var r=n[i++];t.moveTo(r,n[i++]),t.lineTo(r,n[i++])}else i+=3},e}(ys);function WO(t,e,n,i){var r=t.getData().getLayout("largePoints"),o=new GO({shape:{points:r},__sign:1,ignoreCoarsePointer:!0});e.add(o);var a=new GO({shape:{points:r},__sign:-1,ignoreCoarsePointer:!0});e.add(a);var s=new GO({shape:{points:r},__sign:0,ignoreCoarsePointer:!0});e.add(s),HO(1,o,t),HO(-1,a,t),HO(0,s,t),i&&(o.incremental=!0,a.incremental=!0),n&&n.push(o,a)}function HO(t,e,n,i){// TODO put in visual?
var r=n.get(["itemStyle",t>0?"borderColor":"borderColor0"])||n.get(["itemStyle",t>0?"color":"color0"]);0===t&&(r=n.get(["itemStyle","borderColorDoji"]));// Color must be excluded.
// Because symbol provide setColor individually to set fill and stroke
var o=n.getModel("itemStyle").getItemStyle(PO);e.useStyle(o),e.style.fill=null,e.style.stroke=r}const YO=OO;var XO=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.defaultValueDimensions=[{name:"open",defaultTooltip:!0},{name:"close",defaultTooltip:!0},{name:"lowest",defaultTooltip:!0},{name:"highest",defaultTooltip:!0}],n}
/**
               * Get dimension for shadow in dataZoom
               * @return dimension name
               */return n(e,t),e.prototype.getShadowDim=function(){return"open"},e.prototype.brushSelector=function(t,e,n){var i=e.getItemLayout(t);return i&&n.rect(i.brushRect)},e.type="series.candlestick",e.dependencies=["xAxis","yAxis","grid"],e.defaultOption={// zlevel: 0,
z:2,coordinateSystem:"cartesian2d",legendHoverLink:!0,// xAxisIndex: 0,
// yAxisIndex: 0,
layout:null,clip:!0,itemStyle:{color:"#eb5454",color0:"#47b262",borderColor:"#eb5454",borderColor0:"#47b262",borderColorDoji:null,// borderColor: '#d24040',
// borderColor0: '#398f4f',
borderWidth:1},emphasis:{scale:!0,itemStyle:{borderWidth:2}},barMaxWidth:null,barMinWidth:null,barWidth:null,large:!0,largeThreshold:600,progressive:3e3,progressiveThreshold:1e4,progressiveChunkMode:"mod",animationEasing:"linear",animationDuration:300},e}(zg);P(XO,xO,!0);const UO=XO;function ZO(t){t&&G(t.series)&&// Translate 'k' to 'candlestick'.
R(t.series,(function(t){U(t)&&"k"===t.type&&(t.type="candlestick")}))}var jO=["itemStyle","borderColor"],qO=["itemStyle","borderColor0"],KO=["itemStyle","borderColorDoji"],$O=["itemStyle","color"],JO=["itemStyle","color0"];const QO={seriesType:"candlestick",plan:Fg(),// For legend.
performRawSeries:!0,reset:function(t,e){function n(t,e){return e.get(t>0?$O:JO)}function i(t,e){return e.get(0===t?KO:t>0?jO:qO)}// Only visible series has each data be visual encoded
if(!e.isSeriesFiltered(t))return!t.pipelineContext.large&&{progress:function(t,e){for(var r;null!=(r=t.next());){var o=e.getItemModel(r),a=e.getItemLayout(r).sign,s=o.getItemStyle();s.fill=n(a,o),s.stroke=i(a,o)||s.fill,A(e.ensureUniqueItemVisual(r,"style"),s)}}}}};var tR={seriesType:"candlestick",plan:Fg(),reset:function(t){var e=t.coordinateSystem,n=t.getData(),i=function(t,e){var n,i=t.getBaseAxis(),r="category"===i.type?i.getBandWidth():(n=i.getExtent(),Math.abs(n[1]-n[0])/e.count()),o=Vr(Q(t.get("barMaxWidth"),r),r),a=Vr(Q(t.get("barMinWidth"),1),r),s=t.get("barWidth");return null!=s?Vr(s,r):Math.max(Math.min(r/2,o),a)}(t,n),r=["x","y"],o=n.getDimensionIndex(n.mapDimension(r[0])),a=N(n.mapDimensionsAll(r[1]),n.getDimensionIndex,n),s=a[0],l=a[1],u=a[2],h=a[3];if(n.setLayout({candleWidth:i,// The value is experimented visually.
isSimpleBox:i<=1.3}),!(o<0||a.length<4))return{progress:t.pipelineContext.large?function(n,i){for(// Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]
var r,a,c=qx(4*n.count),p=0,d=[],f=[],g=i.getStore(),y=!!t.get(["itemStyle","borderColorDoji"]);null!=(a=n.next());){var v=g.get(o,a),m=g.get(s,a),x=g.get(l,a),_=g.get(u,a),b=g.get(h,a);isNaN(v)||isNaN(_)||isNaN(b)?(c[p++]=NaN,p+=3):(c[p++]=eR(g,a,m,x,l,y),d[0]=v,d[1]=_,r=e.dataToPoint(d,null,f),c[p++]=r?r[0]:NaN,c[p++]=r?r[1]:NaN,d[1]=b,r=e.dataToPoint(d,null,f),c[p++]=r?r[1]:NaN)}i.setLayout("largePoints",c)}:function(t,n){for(var r,a=n.getStore();null!=(r=t.next());){var c=a.get(o,r),p=a.get(s,r),d=a.get(l,r),f=a.get(u,r),g=a.get(h,r),y=Math.min(p,d),v=Math.max(p,d),m=M(y,c),x=M(v,c),_=M(f,c),b=M(g,c),w=[];I(w,x,0),I(w,m,1),w.push(C(b),C(x),C(_),C(m));var S=!!n.getItemModel(r).get(["itemStyle","borderColorDoji"]);n.setItemLayout(r,{sign:eR(a,r,p,d,l,S),initBaseline:p>d?x[1]:m[1],ends:w,brushRect:T(f,g,c)})}function M(t,n){var i=[];return i[0]=n,i[1]=t,isNaN(n)||isNaN(t)?[NaN,NaN]:e.dataToPoint(i)}function I(t,e,n){var r=e.slice(),o=e.slice();r[0]=Wh(r[0]+i/2,1,!1),o[0]=Wh(o[0]-i/2,1,!0),n?t.push(r,o):t.push(o,r)}function T(t,e,n){var r=M(t,n),o=M(e,n);return r[0]-=i/2,o[0]-=i/2,{x:r[0],y:r[1],width:i,height:o[1]-r[1]}}function C(t){return t[0]=Wh(t[0],1),t}}}}};
/**
             * Get the sign of a single data.
             *
             * @returns 0 for doji with hasDojiColor: true,
             *          1 for positive,
             *          -1 for negative.
             */function eR(t,e,n,i,r,o){return n>i?-1:n<i?1:o?0:e>0?t.get(r,e-1)<=i?1:-1:// No record of previous, set to be positive
1}const nR=tR;function iR(t,e){var n=e.rippleEffectColor||e.color;t.eachChild((function(t){t.attr({z:e.z,zlevel:e.zlevel,style:{stroke:"stroke"===e.brushType?n:null,fill:"fill"===e.brushType?n:null}})}))}var rR=/** @class */function(t){function e(e,n){var i=t.call(this)||this,r=new bS(e,n),o=new Lr;return i.add(r),i.add(o),i.updateData(e,n),i}return n(e,t),e.prototype.stopEffectAnimation=function(){this.childAt(1).removeAll()},e.prototype.startEffectAnimation=function(t){for(var e=t.symbolType,n=t.color,i=t.rippleNumber,r=this.childAt(1),o=0;o<i;o++){// If width/height are set too small (e.g., set to 1) on ios10
// and macOS Sierra, a circle stroke become a rect, no matter what
// the scale is set. So we set width/height as 2. See #4136.
var a=ov(e,-1,-1,2,2,n);a.attr({style:{strokeNoScale:!0},z2:99,silent:!0,scaleX:.5,scaleY:.5});var s=-o/i*t.period+t.effectOffset;a.animate("",!0).when(t.period,{scaleX:t.rippleScale/2,scaleY:t.rippleScale/2}).delay(s).start(),a.animateStyle(!0).when(t.period,{opacity:0}).delay(s).start(),r.add(a)}iR(r,t)},
/**
               * Update effect symbol
               */
e.prototype.updateEffectAnimation=function(t){for(var e=this._effectCfg,n=this.childAt(1),i=["symbolType","period","rippleScale","rippleNumber"],r=0;r<i.length;r++){var o=i[r];if(e[o]!==t[o])return this.stopEffectAnimation(),void this.startEffectAnimation(t)}iR(n,t)},
/**
               * Highlight symbol
               */
e.prototype.highlight=function(){Il(this)},
/**
               * Downplay symbol
               */
e.prototype.downplay=function(){Tl(this)},e.prototype.getSymbolType=function(){var t=this.childAt(0);return t&&t.getSymbolType()},
/**
               * Update symbol properties
               */
e.prototype.updateData=function(t,e){var n=this,i=t.hostModel;this.childAt(0).updateData(t,e);var r=this.childAt(1),o=t.getItemModel(e),a=t.getItemVisual(e,"symbol"),s=av(t.getItemVisual(e,"symbolSize")),l=t.getItemVisual(e,"style"),u=l&&l.fill,h=o.getModel("emphasis");r.setScale(s),r.traverse((function(t){t.setStyle("fill",u)}));var c=sv(t.getItemVisual(e,"symbolOffset"),s);c&&(r.x=c[0],r.y=c[1]);var p=t.getItemVisual(e,"symbolRotate");r.rotation=(p||0)*Math.PI/180||0;var d={};d.showEffectOn=i.get("showEffectOn"),d.rippleScale=o.get(["rippleEffect","scale"]),d.brushType=o.get(["rippleEffect","brushType"]),d.period=1e3*o.get(["rippleEffect","period"]),d.effectOffset=e/t.count(),d.z=i.getShallow("z")||0,d.zlevel=i.getShallow("zlevel")||0,d.symbolType=a,d.color=u,d.rippleEffectColor=o.get(["rippleEffect","color"]),d.rippleNumber=o.get(["rippleEffect","number"]),"render"===d.showEffectOn?(this._effectCfg?this.updateEffectAnimation(d):this.startEffectAnimation(d),this._effectCfg=d):(// Not keep old effect config
this._effectCfg=null,this.stopEffectAnimation(),this.onHoverStateChange=function(t){"emphasis"===t?"render"!==d.showEffectOn&&n.startEffectAnimation(d):"normal"===t&&"render"!==d.showEffectOn&&n.stopEffectAnimation()}),this._effectCfg=d,Bl(this,h.get("focus"),h.get("blurScope"),h.get("disabled"))},e.prototype.fadeOut=function(t){t&&t()},e}(Lr);const oR=rR;var aR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(){this._symbolDraw=new TS(oR)},e.prototype.render=function(t,e,n){var i=t.getData(),r=this._symbolDraw;r.updateData(i,{clipShape:this._getClipShape(t)}),this.group.add(r.group)},e.prototype._getClipShape=function(t){var e=t.coordinateSystem,n=e&&e.getArea&&e.getArea();return t.get("clip",!0)?n:null},e.prototype.updateTransform=function(t,e,n){var i=t.getData();this.group.dirty();var r=QS("").reset(t,e,n);r.progress&&r.progress({start:0,end:i.count(),count:i.count()},i),this._symbolDraw.updateLayout()},e.prototype._updateGroupTransform=function(t){var e,n,i=t.coordinateSystem;i&&i.getRoamTransform&&(this.group.transform=(e=i.getRoamTransform(),he(n=[1,0,0,1,0,0],e),n),this.group.decomposeTransform())},e.prototype.remove=function(t,e){this._symbolDraw&&this._symbolDraw.remove(!0)},e.type="effectScatter",e}(qg);const sR=aR;var lR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n}return n(e,t),e.prototype.getInitialData=function(t,e){return Cx(null,this,{useEncodeDefaulter:!0})},e.prototype.brushSelector=function(t,e,n){return n.point(e.getItemLayout(t))},e.type="series.effectScatter",e.dependencies=["grid","polar"],e.defaultOption={coordinateSystem:"cartesian2d",// zlevel: 0,
z:2,legendHoverLink:!0,effectType:"ripple",progressive:0,// When to show the effect, option: 'render'|'emphasis'
showEffectOn:"render",clip:!0,// Ripple effect config
rippleEffect:{period:4,// Scale of ripple
scale:2.5,// Brush type can be fill or stroke
brushType:"fill",// Ripple number
number:3},universalTransition:{divideShape:"clone"},// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Polar coordinate system
// polarIndex: 0,
// Geo coordinate system
// geoIndex: 0,
// symbol: null,        // 
symbolSize:10},e}(zg);const uR=lR;var hR=/** @class */function(t){function e(e,n,i){var r=t.call(this)||this;return r.add(r.createLine(e,n,i)),r._updateEffectSymbol(e,n),r}return n(e,t),e.prototype.createLine=function(t,e,n){return new Pk(t,e,n)},e.prototype._updateEffectSymbol=function(t,e){var n=t.getItemModel(e).getModel("effect"),i=n.get("symbolSize"),r=n.get("symbol");G(i)||(i=[i,i]);var o=t.getItemVisual(e,"style"),a=n.get("color")||o&&o.stroke,s=this.childAt(1);this._symbolType!==r&&(// Remove previous
this.remove(s),(s=ov(r,-.5,-.5,1,1,a)).z2=100,s.culling=!0,this.add(s)),// Symbol may be removed if loop is false
s&&(// Shadow color is same with color in default
s.setStyle("shadowColor",a),s.setStyle(n.getItemStyle(["color"])),s.scaleX=i[0],s.scaleY=i[1],s.setColor(a),this._symbolType=r,this._symbolScale=i,this._updateEffectAnimation(t,n,e))},e.prototype._updateEffectAnimation=function(t,e,n){var i=this.childAt(1);if(i){var r=t.getItemLayout(n),o=1e3*e.get("period"),a=e.get("loop"),s=e.get("roundTrip"),l=e.get("constantSpeed"),u=J(e.get("delay"),(function(e){return e/t.count()*o/3}));if(// Ignore when updating
i.ignore=!0,this._updateAnimationPoints(i,r),l>0&&(o=this._getLineLength(i)/l*1e3),o!==this._period||a!==this._loop||s!==this._roundTrip){i.stopAnimation();var h=void 0;h=W(u)?u(n):u,i.__t>0&&(h=-o*i.__t),this._animateSymbol(i,o,h,a,s)}this._period=o,this._loop=a,this._roundTrip=s}},e.prototype._animateSymbol=function(t,e,n,i,r){if(e>0){t.__t=0;var o=this,a=t.animate("",i).when(r?2*e:e,{__t:r?2:1}).delay(n).during((function(){o._updateSymbolPosition(t)}));i||a.done((function(){o.remove(t)})),a.start()}},e.prototype._getLineLength=function(t){// Not so accurate
return At(t.__p1,t.__cp1)+At(t.__cp1,t.__p2)},e.prototype._updateAnimationPoints=function(t,e){t.__p1=e[0],t.__p2=e[1],t.__cp1=e[2]||[(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2]},e.prototype.updateData=function(t,e,n){this.childAt(0).updateData(t,e,n),this._updateEffectSymbol(t,e)},e.prototype._updateSymbolPosition=function(t){var e=t.__p1,n=t.__p2,i=t.__cp1,r=t.__t<1?t.__t:2-t.__t,o=[t.x,t.y],a=o.slice(),s=mn,l=xn;o[0]=s(e[0],i[0],n[0],r),o[1]=s(e[1],i[1],n[1],r);// Tangent
var u=t.__t<1?l(e[0],i[0],n[0],r):l(n[0],i[0],e[0],1-r),h=t.__t<1?l(e[1],i[1],n[1],r):l(n[1],i[1],e[1],1-r);t.rotation=-Math.atan2(h,u)-Math.PI/2,// enable continuity trail for 'line', 'rect', 'roundRect' symbolType
"line"!==this._symbolType&&"rect"!==this._symbolType&&"roundRect"!==this._symbolType||(void 0!==t.__lastT&&t.__lastT<t.__t?(t.scaleY=1.05*At(a,o),// make sure the last segment render within endPoint
1===r&&(o[0]=a[0]+(o[0]-a[0])/2,o[1]=a[1]+(o[1]-a[1])/2)):1===t.__lastT?// After first loop, symbol.__t does NOT start with 0, so connect p1 to pos directly.
t.scaleY=2*At(e,o):t.scaleY=this._symbolScale[1]),t.__lastT=t.__t,t.ignore=!1,t.x=o[0],t.y=o[1]},e.prototype.updateLayout=function(t,e){this.childAt(0).updateLayout(t,e);var n=t.getItemModel(e).getModel("effect");this._updateEffectAnimation(t,n,e)},e}(Lr);const cR=hR;var pR=/** @class */function(t){function e(e,n,i){var r=t.call(this)||this;return r._createPolyline(e,n,i),r}return n(e,t),e.prototype._createPolyline=function(t,e,n){// let seriesModel = lineData.hostModel;
var i=t.getItemLayout(e),r=new Xu({shape:{points:i}});this.add(r),this._updateCommonStl(t,e,n)},e.prototype.updateData=function(t,e,n){var i=t.hostModel;Sh(this.childAt(0),{shape:{points:t.getItemLayout(e)}},i,e),this._updateCommonStl(t,e,n)},e.prototype._updateCommonStl=function(t,e,n){var i=this.childAt(0),r=t.getItemModel(e),o=n&&n.emphasisLineStyle,a=n&&n.focus,s=n&&n.blurScope,l=n&&n.emphasisDisabled;if(!n||t.hasItemOption){var u=r.getModel("emphasis");o=u.getModel("lineStyle").getLineStyle(),l=u.get("disabled"),a=u.get("focus"),s=u.get("blurScope")}i.useStyle(t.getItemVisual(e,"style")),i.style.fill=null,i.style.strokeNoScale=!0,i.ensureState("emphasis").style=o,Bl(this,a,s,l)},e.prototype.updateLayout=function(t,e){this.childAt(0).setShape("points",t.getItemLayout(e))},e}(Lr);const dR=pR;var fR=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._lastFrame=0,e._lastFramePercent=0,e}// Override
return n(e,t),e.prototype.createLine=function(t,e,n){return new dR(t,e,n)},e.prototype._updateAnimationPoints=function(t,e){this._points=e;for(var n=[0],i=0,r=1;r<e.length;r++){var o=e[r-1],a=e[r];i+=At(o,a),n.push(i)}if(0!==i){for(r=0;r<n.length;r++)n[r]/=i;this._offsets=n,this._length=i}else this._length=0},e.prototype._getLineLength=function(){return this._length},e.prototype._updateSymbolPosition=function(t){var e=t.__t<1?t.__t:2-t.__t,n=this._points,i=this._offsets,r=n.length;if(i){var o,a=this._lastFrame;if(e<this._lastFramePercent){for(o=Math.min(a+1,r-1);o>=0&&!(i[o]<=e);o--);// PENDING really need to do this ?
o=Math.min(o,r-2)}else{for(o=a;o<r&&!(i[o]>e);o++);o=Math.min(o-1,r-2)}var s=(e-i[o])/(i[o+1]-i[o]),l=n[o],u=n[o+1];t.x=l[0]*(1-s)+s*u[0],t.y=l[1]*(1-s)+s*u[1];var h=t.__t<1?u[0]-l[0]:l[0]-u[0],c=t.__t<1?u[1]-l[1]:l[1]-u[1];t.rotation=-Math.atan2(c,h)-Math.PI/2,this._lastFrame=o,this._lastFramePercent=e,t.ignore=!1}},e}(cR);const gR=fR;var yR=function(){this.polyline=!1,this.curveness=0,this.segs=[]},vR=/** @class */function(t){function e(e){var n=t.call(this,e)||this;return n._off=0,n.hoverDataIdx=-1,n}return n(e,t),e.prototype.reset=function(){this.notClear=!1,this._off=0},e.prototype.getDefaultStyle=function(){return{stroke:"#000",fill:null}},e.prototype.getDefaultShape=function(){return new yR},e.prototype.buildPath=function(t,e){var n,i=e.segs,r=e.curveness;if(e.polyline)for(n=this._off;n<i.length;){var o=i[n++];if(o>0){t.moveTo(i[n++],i[n++]);for(var a=1;a<o;a++)t.lineTo(i[n++],i[n++])}}else for(n=this._off;n<i.length;){var s=i[n++],l=i[n++],u=i[n++],h=i[n++];if(t.moveTo(s,l),r>0){var c=(s+u)/2-(l-h)*r,p=(l+h)/2-(u-s)*r;t.quadraticCurveTo(c,p,u,h)}else t.lineTo(u,h)}this.incremental&&(this._off=n,this.notClear=!0)},e.prototype.findDataIndex=function(t,e){var n=this.shape,i=n.segs,r=n.curveness,o=this.style.lineWidth;if(n.polyline)for(var a=0,s=0;s<i.length;){var l=i[s++];if(l>0)for(var u=i[s++],h=i[s++],c=1;c<l;c++)if(Ka(u,h,p=i[s++],d=i[s++],o,t,e))return a;a++}else for(a=0,s=0;s<i.length;){u=i[s++],h=i[s++];var p=i[s++],d=i[s++];if(r>0){if(Ja(u,h,(u+p)/2-(h-d)*r,(h+d)/2-(p-u)*r,p,d,o,t,e))return a}else if(Ka(u,h,p,d,o,t,e))return a;a++}return-1},e.prototype.contain=function(t,e){var n=this.transformCoordToLocal(t,e),i=this.getBoundingRect();return t=n[0],e=n[1],i.contain(t,e)?(this.hoverDataIdx=this.findDataIndex(t,e))>=0:(this.hoverDataIdx=-1,!1)},e.prototype.getBoundingRect=function(){// Ignore stroke for large symbol draw.
var t=this._rect;if(!t){for(var e=this.shape.segs,n=1/0,i=1/0,r=-1/0,o=-1/0,a=0;a<e.length;){var s=e[a++],l=e[a++];n=Math.min(s,n),r=Math.max(s,r),i=Math.min(l,i),o=Math.max(l,o)}t=this._rect=new Ce(n,i,r,o)}return t},e}(ys);const mR=/** @class */function(){function t(){this.group=new Lr}
/**
               * Update symbols draw by new data
               */return t.prototype.updateData=function(t){this._clear();var e=this._create();e.setShape({segs:t.getLayout("linesPoints")}),this._setCommon(e,t)},
/**
               * @override
               */
t.prototype.incrementalPrepareUpdate=function(t){this.group.removeAll(),this._clear()},
/**
               * @override
               */
t.prototype.incrementalUpdate=function(t,e){var n=this._newAdded[0],i=e.getLayout("linesPoints"),r=n&&n.shape.segs;// Merging the exists. Each element has 1e4 points.
// Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)
if(r&&r.length<2e4){var o=r.length,a=new Float32Array(o+i.length);// Concat two array
a.set(r),a.set(i,o),n.setShape({segs:a})}else{// Clear
this._newAdded=[];var s=this._create();s.incremental=!0,s.setShape({segs:i}),this._setCommon(s,e),s.__startIndex=t.start}},
/**
               * @override
               */
t.prototype.remove=function(){this._clear()},t.prototype.eachRendered=function(t){this._newAdded[0]&&t(this._newAdded[0])},t.prototype._create=function(){var t=new vR({cursor:"default",ignoreCoarsePointer:!0});return this._newAdded.push(t),this.group.add(t),t},t.prototype._setCommon=function(t,e,n){var i=e.hostModel;t.setShape({polyline:i.get("polyline"),curveness:i.get(["lineStyle","curveness"])}),t.useStyle(i.getModel("lineStyle").getLineStyle()),t.style.strokeNoScale=!0;var r=e.getVisual("style");r&&r.stroke&&t.setStyle("stroke",r.stroke),t.setStyle("fill",null);var o=js(t);// Enable tooltip
// PENDING May have performance issue when path is extremely large
o.seriesIndex=i.seriesIndex,t.on("mousemove",(function(e){o.dataIndex=null;var n=t.hoverDataIdx;n>0&&(// Provide dataIndex for tooltip
o.dataIndex=n+t.__startIndex)}))},t.prototype._clear=function(){this._newAdded=[],this.group.removeAll()},t}();var xR={seriesType:"lines",plan:Fg(),reset:function(t){var e=t.coordinateSystem;if(e){var n=t.get("polyline"),i=t.pipelineContext.large;return{progress:function(r,o){var a=[];if(i){var s=void 0,l=r.end-r.start;if(n){for(var u=0,h=r.start;h<r.end;h++)u+=t.getLineCoordsCount(h);s=new Float32Array(l+2*u)}else s=new Float32Array(4*l);var c=0,p=[];for(h=r.start;h<r.end;h++){var d=t.getLineCoords(h,a);n&&(s[c++]=d);for(var f=0;f<d;f++)p=e.dataToPoint(a[f],!1,p),s[c++]=p[0],s[c++]=p[1]}o.setLayout("linesPoints",s)}else for(h=r.start;h<r.end;h++){var g=o.getItemModel(h),y=(d=t.getLineCoords(h,a),[]);if(n)for(var v=0;v<d;v++)y.push(e.dataToPoint(a[v]));else{y[0]=e.dataToPoint(a[0]),y[1]=e.dataToPoint(a[1]);var m=g.get(["lineStyle","curveness"]);+m&&(y[2]=[(y[0][0]+y[1][0])/2-(y[0][1]-y[1][1])*m,(y[0][1]+y[1][1])/2-(y[1][0]-y[0][0])*m])}o.setItemLayout(h,y)}}}}}};const _R=xR;var bR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.getData(),r=this._updateLineDraw(i,t),o=t.get("zlevel"),a=t.get(["effect","trailLength"]),s=n.getZr(),l="svg"===s.painter.getType();l||s.painter.getLayer(o).clear(!0),// Config layer with motion blur
null==this._lastZlevel||l||s.configLayer(this._lastZlevel,{motionBlur:!1}),this._showEffect(t)&&a>0&&(l||s.configLayer(o,{motionBlur:!0,lastFrameAlpha:Math.max(Math.min(a/10+.9,1),0)})),r.updateData(i);var u=t.get("clip",!0)&&BS(t.coordinateSystem,!1,t);u?this.group.setClipPath(u):this.group.removeClipPath(),this._lastZlevel=o,this._finished=!0},e.prototype.incrementalPrepareRender=function(t,e,n){var i=t.getData();this._updateLineDraw(i,t).incrementalPrepareUpdate(i),this._clearLayer(n),this._finished=!1},e.prototype.incrementalRender=function(t,e,n){this._lineDraw.incrementalUpdate(t,e.getData()),this._finished=t.end===e.getData().count()},e.prototype.eachRendered=function(t){this._lineDraw&&this._lineDraw.eachRendered(t)},e.prototype.updateTransform=function(t,e,n){var i=t.getData(),r=t.pipelineContext;if(!this._finished||r.large||r.progressiveRender)// TODO Don't have to do update in large mode. Only do it when there are millions of data.
return{update:!0};// TODO Use same logic with ScatterView.
// Manually update layout
var o=_R.reset(t,e,n);o.progress&&o.progress({start:0,end:i.count(),count:i.count()},i),// Not in large mode
this._lineDraw.updateLayout(),this._clearLayer(n)},e.prototype._updateLineDraw=function(t,e){var n=this._lineDraw,i=this._showEffect(e),r=!!e.get("polyline"),o=e.pipelineContext.large;return n&&i===this._hasEffet&&r===this._isPolyline&&o===this._isLargeDraw||(n&&n.remove(),n=this._lineDraw=o?new mR:new Ek(r?i?gR:dR:i?cR:Pk),this._hasEffet=i,this._isPolyline=r,this._isLargeDraw=o),this.group.add(n.group),n},e.prototype._showEffect=function(t){return!!t.get(["effect","show"])},e.prototype._clearLayer=function(t){// Not use motion when dragging or zooming
var e=t.getZr();"svg"===e.painter.getType()||null==this._lastZlevel||e.painter.getLayer(this._lastZlevel).clear(!0)},e.prototype.remove=function(t,e){this._lineDraw&&this._lineDraw.remove(),this._lineDraw=null,// Clear motion when lineDraw is removed
this._clearLayer(e)},e.prototype.dispose=function(t,e){this.remove(t,e)},e.type="lines",e}(qg);const wR=bR;var SR="undefined"==typeof Uint32Array?Array:Uint32Array,MR="undefined"==typeof Float64Array?Array:Float64Array;function IR(t){var e=t.data;e&&e[0]&&e[0][0]&&e[0][0].coord&&(t.data=N(e,(function(t){var e={coords:[t[0].coord,t[1].coord]};return t[0].name&&(e.fromName=t[0].name),t[1].name&&(e.toName=t[1].name),D([e,t[0],t[1]])})))}var TR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.visualStyleAccessPath="lineStyle",n.visualDrawType="stroke",n}return n(e,t),e.prototype.init=function(e){// The input data may be null/undefined.
e.data=e.data||[],// Not using preprocessor because mergeOption may not have series.type
IR(e);var n=this._processFlatCoordsArray(e.data);this._flatCoords=n.flatCoords,this._flatCoordsOffset=n.flatCoordsOffset,n.flatCoords&&(e.data=new Float32Array(n.count)),t.prototype.init.apply(this,arguments)},e.prototype.mergeOption=function(e){if(IR(e),e.data){// Only update when have option data to merge.
var n=this._processFlatCoordsArray(e.data);this._flatCoords=n.flatCoords,this._flatCoordsOffset=n.flatCoordsOffset,n.flatCoords&&(e.data=new Float32Array(n.count))}t.prototype.mergeOption.apply(this,arguments)},e.prototype.appendData=function(t){var e=this._processFlatCoordsArray(t.data);e.flatCoords&&(this._flatCoords?(this._flatCoords=pt(this._flatCoords,e.flatCoords),this._flatCoordsOffset=pt(this._flatCoordsOffset,e.flatCoordsOffset)):(this._flatCoords=e.flatCoords,this._flatCoordsOffset=e.flatCoordsOffset),t.data=new Float32Array(e.count)),this.getRawData().appendData(t.data)},e.prototype._getCoordsFromItemModel=function(t){var e=this.getData().getItemModel(t);return e.option instanceof Array?e.option:e.getShallow("coords")},e.prototype.getLineCoordsCount=function(t){return this._flatCoordsOffset?this._flatCoordsOffset[2*t+1]:this._getCoordsFromItemModel(t).length},e.prototype.getLineCoords=function(t,e){if(this._flatCoordsOffset){for(var n=this._flatCoordsOffset[2*t],i=this._flatCoordsOffset[2*t+1],r=0;r<i;r++)e[r]=e[r]||[],e[r][0]=this._flatCoords[n+2*r],e[r][1]=this._flatCoords[n+2*r+1];return i}var o=this._getCoordsFromItemModel(t);for(r=0;r<o.length;r++)e[r]=e[r]||[],e[r][0]=o[r][0],e[r][1]=o[r][1];return o.length},e.prototype._processFlatCoordsArray=function(t){var e=0;// Stored as a typed array. In format
// Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |
if(this._flatCoords&&(e=this._flatCoords.length),X(t[0])){for(var n=t.length,i=new SR(n),r=new MR(n),o=0,a=0,s=0,l=0// Store offset and len of each segment
;l<n;){s++;var u=t[l++];// Offset
i[a++]=o+e,// Len
i[a++]=u;for(var h=0;h<u;h++){var c=t[l++],p=t[l++];r[o++]=c,r[o++]=p}}return{flatCoordsOffset:new Uint32Array(i.buffer,0,a),flatCoords:r,count:s}}return{flatCoordsOffset:null,flatCoords:null,count:t.length}},e.prototype.getInitialData=function(t,e){var n=new vx(["value"],this);return n.hasItemOption=!1,n.initData(t.data,[],(function(t,e,i,r){// dataItem is simply coords
if(t instanceof Array)return NaN;n.hasItemOption=!0;var o=t.value;return null!=o?o instanceof Array?o[r]:o:void 0})),n},e.prototype.formatTooltip=function(t,e,n){var i=this.getData().getItemModel(t),r=i.get("name");if(r)return r;var o=i.get("fromName"),a=i.get("toName"),s=[];return null!=o&&s.push(o),null!=a&&s.push(a),dg("nameValue",{name:s.join(" > ")})},e.prototype.preventIncremental=function(){return!!this.get(["effect","show"])},e.prototype.getProgressive=function(){var t=this.option.progressive;return null==t?this.option.large?1e4:this.get("progressive"):t},e.prototype.getProgressiveThreshold=function(){var t=this.option.progressiveThreshold;return null==t?this.option.large?2e4:this.get("progressiveThreshold"):t},e.prototype.getZLevelKey=function(){var t=this.getModel("effect"),e=t.get("trailLength");return this.getData().count()>this.getProgressiveThreshold()?this.id:t.get("show")&&e>0?e+"":""},e.type="series.lines",e.dependencies=["grid","polar","geo","calendar"],e.defaultOption={coordinateSystem:"geo",// zlevel: 0,
z:2,legendHoverLink:!0,// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,symbol:["none","none"],symbolSize:[10,10],// Geo coordinate system
geoIndex:0,effect:{show:!1,period:4,constantSpeed:0,symbol:"circle",symbolSize:3,loop:!0,trailLength:.2},large:!1,// Available when large is true
largeThreshold:2e3,polyline:!1,clip:!0,label:{show:!1,position:"end"},lineStyle:{opacity:.5}},e}(zg);const CR=TR;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function DR(t){return t instanceof Array||(t=[t,t]),t}const AR={seriesType:"lines",reset:function(t){var e=DR(t.get("symbol")),n=DR(t.get("symbolSize")),i=t.getData();return i.setVisual("fromSymbol",e&&e[0]),i.setVisual("toSymbol",e&&e[1]),i.setVisual("fromSymbolSize",n&&n[0]),i.setVisual("toSymbolSize",n&&n[1]),{dataEach:i.hasItemOption?function(t,e){var n=t.getItemModel(e),i=DR(n.getShallow("symbol",!0)),r=DR(n.getShallow("symbolSize",!0));i[0]&&t.setItemVisual(e,"fromSymbol",i[0]),i[1]&&t.setItemVisual(e,"toSymbol",i[1]),r[0]&&t.setItemVisual(e,"fromSymbolSize",r[0]),r[1]&&t.setItemVisual(e,"toSymbolSize",r[1])}:null}}};var kR=/** @class */function(){function t(){this.blurSize=30,this.pointSize=20,this.maxOpacity=1,this.minOpacity=0,this._gradientPixels={inRange:null,outOfRange:null};var t=c.createCanvas();this.canvas=t}
/**
               * Renders Heatmap and returns the rendered canvas
               * @param data array of data, each has x, y, value
               * @param width canvas width
               * @param height canvas height
               */return t.prototype.update=function(t,e,n,i,r,o){var a=this._getBrush(),s=this._getGradient(r,"inRange"),l=this._getGradient(r,"outOfRange"),u=this.pointSize+this.blurSize,h=this.canvas,c=h.getContext("2d"),p=t.length;h.width=e,h.height=n;for(var d=0;d<p;++d){var f=t[d],g=f[0],y=f[1],v=i(f[2]);// draw with the circle brush with alpha
c.globalAlpha=v,c.drawImage(a,g-u,y-u)}if(!h.width||!h.height)// Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
// 'CanvasRenderingContext2D': The source height is 0."
return h;// colorize the canvas using alpha value and set with gradient
for(var m=c.getImageData(0,0,h.width,h.height),x=m.data,_=0,b=x.length,w=this.minOpacity,S=this.maxOpacity-w;_<b;){v=x[_+3]/256;var M=4*Math.floor(255*v);// Simple optimize to ignore the empty data
if(v>0){var I=o(v)?s:l;// Any alpha > 0 will be mapped to [minOpacity, maxOpacity]
v>0&&(v=v*S+w),x[_++]=I[M],x[_++]=I[M+1],x[_++]=I[M+2],x[_++]=I[M+3]*v*256}else _+=4}return c.putImageData(m,0,0),h},
/**
               * get canvas of a black circle brush used for canvas to draw later
               */
t.prototype._getBrush=function(){var t=this._brushCanvas||(this._brushCanvas=c.createCanvas()),e=this.pointSize+this.blurSize,n=2*e;// set brush size
t.width=n,t.height=n;var i=t.getContext("2d");return i.clearRect(0,0,n,n),// in order to render shadow without the distinct circle,
// draw the distinct circle in an invisible place,
// and use shadowOffset to draw shadow in the center of the canvas
i.shadowOffsetX=n,i.shadowBlur=this.blurSize,// draw the shadow in black, and use alpha and shadow blur to generate
// color in color map
i.shadowColor="#000",// draw circle in the left to the canvas
i.beginPath(),i.arc(-e,e,this.pointSize,0,2*Math.PI,!0),i.closePath(),i.fill(),t},
/**
               * get gradient color map
               * @private
               */
t.prototype._getGradient=function(t,e){for(var n=this._gradientPixels,i=n[e]||(n[e]=new Uint8ClampedArray(1024)),r=[0,0,0,0],o=0,a=0;a<256;a++)t[e](a/255,!0,r),i[o++]=r[0],i[o++]=r[1],i[o++]=r[2],i[o++]=r[3];return i},t}();const LR=kR;function PR(t){var e=t.dimensions;// Not use coordSys.type === 'geo' because coordSys maybe extended
return"lng"===e[0]&&"lat"===e[1]}var OR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i;e.eachComponent("visualMap",(function(e){e.eachTargetSeries((function(n){n===t&&(i=e)}))})),this._progressiveEls=null,this.group.removeAll();var r=t.coordinateSystem;"cartesian2d"===r.type||"calendar"===r.type?this._renderOnCartesianAndCalendar(t,n,0,t.getData().count()):PR(r)&&this._renderOnGeo(r,t,i,n)},e.prototype.incrementalPrepareRender=function(t,e,n){this.group.removeAll()},e.prototype.incrementalRender=function(t,e,n,i){var r=e.coordinateSystem;r&&(// geo does not support incremental rendering?
PR(r)?this.render(e,n,i):(this._progressiveEls=[],this._renderOnCartesianAndCalendar(e,i,t.start,t.end,!0)))},e.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},e.prototype._renderOnCartesianAndCalendar=function(t,e,n,i,r){var o,a,s,l,u=t.coordinateSystem,h=FS(u,"cartesian2d");if(h){var c=u.getAxis("x"),p=u.getAxis("y");o=c.getBandWidth()+.5,a=p.getBandWidth()+.5,s=c.scale.getExtent(),l=p.scale.getExtent()}for(var d=this.group,f=t.getData(),g=t.getModel(["emphasis","itemStyle"]).getItemStyle(),y=t.getModel(["blur","itemStyle"]).getItemStyle(),v=t.getModel(["select","itemStyle"]).getItemStyle(),m=t.get(["itemStyle","borderRadius"]),x=sc(t),_=t.getModel("emphasis"),b=_.get("focus"),w=_.get("blurScope"),S=_.get("disabled"),M=h?[f.mapDimension("x"),f.mapDimension("y"),f.mapDimension("value")]:[f.mapDimension("time"),f.mapDimension("value")],I=n;I<i;I++){var T=void 0,C=f.getItemVisual(I,"style");if(h){var D=f.get(M[0],I),A=f.get(M[1],I);// Ignore empty data and out of extent data
if(isNaN(f.get(M[2],I))||isNaN(D)||isNaN(A)||D<s[0]||D>s[1]||A<l[0]||A>l[1])continue;var k=u.dataToPoint([D,A]);T=new Ls({shape:{x:k[0]-o/2,y:k[1]-a/2,width:o,height:a},style:C})}else{// Ignore empty data
if(isNaN(f.get(M[1],I)))continue;T=new Ls({z2:1,shape:u.dataToRect([f.get(M[0],I)]).contentShape,style:C})}// Optimization for large dataset
if(f.hasItemOption){var L=f.getItemModel(I),P=L.getModel("emphasis");g=P.getModel("itemStyle").getItemStyle(),y=L.getModel(["blur","itemStyle"]).getItemStyle(),v=L.getModel(["select","itemStyle"]).getItemStyle(),// Each item value struct in the data would be firstly
// {
//     itemStyle: { borderRadius: [30, 30] },
//     value: [2022, 02, 22]
// }
m=L.get(["itemStyle","borderRadius"]),b=P.get("focus"),w=P.get("blurScope"),S=P.get("disabled"),x=sc(L)}T.shape.r=m;var O=t.getRawValue(I),R="-";O&&null!=O[2]&&(R=O[2]+""),ac(T,x,{labelFetcher:t,labelDataIndex:I,defaultOpacity:C.opacity,defaultText:R}),T.ensureState("emphasis").style=g,T.ensureState("blur").style=y,T.ensureState("select").style=v,Bl(T,b,w,S),T.incremental=r,// PENDING
r&&(// Rect must use hover layer if it's incremental.
T.states.emphasis.hoverLayer=!0),d.add(T),f.setItemGraphicEl(I,T),this._progressiveEls&&this._progressiveEls.push(T)}},e.prototype._renderOnGeo=function(t,e,n,i){var r=n.targetVisuals.inRange,o=n.targetVisuals.outOfRange,a=e.getData(),s=this._hmLayer||this._hmLayer||new LR;s.blurSize=e.get("blurSize"),s.pointSize=e.get("pointSize"),s.minOpacity=e.get("minOpacity"),s.maxOpacity=e.get("maxOpacity");var l=t.getViewRect().clone(),u=t.getRoamTransform();l.applyTransform(u);// Clamp on viewport
var h=Math.max(l.x,0),c=Math.max(l.y,0),p=Math.min(l.width+l.x,i.getWidth()),d=Math.min(l.height+l.y,i.getHeight()),f=p-h,g=d-c,y=[a.mapDimension("lng"),a.mapDimension("lat"),a.mapDimension("value")],v=a.mapArray(y,(function(e,n,i){var r=t.dataToPoint([e,n]);return r[0]-=h,r[1]-=c,r.push(i),r})),m=n.getExtent(),x="visualMap.continuous"===n.type?function(t,e){var n=t[1]-t[0];return e=[(e[0]-t[0])/n,(e[1]-t[0])/n],function(t){return t>=e[0]&&t<=e[1]}}(m,n.option.range):function(t,e,n){var i=t[1]-t[0],r=(e=N(e,(function(e){return{interval:[(e.interval[0]-t[0])/i,(e.interval[1]-t[0])/i]}}))).length,o=0;return function(t){var i;// Try to find in the location of the last found
for(i=o;i<r;i++)if((a=e[i].interval)[0]<=t&&t<=a[1]){o=i;break}if(i===r)// Not found, back interation
for(i=o-1;i>=0;i--){var a;if((a=e[i].interval)[0]<=t&&t<=a[1]){o=i;break}}return i>=0&&i<r&&n[i]}}(m,n.getPieceList(),n.option.selected);s.update(v,f,g,r.color.getNormalizer(),{inRange:r.color.getColorMapper(),outOfRange:o.color.getColorMapper()},x);var _=new Ss({style:{width:f,height:g,x:h,y:c,image:s.canvas},silent:!0});this.group.add(_)},e.type="heatmap",e}(qg);const RR=OR;var NR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.getInitialData=function(t,e){return Cx(null,this,{generateCoord:"value"})},e.prototype.preventIncremental=function(){var t=Ad.get(this.get("coordinateSystem"));if(t&&t.dimensions)return"lng"===t.dimensions[0]&&"lat"===t.dimensions[1]},e.type="series.heatmap",e.dependencies=["grid","geo","calendar"],e.defaultOption={coordinateSystem:"cartesian2d",// zlevel: 0,
z:2,// Cartesian coordinate system
// xAxisIndex: 0,
// yAxisIndex: 0,
// Geo coordinate system
geoIndex:0,blurSize:30,pointSize:20,maxOpacity:1,minOpacity:0,select:{itemStyle:{borderColor:"#212121"}}},e}(zg);const ER=NR;var zR=["itemStyle","borderWidth"],VR=[{xy:"x",wh:"width",index:0,posDesc:["left","right"]},{xy:"y",wh:"height",index:1,posDesc:["top","bottom"]}],BR=new yu,FR=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=this.group,r=t.getData(),o=this._data,a=t.coordinateSystem,s=a.getBaseAxis().isHorizontal(),l=a.master.getRect(),u={ecSize:{width:n.getWidth(),height:n.getHeight()},seriesModel:t,coordSys:a,coordSysExtent:[[l.x,l.x+l.width],[l.y,l.y+l.height]],isHorizontal:s,valueDim:VR[+s],categoryDim:VR[1-+s]};return r.diff(o).add((function(t){if(r.hasValue(t)){var e=jR(r,t),n=GR(r,t,e,u),o=$R(r,u,n);r.setItemGraphicEl(t,o),i.add(o),nN(o,u,n)}})).update((function(t,e){var n=o.getItemGraphicEl(e);if(r.hasValue(t)){var a=jR(r,t),s=GR(r,t,a,u),l=QR(r,s);n&&l!==n.__pictorialShapeStr&&(i.remove(n),r.setItemGraphicEl(t,null),n=null),n?function(t,e,n){var i=n.animationModel,r=n.dataIndex,o=t.__pictorialBundle;Sh(o,{x:n.bundlePosition[0],y:n.bundlePosition[1]},i,r),n.symbolRepeat?YR(t,e,n,!0):XR(t,0,n,!0),UR(t,n,!0),ZR(t,e,n,!0)}(n,u,s):n=$R(r,u,s,!0),r.setItemGraphicEl(t,n),n.__pictorialSymbolMeta=s,// Add back
i.add(n),nN(n,u,s)}else i.remove(n)})).remove((function(t){var e=o.getItemGraphicEl(t);e&&JR(o,t,e.__pictorialSymbolMeta.animationModel,e)})).execute(),this._data=r,this.group},e.prototype.remove=function(t,e){var n=this.group,i=this._data;t.get("animation")?i&&i.eachItemGraphicEl((function(e){JR(i,js(e).dataIndex,t,e)})):n.removeAll()},e.type="pictorialBar",e}(qg);// index: +isHorizontal
// Set or calculate default value about symbol, and calculate layout info.
function GR(t,e,n,i){var r=t.getItemLayout(e),o=n.get("symbolRepeat"),a=n.get("symbolClip"),s=n.get("symbolPosition")||"start",l=(n.get("symbolRotate")||0)*Math.PI/180||0,u=n.get("symbolPatternSize")||2,h=n.isAnimationEnabled(),c={dataIndex:e,layout:r,itemModel:n,symbolType:t.getItemVisual(e,"symbol")||"circle",style:t.getItemVisual(e,"style"),symbolClip:a,symbolRepeat:o,symbolRepeatDirection:n.get("symbolRepeatDirection"),symbolPatternSize:u,rotation:l,animationModel:h?n:null,hoverScale:h&&n.get(["emphasis","scale"]),z2:n.getShallow("z",!0)||0};!// bar length can be negative.
function(t,e,n,i,r){var o,a=i.valueDim,s=t.get("symbolBoundingData"),l=i.coordSys.getOtherAxis(i.coordSys.getBaseAxis()),u=l.toGlobalCoord(l.dataToCoord(0)),h=1-+(n[a.wh]<=0);if(G(s)){var c=[WR(l,s[0])-u,WR(l,s[1])-u];c[1]<c[0]&&c.reverse(),o=c[h]}else o=null!=s?WR(l,s)-u:e?i.coordSysExtent[a.index][h]-u:n[a.wh];r.boundingLength=o,e&&(r.repeatCutLength=n[a.wh]),// if 'pxSign' means sign of pixel,  it can't be zero, or symbolScale will be zero
// and when borderWidth be settled, the actual linewidth will be NaN
r.pxSign=o>0?1:-1}(n,o,r,i,c),// Support ['100%', '100%']
function(t,e,n,i,r,o,a,s,l,u){var h,c=l.valueDim,p=l.categoryDim,d=Math.abs(n[p.wh]),f=t.getItemVisual(e,"symbolSize");// Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is
// to complicated to calculate real percent value if considering scaled lineWidth.
// So the actual size will bigger than layout size if lineWidth is bigger than zero,
// which can be tolerated in pictorial chart.
(h=G(f)?f.slice():null==f?["100%","100%"]:[f,f])[p.index]=Vr(h[p.index],d),h[c.index]=Vr(h[c.index],i?d:Math.abs(o)),u.symbolSize=h;// If x or y is less than zero, show reversed shape.
var g=u.symbolScale=[h[0]/s,h[1]/s];// Follow convention, 'right' and 'top' is the normal scale.
g[c.index]*=(l.isHorizontal?-1:1)*a}(t,e,r,o,0,c.boundingLength,c.pxSign,u,i,c),function(t,e,n,i,r){// In symbols are drawn with scale, so do not need to care about the case that width
// or height are too small. But symbol use strokeNoScale, where acture lineWidth should
// be calculated.
var o=t.get(zR)||0;o&&(BR.attr({scaleX:e[0],scaleY:e[1],rotation:n}),BR.updateTransform(),o/=BR.getLineScale(),o*=e[i.valueDim.index]),r.valueLineWidth=o||0}(n,c.symbolScale,l,i,c);var p=c.symbolSize,d=sv(n.get("symbolOffset"),p);return function(t,e,n,i,r,o,a,s,l,u,h,c){var p=h.categoryDim,d=h.valueDim,f=c.pxSign,g=Math.max(e[d.index]+s,0),y=g;// Note: rotation will not effect the layout of symbols, because user may
// want symbols to rotate on its center, which should not be translated
// when rotating.
if(i){var v=Math.abs(l),m=J(t.get("symbolMargin"),"15%")+"",x=!1;m.lastIndexOf("!")===m.length-1&&(x=!0,m=m.slice(0,m.length-1));var _=Vr(m,e[d.index]),b=Math.max(g+2*_,0),w=x?0:2*_,S=to(i),M=S?i:iN((v+w)/b);b=g+2*(_=(v-M*g)/2/(x?M:Math.max(M-1,1))),w=x?0:2*_,// Update repeatTimes when not all symbol will be shown.
S||"fixed"===i||(M=u?iN((Math.abs(u)+w)/b):0),y=M*b-w,c.repeatTimes=M,c.symbolMargin=_}var I=f*(y/2),T=c.pathPosition=[];T[p.index]=n[p.wh]/2,T[d.index]="start"===a?I:"end"===a?l-I:l/2,// 'center'
o&&(T[0]+=o[0],T[1]+=o[1]);var C=c.bundlePosition=[];C[p.index]=n[p.xy],C[d.index]=n[d.xy];var D=c.barRectShape=A({},n);D[d.wh]=f*Math.max(Math.abs(n[d.wh]),Math.abs(T[d.index]+I)),D[p.wh]=n[p.wh];var k=c.clipShape={};// Consider that symbol may be overflow layout rect.
k[p.xy]=-n[p.xy],k[p.wh]=h.ecSize[p.wh],k[d.xy]=0,k[d.wh]=n[d.wh]}(n,p,r,o,0,d,s,c.valueLineWidth,c.boundingLength,c.repeatCutLength,i,c),c}function WR(t,e){return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)))}function HR(t){var e=t.symbolPatternSize,n=ov(// Consider texture img, make a big size.
t.symbolType,-e/2,-e/2,e,e);return n.attr({culling:!0}),"image"!==n.type&&n.setStyle({strokeNoScale:!0}),n}function YR(t,e,n,i){var r=t.__pictorialBundle,o=n.symbolSize,a=n.valueLineWidth,s=n.pathPosition,l=e.valueDim,u=n.repeatTimes||0,h=0,c=o[e.valueDim.index]+a+2*n.symbolMargin;for(tN(t,(function(t){t.__pictorialAnimationIndex=h,t.__pictorialRepeatTimes=u,h<u?eN(t,null,f(h),n,i):eN(t,null,{scaleX:0,scaleY:0},n,i,(function(){r.remove(t)})),// updateHoverAnimation(path, symbolMeta);
h++}));h<u;h++){var p=HR(n);p.__pictorialAnimationIndex=h,p.__pictorialRepeatTimes=u,r.add(p);var d=f(h);eN(p,{x:d.x,y:d.y,scaleX:0,scaleY:0},{scaleX:d.scaleX,scaleY:d.scaleY,rotation:d.rotation},n,i)}function f(t){var e=s.slice(),i=n.pxSign,r=t;// (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index
// Otherwise: i = index;
return("start"===n.symbolRepeatDirection?i>0:i<0)&&(r=u-1-t),e[l.index]=c*(r-u/2+.5)+s[l.index],{x:e[0],y:e[1],scaleX:n.symbolScale[0],scaleY:n.symbolScale[1],rotation:n.rotation}}}function XR(t,e,n,i){var r=t.__pictorialBundle,o=t.__pictorialMainPath;o?eN(o,null,{x:n.pathPosition[0],y:n.pathPosition[1],scaleX:n.symbolScale[0],scaleY:n.symbolScale[1],rotation:n.rotation},n,i):(o=t.__pictorialMainPath=HR(n),r.add(o),eN(o,{x:n.pathPosition[0],y:n.pathPosition[1],scaleX:0,scaleY:0,rotation:n.rotation},{scaleX:n.symbolScale[0],scaleY:n.symbolScale[1]},n,i))}// bar rect is used for label.
function UR(t,e,n){var i=A({},e.barRectShape),r=t.__pictorialBarRect;r?eN(r,null,{shape:i},e,n):((r=t.__pictorialBarRect=new Ls({z2:2,shape:i,silent:!0,style:{stroke:"transparent",fill:"transparent",lineWidth:0}})).disableMorphing=!0,t.add(r))}function ZR(t,e,n,i){// If not clip, symbol will be remove and rebuilt.
if(n.symbolClip){var r=t.__pictorialClipPath,o=A({},n.clipShape),a=e.valueDim,s=n.animationModel,l=n.dataIndex;if(r)Sh(r,{shape:o},s,l);else{o[a.wh]=0,r=new Ls({shape:o}),t.__pictorialBundle.setClipPath(r),t.__pictorialClipPath=r;var u={};u[a.wh]=n.clipShape[a.wh],nc[i?"updateProps":"initProps"](r,{shape:u},s,l)}}}function jR(t,e){var n=t.getItemModel(e);return n.getAnimationDelayParams=qR,n.isAnimationEnabled=KR,n}function qR(t){// The order is the same as the z-order, see `symbolRepeatDiretion`.
return{index:t.__pictorialAnimationIndex,count:t.__pictorialRepeatTimes}}function KR(){// `animation` prop can be set on itemModel in pictorial bar chart.
return this.parentModel.isAnimationEnabled()&&!!this.getShallow("animation")}function $R(t,e,n,i){// bar is the main element for each data.
var r=new Lr,o=new Lr;// bundle is used for location and clip.
return r.add(o),r.__pictorialBundle=o,o.x=n.bundlePosition[0],o.y=n.bundlePosition[1],n.symbolRepeat?YR(r,e,n):XR(r,0,n),UR(r,n,i),ZR(r,e,n,i),r.__pictorialShapeStr=QR(t,n),r.__pictorialSymbolMeta=n,r}function JR(t,e,n,i){// Not show text when animating
var r=i.__pictorialBarRect;r&&r.removeTextContent();var o=[];tN(i,(function(t){o.push(t)})),i.__pictorialMainPath&&o.push(i.__pictorialMainPath),// I do not find proper remove animation for clip yet.
i.__pictorialClipPath&&(n=null),R(o,(function(t){Th(t,{scaleX:0,scaleY:0},n,e,(function(){i.parent&&i.parent.remove(i)}))})),t.setItemGraphicEl(e,null)}function QR(t,e){return[t.getItemVisual(e.dataIndex,"symbol")||"none",!!e.symbolRepeat,!!e.symbolClip].join(":")}function tN(t,e,n){// Do not use Group#eachChild, because it do not support remove.
R(t.__pictorialBundle.children(),(function(i){i!==t.__pictorialBarRect&&e.call(n,i)}))}function eN(t,e,n,i,r,o){e&&t.attr(e),// when symbolCip used, only clip path has init animation, otherwise it would be weird effect.
i.symbolClip&&!r?n&&t.attr(n):n&&nc[r?"updateProps":"initProps"](t,n,i.animationModel,i.dataIndex,o)}function nN(t,e,n){var i=n.dataIndex,r=n.itemModel,o=r.getModel("emphasis"),a=o.getModel("itemStyle").getItemStyle(),s=r.getModel(["blur","itemStyle"]).getItemStyle(),l=r.getModel(["select","itemStyle"]).getItemStyle(),u=r.getShallow("cursor"),h=o.get("focus"),c=o.get("blurScope"),p=o.get("scale");tN(t,(function(t){if(t instanceof Ss){var e=t.style;t.useStyle(A({// TODO other properties like dx, dy ?
image:e.image,x:e.x,y:e.y,width:e.width,height:e.height},n.style))}else t.useStyle(n.style);var i=t.ensureState("emphasis");i.style=a,p&&(// NOTE: Must after scale is set after updateAttr
i.scaleX=1.1*t.scaleX,i.scaleY=1.1*t.scaleY),t.ensureState("blur").style=s,t.ensureState("select").style=l,u&&(t.cursor=u),t.z2=n.z2}));var d=e.valueDim.posDesc[+(n.boundingLength>0)];ac(t.__pictorialBarRect,sc(r),{labelFetcher:e.seriesModel,labelDataIndex:i,defaultText:vS(e.seriesModel.getData(),i),inheritColor:n.style.fill,defaultOpacity:n.style.opacity,defaultOutsidePosition:d}),Bl(t,h,c,o.get("disabled"))}function iN(t){var e=Math.round(t);// Escapse accurate error
return Math.abs(t-e)<1e-4?e:Math.ceil(t)}const rN=FR;var oN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.hasSymbolVisual=!0,n.defaultSymbol="roundRect",n}return n(e,t),e.prototype.getInitialData=function(e){// Disable stack.
return e.stack=null,t.prototype.getInitialData.apply(this,arguments)},e.type="series.pictorialBar",e.dependencies=["grid"],e.defaultOption=Nc(rM.defaultOption,{symbol:"circle",symbolSize:null,symbolRotate:null,symbolPosition:null,symbolOffset:null,symbolMargin:null,symbolRepeat:!1,symbolRepeatDirection:"end",symbolClip:!1,symbolBoundingData:null,symbolPatternSize:400,barGap:"-100%",// z can be set in data item, which is z2 actually.
// Disable progressive
progressive:0,emphasis:{// By default pictorialBar do not hover scale. Hover scale is not suitable
// for the case that both has foreground and background.
scale:!1},select:{itemStyle:{borderColor:"#212121"}}}),e}(rM);const aN=oN;var sN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._layers=[],n}return n(e,t),e.prototype.render=function(t,e,n){var i=t.getData(),r=this,o=this.group,a=t.getLayerSeries(),s=i.getLayout("layoutInfo"),l=s.rect,u=s.boundaryGap;function h(t){return t.name}o.x=0,o.y=l.y+u[0];var c=new Um(this._layersSeries||[],a,h,h),p=[];function d(e,n,s){var l=r._layers;if("remove"!==e){for(var u,h,c=[],d=[],f=a[n].indices,g=0;g<f.length;g++){var y=i.getItemLayout(f[g]),v=y.x,m=y.y0,x=y.y;c.push(v,m),d.push(v,m+x),u=i.getItemVisual(f[g],"style")}var _=i.getItemLayout(f[0]),b=t.getModel("label").get("margin"),w=t.getModel("emphasis");if("add"===e){var S=p[n]=new Lr;h=new ES({shape:{points:c,stackedOnPoints:d,smooth:.4,stackedOnSmooth:.4,smoothConstraint:!1},z2:0}),S.add(h),o.add(S),t.isAnimationEnabled()&&h.setClipPath(function(t,e,n){var i=new Ls({shape:{x:t.x-10,y:t.y-10,width:0,height:t.height+20}});return Mh(i,{shape:{x:t.x-50,width:t.width+100,height:t.height+20}},e,n),i}(h.getBoundingRect(),t,(function(){h.removeClipPath()})))}else S=l[s],h=S.childAt(0),o.add(S),p[n]=S,Sh(h,{shape:{points:c,stackedOnPoints:d}},t),Ah(h);ac(h,sc(t),{labelDataIndex:f[g-1],defaultText:i.getName(f[g-1]),inheritColor:u.fill},{normal:{verticalAlign:"middle"}}),h.setTextConfig({position:null,local:!0});var M=h.getTextContent();// TODO More label position options.
M&&(M.x=_.x-b,M.y=_.y0+_.y/2),h.useStyle(u),i.setItemGraphicEl(n,h),Hl(h,t),Bl(h,w.get("focus"),w.get("blurScope"),w.get("disabled"))}else o.remove(l[n])}c.add(B(d,this,"add")).update(B(d,this,"update")).remove(B(d,this,"remove")).execute(),this._layersSeries=a,this._layers=p},e.type="themeRiver",e}(qg);const lN=sN;var uN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * @override
               */return n(e,t),e.prototype.init=function(e){// eslint-disable-next-line
t.prototype.init.apply(this,arguments),// Put this function here is for the sake of consistency of code style.
// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendVisualProvider=new jM(B(this.getData,this),B(this.getRawData,this))},
/**
               * If there is no value of a certain point in the time for some event,set it value to 0.
               *
               * @param {Array} data  initial data in the option
               * @return {Array}
               */
e.prototype.fixData=function(t){var e=t.length,n={},i=Ao(t,(function(t){return n.hasOwnProperty(t[0]+"")||(n[t[0]+""]=-1),t[2]})),r=[];
/**
                 * Make sure every layer data get the same keys.
                 * The value index tells which layer has visited.
                 * {
                 *  2014/01/01: -1
                 * }
                 */i.buckets.each((function(t,e){r.push({name:e,dataList:t})}));for(var o=r.length,a=0;a<o;++a){for(var s=r[a].name,l=0;l<r[a].dataList.length;++l){var u=r[a].dataList[l][0]+"";n[u]=a}for(var u in n)n.hasOwnProperty(u)&&n[u]!==a&&(n[u]=a,t[e]=[u,0,s],e++)}return t},
/**
               * @override
               * @param  option  the initial option that user gave
               * @param  ecModel  the model object for themeRiver option
               */
e.prototype.getInitialData=function(t,e){for(var n=this.getReferringComponents("singleAxis",Io).models[0].get("type"),i=z(t.data,(function(t){return void 0!==t[2]})),r=this.fixData(i||[]),o=[],a=this.nameMap=ct(),s=0,l=0;l<r.length;++l)o.push(r[l][2]),a.get(r[l][2])||(a.set(r[l][2],s),s++);var u=mx(r,{coordDimensions:["single"],dimensionsDefine:[{name:"time",type:qm(n)},{name:"value",type:"float"},{name:"name",type:"ordinal"}],encodeDefine:{single:0,value:1,itemName:2}}).dimensions,h=new vx(u,this);return h.initData(r),h},
/**
               * The raw data is divided into multiple layers and each layer
               *     has same name.
               */
e.prototype.getLayerSeries=function(){for(var t=this.getData(),e=t.count(),n=[],i=0;i<e;++i)n[i]=i;var r=t.mapDimension("single"),o=Ao(n,(function(e){return t.get("name",e)})),a=[];// data group by name
return o.buckets.each((function(e,n){e.sort((function(e,n){return t.get(r,e)-t.get(r,n)})),a.push({name:n,indices:e})})),a},
/**
               * Get data indices for show tooltip content
               */
e.prototype.getAxisTooltipData=function(t,e,n){G(t)||(t=t?[t]:[]);for(var i,r=this.getData(),o=this.getLayerSeries(),a=[],s=o.length,l=0;l<s;++l){for(var u=Number.MAX_VALUE,h=-1,c=o[l].indices.length,p=0;p<c;++p){var d=r.get(t[0],o[l].indices[p]),f=Math.abs(d-e);f<=u&&(i=d,u=f,h=o[l].indices[p])}a.push(h)}return{dataIndices:a,nestestValue:i}},e.prototype.formatTooltip=function(t,e,n){var i=this.getData();return dg("nameValue",{name:i.getName(t),value:i.get(i.mapDimension("value"),t)})},e.type="series.themeRiver",e.dependencies=["singleAxis"],e.defaultOption={// zlevel: 0,
z:2,colorBy:"data",coordinateSystem:"singleAxis",// gap in axis's orthogonal orientation
boundaryGap:["10%","10%"],// legendHoverLink: true,
singleAxisIndex:0,animationEasing:"linear",label:{margin:4,show:!0,position:"left",fontSize:11},emphasis:{label:{show:!0}}},e}(zg);const hN=uN;function cN(t,e){t.eachSeriesByType("themeRiver",(function(t){var e=t.getData(),n=t.coordinateSystem,i={},r=n.getRect();i.rect=r;var o=t.get("boundaryGap"),a=n.getAxis();i.boundaryGap=o,"horizontal"===a.orient?(o[0]=Vr(o[0],r.height),o[1]=Vr(o[1],r.height),pN(e,t,r.height-o[0]-o[1])):(o[0]=Vr(o[0],r.width),o[1]=Vr(o[1],r.width),pN(e,t,r.width-o[0]-o[1])),e.setLayout("layoutInfo",i)}))}
/**
             * The layout information about themeriver
             *
             * @param data  data in the series
             * @param seriesModel  the model object of themeRiver series
             * @param height  value used to compute every series height
             */function pN(t,e,n){if(t.count())for(var i,r=e.coordinateSystem,o=e.getLayerSeries(),a=t.mapDimension("single"),s=t.mapDimension("value"),l=N(o,(function(e){return N(e.indices,(function(e){var n=r.dataToPoint(t.get(a,e));return n[1]=t.get(s,e),n}))})),u=
/**
             * Compute the baseLine of the rawdata
             * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
             *
             * @param  data  the points in each layer
             */
function(t){for(var e=t.length,n=t[0].length,i=[],r=[],o=0,a=0;a<n;++a){for(var s=0,l=0;l<e;++l)s+=t[l][a][1];s>o&&(o=s),i.push(s)}for(var u=0;u<n;++u)r[u]=(o-i[u])/2;o=0;for(var h=0;h<n;++h){var c=i[h]+r[h];c>o&&(o=c)}return{y0:r,max:o}}(l),h=u.y0,c=n/u.max,p=o.length,d=o[0].indices.length,f=0// the data in each layer are organized into a series.
;f<d;++f){i=h[f]*c,t.setItemLayout(o[0].indices[f],{layerIndex:0,x:l[0][f][0],y0:i,y:l[0][f][1]*c});for(var g=1;g<p;++g)i+=l[g-1][f][1]*c,t.setItemLayout(o[g].indices[f],{layerIndex:g,x:l[g][f][0],y0:i,y:l[g][f][1]*c})}}var dN=/** @class */function(t){function e(e,n,i,r){var o=t.call(this)||this;o.z2=2,o.textConfig={inside:!0},js(o).seriesIndex=n.seriesIndex;var a=new Zs({z2:4,silent:e.getModel().get(["label","silent"])});return o.setTextContent(a),o.updateData(!0,e,n,i,r),o}return n(e,t),e.prototype.updateData=function(t,e,// state: 'emphasis' | 'normal' | 'highlight' | 'downplay',
n,i,r){this.node=e,e.piece=this,n=n||this._seriesModel,i=i||this._ecModel;var o=this;js(o).dataIndex=e.dataIndex;var a=e.getModel(),s=a.getModel("emphasis"),l=e.getLayout(),u=A({},l);u.label=null;var h=e.getVisual("style");h.lineJoin="bevel";var c=e.getVisual("decal");c&&(h.decal=Pv(c,r));var p=WM(a.getModel("itemStyle"),u,!0);A(u,p),R(tl,(function(t){var e=o.ensureState(t),n=a.getModel([t,"itemStyle"]);e.style=n.getItemStyle();// border radius
var i=WM(n,u);i&&(e.shape=i)})),t?(o.setShape(u),o.shape.r=l.r0,Sh(o,{shape:{r:l.r}},n,e.dataIndex)):(// Disable animation for gradient since no interpolation method
// is supported for gradient
Sh(o,{shape:u},n),Ah(o)),o.useStyle(h),this._updateLabel(n);var d=a.getShallow("cursor");d&&o.attr("cursor",d),this._seriesModel=n||this._seriesModel,this._ecModel=i||this._ecModel;var f=s.get("focus");Bl(this,"ancestor"===f?e.getAncestorsIndices():"descendant"===f?e.getDescendantIndices():f,s.get("blurScope"),s.get("disabled"))},e.prototype._updateLabel=function(t){var e=this,n=this.node.getModel(),i=n.getModel("label"),r=this.node.getLayout(),o=r.endAngle-r.startAngle,a=(r.startAngle+r.endAngle)/2,s=Math.cos(a),l=Math.sin(a),u=this,h=u.getTextContent(),c=this.node.dataIndex,p=i.get("minAngle")/180*Math.PI,d=i.get("show")&&!(null!=p&&Math.abs(o)<p);function f(t,e){var n=t.get(e);return null==n?i.get(e):n}h.ignore=!d,// TODO use setLabelStyle
R(el,(function(i){var p="normal"===i?n.getModel("label"):n.getModel([i,"label"]),d="normal"===i,g=d?h:h.ensureState(i),y=t.getFormattedLabel(c,i);d&&(y=y||e.node.name),g.style=lc(p,{},null,"normal"!==i,!0),y&&(g.style.text=y);// Not displaying text when angle is too small
var v=p.get("show");null==v||d||(g.ignore=!v);var m,x=f(p,"position"),_=d?u:u.states[i],b=_.style.fill;_.textConfig={outsideFill:"inherit"===p.get("color")?b:null,inside:"outside"!==x};var w=f(p,"distance")||0,S=f(p,"align");"outside"===x?(m=r.r+w,S=a>Math.PI/2?"right":"left"):S&&"center"!==S?"left"===S?(m=r.r0+w,a>Math.PI/2&&(S="right")):"right"===S&&(m=r.r-w,a>Math.PI/2&&(S="left")):(// Put label in the center if it's a circle
m=o===2*Math.PI&&0===r.r0?0:(r.r+r.r0)/2,S="center"),g.style.align=S,g.style.verticalAlign=f(p,"verticalAlign")||"middle",g.x=m*s+r.cx,g.y=m*l+r.cy;var M=f(p,"rotate"),I=0;"radial"===M?(I=-a)<-Math.PI/2&&(I+=Math.PI):"tangential"===M?(I=Math.PI/2-a)>Math.PI/2?I-=Math.PI:I<-Math.PI/2&&(I+=Math.PI):X(M)&&(I=M*Math.PI/180),g.rotation=I})),h.dirtyStyle()},e}(Nu);const fN=dN;var gN="sunburstRootToNode",yN="sunburstHighlight",vN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n,// @ts-ignore
i){var r=this;this.seriesModel=t,this.api=n,this.ecModel=e;var o=t.getData(),a=o.tree.root,s=t.getViewRoot(),l=this.group,u=t.get("renderLabelForZeroData"),h=[];s.eachNode((function(t){h.push(t)}));var c=this._oldChildren||[];!function(i,r){function s(t){return t.getId()}function h(s,h){!function(i,r){if(u||!i||i.getValue()||(// Not render data with value 0
i=null),i!==a&&r!==a)if(r&&r.piece)i?(// Update
r.piece.updateData(!1,i,t,e,n),// For tooltip
o.setItemGraphicEl(i.dataIndex,r.piece)):(// Remove
h=r)&&h.piece&&(l.remove(h.piece),h.piece=null);else if(i){// Add
var s=new fN(i,t,e,n);l.add(s),// For tooltip
o.setItemGraphicEl(i.dataIndex,s)}var h}(null==s?null:i[s],null==h?null:r[h])}0===i.length&&0===r.length||new Um(r,i,s,s).add(h).update(h).remove(F(h,null)).execute()}(h,c),function(i,o){o.depth>0?(// Render
r.virtualPiece?// Update
r.virtualPiece.updateData(!1,i,t,e,n):(// Add
r.virtualPiece=new fN(i,t,e,n),l.add(r.virtualPiece)),// TODO event scope
o.piece.off("click"),r.virtualPiece.on("click",(function(t){r._rootToNode(o.parentNode)}))):r.virtualPiece&&(// Remove
l.remove(r.virtualPiece),r.virtualPiece=null)}(a,s),this._initEvents(),this._oldChildren=h},
/**
               * @private
               */
e.prototype._initEvents=function(){var t=this;this.group.off("click"),this.group.on("click",(function(e){var n=!1;t.seriesModel.getViewRoot().eachNode((function(i){if(!n&&i.piece&&i.piece===e.target){var r=i.getModel().get("nodeClick");if("rootToNode"===r)t._rootToNode(i);else if("link"===r){var o=i.getModel(),a=o.get("link");a&&Dp(a,o.get("target",!0)||"_blank")}n=!0}}))}))},
/**
               * @private
               */
e.prototype._rootToNode=function(t){t!==this.seriesModel.getViewRoot()&&this.api.dispatchAction({type:gN,from:this.uid,seriesId:this.seriesModel.id,targetNode:t})},
/**
               * @implement
               */
e.prototype.containPoint=function(t,e){var n=e.getData().getItemLayout(0);if(n){var i=t[0]-n.cx,r=t[1]-n.cy,o=Math.sqrt(i*i+r*r);return o<=n.r&&o>=n.r0}},e.type="sunburst",e}(qg);const mN=vN;var xN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.ignoreStyleOnData=!0,n}return n(e,t),e.prototype.getInitialData=function(t,e){// Create a virtual root.
var n={name:t.name,children:t.data};_N(n);var i=this._levelModels=N(t.levels||[],(function(t){return new Pc(t,this,e)}),this),r=FD.createTree(n,this,(function(t){t.wrapMethod("getItemModel",(function(t,e){var n=r.getNodeByDataIndex(e),o=i[n.depth];return o&&(t.parentModel=o),t}))}));// Make sure always a new tree is created when setOption,
// in TreemapView, we check whether oldTree === newTree
// to choose mappings approach among old shapes and new shapes.
return r.data},e.prototype.optionUpdated=function(){this.resetViewRoot()},
/*
               * @override
               */
e.prototype.getDataParams=function(e){var n=t.prototype.getDataParams.apply(this,arguments),i=this.getData().tree.getNodeByDataIndex(e);return n.treePathInfo=YD(i,this),n},e.prototype.getLevelModel=function(t){return this._levelModels&&this._levelModels[t.depth]},e.prototype.getViewRoot=function(){return this._viewRoot},e.prototype.resetViewRoot=function(t){t?this._viewRoot=t:t=this._viewRoot;var e=this.getRawData().tree.root;t&&(t===e||e.contains(t))||(this._viewRoot=e)},e.prototype.enableAriaDecal=function(){$D(this)},e.type="series.sunburst",e.defaultOption={// zlevel: 0,
z:2,// 
center:["50%","50%"],radius:[0,"75%"],// 
clockwise:!0,startAngle:90,// 0
minAngle:0,// If still show when all data zero.
stillShowZeroSum:!0,// 'rootToNode', 'link', or false
nodeClick:"rootToNode",renderLabelForZeroData:!1,label:{// could be: 'radial', 'tangential', or 'none'
rotate:"radial",show:!0,opacity:1,// 'left' is for inner side of inside, and 'right' is for outer
// side for inside
align:"center",position:"inside",distance:5,silent:!0},itemStyle:{borderWidth:1,borderColor:"white",borderType:"solid",shadowBlur:0,shadowColor:"rgba(0, 0, 0, 0.2)",shadowOffsetX:0,shadowOffsetY:0,opacity:1},emphasis:{focus:"descendant"},blur:{itemStyle:{opacity:.2},label:{opacity:.1}},// Animation type can be expansion, scale.
animationType:"expansion",animationDuration:1e3,animationDurationUpdate:500,data:[],
/**
                 * Sort order.
                 *
                 * Valid values: 'desc', 'asc', null, or callback function.
                 * 'desc' and 'asc' for descend and ascendant order;
                 * null for not sorting;
                 * example of callback function:
                 * function(nodeA, nodeB) {
                 *     return nodeA.getValue() - nodeB.getValue();
                 * }
                 */
sort:"desc"},e}(zg);function _N(t){// Postorder travel tree.
// If value of none-leaf node is not set,
// calculate it by suming up the value of all children.
var e=0;R(t.children,(function(t){_N(t);var n=t.value;// TODO First value of array must be a number
G(n)&&(n=n[0]),e+=n}));var n=t.value;G(n)&&(n=n[0]),(null==n||isNaN(n))&&(n=e),// Value should not less than 0.
n<0&&(n=0),G(t.value)?t.value[0]=n:t.value=n}const bN=xN;var wN=Math.PI/180;function SN(t,e,n){e.eachSeriesByType(t,(function(t){var e=t.get("center"),i=t.get("radius");G(i)||(i=[0,i]),G(e)||(e=[e,e]);var r=n.getWidth(),o=n.getHeight(),a=Math.min(r,o),s=Vr(e[0],r),l=Vr(e[1],o),u=Vr(i[0],a/2),h=Vr(i[1],a/2),c=-t.get("startAngle")*wN,p=t.get("minAngle")*wN,d=t.getData().tree.root,f=t.getViewRoot(),g=f.depth,y=t.get("sort");null!=y&&MN(f,y);var v=0;R(f.children,(function(t){!isNaN(t.getValue())&&v++}));var m=f.getValue(),x=Math.PI/(m||v)*2,_=f.depth>0,b=f.height-(_?-1:1),w=(h-u)/(b||1),S=t.get("clockwise"),M=t.get("stillShowZeroSum"),I=S?1:-1,T=function(e,n){if(e){var i=n;// Render self
if(e!==d){// Tree node is virtual, so it doesn't need to be drawn
var r=e.getValue(),o=0===m&&M?x:r*x;o<p&&(o=p),// else {
//     valueSumLargerThanMinAngle += value;
// }
i=n+I*o;var h=e.depth-g-(_?-1:1),c=u+w*h,f=u+w*(h+1),y=t.getLevelModel(e);if(y){var v=y.get("r0",!0),b=y.get("r",!0),C=y.get("radius",!0);null!=C&&(v=C[0],b=C[1]),null!=v&&(c=Vr(v,a/2)),null!=b&&(f=Vr(b,a/2))}e.setLayout({angle:o,startAngle:n,endAngle:i,clockwise:S,cx:s,cy:l,r0:c,r:f})}// Render children
if(e.children&&e.children.length){// currentAngle = startAngle;
var D=0;R(e.children,(function(t){D+=T(t,n+D)}))}return i-n}};// Sum may be 0
// Virtual root node for roll up
if(_){var C=u,D=u+w,A=2*Math.PI;d.setLayout({angle:A,startAngle:c,endAngle:c+A,clockwise:S,cx:s,cy:l,r0:C,r:D})}T(f,c)}))}
/**
             * Init node children by order and update visual
             */function MN(t,e){var n=t.children||[];t.children=
/**
             * Sort children nodes
             *
             * @param {TreeNode[]}               children children of node to be sorted
             * @param {string | function | null} sort sort method
             *                                   See SunburstSeries.js for details.
             */
function(t,e){if(W(e)){var n=N(t,(function(t,e){var n=t.getValue();return{params:{depth:t.depth,height:t.height,dataIndex:t.dataIndex,getValue:function(){return n}},index:e}}));return n.sort((function(t,n){return e(t.params,n.params)})),N(n,(function(e){return t[e.index]}))}var i="asc"===e;return t.sort((function(t,e){var n=(t.getValue()-e.getValue())*(i?1:-1);return 0===n?(t.dataIndex-e.dataIndex)*(i?-1:1):n}))}(n,e),// Init children recursively
n.length&&R(t.children,(function(t){MN(t,e)}))}function IN(t){var e={};// Default color strategy
t.eachSeriesByType("sunburst",(function(t){var n=t.getData(),i=n.tree;i.eachNode((function(r){var o=r.getModel().getModel("itemStyle").getItemStyle();o.fill||(o.fill=function(t,n,i){for(// Choose color from palette based on the first level.
var r=t;r&&r.depth>1;)r=r.parentNode;var o=n.getColorFromPalette(r.name||r.dataIndex+"",e);return t.depth>1&&H(o)&&(// Lighter on the deeper level.
o=Xn(o,(t.depth-1)/(i-1)*.5)),o}(r,t,i.root.height)),A(n.ensureUniqueItemVisual(r.dataIndex,"style"),o)}))}))}// `visual('color') visual('borderColor')` is supported.
var TN={color:"fill",borderColor:"stroke"},CN={symbol:1,symbolSize:1,symbolKeepAspect:1,legendIcon:1,visualMeta:1,liftZ:1,decal:1},DN=bo(),AN=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.optionUpdated=function(){this.currentZLevel=this.get("zlevel",!0),this.currentZ=this.get("z",!0)},e.prototype.getInitialData=function(t,e){return Cx(null,this)},e.prototype.getDataParams=function(e,n,i){var r=t.prototype.getDataParams.call(this,e,n);return i&&(r.info=DN(i).info),r},e.type="series.custom",e.dependencies=["grid","polar","geo","singleAxis","calendar"],e.defaultOption={coordinateSystem:"cartesian2d",// zlevel: 0,
z:2,legendHoverLink:!0,// Custom series will not clip by default.
// Some case will use custom series to draw label
// For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
clip:!1},e}(zg);const kN=AN;function LN(t,e){// dataItem is necessary in log axis.
return e=e||[0,0],N(["x","y"],(function(n,i){var r=this.getAxis(n),o=e[i],a=t[i]/2;return"category"===r.type?r.getBandWidth():Math.abs(r.dataToCoord(o-a)-r.dataToCoord(o+a))}),this)}function PN(t,e){return e=e||[0,0],N([0,1],(function(n){var i=e[n],r=t[n]/2,o=[],a=[];return o[n]=i-r,a[n]=i+r,o[1-n]=a[1-n]=e[1-n],Math.abs(this.dataToPoint(o)[n]-this.dataToPoint(a)[n])}),this)}function ON(t,e){// dataItem is necessary in log axis.
var n=this.getAxis(),i=e instanceof Array?e[0]:e,r=(t instanceof Array?t[0]:t)/2;return"category"===n.type?n.getBandWidth():Math.abs(n.dataToCoord(i-r)-n.dataToCoord(i+r))}function RN(t,e){// dataItem is necessary in log axis.
return e=e||[0,0],N(["Radius","Angle"],(function(n,i){var r=this["get"+n+"Axis"](),o=e[i],a=t[i]/2,s="category"===r.type?r.getBandWidth():Math.abs(r.dataToCoord(o-a)-r.dataToCoord(o+a));// TODO: TYPE Check Angle Axis
return"Angle"===n&&(s=s*Math.PI/180),s}),this)}
/**
             * Whether need to call `convertEC4CompatibleStyle`.
             */
function NN(t,e,n,i){// Since echarts5, `RectText` is separated from its host element and style.text
// does not exist any more. The compat work brings some extra burden on performance.
// So we provide:
// `legacy: true` force make compat.
// `legacy: false`, force do not compat.
// `legacy` not set: auto detect whether legacy.
//     But in this case we do not compat (difficult to detect and rare case):
//     Becuse custom series and graphic component support "merge", users may firstly
//     only set `textStrokeWidth` style or secondly only set `text`.
return t&&(t.legacy||!1!==t.legacy&&!n&&!i&&"tspan"!==e&&("text"===e||gt(t,"text")))}
/**
             * `EC4CompatibleStyle` is style that might be in echarts4 format or echarts5 format.
             * @param hostStyle The properties might be modified.
             * @return If be text el, `textContentStyle` and `textConfig` will not be returned.
             *         Otherwise a `textContentStyle` and `textConfig` will be created, whose props area
             *         retried from the `hostStyle`.
             */function EN(t,e,n){var i,r,o,a=t;if("text"===e)o=a;else{o={},gt(a,"text")&&(o.text=a.text),gt(a,"rich")&&(o.rich=a.rich),gt(a,"textFill")&&(o.fill=a.textFill),gt(a,"textStroke")&&(o.stroke=a.textStroke),gt(a,"fontFamily")&&(o.fontFamily=a.fontFamily),gt(a,"fontSize")&&(o.fontSize=a.fontSize),gt(a,"fontStyle")&&(o.fontStyle=a.fontStyle),gt(a,"fontWeight")&&(o.fontWeight=a.fontWeight),r={type:"text",style:o,// ec4 does not support rectText trigger.
// And when text position is different in normal and emphasis
// => hover text trigger emphasis;
// => text position changed, leave mouse pointer immediately;
// That might cause incorrect state.
silent:!0},i={};var s=gt(a,"textPosition");n?i.position=s?a.textPosition:"inside":s&&(i.position=a.textPosition),gt(a,"textPosition")&&(i.position=a.textPosition),gt(a,"textOffset")&&(i.offset=a.textOffset),gt(a,"textRotation")&&(i.rotation=a.textRotation),gt(a,"textDistance")&&(i.distance=a.textDistance)}return zN(o,t),R(o.rich,(function(t){zN(t,t)})),{textConfig:i,textContent:r}}
/**
             * The result will be set to `out`.
             */function zN(t,e){e&&(// (1) For simplicity, make textXXX properties (deprecated since ec5) has
// higher priority. For example, consider in ec4 `borderColor: 5, textBorderColor: 10`
// on a rect means `borderColor: 4` on the rect and `borderColor: 10` on an attached
// richText in ec5.
// (2) `out === richItem` if and only if `out` is text el or rich item.
// So we can overwrite existing props in `out` since textXXX has higher priority.
e.font=e.textFont||e.font,gt(e,"textStrokeWidth")&&(t.lineWidth=e.textStrokeWidth),gt(e,"textAlign")&&(t.align=e.textAlign),gt(e,"textVerticalAlign")&&(t.verticalAlign=e.textVerticalAlign),gt(e,"textLineHeight")&&(t.lineHeight=e.textLineHeight),gt(e,"textWidth")&&(t.width=e.textWidth),gt(e,"textHeight")&&(t.height=e.textHeight),gt(e,"textBackgroundColor")&&(t.backgroundColor=e.textBackgroundColor),gt(e,"textPadding")&&(t.padding=e.textPadding),gt(e,"textBorderColor")&&(t.borderColor=e.textBorderColor),gt(e,"textBorderWidth")&&(t.borderWidth=e.textBorderWidth),gt(e,"textBorderRadius")&&(t.borderRadius=e.textBorderRadius),gt(e,"textBoxShadowColor")&&(t.shadowColor=e.textBoxShadowColor),gt(e,"textBoxShadowBlur")&&(t.shadowBlur=e.textBoxShadowBlur),gt(e,"textBoxShadowOffsetX")&&(t.shadowOffsetX=e.textBoxShadowOffsetX),gt(e,"textBoxShadowOffsetY")&&(t.shadowOffsetY=e.textBoxShadowOffsetY))}
/**
             * Convert to pure echarts4 format style.
             * `itemStyle` will be modified, added with ec4 style properties from
             * `textStyle` and `textConfig`.
             *
             * [Caveat]: For simplicity, `insideRollback` in ec4 does not compat, where
             * `styleEmphasis: {textFill: 'red'}` will remove the normal auto added stroke.
             */function VN(t,e,n){var i=t;// See `custom.ts`, a trick to set extra `textPosition` firstly.
i.textPosition=i.textPosition||n.position||"inside",null!=n.offset&&(i.textOffset=n.offset),null!=n.rotation&&(i.textRotation=n.rotation),null!=n.distance&&(i.textDistance=n.distance);var r=i.textPosition.indexOf("inside")>=0,o=t.fill||"#000";BN(i,e);var a=null==i.textFill;return r?a&&(i.textFill=n.insideFill||"#fff",!i.textStroke&&n.insideStroke&&(i.textStroke=n.insideStroke),!i.textStroke&&(i.textStroke=o),null==i.textStrokeWidth&&(i.textStrokeWidth=2)):(a&&(i.textFill=t.fill||n.outsideFill||"#000"),!i.textStroke&&n.outsideStroke&&(i.textStroke=n.outsideStroke)),i.text=e.text,i.rich=e.rich,R(e.rich,(function(t){BN(t,t)})),i}function BN(t,e){e&&(gt(e,"fill")&&(t.textFill=e.fill),gt(e,"stroke")&&(t.textStroke=e.fill),gt(e,"lineWidth")&&(t.textStrokeWidth=e.lineWidth),gt(e,"font")&&(t.font=e.font),gt(e,"fontStyle")&&(t.fontStyle=e.fontStyle),gt(e,"fontWeight")&&(t.fontWeight=e.fontWeight),gt(e,"fontSize")&&(t.fontSize=e.fontSize),gt(e,"fontFamily")&&(t.fontFamily=e.fontFamily),gt(e,"align")&&(t.textAlign=e.align),gt(e,"verticalAlign")&&(t.textVerticalAlign=e.verticalAlign),gt(e,"lineHeight")&&(t.textLineHeight=e.lineHeight),gt(e,"width")&&(t.textWidth=e.width),gt(e,"height")&&(t.textHeight=e.height),gt(e,"backgroundColor")&&(t.textBackgroundColor=e.backgroundColor),gt(e,"padding")&&(t.textPadding=e.padding),gt(e,"borderColor")&&(t.textBorderColor=e.borderColor),gt(e,"borderWidth")&&(t.textBorderWidth=e.borderWidth),gt(e,"borderRadius")&&(t.textBorderRadius=e.borderRadius),gt(e,"shadowColor")&&(t.textBoxShadowColor=e.shadowColor),gt(e,"shadowBlur")&&(t.textBoxShadowBlur=e.shadowBlur),gt(e,"shadowOffsetX")&&(t.textBoxShadowOffsetX=e.shadowOffsetX),gt(e,"shadowOffsetY")&&(t.textBoxShadowOffsetY=e.shadowOffsetY),gt(e,"textShadowColor")&&(t.textShadowColor=e.textShadowColor),gt(e,"textShadowBlur")&&(t.textShadowBlur=e.textShadowBlur),gt(e,"textShadowOffsetX")&&(t.textShadowOffsetX=e.textShadowOffsetX),gt(e,"textShadowOffsetY")&&(t.textShadowOffsetY=e.textShadowOffsetY))}var FN={position:["x","y"],scale:["scaleX","scaleY"],origin:["originX","originY"]},GN=V(FN);E(lr,(function(t,e){return t[e]=1,t}),{}),lr.join(", ");// '' means root
var WN=["","style","shape","extra"],HN=bo();function YN(t,e,n,i,r){var o=t+"Animation",a=bh(t,i,r)||{},s=HN(e).userDuring;// Only set when duration is > 0 and it's need to be animated.
return a.duration>0&&(// For simplicity, if during not specified, the previous during will not work any more.
a.during=s?B($N,{el:e,userDuring:s}):null,a.setToFinal=!0,a.scope=t),A(a,n[o]),a}function XN(t,e,n,i){var r=(i=i||{}).dataIndex,o=i.isInit,a=i.clearStyle,s=n.isAnimationEnabled(),l=HN(t),u=e.style;l.userDuring=e.during;var h={},c={};if(function(t,e,n){for(var i=0;i<GN.length;i++){var r=GN[i],o=FN[r],a=e[r];a&&(n[o[0]]=a[0],n[o[1]]=a[1])}for(i=0;i<lr.length;i++){var s=lr[i];null!=e[s]&&(n[s]=e[s])}}(0,e,c),QN("shape",e,c),QN("extra",e,c),!o&&s&&(function(t,e,n){for(var i=e.transition,r=jN(i)?lr:lo(i||[]),o=0;o<r.length;o++){var a=r[o];if("style"!==a&&"shape"!==a&&"extra"!==a){var s=t[a];n[a]=s}}}(t,e,h),JN("shape",t,e,h),JN("extra",t,e,h),function(t,e,n,i){if(n){var r,o=t.style;if(o){var a=n.transition,s=e.transition;if(a&&!jN(a)){var l=lo(a);!r&&(r=i.style={});for(var u=0;u<l.length;u++){var h=o[f=l[u]];// Do not clone, see `checkNonStyleTansitionRefer`.
r[f]=h}}else if(t.getAnimationStyleProps&&(jN(s)||jN(a)||L(s,"style")>=0)){var c=t.getAnimationStyleProps(),p=c?c.style:null;if(p){!r&&(r=i.style={});var d=V(n);for(u=0;u<d.length;u++){var f;p[f=d[u]]&&(h=o[f],r[f]=h)}}}}}}(t,e,u,h)),c.style=u,function(t,// Can be null/undefined
e,n){var i=e.style;if(!t.isGroup&&i){if(n){t.useStyle({});for(// When style object changed, how to trade the existing animation?
// It is probably complicated and not needed to cover all the cases.
// But still need consider the case:
// (1) When using init animation on `style.opacity`, and before the animation
//     ended users triggers an update by mousewhel. At that time the init
//     animation should better be continued rather than terminated.
//     So after `useStyle` called, we should change the animation target manually
//     to continue the effect of the init animation.
// (2) PENDING: If the previous animation targeted at a `val1`, and currently we need
//     to update the value to `val2` and no animation declared, should be terminate
//     the previous animation or just modify the target of the animation?
//     Therotically That will happen not only on `style` but also on `shape` and
//     `transfrom` props. But we haven't handle this case at present yet.
// (3) PENDING: Is it proper to visit `animators` and `targetName`?
var r=t.animators,o=0;o<r.length;o++){var a=r[o];// targetName is the "topKey".
"style"===a.targetName&&a.changeTarget(t.style)}}t.setStyle(i)}e&&(// Not set style here.
e.style=null,// Set el to the final state firstly.
e&&t.attr(e),e.style=i)}(t,c,a),function(t,e){// Merge by default.
gt(e,"silent")&&(t.silent=e.silent),gt(e,"ignore")&&(t.ignore=e.ignore),t instanceof fa&&gt(e,"invisible")&&(t.invisible=e.invisible),t instanceof ys&&gt(e,"autoBatch")&&(t.autoBatch=e.autoBatch)}// Use it to avoid it be exposed to user.
(t,e),s)if(o){var p={};R(WN,(function(t){var n=t?e[t]:e;n&&n.enterFrom&&(t&&(p[t]=p[t]||{}),A(t?p[t]:p,n.enterFrom))}));var d=YN("enter",t,e,n,r);d.duration>0&&t.animateFrom(p,d)}else!function(t,e,n,i,// Can be null/undefined
r){if(r){var o=YN("update",t,e,i,n);o.duration>0&&t.animateFrom(r,o)}}(t,e,r||0,n,h);// Store leave to be used in leave transition.
UN(t,e),u?t.dirty():t.markRedraw()}function UN(t,e){for(// Try merge to previous set leaveTo
var n=HN(t).leaveToProps,i=0;i<WN.length;i++){var r=WN[i],o=r?e[r]:e;o&&o.leaveTo&&(n||(n=HN(t).leaveToProps={}),r&&(n[r]=n[r]||{}),A(r?n[r]:n,o.leaveTo))}}function ZN(t,e,n,i){if(t){var r=t.parent,o=HN(t).leaveToProps;if(o){// TODO TODO use leave after leaveAnimation in series is introduced
// TODO Data index?
var a=YN("update",t,e,n,0);a.done=function(){r.remove(t),i&&i()},t.animateTo(o,a)}else r.remove(t),i&&i()}}function jN(t){return"all"===t}var qN={},KN={// Usually other props do not need to be changed in animation during.
setTransform:function(t,e){return qN.el[t]=e,this},getTransform:function(t){return qN.el[t]},setShape:function(t,e){var n=qN.el;return(n.shape||(n.shape={}))[t]=e,n.dirtyShape&&n.dirtyShape(),this},getShape:function(t){var e=qN.el.shape;if(e)return e[t]},setStyle:function(t,e){var n=qN.el,i=n.style;return i&&(i[t]=e,n.dirtyStyle&&n.dirtyStyle()),this},getStyle:function(t){var e=qN.el.style;if(e)return e[t]},setExtra:function(t,e){return(qN.el.extra||(qN.el.extra={}))[t]=e,this},getExtra:function(t){var e=qN.el.extra;if(e)return e[t]}};function $N(){// Do not provide "percent" until some requirements come.
// Because consider thies case:
// enterFrom: {x: 100, y: 30}, transition: 'x'.
// And enter duration is different from update duration.
// Thus it might be confused about the meaning of "percent" in during callback.
var t=this,e=t.el;if(e){// If el is remove from zr by reason like legend, during still need to called,
// because el will be added back to zr and the prop value should not be incorrect.
var n=HN(e).userDuring,i=t.userDuring;// Ensured a during is only called once in each animation frame.
// If a during is called multiple times in one frame, maybe some users' calculation logic
// might be wrong (not sure whether this usage exists).
// The case of a during might be called twice can be: by default there is a animator for
// 'x', 'y' when init. Before the init animation finished, call `setOption` to start
// another animators for 'style'/'shape'/'extra'.
n===i?(qN.el=e,// Give no `this` to user in "during" calling.
i(KN)):// release
t.el=t.userDuring=null}}function JN(t,e,n,i){var r=n[t];if(r){var o,a=e[t];if(a){var s=n.transition,l=r.transition;if(l)if(!o&&(o=i[t]={}),jN(l))A(o,a);else for(var u=lo(l),h=0;h<u.length;h++){var c=a[d=u[h]];o[d]=c}else if(jN(s)||L(s,t)>=0){!o&&(o=i[t]={});var p=V(a);for(h=0;h<p.length;h++){var d;c=a[d=p[h]],tE(r[d],c)&&(o[d]=c)}}}}}function QN(t,e,n){var i=e[t];if(i)for(var r=n[t]={},o=V(i),a=0;a<o.length;a++){var s=o[a];// To avoid share one object with different element, and
// to avoid user modify the object inexpectedly, have to clone.
r[s]=_i(i[s])}}function tE(t,e){// The same as `checkNonStyleTansitionRefer`.
return O(t)?t!==e:null!=t&&isFinite(t)}var eE=bo(),nE=["percent","easing","shape","style","extra"];
/**
             * Stop previous keyframe animation and restore the attributes.
             * Avoid new keyframe animation starts with wrong internal state when the percent: 0 is not set.
             */
function iE(t){// Stop previous keyframe animation.
t.stopAnimation("keyframe"),// Restore
t.attr(eE(t))}function rE(t,e,n){if(n.isAnimationEnabled()&&e)if(G(e))R(e,(function(e){rE(t,e,n)}));else{var i=e.keyframes,r=e.duration;if(n&&null==r){// Default to use duration of config.
// NOTE: animation config from payload will be ignored because they are mainly for transitions.
var o=bh("enter",n,0);r=o&&o.duration}if(i&&r){var a=eE(t);R(WN,(function(n){var o;n&&!t[n]||(i.sort((function(t,e){return t.percent-e.percent})),R(i,(function(i){// Stop current animation.
var s=t.animators,l=n?i[n]:i;if(l){var u=V(l);if(n||(// PENDING performance?
u=z(u,(function(t){return L(nE,t)<0}))),u.length){o||((o=t.animate(n,e.loop,!0)).scope="keyframe");for(var h=0;h<s.length;h++)// Stop all other animation that is not keyframe.
s[h]!==o&&s[h].targetName===o.targetName&&s[h].stopTracks(u);n&&(a[n]=a[n]||{});var c=n?a[n]:a;R(u,(function(e){// Save original value.
c[e]=((n?t[n]:t)||{})[e]})),o.whenWithKeys(r*i.percent,l,u,i.easing)}}})),o&&o.delay(e.delay||0).duration(r).start(e.easing))}))}}}var oE="emphasis",aE="normal",sE="blur",lE="select",uE=[aE,oE,sE,lE],hE={normal:["itemStyle"],emphasis:[oE,"itemStyle"],blur:[sE,"itemStyle"],select:[lE,"itemStyle"]},cE={normal:["label"],emphasis:[oE,"label"],blur:[sE,"label"],select:[lE,"label"]},pE=["x","y"],dE={normal:{},emphasis:{},blur:{},select:{}},fE={cartesian2d:function(t){var e=t.master.getRect();return{coordSys:{// The name exposed to user is always 'cartesian2d' but not 'grid'.
type:"cartesian2d",x:e.x,y:e.y,width:e.width,height:e.height},api:{coord:function(e){// do not provide "out" param
return t.dataToPoint(e)},size:B(LN,t)}}},geo:function(t){var e=t.getBoundingRect();return{coordSys:{type:"geo",x:e.x,y:e.y,width:e.width,height:e.height,zoom:t.getZoom()},api:{coord:function(e){// do not provide "out" and noRoam param,
// Compatible with this usage:
// echarts.util.map(item.points, api.coord)
return t.dataToPoint(e)},size:B(PN,t)}}},single:function(t){var e=t.getRect();return{coordSys:{type:"singleAxis",x:e.x,y:e.y,width:e.width,height:e.height},api:{coord:function(e){// do not provide "out" param
return t.dataToPoint(e)},size:B(ON,t)}}},polar:function(t){var e=t.getRadiusAxis(),n=t.getAngleAxis(),i=e.getExtent();return i[0]>i[1]&&i.reverse(),{coordSys:{type:"polar",cx:t.cx,cy:t.cy,r:i[1],r0:i[0]},api:{coord:function(i){var r=e.dataToRadius(i[0]),o=n.dataToAngle(i[1]),a=t.coordToPoint([r,o]);return a.push(r,o*Math.PI/180),a},size:B(RN,t)}}}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */,calendar:function(t){var e=t.getRect(),n=t.getRangeInfo();return{coordSys:{type:"calendar",x:e.x,y:e.y,width:e.width,height:e.height,cellWidth:t.getCellWidth(),cellHeight:t.getCellHeight(),rangeInfo:{start:n.start,end:n.end,weeks:n.weeks,dayCount:n.allDay}},api:{coord:function(e,n){return t.dataToPoint(e,n)}}}}};function gE(t){return t instanceof ys}function yE(t){return t instanceof fa}var vE=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n,i){// Clear previously rendered progressive elements.
this._progressiveEls=null;var r=this._data,o=t.getData(),a=this.group,s=SE(t,o,e,n);r||// Previous render is incremental render or first render.
// Needs remove the incremental rendered elements.
a.removeAll(),o.diff(r).add((function(e){IE(n,null,e,s(e,i),t,a,o)})).remove((function(e){var n=r.getItemGraphicEl(e);n&&ZN(n,DN(n).option,t)})).update((function(e,l){var u=r.getItemGraphicEl(l);IE(n,u,e,s(e,i),t,a,o)})).execute();// Do clipping
var l=t.get("clip",!0)?BS(t.coordinateSystem,!1,t):null;l?a.setClipPath(l):a.removeClipPath(),this._data=o},e.prototype.incrementalPrepareRender=function(t,e,n){this.group.removeAll(),this._data=null},e.prototype.incrementalRender=function(t,e,n,i,r){var o=e.getData(),a=SE(e,o,n,i),s=this._progressiveEls=[];function l(t){t.isGroup||(t.incremental=!0,t.ensureState("emphasis").hoverLayer=!0)}for(var u=t.start;u<t.end;u++){var h=IE(null,null,u,a(u,r),e,this.group,o);h&&(h.traverse(l),s.push(h))}},e.prototype.eachRendered=function(t){ec(this._progressiveEls||this.group,t)},e.prototype.filterForExposedEvent=function(t,e,n,i){var r=e.element;if(null==r||n.name===r)return!0;// Enable to give a name on a group made by `renderItem`, and listen
// events that are triggered by its descendents.
for(;(n=n.__hostTarget||n.parent)&&n!==this.group;)if(n.name===r)return!0;return!1},e.type="custom",e}(qg);const mE=vE;function xE(t){var e,n=t.type;// Those graphic elements are not shapes. They should not be
// overwritten by users, so do them first.
if("path"===n){var i=t.shape,r=null!=i.width&&null!=i.height?{x:i.x||0,y:i.y||0,width:i.width,height:i.height}:null,o=NE(i);// Using pathRect brings convenience to users sacle svg path.
// Path is also used for icon, so layout 'center' by default.
e=Eh(o,null,r,i.layout||"center"),DN(e).customPathData=o}else if("image"===n)e=new Ss({}),DN(e).customImagePath=t.style.image;else if("text"===n)e=new Zs({});// customInnerStore(el).customText = (elOption.style as TextStyleProps).text;
else if("group"===n)e=new Lr;else{if("compoundPath"===n)throw new Error('"compoundPath" is not supported yet.');var a=Nh(n);a||ro(""),e=new a}return DN(e).customGraphicType=n,e.name=t.name,// Compat ec4: the default z2 lift is 1. If changing the number,
// some cases probably be broken: hierarchy layout along z, like circle packing,
// where emphasis only intending to modify color/border rather than lift z2.
e.z2EmphasisLift=1,e.z2SelectLift=1,e}function _E(// Can be null/undefined
t,e,n,i,r,o,a){// Stop and restore before update any other attributes.
iE(e);var s=r&&r.normal.cfg;s&&// PENDING: whether use user object directly rather than clone?
// TODO:5.0 textConfig transition animation?
e.setTextConfig(s),// Default transition ['x', 'y']
i&&null==i.transition&&(i.transition=pE);// Do some normalization on style.
var l=i&&i.style;if(l){if("text"===e.type){var u=l;// Compatible with ec4: if `textFill` or `textStroke` exists use them.
gt(u,"textFill")&&(u.fill=u.textFill),gt(u,"textStroke")&&(u.stroke=u.textStroke)}var h=void 0,c=gE(e)?l.decal:null;t&&c&&(c.dirty=!0,h=Pv(c,t)),// Always overwrite in case user specify this prop.
l.__decalPattern=h}yE(e)&&l&&(h=l.__decalPattern)&&(l.decal=h),XN(e,i,o,{dataIndex:n,isInit:a,clearStyle:!0}),rE(e,i.keyframeAnimation,o)}function bE(t,e,n,i,r){var o=e.isGroup?null:e,a=r&&r[t].cfg;// PENDING:5.0 support customize scale change and transition animation?
if(o){// By default support auto lift color when hover whether `emphasis` specified.
var s=o.ensureState(t);if(!1===i){var l=o.getState(t);l&&(l.style=null)}else// style is needed to enable default emphasis.
s.style=i||null;// If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,
// remove hover style.
// If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not
// make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.
a&&(s.textConfig=a),wl(o)}}function wE(t,e,n){var i=n===aE,r=i?e:AE(e,n),o=r?r.z2:null;null!=o&&((i?t:t.ensureState(n)).z2=o||0)}function SE(t,e,n,i){var r=t.get("renderItem"),o=t.coordinateSystem,a={};o&&(a=o.prepareCustoms?o.prepareCustoms(o):fE[o.type](o));for(var s,l,u=k({getWidth:i.getWidth,getHeight:i.getHeight,getZr:i.getZr,getDevicePixelRatio:i.getDevicePixelRatio,value:
/**
               * @public
               * @param dim by default 0.
               * @param dataIndexInside by default `currDataIndexInside`.
               */
function(t,n){return null==n&&(n=s),e.getStore().get(e.getDimensionIndex(t||0),n)}
/**
               * @public
               * @param dim by default 0.
               * @param dataIndexInside by default `currDataIndexInside`.
               */,style:
/**
               * @deprecated The original intention of `api.style` is enable to set itemStyle
               * like other series. But it is not necessary and not easy to give a strict definition
               * of what it returns. And since echarts5 it needs to be make compat work. So
               * deprecates it since echarts5.
               *
               * By default, `visual` is applied to style (to support visualMap).
               * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
               * it can be implemented as:
               * `api.style({stroke: api.visual('color'), fill: null})`;
               *
               * [Compat]: since ec5, RectText has been separated from its hosts el.
               * so `api.style()` will only return the style from `itemStyle` but not handle `label`
               * any more. But `series.label` config is never published in doc.
               * We still compat it in `api.style()`. But not encourage to use it and will still not
               * to pulish it to doc.
               * @public
               * @param dataIndexInside by default `currDataIndexInside`.
               */
function(n,i){null==i&&(i=s);var r=e.getItemVisual(i,"style"),o=r&&r.fill,a=r&&r.opacity,l=m(i,aE).getItemStyle();null!=o&&(l.fill=o),null!=a&&(l.opacity=a);var u={inheritColor:H(o)?o:"#000"},h=x(i,aE),c=lc(h,null,u,!1,!0);c.text=h.getShallow("show")?Q(t.getFormattedLabel(i,aE),vS(e,i)):null;var p=uc(h,u,!1);return b(n,l),l=VN(l,c,p),n&&_(l,n),l.legacy=!0,l}
/**
               * @deprecated The reason see `api.style()`
               * @public
               * @param dataIndexInside by default `currDataIndexInside`.
               */,ordinalRawValue:function(t,n){null==n&&(n=s),t=t||0;var i=e.getDimensionInfo(t);if(!i){var r=e.getDimensionIndex(t);return r>=0?e.getStore().get(r,n):void 0}var o=e.get(i.name,n),a=i&&i.ordinalMeta;return a?a.categories[o]:o},styleEmphasis:function(n,i){null==i&&(i=s);var r=m(i,oE).getItemStyle(),o=x(i,oE),a=lc(o,null,null,!0,!0);a.text=o.getShallow("show")?tt(t.getFormattedLabel(i,oE),t.getFormattedLabel(i,aE),vS(e,i)):null;var l=uc(o,null,!0);return b(n,r),r=VN(r,a,l),n&&_(r,n),r.legacy=!0,r},visual:
/**
               * @public
               * @param dataIndexInside by default `currDataIndexInside`.
               */
function(t,n){if(null==n&&(n=s),gt(TN,t)){var i=e.getItemVisual(n,"style");return i?i[TN[t]]:null}// Only support these visuals. Other visual might be inner tricky
// for performance (like `style`), do not expose to users.
if(gt(CN,t))return e.getItemVisual(n,t)}
/**
               * @public
               * @return If not support, return undefined.
               */,barLayout:function(t){if("cartesian2d"===o.type)return function(t){var e=[],n=t.axis,i="axis0";if("category"===n.type){for(var r=n.getBandWidth(),o=0;o<t.count;o++)e.push(k({bandWidth:r,axisKey:i,stackId:Kx+o},t));var a=e_(e),s=[];for(o=0;o<t.count;o++){var l=a[i][Kx+o];l.offsetCenter=l.offset+l.width/2,s.push(l)}return s}}(k({axis:o.getBaseAxis()},t))}
/**
               * @public
               */,currentSeriesIndices:function(){return n.getCurrentSeriesIndices()}
/**
               * @public
               * @return font string
               */,font:function(t){return fc(t,n)}},a.api||{}),h={// The life cycle of context: current round of rendering.
// The global life cycle is probably not necessary, because
// user can store global status by themselves.
context:{},seriesId:t.id,seriesName:t.name,seriesIndex:t.seriesIndex,coordSys:a.coordSys,dataInsideLength:e.count(),encode:ME(t.getData())},c={},p={},d={},f={},g=0;g<uE.length;g++){var y=uE[g];d[y]=t.getModel(hE[y]),f[y]=t.getModel(cE[y])}function v(t){return t===s?l||(l=e.getItemModel(t)):e.getItemModel(t)}function m(t,n){return e.hasItemOption?t===s?c[n]||(c[n]=v(t).getModel(hE[n])):v(t).getModel(hE[n]):d[n]}function x(t,n){return e.hasItemOption?t===s?p[n]||(p[n]=v(t).getModel(cE[n])):v(t).getModel(cE[n]):f[n]}return function(t,n){return s=t,l=null,c={},p={},r&&r(k({dataIndexInside:t,dataIndex:e.getRawIndex(t),// Can be used for optimization when zoom or roam.
actionType:n?n.type:null},h),u)};function _(t,e){for(var n in e)gt(e,n)&&(t[n]=e[n])}function b(t,e){// A trick to retrieve those props firstly, which are used to
// apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.
// (It's not reasonable but only for a degree of compat)
t&&(t.textFill&&(e.textFill=t.textFill),t.textPosition&&(e.textPosition=t.textPosition))}}function ME(t){var e={};return R(t.dimensions,(function(n){var i=t.getDimensionInfo(n);if(!i.isExtraCoord){var r=i.coordDim;(e[r]=e[r]||[])[i.coordDimIndex]=t.getDimensionIndex(n)}})),e}function IE(t,e,n,i,r,o,a){// [Rule]
// If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.
//     (It seems that violate the "merge" principle, but most of users probably intuitively
//     regard "return;" as "show nothing element whatever", so make a exception to meet the
//     most cases.)
// The rule or "merge" see [STRATEGY_MERGE].
// If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).
if(i){var s=TE(t,e,n,i,r,o);return s&&a.setItemGraphicEl(n,s),s&&Bl(s,i.focus,i.blurScope,i.emphasisDisabled),s}o.remove(e)}function TE(t,e,n,i,r,o){var a=-1,s=e;e&&CE(e,i,r)&&(// Should keep at the original index, otherwise "merge by index" will be incorrect.
a=L(o.childrenRef(),e),e=null);var l,u,h=!e,c=e;c?// FIMXE:NEXT unified clearState?
// If in some case the performance issue arised, consider
// do not clearState but update cached normal state directly.
c.clearStates():(c=xE(i),s&&(l=s,(u=c).copyTransform(l),yE(u)&&yE(l)&&(u.setStyle(l.style),u.z=l.z,u.z2=l.z2,u.zlevel=l.zlevel,u.invisible=l.invisible,u.ignore=l.ignore,gE(u)&&gE(l)&&u.setShape(l.shape)))),// Need to set morph: false explictly to disable automatically morphing.
!1===i.morph?c.disableMorphing=!0:c.disableMorphing&&(c.disableMorphing=!1),dE.normal.cfg=dE.normal.conOpt=dE.emphasis.cfg=dE.emphasis.conOpt=dE.blur.cfg=dE.blur.conOpt=dE.select.cfg=dE.select.conOpt=null,dE.isLegacy=!1,function(t,e,n,i,r,o){// Group does not support textContent temporarily until necessary.
if(!t.isGroup){// Normal must be called before emphasis, for `isLegacy` detection.
DE(n,null,o),DE(n,oE,o);// If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sense.
// So for simplicity, if "elOption hasOwnProperty of them but be null/undefined", we do not
// trade them as set to null to el.
// Especially:
// `elOption.textContent: false` means remove textContent.
// `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.
var a=o.normal.conOpt,s=o.emphasis.conOpt,l=o.blur.conOpt,u=o.select.conOpt;if(null!=a||null!=s||null!=u||null!=l){var h=t.getTextContent();if(!1===a)h&&t.removeTextContent();else{a=o.normal.conOpt=a||{type:"text"},h?// If in some case the performance issue arised, consider
// do not clearState but update cached normal state directly.
h.clearStates():(h=xE(a),t.setTextContent(h)),_E(null,h,e,a,null,i,r);for(var c=a&&a.style,p=0;p<uE.length;p++){var d=uE[p];if(d!==aE){var f=o[d].conOpt;bE(d,h,0,kE(a,f,d),null)}}c?h.dirty():h.markRedraw()}}}}(c,n,i,r,h,dE),function(t,e,n,i,r){// Based on the "merge" principle, if no clipPath provided,
// do nothing. The exists clip will be totally removed only if
// `el.clipPath` is `false`. Otherwise it will be merged/replaced.
var o=n.clipPath;if(!1===o)t&&t.getClipPath()&&t.removeClipPath();else if(o){var a=t.getClipPath();a&&CE(a,o,i)&&(a=null),a||(a=xE(o),t.setClipPath(a)),_E(null,a,e,o,null,i,r)}// If not define `clipPath` in option, do nothing unnecessary.
}(c,n,i,r,h),_E(t,c,n,i,dE,r,h),// `elOption.info` enables user to mount some info on
// elements and use them in event handlers.
// Update them only when user specified, otherwise, remain.
gt(i,"info")&&(DN(c).info=i.info);for(var p=0;p<uE.length;p++){var d=uE[p];if(d!==aE){var f=AE(i,d);bE(d,c,0,kE(i,f,d),dE)}}return function(t,e,n){// Group not support textContent and not support z yet.
if(!t.isGroup){var i=t,r=n.currentZ,o=n.currentZLevel;// Always erase.
i.z=r,i.zlevel=o;// z2 must not be null/undefined, otherwise sort error may occur.
var a=e.z2;null!=a&&(i.z2=a||0);for(var s=0;s<uE.length;s++)wE(i,e,uE[s])}}(c,i,r),"group"===i.type&&// Usage:
// (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates
//     that the existing children will not be removed, and enables the feature
//     that update some of the props of some of the children simply by construct
//     the returned children of `renderItem` like:
//     `var children = group.children = []; children[3] = {opacity: 0.5};`
// (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children
//     by child.name. But that might be lower performance.
// (3) If `elOption.$mergeChildren` is `false`, the existing children will be
//     replaced totally.
// (4) If `!elOption.children`, following the "merge" principle, nothing will
//     happen.
// (5) If `elOption.$mergeChildren` is not `false` neither `'byName'` and the
//     `el` is a group, and if any of the new child is null, it means to remove
//     the element at the same index, if exists. On the other hand, if the new
//     child is and empty object `{}`, it means to keep the element not changed.
// For implementation simpleness, do not provide a direct way to remove single
// child (otherwise the total indices of the children array have to be modified).
// User can remove a single child by setting its `ignore` to `true`.
function(t,e,n,i,r){var o=i.children,a=o?o.length:0,s=i.$mergeChildren,l="byName"===s||i.diffChildrenByName,u=!1===s;// For better performance on roam update, only enter if necessary.
if(a||l||u){if(l)return h={api:t,oldChildren:e.children()||[],newChildren:o||[],dataIndex:n,seriesModel:r,group:e},void new Um(h.oldChildren,h.newChildren,PE,PE,h).add(OE).update(OE).remove(RE).execute();var h;u&&e.removeAll();for(// Mapping children of a group simply by index, which
// might be better performance.
var c=0;c<a;c++){var p=o[c],d=e.childAt(c);p?(null==p.ignore&&(// The old child is set to be ignored if null (see comments
// below). So we need to set ignore to be false back.
p.ignore=!1),TE(t,d,n,p,r,e)):// element. But we cannot really remove the element from the group
// directly, because the element order may not be stable when this
// element is added back. So we set the element to be ignored.
d.ignore=!0}for(var f=e.childCount()-1;f>=c;f--){var g=e.childAt(f);LE(e,g,r)}}}(t,c,n,i,r),a>=0?o.replaceAt(c,a):o.add(c),c}// `el` must not be null/undefined.
function CE(t,e,n){var i,r=DN(t),o=e.type,a=e.shape,s=e.style;// Always create new if universal transition is enabled.
// Because we do transition after render. It needs to know what old element is. Replacement will loose it.
return n.isUniversalTransitionEnabled()||null!=o&&o!==r.customGraphicType||"path"===o&&(i=a)&&(gt(i,"pathData")||gt(i,"d"))&&NE(a)!==r.customPathData||"image"===o&&gt(s,"image")&&s.image!==r.customImagePath}function DE(t,e,n){var i=e?AE(t,e):t,r=e?kE(t,i,oE):t.style,o=t.type,a=i?i.textConfig:null,s=t.textContent,l=s?e?AE(s,e):s:null;if(r&&(// Because emphasis style has little info to detect legacy,
// if normal is legacy, emphasis is trade as legacy.
n.isLegacy||NN(r,o,!!a,!!l))){n.isLegacy=!0;var u=EN(r,o,!e);// Explicitly specified `textConfig` and `textContent` has higher priority than
// the ones generated by legacy style. Otherwise if users use them and `api.style`
// at the same time, they not both work and hardly to known why.
!a&&u.textConfig&&(a=u.textConfig),!l&&u.textContent&&(l=u.textContent)}if(!e&&l){var h=l;// `textContent: {type: 'text'}`, the "type" is easy to be missing. So we tolerate it.
!h.type&&(h.type="text")}var c=e?n[e]:n.normal;c.cfg=a,c.conOpt=l}function AE(t,e){return e?t?t[e]:null:t}function kE(t,e,n){var i=e&&e.style;return null==i&&n===oE&&t&&(i=t.styleEmphasis),i}function LE(t,e,n){// Do not support leave elements that are not mentioned in the latest
// `renderItem` return. Otherwise users may not have a clear and simple
// concept that how to control all of the elements.
e&&ZN(e,DN(t).option,n)}function PE(t,e){var n=t&&t.name;return null!=n?n:"e\0\0"+e}function OE(t,e){var n=this.context,i=null!=t?n.newChildren[t]:null,r=null!=e?n.oldChildren[e]:null;TE(n.api,r,n.dataIndex,i,n.seriesModel,n.group)}function RE(t){var e=this.context,n=e.oldChildren[t];n&&ZN(n,DN(n).option,e.seriesModel)}
/**
             * @return SVG Path data.
             */function NE(t){// "d" follows the SVG convention.
return t&&(t.pathData||t.d)}var EE=bo(),zE=T,VE=B,BE=/** @class */function(){function t(){this._dragging=!1,
/**
                 * In px, arbitrary value. Do not set too small,
                 * no animation is ok for most cases.
                 */
this.animationThreshold=15}
/**
               * @implement
               */return t.prototype.render=function(t,e,n,i){var r=e.get("value"),o=e.get("status");// Optimize: `render` will be called repeatly during mouse move.
// So it is power consuming if performing `render` each time,
// especially on mobile device.
if(// Bind them to `this`, not in closure, otherwise they will not
// be replaced when user calling setOption in not merge mode.
this._axisModel=t,this._axisPointerModel=e,this._api=n,i||this._lastValue!==r||this._lastStatus!==o){this._lastValue=r,this._lastStatus=o;var a=this._group,s=this._handle;if(!o||"hide"===o)// Do not clear here, for animation better.
return a&&a.hide(),void(s&&s.hide());a&&a.show(),s&&s.show();// Otherwise status is 'show'
var l={};this.makeElOption(l,r,t,e,n);// Enable change axis pointer type.
var u=l.graphicKey;u!==this._lastGraphicKey&&this.clear(n),this._lastGraphicKey=u;var h=this._moveAnimation=this.determineAnimation(t,e);if(a){var c=F(FE,e,h);this.updatePointerEl(a,l,c),this.updateLabelEl(a,l,c,e)}else a=this._group=new Lr,this.createPointerEl(a,l,t,e),this.createLabelEl(a,l,t,e),n.getZr().add(a);YE(a,e,!0),this._renderHandle(r)}},
/**
               * @implement
               */
t.prototype.remove=function(t){this.clear(t)},
/**
               * @implement
               */
t.prototype.dispose=function(t){this.clear(t)},
/**
               * @protected
               */
t.prototype.determineAnimation=function(t,e){var n=e.get("animation"),i=t.axis,r="category"===i.type,o=e.get("snap");// Value axis without snap always do not snap.
if(!o&&!r)return!1;if("auto"===n||null==n){var a=this.animationThreshold;if(r&&i.getBandWidth()>a)return!0;// It is important to auto animation when snap used. Consider if there is
// a dataZoom, animation will be disabled when too many points exist, while
// it will be enabled for better visual effect when little points exist.
if(o){var s=HI(t).seriesDataCount,l=i.getExtent();// Approximate band width
return Math.abs(l[0]-l[1])/s>a}return!1}return!0===n},
/**
               * add {pointer, label, graphicKey} to elOption
               * @protected
               */
t.prototype.makeElOption=function(t,e,n,i,r){// Shoule be implemenented by sub-class.
},
/**
               * @protected
               */
t.prototype.createPointerEl=function(t,e,n,i){var r=e.pointer;if(r){var o=EE(t).pointerEl=new nc[r.type](zE(e.pointer));t.add(o)}},
/**
               * @protected
               */
t.prototype.createLabelEl=function(t,e,n,i){if(e.label){var r=EE(t).labelEl=new Zs(zE(e.label));t.add(r),WE(r,i)}},
/**
               * @protected
               */
t.prototype.updatePointerEl=function(t,e,n){var i=EE(t).pointerEl;i&&e.pointer&&(i.setStyle(e.pointer.style),n(i,{shape:e.pointer.shape}))},
/**
               * @protected
               */
t.prototype.updateLabelEl=function(t,e,n,i){var r=EE(t).labelEl;r&&(r.setStyle(e.label.style),n(r,{// Consider text length change in vertical axis, animation should
// be used on shape, otherwise the effect will be weird.
// TODOTODO
// shape: elOption.label.shape,
x:e.label.x,y:e.label.y}),WE(r,i))},
/**
               * @private
               */
t.prototype._renderHandle=function(t){if(!this._dragging&&this.updateHandleTransform){var e,n=this._axisPointerModel,i=this._api.getZr(),r=this._handle,o=n.getModel("handle"),a=n.get("status");if(!o.get("show")||!a||"hide"===a)return r&&i.remove(r),void(this._handle=null);this._handle||(e=!0,r=this._handle=qh(o.get("icon"),{cursor:"move",draggable:!0,onmousemove:function(t){// Fot mobile devicem, prevent screen slider on the button.
re(t.event)},onmousedown:VE(this._onHandleDragMove,this,0,0),drift:VE(this._onHandleDragMove,this),ondragend:VE(this._onHandleDragEnd,this)}),i.add(r)),YE(r,n,!1),// update style
r.setStyle(o.getItemStyle(null,["color","borderColor","borderWidth","opacity","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY"]));// update position
var s=o.get("size");G(s)||(s=[s,s]),r.scaleX=s[0]/2,r.scaleY=s[1]/2,ty(this,"_doDispatchAxisPointer",o.get("throttle")||0,"fixRate"),this._moveHandleToValue(t,e)}},t.prototype._moveHandleToValue=function(t,e){FE(this._axisPointerModel,!e&&this._moveAnimation,this._handle,HE(this.getHandleTransform(t,this._axisModel,this._axisPointerModel)))},t.prototype._onHandleDragMove=function(t,e){var n=this._handle;if(n){this._dragging=!0;// Persistent for throttle.
var i=this.updateHandleTransform(HE(n),[t,e],this._axisModel,this._axisPointerModel);this._payloadInfo=i,n.stopAnimation(),n.attr(HE(i)),EE(n).lastProp=null,this._doDispatchAxisPointer()}},
/**
               * Throttled method.
               */
t.prototype._doDispatchAxisPointer=function(){if(this._handle){var t=this._payloadInfo,e=this._axisModel;this._api.dispatchAction({type:"updateAxisPointer",x:t.cursorPoint[0],y:t.cursorPoint[1],tooltipOption:t.tooltipOption,axesInfo:[{axisDim:e.axis.dim,axisIndex:e.componentIndex}]})}},t.prototype._onHandleDragEnd=function(){if(this._dragging=!1,this._handle){var t=this._axisPointerModel.get("value");// Consider snap or categroy axis, handle may be not consistent with
// axisPointer. So move handle to align the exact value position when
// drag ended.
this._moveHandleToValue(t),// For the effect: tooltip will be shown when finger holding on handle
// button, and will be hidden after finger left handle button.
this._api.dispatchAction({type:"hideTip"})}},
/**
               * @private
               */
t.prototype.clear=function(t){this._lastValue=null,this._lastStatus=null;var e=t.getZr(),n=this._group,i=this._handle;e&&n&&(this._lastGraphicKey=null,n&&e.remove(n),i&&e.remove(i),this._group=null,this._handle=null,this._payloadInfo=null),ey(this,"_doDispatchAxisPointer")},
/**
               * @protected
               */
t.prototype.doClear=function(){// Implemented by sub-class if necessary.
},t.prototype.buildLabel=function(t,e,n){return{x:t[n=n||0],y:t[1-n],width:e[n],height:e[1-n]}},t}();function FE(t,e,n,i){// Animation optimize.
GE(EE(n).lastProp,i)||(EE(n).lastProp=i,e?Sh(n,i,t):(n.stopAnimation(),n.attr(i)))}function GE(t,e){if(U(t)&&U(e)){var n=!0;return R(e,(function(e,i){n=n&&GE(t[i],e)})),!!n}return t===e}function WE(t,e){t[e.get(["label","show"])?"show":"hide"]()}function HE(t){return{x:t.x||0,y:t.y||0,rotation:t.rotation||0}}function YE(t,e,n){var i=e.get("z"),r=e.get("zlevel");t&&t.traverse((function(t){"group"!==t.type&&(null!=i&&(t.z=i),null!=r&&(t.zlevel=r),t.silent=n)}))}const XE=BE;function UE(t){var e,n=t.get("type"),i=t.getModel(n+"Style");return"line"===n?(e=i.getLineStyle()).fill=null:"shadow"===n&&((e=i.getAreaStyle()).stroke=null),e}
/**
             * @param {Function} labelPos {align, verticalAlign, position}
             */function ZE(t,e,n,i,r){var o=jE(n.get("value"),e.axis,e.ecModel,n.get("seriesDataIndices"),{precision:n.get(["label","precision"]),formatter:n.get(["label","formatter"])}),a=n.getModel("label"),s=wp(a.get("padding")||0),l=a.getFont(),u=dr(o,l),h=r.position,c=u.width+s[1]+s[3],p=u.height+s[0]+s[2],d=r.align;"right"===d&&(h[0]-=c),"center"===d&&(h[0]-=c/2);var f=r.verticalAlign;"bottom"===f&&(h[1]-=p),"middle"===f&&(h[1]-=p/2),// Not overflow ec container
// Do not overflow ec container
function(t,e,n,i){var r=i.getWidth(),o=i.getHeight();t[0]=Math.min(t[0]+e,r)-e,t[1]=Math.min(t[1]+n,o)-n,t[0]=Math.max(t[0],0),t[1]=Math.max(t[1],0)}(h,c,p,i);var g=a.get("backgroundColor");g&&"auto"!==g||(g=e.get(["axisLine","lineStyle","color"])),t.label={// shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
x:h[0],y:h[1],style:lc(a,{text:o,font:l,fill:a.getTextColor(),padding:s,backgroundColor:g}),// Lable should be over axisPointer.
z2:10}}function jE(t,e,n,i,r){t=e.scale.parse(t);var o=e.scale.getLabel({value:t},{// If `precision` is set, width can be fixed (like '12.00500'), which
// helps to debounce when when moving label.
precision:r.precision}),a=r.formatter;if(a){var s={value:N_(e,{value:t}),axisDimension:e.dim,axisIndex:e.index,seriesData:[]};R(i,(function(t){var e=n.getSeriesByIndex(t.seriesIndex),i=t.dataIndexInside,r=e&&e.getDataParams(i);r&&s.seriesData.push(r)})),H(a)?o=a.replace("{value}",o):W(a)&&(o=a(s))}return o}function qE(t,e,n){var i=[1,0,0,1,0,0];return de(i,i,n.rotation),pe(i,i,n.position),Yh([t.dataToCoord(e),(n.labelOffset||0)+(n.labelDirection||1)*(n.labelMargin||0)],i)}function KE(t,e,n,i,r,o){// @ts-ignore
var a=BI.innerTextLayout(n.rotation,0,n.labelDirection);n.labelMargin=r.get(["label","margin"]),ZE(e,i,r,o,{position:qE(i.axis,t,n),align:a.textAlign,verticalAlign:a.textVerticalAlign})}function $E(t,e,n){return{x1:t[n=n||0],y1:t[1-n],x2:e[n],y2:e[1-n]}}function JE(t,e,n){return{x:t[n=n||0],y:t[1-n],width:e[n],height:e[1-n]}}function QE(t,e,n,i,r,o){return{cx:t,cy:e,r0:n,r:i,startAngle:r,endAngle:o,clockwise:!0}}var tz=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}
/**
               * @override
               */return n(e,t),e.prototype.makeElOption=function(t,e,n,i,r){var o=n.axis,a=o.grid,s=i.get("type"),l=ez(a,o).getOtherAxis(o).getGlobalExtent(),u=o.toGlobalCoord(o.dataToCoord(e,!0));if(s&&"none"!==s){var h=UE(i),c=nz[s](o,u,l);c.style=h,t.graphicKey=c.type,t.pointer=c}KE(// @ts-ignore
e,t,wI(a.model,n),n,i,r)},
/**
               * @override
               */
e.prototype.getHandleTransform=function(t,e,n){var i=wI(e.axis.grid.model,e,{labelInside:!1});// @ts-ignore
i.labelMargin=n.get(["handle","margin"]);var r=qE(e.axis,t,i);return{x:r[0],y:r[1],rotation:i.rotation+(i.labelDirection<0?Math.PI:0)}},
/**
               * @override
               */
e.prototype.updateHandleTransform=function(t,e,n,i){var r=n.axis,o=r.grid,a=r.getGlobalExtent(!0),s=ez(o,r).getOtherAxis(r).getGlobalExtent(),l="x"===r.dim?0:1,u=[t.x,t.y];u[l]+=e[l],u[l]=Math.min(a[1],u[l]),u[l]=Math.max(a[0],u[l]);var h=(s[1]+s[0])/2,c=[h,h];return c[l]=u[l],{x:u[0],y:u[1],rotation:t.rotation,cursorPoint:c,tooltipOption:[{verticalAlign:"middle"},{align:"center"}][l]}},e}(XE);function ez(t,e){var n={};return n[e.dim+"AxisIndex"]=e.index,t.getCartesian(n)}var nz={line:function(t,e,n){return{type:"Line",subPixelOptimize:!0,shape:$E([e,n[0]],[e,n[1]],iz(t))}},shadow:function(t,e,n){var i=Math.max(1,t.getBandWidth()),r=n[1]-n[0];return{type:"Rect",shape:JE([e-i/2,n[0]],[i,r],iz(t))}}};function iz(t){return"x"===t.dim?0:1}const rz=tz;var oz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="axisPointer",e.defaultOption={// 'auto' means that show when triggered by tooltip or handle.
show:"auto",// zlevel: 0,
z:50,type:"line",// axispointer triggered by tootip determine snap automatically,
// see `modelHelper`.
snap:!1,triggerTooltip:!0,value:null,status:null,link:[],// Do not set 'auto' here, otherwise global animation: false
// will not effect at this axispointer.
animation:null,animationDurationUpdate:200,lineStyle:{color:"#B9BEC9",width:1,type:"dashed"},shadowStyle:{color:"rgba(210,219,238,0.2)"},label:{show:!0,formatter:null,precision:"auto",margin:3,color:"#fff",padding:[5,7,5,7],backgroundColor:"auto",borderColor:null,borderWidth:0,borderRadius:3},handle:{show:!1,// eslint-disable-next-line
icon:"M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",size:45,// handle margin is from symbol center to axis, which is stable when circular move.
margin:50,// color: '#1b8bbd'
// color: '#2f4554'
color:"#333",shadowBlur:3,shadowColor:"#aaa",shadowOffsetX:0,shadowOffsetY:2,// For mobile performance
throttle:40}},e}(Wp);const az=oz;var sz=bo(),lz=R;
/**
             * @param {string} key
             * @param {module:echarts/ExtensionAPI} api
             * @param {Function} handler
             *      param: {string} currTrigger
             *      param: {Array.<number>} point
             */
function uz(t,e,n){if(!o.node){var i=e.getZr();sz(i).records||(sz(i).records={}),function(t,e){function n(n,i){t.on(n,(function(n){var r=function(t){var e={showTip:[],hideTip:[]},n=function(i){var r=e[i.type];r?r.push(i):(i.dispatchAction=n,t.dispatchAction(i))};// FIXME
// better approach?
// 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
// which may be conflict, (axisPointer call showTip but tooltip call hideTip);
// So we have to add "final stage" to merge those dispatched actions.
return{dispatchAction:n,pendings:e}}(e);lz(sz(t).records,(function(t){t&&i(t,n,r.dispatchAction)})),function(t,e){var n,i=t.showTip.length,r=t.hideTip.length;i?n=t.showTip[i-1]:r&&(n=t.hideTip[r-1]),n&&(n.dispatchAction=null,e.dispatchAction(n))}(r.pendings,e)}))}sz(t).initialized||(sz(t).initialized=!0,n("click",F(cz,"click")),n("mousemove",F(cz,"mousemove")),// useHandler('mouseout', onLeave);
n("globalout",hz))}(i,e),(sz(i).records[t]||(sz(i).records[t]={})).handler=n}}function hz(t,e,n){t.handler("leave",null,n)}function cz(t,e,n,i){e.handler(t,n,i)}function pz(t,e){if(!o.node){var n=e.getZr();(sz(n).records||{})[t]&&(sz(n).records[t]=null)}}var dz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=e.getComponent("tooltip"),r=t.get("triggerOn")||i&&i.get("triggerOn")||"mousemove|click";// Register global listener in AxisPointerView to enable
// AxisPointerView to be independent to Tooltip.
uz("axisPointer",n,(function(t,e,n){// If 'none', it is not controlled by mouse totally.
"none"!==r&&("leave"===t||r.indexOf(t)>=0)&&n({type:"updateAxisPointer",currTrigger:t,x:e&&e.offsetX,y:e&&e.offsetY})}))},e.prototype.remove=function(t,e){pz("axisPointer",e)},e.prototype.dispose=function(t,e){pz("axisPointer",e)},e.type="axisPointer",e}(Bg);const fz=dz;
/**
             * @param finder contains {seriesIndex, dataIndex, dataIndexInside}
             * @param ecModel
             * @return  {point: [x, y], el: ...} point Will not be null.
             */function gz(t,e){var n,i=[],r=t.seriesIndex;if(null==r||!(n=e.getSeriesByIndex(r)))return{point:[]};var o=n.getData(),a=_o(o,t);if(null==a||a<0||G(a))return{point:[]};var s=o.getItemGraphicEl(a),l=n.coordinateSystem;if(n.getTooltipPosition)i=n.getTooltipPosition(a)||[];else if(l&&l.dataToPoint)if(t.isStacked){var u=l.getBaseAxis(),h=l.getOtherAxis(u).dim,c=u.dim,p="x"===h||"radius"===h?1:0,d=o.mapDimension(c),f=[];f[p]=o.get(d,a),f[1-p]=o.get(o.getCalculationInfo("stackResultDimension"),a),i=l.dataToPoint(f)||[]}else i=l.dataToPoint(o.getValues(N(l.dimensions,(function(t){return o.mapDimension(t)})),a))||[];else if(s){// Use graphic bounding rect
var g=s.getBoundingRect().clone();g.applyTransform(s.transform),i=[g.x+g.width/2,g.y+g.height/2]}return{point:i,el:s}}var yz=bo();
/**
             * Basic logic: check all axis, if they do not demand show/highlight,
             * then hide/downplay them.
             *
             * @return content of event obj for echarts.connect.
             */function vz(t,e,n){var i=t.currTrigger,r=[t.x,t.y],o=t,a=t.dispatchAction||B(n.dispatchAction,n),s=e.getComponent("axisPointer").coordSysAxesInfo;// Pending
// See #6121. But we are not able to reproduce it yet.
if(s){wz(r)&&(// Used in the default behavior of `connection`: use the sample seriesIndex
// and dataIndex. And also used in the tooltipView trigger.
r=gz({seriesIndex:o.seriesIndex,// Do not use dataIndexInside from other ec instance.
// FIXME: auto detect it?
dataIndex:o.dataIndex},e).point);var l=wz(r),u=o.axesInfo,h=s.axesInfo,c="leave"===i||wz(r),p={},d={},f={list:[],map:{}},g={showPointer:F(xz,d),showTooltip:F(_z,f)};// Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
// Notice: In this case, it is difficult to get the `point` (which is necessary to show
// tooltip, so if point is not given, we just use the point found by sample seriesIndex
// and dataIndex.
// Process for triggered axes.
R(s.coordSysMap,(function(t,e){// If a point given, it must be contained by the coordinate system.
var n=l||t.containPoint(r);R(s.coordSysAxesInfo[e],(function(t,e){var i=t.axis,o=function(t,e){for(var n=0;n<(t||[]).length;n++){var i=t[n];if(e.axis.dim===i.axisDim&&e.axis.model.componentIndex===i.axisIndex)return i}}(u,t);// If no inputAxesInfo, no axis is restricted.
if(!c&&n&&(!u||o)){var a=o&&o.value;null!=a||l||(a=i.pointToData(r)),null!=a&&mz(t,a,g,!1,p)}}))}));// Process for linked axes.
var y={};return R(h,(function(t,e){var n=t.linkGroup;// If axis has been triggered in the previous stage, it should not be triggered by link.
n&&!d[e]&&R(n.axesInfo,(function(e,i){var r=d[i];// If srcValItem exist, source axis is triggered, so link to target axis.
if(e!==t&&r){var o=r.value;n.mapper&&(o=t.axis.scale.parse(n.mapper(o,bz(e),bz(t)))),y[t.key]=o}}))})),R(y,(function(t,e){mz(h[e],t,g,!0,p)})),function(t,e,n){var i=n.axesInfo=[];// Basic logic: If no 'show' required, 'hide' this axisPointer.
R(e,(function(e,n){var r=e.axisPointerModel.option,o=t[n];o?(!e.useHandle&&(r.status="show"),r.value=o.value,// For label formatter param and highlight.
r.seriesDataIndices=(o.payloadBatch||[]).slice()):// If hide, value still need to be set, consider
// click legend to toggle axis blank.
!e.useHandle&&(r.status="hide"),// If status is 'hide', should be no info in payload.
"show"===r.status&&i.push({axisDim:e.axis.dim,axisIndex:e.axis.model.componentIndex,value:r.value})}))}(d,h,p),function(t,e,n,i){// Basic logic: If no showTip required, hideTip will be dispatched.
if(!wz(e)&&t.list.length){// In most case only one axis (or event one series is used). It is
// convinient to fetch payload.seriesIndex and payload.dataIndex
// dirtectly. So put the first seriesIndex and dataIndex of the first
// axis on the payload.
var r=((t.list[0].dataByAxis[0]||{}).seriesDataIndices||[])[0]||{};i({type:"showTip",escapeConnect:!0,x:e[0],y:e[1],tooltipOption:n.tooltipOption,position:n.position,dataIndexInside:r.dataIndexInside,dataIndex:r.dataIndex,seriesIndex:r.seriesIndex,dataByCoordSys:t.list})}else i({type:"hideTip"})}(f,r,t,a),function(t,e,n){// FIXME
// highlight status modification shoule be a stage of main process?
// (Consider confilct (e.g., legend and axisPointer) and setOption)
var i=n.getZr(),r="axisPointerLastHighlights",o=yz(i)[r]||{},a=yz(i)[r]={};// Update highlight/downplay status according to axisPointer model.
// Build hash map and remove duplicate incidentally.
R(t,(function(t,e){var n=t.axisPointerModel.option;"show"===n.status&&R(n.seriesDataIndices,(function(t){var e=t.seriesIndex+" | "+t.dataIndex;a[e]=t}))}));// Diff.
var s=[],l=[];R(o,(function(t,e){!a[e]&&l.push(t)})),R(a,(function(t,e){!o[e]&&s.push(t)})),l.length&&n.dispatchAction({type:"downplay",escapeConnect:!0,// Not blur others when highlight in axisPointer.
notBlur:!0,batch:l}),s.length&&n.dispatchAction({type:"highlight",escapeConnect:!0,// Not blur others when highlight in axisPointer.
notBlur:!0,batch:s})}(h,0,n),p}}function mz(t,e,n,i,r){var o=t.axis;if(!o.scale.isBlank()&&o.containData(e))if(t.involveSeries){// Heavy calculation. So put it after axis.containData checking.
var a=function(t,e){var n=e.axis,i=n.dim,r=t,o=[],a=Number.MAX_VALUE,s=-1;return R(e.seriesModels,(function(e,l){var u,h,c=e.getData().mapDimensionsAll(i);if(e.getAxisTooltipData){var p=e.getAxisTooltipData(c,t,n);h=p.dataIndices,u=p.nestestValue}else{if(!(h=e.getData().indicesOfNearest(c[0],t,// Add a threshold to avoid find the wrong dataIndex
// when data length is not same.
// false,
"category"===n.type?.5:null)).length)return;u=e.getData().get(c[0],h[0])}if(null!=u&&isFinite(u)){var d=t-u,f=Math.abs(d);// Consider category case
f<=a&&((f<a||d>=0&&s<0)&&(a=f,s=d,r=u,o.length=0),R(h,(function(t){o.push({seriesIndex:e.seriesIndex,dataIndexInside:t,dataIndex:e.getData().getRawIndex(t)})})))}})),{payloadBatch:o,snapToValue:r}}(e,t),s=a.payloadBatch,l=a.snapToValue;// Fill content of event obj for echarts.connect.
// By default use the first involved series data as a sample to connect.
s[0]&&null==r.seriesIndex&&A(r,s[0]),// If no linkSource input, this process is for collecting link
// target, where snap should not be accepted.
!i&&t.snap&&o.containData(l)&&null!=l&&(e=l),n.showPointer(t,e,s),// Tooltip should always be snapToValue, otherwise there will be
// incorrect "axis value ~ series value" mapping displayed in tooltip.
n.showTooltip(t,a,l)}else n.showPointer(t,e)}function xz(t,e,n,i){t[e.key]={value:n,payloadBatch:i}}function _z(t,e,n,i){var r=n.payloadBatch,o=e.axis,a=o.model,s=e.axisPointerModel;// If no data, do not create anything in dataByCoordSys,
// whose length will be used to judge whether dispatch action.
if(e.triggerTooltip&&r.length){var l=e.coordSys.model,u=XI(l),h=t.map[u];h||(h=t.map[u]={coordSysId:l.id,coordSysIndex:l.componentIndex,coordSysType:l.type,coordSysMainType:l.mainType,dataByAxis:[]},t.list.push(h)),h.dataByAxis.push({axisDim:o.dim,axisIndex:a.componentIndex,axisType:a.type,axisId:a.id,value:i,// Caustion: viewHelper.getValueLabel is actually on "view stage", which
// depends that all models have been updated. So it should not be performed
// here. Considering axisPointerModel used here is volatile, which is hard
// to be retrieve in TooltipView, we prepare parameters here.
valueLabelOpt:{precision:s.get(["label","precision"]),formatter:s.get(["label","formatter"])},seriesDataIndices:r.slice()})}}function bz(t){var e=t.axis.model,n={},i=n.axisDim=t.axis.dim;return n.axisIndex=n[i+"AxisIndex"]=e.componentIndex,n.axisName=n[i+"AxisName"]=e.name,n.axisId=n[i+"AxisId"]=e.id,n}function wz(t){return!t||null==t[0]||isNaN(t[0])||null==t[1]||isNaN(t[1])}function Sz(t){// CartesianAxisPointer is not supposed to be required here. But consider
// echarts.simple.js and online build tooltip, which only require gridSimple,
// CartesianAxisPointer should be able to required somewhere.
jI.registerAxisPointerClass("CartesianAxisPointer",rz),t.registerComponentModel(az),t.registerComponentView(fz),t.registerPreprocessor((function(t){// Always has a global axisPointerModel for default setting.
if(t){(!t.axisPointer||0===t.axisPointer.length)&&(t.axisPointer={});var e=t.axisPointer.link;// Normalize to array to avoid object mergin. But if link
// is not set, remain null/undefined, otherwise it will
// override existent link setting.
e&&!G(e)&&(t.axisPointer.link=[e])}})),// This process should proformed after coordinate systems created
// and series data processed. So put it on statistic processing stage.
t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC,(function(t,e){// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.
t.getComponent("axisPointer").coordSysAxesInfo=FI(t,e)})),// Broadcast to all views.
t.registerAction({type:"updateAxisPointer",event:"updateAxisPointer",update:":updateAxisPointer"},vz)}var Mz=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}
/**
               * @override
               */return n(e,t),e.prototype.makeElOption=function(t,e,n,i,r){var o=n.axis;"angle"===o.dim&&(this.animationThreshold=Math.PI/18);var a=o.polar,s=a.getOtherAxis(o).getExtent(),l=o.dataToCoord(e),u=i.get("type");if(u&&"none"!==u){var h=UE(i),c=Iz[u](o,a,l,s);c.style=h,t.graphicKey=c.type,t.pointer=c}var p=function(t,e,n,i,r){var o=e.axis,a=o.dataToCoord(t),s=i.getAngleAxis().getExtent()[0];s=s/180*Math.PI;var l,u,h,c=i.getRadiusAxis().getExtent();if("radius"===o.dim){var p=[1,0,0,1,0,0];de(p,p,s),pe(p,p,[i.cx,i.cy]),l=Yh([a,-r],p);var d=e.getModel("axisLabel").get("rotate")||0,f=BI.innerTextLayout(s,d*Math.PI/180,-1);// @ts-ignore
u=f.textAlign,h=f.textVerticalAlign}else{// angle axis
var g=c[1];l=i.coordToPoint([g+r,a]);var y=i.cx,v=i.cy;u=Math.abs(l[0]-y)/g<.3?"center":l[0]>y?"left":"right",h=Math.abs(l[1]-v)/g<.3?"middle":l[1]>v?"top":"bottom"}return{position:l,align:u,verticalAlign:h}}(e,n,0,a,i.get(["label","margin"]));ZE(t,n,i,r,p)},e}(XE),Iz={line:function(t,e,n,i){return"angle"===t.dim?{type:"Line",shape:$E(e.coordToPoint([i[0],n]),e.coordToPoint([i[1],n]))}:{type:"Circle",shape:{cx:e.cx,cy:e.cy,r:n}}},shadow:function(t,e,n,i){var r=Math.max(1,t.getBandWidth()),o=Math.PI/180;return"angle"===t.dim?{type:"Sector",shape:QE(e.cx,e.cy,i[0],i[1],// In ECharts y is negative if angle is positive
(-n-r/2)*o,(r/2-n)*o)}:{type:"Sector",shape:QE(e.cx,e.cy,n-r/2,n+r/2,0,2*Math.PI)}}};const Tz=Mz;var Cz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.findAxisModel=function(t){var e;return this.ecModel.eachComponent(t,(function(t){t.getCoordSysModel()===this&&(e=t)}),this),e},e.type="polar",e.dependencies=["radiusAxis","angleAxis"],e.defaultOption={// zlevel: 0,
z:0,center:["50%","50%"],radius:"80%"},e}(Wp);const Dz=Cz;var Az=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.getCoordSysModel=function(){return this.getReferringComponents("polar",Io).models[0]},e.type="polarAxis",e}(Wp);P(Az,F_);var kz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="angleAxis",e}(Az),Lz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="radiusAxis",e}(Az),Pz=/** @class */function(t){function e(e,n){return t.call(this,"radius",e,n)||this}return n(e,t),e.prototype.pointToData=function(t,e){return this.polar.pointToData(t,e)["radius"===this.dim?0:1]},e}(pb);Pz.prototype.dataToRadius=pb.prototype.dataToCoord,Pz.prototype.radiusToData=pb.prototype.coordToData;const Oz=Pz;var Rz=bo(),Nz=/** @class */function(t){function e(e,n){return t.call(this,"angle",e,n||[0,360])||this}return n(e,t),e.prototype.pointToData=function(t,e){return this.polar.pointToData(t,e)["radius"===this.dim?0:1]},
/**
               * Only be called in category axis.
               * Angle axis uses text height to decide interval
               *
               * @override
               * @return {number} Auto interval for cateogry axis tick and label
               */
e.prototype.calculateCategoryInterval=function(){var t=this,e=t.getLabelModel(),n=t.scale,i=n.getExtent(),r=n.count();if(i[1]-i[0]<1)return 0;var o=i[0],a=t.dataToCoord(o+1)-t.dataToCoord(o),s=Math.abs(a),l=dr(null==o?"":o+"",e.getFont(),"center","top"),u=Math.max(l.height,7)/s;// 0/0 is NaN, 1/0 is Infinity.
isNaN(u)&&(u=1/0);var h=Math.max(0,Math.floor(u)),c=Rz(t.model),p=c.lastAutoInterval,d=c.lastTickCount;// Use cache to keep interval stable while moving zoom window,
// otherwise the calculated interval might jitter when the zoom
// window size is close to the interval-changing size.
return null!=p&&null!=d&&Math.abs(p-h)<=1&&Math.abs(d-r)<=1&&p>h?h=p:(c.lastTickCount=r,c.lastAutoInterval=h),h},e}(pb);Nz.prototype.dataToAngle=pb.prototype.dataToCoord,Nz.prototype.angleToData=pb.prototype.coordToData;const Ez=Nz;var zz=["radius","angle"],Vz=/** @class */function(){function t(t){this.dimensions=zz,this.type="polar",
/**
                 * x of polar center
                 */
this.cx=0,
/**
                 * y of polar center
                 */
this.cy=0,this._radiusAxis=new Oz,this._angleAxis=new Ez,this.axisPointerEnabled=!0,this.name=t||"",this._radiusAxis.polar=this._angleAxis.polar=this}
/**
               * If contain coord
               */return t.prototype.containPoint=function(t){var e=this.pointToCoord(t);return this._radiusAxis.contain(e[0])&&this._angleAxis.contain(e[1])},
/**
               * If contain data
               */
t.prototype.containData=function(t){return this._radiusAxis.containData(t[0])&&this._angleAxis.containData(t[1])},t.prototype.getAxis=function(t){return this["_"+t+"Axis"]},t.prototype.getAxes=function(){return[this._radiusAxis,this._angleAxis]},
/**
               * Get axes by type of scale
               */
t.prototype.getAxesByScale=function(t){var e=[],n=this._angleAxis,i=this._radiusAxis;return n.scale.type===t&&e.push(n),i.scale.type===t&&e.push(i),e},t.prototype.getAngleAxis=function(){return this._angleAxis},t.prototype.getRadiusAxis=function(){return this._radiusAxis},t.prototype.getOtherAxis=function(t){var e=this._angleAxis;return t===e?this._radiusAxis:e},
/**
               * Base axis will be used on stacking.
               *
               */
t.prototype.getBaseAxis=function(){return this.getAxesByScale("ordinal")[0]||this.getAxesByScale("time")[0]||this.getAngleAxis()},t.prototype.getTooltipAxes=function(t){var e=null!=t&&"auto"!==t?this.getAxis(t):this.getBaseAxis();return{baseAxes:[e],otherAxes:[this.getOtherAxis(e)]}},
/**
               * Convert a single data item to (x, y) point.
               * Parameter data is an array which the first element is radius and the second is angle
               */
t.prototype.dataToPoint=function(t,e){return this.coordToPoint([this._radiusAxis.dataToRadius(t[0],e),this._angleAxis.dataToAngle(t[1],e)])},
/**
               * Convert a (x, y) point to data
               */
t.prototype.pointToData=function(t,e){var n=this.pointToCoord(t);return[this._radiusAxis.radiusToData(n[0],e),this._angleAxis.angleToData(n[1],e)]},
/**
               * Convert a (x, y) point to (radius, angle) coord
               */
t.prototype.pointToCoord=function(t){var e=t[0]-this.cx,n=t[1]-this.cy,i=this.getAngleAxis(),r=i.getExtent(),o=Math.min(r[0],r[1]),a=Math.max(r[0],r[1]);// Fix fixed extent in polarCreator
// FIXME
i.inverse?o=a-360:a=o+360;var s=Math.sqrt(e*e+n*n);e/=s,n/=s;for(var l=Math.atan2(-n,e)/Math.PI*180,u=l<o?1:-1// move to angleExtent
;l<o||l>a;)l+=360*u;return[s,l]},
/**
               * Convert a (radius, angle) coord to (x, y) point
               */
t.prototype.coordToPoint=function(t){var e=t[0],n=t[1]/180*Math.PI;return[Math.cos(n)*e+this.cx,-Math.sin(n)*e+this.cy]},
/**
               * Get ring area of cartesian.
               * Area will have a contain function to determine if a point is in the coordinate system.
               */
t.prototype.getArea=function(){var t=this.getAngleAxis(),e=this.getRadiusAxis().getExtent().slice();e[0]>e[1]&&e.reverse();var n=t.getExtent(),i=Math.PI/180;return{cx:this.cx,cy:this.cy,r0:e[0],r:e[1],startAngle:-n[0]*i,endAngle:-n[1]*i,clockwise:t.inverse,contain:function(t,e){// It's a ring shape.
// Start angle and end angle don't matter
var n=t-this.cx,i=e-this.cy,r=n*n+i*i-1e-4,o=this.r,a=this.r0;return r<=o*o&&r>=a*a}}},t.prototype.convertToPixel=function(t,e,n){return Bz(e)===this?this.dataToPoint(n):null},t.prototype.convertFromPixel=function(t,e,n){return Bz(e)===this?this.pointToData(n):null},t}();function Bz(t){var e=t.seriesModel,n=t.polarModel;return n&&n.coordinateSystem||e&&e.coordinateSystem}const Fz=Vz;
/**
             * Resize method bound to the polar
             */
/**
             * Update polar
             */
function Gz(t,e){var n=this,i=n.getAngleAxis(),r=n.getRadiusAxis();// Fix extent of category angle axis
if(// Reset scale
i.scale.setExtent(1/0,-1/0),r.scale.setExtent(1/0,-1/0),t.eachSeries((function(t){if(t.coordinateSystem===n){var e=t.getData();R(B_(e,"radius"),(function(t){r.scale.unionExtentFromData(e,t)})),R(B_(e,"angle"),(function(t){i.scale.unionExtentFromData(e,t)}))}})),P_(i.scale,i.model),P_(r.scale,r.model),"category"===i.type&&!i.onBand){var o=i.getExtent(),a=360/i.scale.count();i.inverse?o[1]+=a:o[1]-=a,i.setExtent(o[0],o[1])}}
/**
             * Set common axis properties
             */
function Wz(t,e){if(t.type=e.get("type"),t.scale=O_(e),t.onBand=e.get("boundaryGap")&&"category"===t.type,t.inverse=e.get("inverse"),function(t){return"angleAxis"===t.mainType}(e)){t.inverse=t.inverse!==e.get("clockwise");var n=e.get("startAngle");t.setExtent(n,n+(t.inverse?-360:360))}// Inject axis instance
e.axis=t,t.model=e}var Hz={dimensions:zz,create:function(t,e){var n=[];return t.eachComponent("polar",(function(t,i){var r=new Fz(i+"");// Inject resize and update method
r.update=Gz;var o=r.getRadiusAxis(),a=r.getAngleAxis(),s=t.findAxisModel("radiusAxis"),l=t.findAxisModel("angleAxis");Wz(o,s),Wz(a,l),function(t,e,n){var i=e.get("center"),r=n.getWidth(),o=n.getHeight();t.cx=Vr(i[0],r),t.cy=Vr(i[1],o);var a=t.getRadiusAxis(),s=Math.min(r,o)/2,l=e.get("radius");null==l?l=[0,"100%"]:G(l)||(// r0 = 0
l=[0,l]);var u=[Vr(l[0],s),Vr(l[1],s)];a.inverse?a.setExtent(u[1],u[0]):a.setExtent(u[0],u[1])}(r,t,e),n.push(r),t.coordinateSystem=r,r.model=t})),// Inject coordinateSystem to series
t.eachSeries((function(t){if("polar"===t.get("coordinateSystem")){var e=t.getReferringComponents("polar",Io).models[0];t.coordinateSystem=e.coordinateSystem}})),n}};const Yz=Hz;var Xz=["axisLine","axisLabel","axisTick","minorTick","splitLine","minorSplitLine","splitArea"];function Uz(t,e,n){e[1]>e[0]&&(e=e.slice().reverse());var i=t.coordToPoint([e[0],n]),r=t.coordToPoint([e[1],n]);return{x1:i[0],y1:i[1],x2:r[0],y2:r[1]}}function Zz(t){return t.getRadiusAxis().inverse?0:1}// Remove the last tick which will overlap the first tick
function jz(t){var e=t[0],n=t[t.length-1];e&&n&&Math.abs(Math.abs(e.coord-n.coord)-360)<1e-4&&t.pop()}var qz=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.axisPointerClass="PolarAxisPointer",n}return n(e,t),e.prototype.render=function(t,e){if(this.group.removeAll(),t.get("show")){var n=t.axis,i=n.polar,r=i.getRadiusAxis().getExtent(),o=n.getTicksCoords(),a=n.getMinorTicksCoords(),s=N(n.getViewLabels(),(function(t){t=T(t);var e=n.scale,i="ordinal"===e.type?e.getRawOrdinalNumber(t.tickValue):t.tickValue;return t.coord=n.dataToCoord(i),t}));jz(s),jz(o),R(Xz,(function(e){!t.get([e,"show"])||n.scale.isBlank()&&"axisLine"!==e||Kz[e](this.group,t,i,o,a,r,s)}),this)}},e.type="angleAxis",e}(jI),Kz={axisLine:function(t,e,n,i,r,o){var a,s=e.getModel(["axisLine","lineStyle"]),l=Zz(n),u=l?0:1;// extent id of the axis radius (r0 and r)
(a=0===o[u]?new yu({shape:{cx:n.cx,cy:n.cy,r:o[l]},style:s.getLineStyle(),z2:1,silent:!0}):new Vu({shape:{cx:n.cx,cy:n.cy,r:o[l],r0:o[u]},style:s.getLineStyle(),z2:1,silent:!0})).style.fill=null,t.add(a)},axisTick:function(t,e,n,i,r,o){var a=e.getModel("axisTick"),s=(a.get("inside")?-1:1)*a.get("length"),l=o[Zz(n)],u=N(i,(function(t){return new qu({shape:Uz(n,[l,l+s],t.coord)})}));t.add(Bh(u,{style:k(a.getModel("lineStyle").getLineStyle(),{stroke:e.get(["axisLine","lineStyle","color"])})}))},minorTick:function(t,e,n,i,r,o){if(r.length){for(var a=e.getModel("axisTick"),s=e.getModel("minorTick"),l=(a.get("inside")?-1:1)*s.get("length"),u=o[Zz(n)],h=[],c=0;c<r.length;c++)for(var p=0;p<r[c].length;p++)h.push(new qu({shape:Uz(n,[u,u+l],r[c][p].coord)}));t.add(Bh(h,{style:k(s.getModel("lineStyle").getLineStyle(),k(a.getLineStyle(),{stroke:e.get(["axisLine","lineStyle","color"])}))}))}},axisLabel:function(t,e,n,i,r,o,a){var s=e.getCategories(!0),l=e.getModel("axisLabel"),u=l.get("margin"),h=e.get("triggerEvent");// Use length of ticksAngles because it may remove the last tick to avoid overlapping
R(a,(function(i,r){var a=l,c=i.tickValue,p=o[Zz(n)],d=n.coordToPoint([p+u,i.coord]),f=n.cx,g=n.cy,y=Math.abs(d[0]-f)/p<.3?"center":d[0]>f?"left":"right",v=Math.abs(d[1]-g)/p<.3?"middle":d[1]>g?"top":"bottom";if(s&&s[c]){var m=s[c];U(m)&&m.textStyle&&(a=new Pc(m.textStyle,l,l.ecModel))}var x=new Zs({silent:BI.isLabelSilent(e),style:lc(a,{x:d[0],y:d[1],fill:a.getTextColor()||e.get(["axisLine","lineStyle","color"]),text:i.formattedLabel,align:y,verticalAlign:v})});// Pack data for mouse event
if(t.add(x),h){var _=BI.makeAxisEventDataBase(e);_.targetType="axisLabel",_.value=i.rawLabel,js(x).eventData=_}}),this)},splitLine:function(t,e,n,i,r,o){var a=e.getModel("splitLine").getModel("lineStyle"),s=a.get("color"),l=0;s=s instanceof Array?s:[s];for(var u=[],h=0;h<i.length;h++){var c=l++%s.length;u[c]=u[c]||[],u[c].push(new qu({shape:Uz(n,o,i[h].coord)}))}// Simple optimization
// Batching the lines if color are the same
for(h=0;h<u.length;h++)t.add(Bh(u[h],{style:k({stroke:s[h%s.length]},a.getLineStyle()),silent:!0,z:e.get("z")}))},minorSplitLine:function(t,e,n,i,r,o){if(r.length){for(var a=e.getModel("minorSplitLine").getModel("lineStyle"),s=[],l=0;l<r.length;l++)for(var u=0;u<r[l].length;u++)s.push(new qu({shape:Uz(n,o,r[l][u].coord)}));t.add(Bh(s,{style:a.getLineStyle(),silent:!0,z:e.get("z")}))}},splitArea:function(t,e,n,i,r,o){if(i.length){var a=e.getModel("splitArea").getModel("areaStyle"),s=a.get("color"),l=0;s=s instanceof Array?s:[s];for(var u=[],h=Math.PI/180,c=-i[0].coord*h,p=Math.min(o[0],o[1]),d=Math.max(o[0],o[1]),f=e.get("clockwise"),g=1,y=i.length;g<=y;g++){var v=g===y?i[0].coord:i[g].coord,m=l++%s.length;u[m]=u[m]||[],u[m].push(new Nu({shape:{cx:n.cx,cy:n.cy,r0:p,r:d,startAngle:c,endAngle:-v*h,clockwise:f},silent:!0})),c=-v*h}// Simple optimization
// Batching the lines if color are the same
for(g=0;g<u.length;g++)t.add(Bh(u[g],{style:k({fill:s[g%s.length]},a.getAreaStyle()),silent:!0}))}}};const $z=qz;var Jz=["axisLine","axisTickLabel","axisName"],Qz=["splitLine","splitArea","minorSplitLine"],tV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.axisPointerClass="PolarAxisPointer",n}return n(e,t),e.prototype.render=function(t,e){if(this.group.removeAll(),t.get("show")){var n=this._axisGroup,i=this._axisGroup=new Lr;this.group.add(i);var r=t.axis,o=r.polar,a=o.getAngleAxis(),s=r.getTicksCoords(),l=r.getMinorTicksCoords(),u=a.getExtent()[0],h=r.getExtent(),c=
/**
             * @inner
             */
function(t,e,n){return{position:[t.cx,t.cy],rotation:n/180*Math.PI,labelDirection:-1,tickDirection:-1,nameDirection:1,labelRotate:e.getModel("axisLabel").get("rotate"),// Over splitLine and splitArea
z2:1}}(o,t,u),p=new BI(t,c);R(Jz,p.add,p),i.add(p.getGroup()),Zh(n,i,t),R(Qz,(function(e){t.get([e,"show"])&&!r.scale.isBlank()&&eV[e](this.group,t,o,u,h,s,l)}),this)}},e.type="radiusAxis",e}(jI),eV={splitLine:function(t,e,n,i,r,o){var a=e.getModel("splitLine").getModel("lineStyle"),s=a.get("color"),l=0;s=s instanceof Array?s:[s];for(var u=[],h=0;h<o.length;h++){var c=l++%s.length;u[c]=u[c]||[],u[c].push(new yu({shape:{cx:n.cx,cy:n.cy,// ensure circle radius >= 0
r:Math.max(o[h].coord,0)}}))}// Simple optimization
// Batching the lines if color are the same
for(h=0;h<u.length;h++)t.add(Bh(u[h],{style:k({stroke:s[h%s.length],fill:null},a.getLineStyle()),silent:!0}))},minorSplitLine:function(t,e,n,i,r,o,a){if(a.length){for(var s=e.getModel("minorSplitLine").getModel("lineStyle"),l=[],u=0;u<a.length;u++)for(var h=0;h<a[u].length;h++)l.push(new yu({shape:{cx:n.cx,cy:n.cy,r:a[u][h].coord}}));t.add(Bh(l,{style:k({fill:null},s.getLineStyle()),silent:!0}))}},splitArea:function(t,e,n,i,r,o){if(o.length){var a=e.getModel("splitArea").getModel("areaStyle"),s=a.get("color"),l=0;s=s instanceof Array?s:[s];for(var u=[],h=o[0].coord,c=1;c<o.length;c++){var p=l++%s.length;u[p]=u[p]||[],u[p].push(new Nu({shape:{cx:n.cx,cy:n.cy,r0:h,r:o[c].coord,startAngle:0,endAngle:2*Math.PI},silent:!0})),h=o[c].coord}// Simple optimization
// Batching the lines if color are the same
for(c=0;c<u.length;c++)t.add(Bh(u[c],{style:k({fill:s[c%s.length]},a.getAreaStyle()),silent:!0}))}}};const nV=tV;function iV(t){return t.get("stack")||"__ec_stack_"+t.seriesIndex}function rV(t,e){return e.dim+t.model.componentIndex}function oV(t,e,n){var i={},r=
/**
             * Calculate bar width and offset for radial bar charts
             */
function(t){// Columns info on each category axis. Key is polar name
var e={};R(t,(function(t,n){var i=t.getData(),r=t.coordinateSystem,o=r.getBaseAxis(),a=rV(r,o),s=o.getExtent(),l="category"===o.type?o.getBandWidth():Math.abs(s[1]-s[0])/i.count(),u=e[a]||{bandWidth:l,remainedWidth:l,autoWidthCount:0,categoryGap:"20%",gap:"30%",stacks:{}},h=u.stacks;e[a]=u;var c=iV(t);h[c]||u.autoWidthCount++,h[c]=h[c]||{width:0,maxWidth:0};var p=Vr(t.get("barWidth"),l),d=Vr(t.get("barMaxWidth"),l),f=t.get("barGap"),g=t.get("barCategoryGap");p&&!h[c].width&&(p=Math.min(u.remainedWidth,p),h[c].width=p,u.remainedWidth-=p),d&&(h[c].maxWidth=d),null!=f&&(u.gap=f),null!=g&&(u.categoryGap=g)}));var n={};return R(e,(function(t,e){n[e]={};var i=t.stacks,r=t.bandWidth,o=Vr(t.categoryGap,r),a=Vr(t.gap,1),s=t.remainedWidth,l=t.autoWidthCount,u=(s-o)/(l+(l-1)*a);u=Math.max(u,0),// Find if any auto calculated bar exceeded maxBarWidth
R(i,(function(t,e){var n=t.maxWidth;n&&n<u&&(n=Math.min(n,s),t.width&&(n=Math.min(n,t.width)),s-=n,t.width=n,l--)})),// Recalculate width again
u=(s-o)/(l+(l-1)*a),u=Math.max(u,0);var h,c=0;R(i,(function(t,e){t.width||(t.width=u),h=t,c+=t.width*(1+a)})),h&&(c-=h.width*a);var p=-c/2;R(i,(function(t,i){n[e][i]=n[e][i]||{offset:p,width:t.width},p+=t.width*(1+a)}))})),n}(z(e.getSeriesByType(t),(function(t){return!e.isSeriesFiltered(t)&&t.coordinateSystem&&"polar"===t.coordinateSystem.type})));e.eachSeriesByType(t,(function(t){// Check series coordinate, do layout for polar only
if("polar"===t.coordinateSystem.type){var e=t.getData(),n=t.coordinateSystem,o=n.getBaseAxis(),a=rV(n,o),s=iV(t),l=r[a][s],u=l.offset,h=l.width,c=n.getOtherAxis(o),p=t.coordinateSystem.cx,d=t.coordinateSystem.cy,f=t.get("barMinHeight")||0,g=t.get("barMinAngle")||0;i[s]=i[s]||[];for(var y=e.mapDimension(c.dim),v=e.mapDimension(o.dim),m=Ix(e,y/* , baseDim */),x="radius"!==o.dim||!t.get("roundCap",!0),_=c.dataToCoord(0),b=0,w=e.count();b<w;b++){var S=e.get(y,b),M=e.get(v,b),I=S>=0?"p":"n",T=_;// Because of the barMinHeight, we can not use the value in
// stackResultDimension directly.
// Only ordinal axis can be stacked.
m&&(i[s][M]||(i[s][M]={p:_,n:_}),// Should also consider #4243
T=i[s][M][I]);var C=void 0,D=void 0,A=void 0,k=void 0;// radial sector
if("radius"===c.dim){var L=c.dataToCoord(S)-_,P=o.dataToCoord(M);Math.abs(L)<f&&(L=(L<0?-1:1)*f),C=T,D=T+L,k=(A=P-u)-h,m&&(i[s][M][I]=D)}// tangential sector
else{var O=c.dataToCoord(S,x)-_,R=o.dataToCoord(M);Math.abs(O)<g&&(O=(O<0?-1:1)*g),D=(C=R+u)+h,A=T,k=T+O,// if the previous stack is at the end of the ring,
// add a round to differentiate it from origin
// let extent = angleAxis.getExtent();
// let stackCoord = angle;
// if (stackCoord === extent[0] && value > 0) {
//     stackCoord = extent[1];
// }
// else if (stackCoord === extent[1] && value < 0) {
//     stackCoord = extent[0];
// }
m&&(i[s][M][I]=k)}e.setItemLayout(b,{cx:p,cy:d,r0:C,r:D,// Consider that positive angle is anti-clockwise,
// while positive radian of sector is clockwise
startAngle:-A*Math.PI/180,endAngle:-k*Math.PI/180,
/**
                     * Keep the same logic with bar in catesion: use end value to
                     * control direction. Notice that if clockwise is true (by
                     * default), the sector will always draw clockwisely, no matter
                     * whether endAngle is greater or less than startAngle.
                     */
clockwise:A>=k})}}}))}var aV={startAngle:90,clockwise:!0,splitNumber:12,axisLabel:{rotate:0}},sV={splitNumber:5},lV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="polar",e}(Bg);function uV(t,e){e=e||{};var n=t.coordinateSystem,i=t.axis,r={},o=i.position,a=i.orient,s=n.getRect(),l=[s.x,s.x+s.width,s.y,s.y+s.height],u={horizontal:{top:l[2],bottom:l[3]},vertical:{left:l[0],right:l[1]}};r.position=["vertical"===a?u.vertical[o]:l[0],"horizontal"===a?u.horizontal[o]:l[3]],r.rotation=Math.PI/2*{horizontal:0,vertical:1}[a],r.labelDirection=r.tickDirection=r.nameDirection={top:-1,bottom:1,right:1,left:-1}[o],t.get(["axisTick","inside"])&&(r.tickDirection=-r.tickDirection),J(e.labelInside,t.get(["axisLabel","inside"]))&&(r.labelDirection=-r.labelDirection);var h=e.rotate;return null==h&&(h=t.get(["axisLabel","rotate"])),r.labelRotation="top"===o?-h:h,r.z2=1,r}var hV=["axisLine","axisTickLabel","axisName"],cV=["splitArea","splitLine"],pV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.axisPointerClass="SingleAxisPointer",n}return n(e,t),e.prototype.render=function(e,n,i,r){var o=this.group;o.removeAll();var a=this._axisGroup;this._axisGroup=new Lr;var s=uV(e),l=new BI(e,s);R(hV,l.add,l),o.add(this._axisGroup),o.add(l.getGroup()),R(cV,(function(t){e.get([t,"show"])&&dV[t](this,this.group,this._axisGroup,e)}),this),Zh(a,this._axisGroup,e),t.prototype.render.call(this,e,n,i,r)},e.prototype.remove=function(){$I(this)},e.type="singleAxis",e}(jI),dV={splitLine:function(t,e,n,i){var r=i.axis;if(!r.scale.isBlank()){var o=i.getModel("splitLine"),a=o.getModel("lineStyle"),s=a.get("color");s=s instanceof Array?s:[s];for(var l=a.get("width"),u=i.coordinateSystem.getRect(),h=r.isHorizontal(),c=[],p=0,d=r.getTicksCoords({tickModel:o}),f=[],g=[],y=0;y<d.length;++y){var v=r.toGlobalCoord(d[y].coord);h?(f[0]=v,f[1]=u.y,g[0]=v,g[1]=u.y+u.height):(f[0]=u.x,f[1]=v,g[0]=u.x+u.width,g[1]=v);var m=new qu({shape:{x1:f[0],y1:f[1],x2:g[0],y2:g[1]},silent:!0});Gh(m.shape,l);var x=p++%s.length;c[x]=c[x]||[],c[x].push(m)}var _=a.getLineStyle(["color"]);for(y=0;y<c.length;++y)e.add(Bh(c[y],{style:k({stroke:s[y%s.length]},_),silent:!0}))}},splitArea:function(t,e,n,i){KI(t,n,i,i)}};const fV=pV;var gV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.getCoordSysModel=function(){return this},e.type="singleAxis",e.layoutMode="box",e.defaultOption={left:"5%",top:"5%",right:"5%",bottom:"5%",type:"value",position:"bottom",orient:"horizontal",axisLine:{show:!0,lineStyle:{width:1,type:"solid"}},// Single coordinate system and single axis is the,
// which is used as the parent tooltip model.
// same model, so we set default tooltip show as true.
tooltip:{show:!0},axisTick:{show:!0,length:6,lineStyle:{width:1}},axisLabel:{show:!0,interval:"auto"},splitLine:{show:!0,lineStyle:{type:"dashed",opacity:.2}}},e}(Wp);P(gV,F_.prototype);const yV=gV;var vV=/** @class */function(t){function e(e,n,i,r,o){var a=t.call(this,e,n,i)||this;return a.type=r||"value",a.position=o||"bottom",a}
/**
               * Judge the orient of the axis.
               */return n(e,t),e.prototype.isHorizontal=function(){var t=this.position;return"top"===t||"bottom"===t},e.prototype.pointToData=function(t,e){return this.coordinateSystem.pointToData(t)[0]},e}(pb);const mV=vV;var xV=["single"],_V=/** @class */function(){function t(t,e,n){this.type="single",this.dimension="single",
/**
                 * Add it just for draw tooltip.
                 */
this.dimensions=xV,this.axisPointerEnabled=!0,this.model=t,this._init(t,e,n)}
/**
               * Initialize single coordinate system.
               */return t.prototype._init=function(t,e,n){var i=this.dimension,r=new mV(i,O_(t),[0,0],t.get("type"),t.get("position")),o="category"===r.type;r.onBand=o&&t.get("boundaryGap"),r.inverse=t.get("inverse"),r.orient=t.get("orient"),t.axis=r,r.model=t,r.coordinateSystem=this,this._axis=r},
/**
               * Update axis scale after data processed
               */
t.prototype.update=function(t,e){t.eachSeries((function(t){if(t.coordinateSystem===this){var e=t.getData();R(e.mapDimensionsAll(this.dimension),(function(t){this._axis.scale.unionExtentFromData(e,t)}),this),P_(this._axis.scale,this._axis.model)}}),this)},
/**
               * Resize the single coordinate system.
               */
t.prototype.resize=function(t,e){this._rect=Rp({left:t.get("left"),top:t.get("top"),right:t.get("right"),bottom:t.get("bottom"),width:t.get("width"),height:t.get("height")},{width:e.getWidth(),height:e.getHeight()}),this._adjustAxis()},t.prototype.getRect=function(){return this._rect},t.prototype._adjustAxis=function(){var t=this._rect,e=this._axis,n=e.isHorizontal(),i=n?[0,t.width]:[0,t.height],r=e.inverse?1:0;e.setExtent(i[r],i[1-r]),this._updateAxisTransform(e,n?t.x:t.y)},t.prototype._updateAxisTransform=function(t,e){var n=t.getExtent(),i=n[0]+n[1],r=t.isHorizontal();t.toGlobalCoord=r?function(t){return t+e}:function(t){return i-t+e},t.toLocalCoord=r?function(t){return t-e}:function(t){return i-t+e}},
/**
               * Get axis.
               */
t.prototype.getAxis=function(){return this._axis},
/**
               * Get axis, add it just for draw tooltip.
               */
t.prototype.getBaseAxis=function(){return this._axis},t.prototype.getAxes=function(){return[this._axis]},t.prototype.getTooltipAxes=function(){return{baseAxes:[this.getAxis()],// Empty otherAxes
otherAxes:[]}},
/**
               * If contain point.
               */
t.prototype.containPoint=function(t){var e=this.getRect(),n=this.getAxis();return"horizontal"===n.orient?n.contain(n.toLocalCoord(t[0]))&&t[1]>=e.y&&t[1]<=e.y+e.height:n.contain(n.toLocalCoord(t[1]))&&t[0]>=e.y&&t[0]<=e.y+e.height},t.prototype.pointToData=function(t){var e=this.getAxis();return[e.coordToData(e.toLocalCoord(t["horizontal"===e.orient?0:1]))]},
/**
               * Convert the series data to concrete point.
               * Can be [val] | val
               */
t.prototype.dataToPoint=function(t){var e=this.getAxis(),n=this.getRect(),i=[],r="horizontal"===e.orient?0:1;return t instanceof Array&&(t=t[0]),i[r]=e.toGlobalCoord(e.dataToCoord(+t)),i[1-r]=0===r?n.y+n.height/2:n.x+n.width/2,i},t.prototype.convertToPixel=function(t,e,n){return bV(e)===this?this.dataToPoint(n):null},t.prototype.convertFromPixel=function(t,e,n){return bV(e)===this?this.pointToData(n):null},t}();
/**
             * Create a single coordinates system.
             */function bV(t){var e=t.seriesModel,n=t.singleAxisModel;return n&&n.coordinateSystem||e&&e.coordinateSystem}
/**
             * Create single coordinate system and inject it into seriesModel.
             */const wV={create:function(t,e){var n=[];return t.eachComponent("singleAxis",(function(i,r){var o=new _V(i,t,e);o.name="single_"+r,o.resize(i,e),i.coordinateSystem=o,n.push(o)})),t.eachSeries((function(t){if("singleAxis"===t.get("coordinateSystem")){var e=t.getReferringComponents("singleAxis",Io).models[0];t.coordinateSystem=e&&e.coordinateSystem}})),n},dimensions:xV};var SV=["x","y"],MV=["width","height"],IV=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}
/**
               * @override
               */return n(e,t),e.prototype.makeElOption=function(t,e,n,i,r){var o=n.axis,a=o.coordinateSystem,s=DV(a,1-CV(o)),l=a.dataToPoint(e)[0],u=i.get("type");if(u&&"none"!==u){var h=UE(i),c=TV[u](o,l,s);c.style=h,t.graphicKey=c.type,t.pointer=c}KE(// @ts-ignore
e,t,uV(n),n,i,r)},
/**
               * @override
               */
e.prototype.getHandleTransform=function(t,e,n){var i=uV(e,{labelInside:!1});// @ts-ignore
i.labelMargin=n.get(["handle","margin"]);var r=qE(e.axis,t,i);return{x:r[0],y:r[1],rotation:i.rotation+(i.labelDirection<0?Math.PI:0)}},
/**
               * @override
               */
e.prototype.updateHandleTransform=function(t,e,n,i){var r=n.axis,o=r.coordinateSystem,a=CV(r),s=DV(o,a),l=[t.x,t.y];l[a]+=e[a],l[a]=Math.min(s[1],l[a]),l[a]=Math.max(s[0],l[a]);var u=DV(o,1-a),h=(u[1]+u[0])/2,c=[h,h];return c[a]=l[a],{x:l[0],y:l[1],rotation:t.rotation,cursorPoint:c,tooltipOption:{verticalAlign:"middle"}}},e}(XE),TV={line:function(t,e,n){return{type:"Line",subPixelOptimize:!0,shape:$E([e,n[0]],[e,n[1]],CV(t))}},shadow:function(t,e,n){var i=t.getBandWidth(),r=n[1]-n[0];return{type:"Rect",shape:JE([e-i/2,n[0]],[i,r],CV(t))}}};function CV(t){return t.isHorizontal()?0:1}function DV(t,e){var n=t.getRect();return[n[SV[e]],n[SV[e]]+n[MV[e]]]}const AV=IV;var kV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="single",e}(Bg),LV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * @override
               */return n(e,t),e.prototype.init=function(e,n,i){var r=Vp(e);t.prototype.init.apply(this,arguments),PV(e,r)},
/**
               * @override
               */
e.prototype.mergeOption=function(e){t.prototype.mergeOption.apply(this,arguments),PV(this.option,e)},e.prototype.getCellSize=function(){// Has been normalized
return this.option.cellSize},e.type="calendar",e.defaultOption={// zlevel: 0,
z:2,left:80,top:60,cellSize:20,// horizontal vertical
orient:"horizontal",// month separate line style
splitLine:{show:!0,lineStyle:{color:"#000",width:1,type:"solid"}},// rect style  temporarily unused emphasis
itemStyle:{color:"#fff",borderWidth:1,borderColor:"#ccc"},// week text style
dayLabel:{show:!0,firstDay:0,// start end
position:"start",margin:"50%",color:"#000"},// month text style
monthLabel:{show:!0,// start end
position:"start",margin:5,// center or left
align:"center",formatter:null,color:"#000"},// year text style
yearLabel:{show:!0,// top bottom left right
position:null,margin:30,formatter:null,color:"#ccc",fontFamily:"sans-serif",fontWeight:"bolder",fontSize:20}},e}(Wp);function PV(t,e){// Normalize cellSize
var n,i=t.cellSize;1===(n=G(i)?i:t.cellSize=[i,i]).length&&(n[1]=n[0]);var r=N([0,1],(function(t){// If user have set `width` or both `left` and `right`, cellSizeArr
// will be automatically set to 'auto', otherwise the default
// setting of cellSizeArr will make `width` setting not work.
return function(t,e){return null!=t[Lp[e][0]]||null!=t[Lp[e][1]]&&null!=t[Lp[e][2]]}(e,t)&&(n[t]="auto"),null!=n[t]&&"auto"!==n[t]}));zp(t,e,{type:"box",ignoreSize:r})}const OV=LV;var RV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){var i=this.group;i.removeAll();var r=t.coordinateSystem,o=r.getRangeInfo(),a=r.getOrient(),s=e.getLocaleModel();// range info
this._renderDayRect(t,o,i),// _renderLines must be called prior to following function
this._renderLines(t,o,a,i),this._renderYearText(t,o,a,i),this._renderMonthText(t,s,a,i),this._renderWeekText(t,s,o,a,i)},// render day rect
e.prototype._renderDayRect=function(t,e,n){for(var i=t.coordinateSystem,r=t.getModel("itemStyle").getItemStyle(),o=i.getCellWidth(),a=i.getCellHeight(),s=e.start.time;s<=e.end.time;s=i.getNextNDay(s,1).time){var l=i.dataToRect([s],!1).tl,u=new Ls({shape:{x:l[0],y:l[1],width:o,height:a},cursor:"default",style:r});// every rect
n.add(u)}},// render separate line
e.prototype._renderLines=function(t,e,n,i){var r=this,o=t.coordinateSystem,a=t.getModel(["splitLine","lineStyle"]).getLineStyle(),s=t.get(["splitLine","show"]),l=a.lineWidth;this._tlpoints=[],this._blpoints=[],this._firstDayOfMonth=[],this._firstDayPoints=[];for(var u=e.start,h=0;u.time<=e.end.time;h++){p(u.formatedDate),0===h&&(u=o.getDateInfo(e.start.y+"-"+e.start.m));var c=u.date;c.setMonth(c.getMonth()+1),u=o.getDateInfo(c)}function p(e){r._firstDayOfMonth.push(o.getDateInfo(e)),r._firstDayPoints.push(o.dataToRect([e],!1).tl);var l=r._getLinePointsOfOneWeek(t,e,n);r._tlpoints.push(l[0]),r._blpoints.push(l[l.length-1]),s&&r._drawSplitline(l,a,i)}// render top/left line
p(o.getNextNDay(e.end.time,1).formatedDate),s&&this._drawSplitline(r._getEdgesPoints(r._tlpoints,l,n),a,i),// render bottom/right line
s&&this._drawSplitline(r._getEdgesPoints(r._blpoints,l,n),a,i)},// get points at both ends
e.prototype._getEdgesPoints=function(t,e,n){var i=[t[0].slice(),t[t.length-1].slice()],r="horizontal"===n?0:1;// both ends of the line are extend half lineWidth
return i[0][r]=i[0][r]-e/2,i[1][r]=i[1][r]+e/2,i},// render split line
e.prototype._drawSplitline=function(t,e,n){var i=new Xu({z2:20,shape:{points:t},style:e});n.add(i)},// render month line of one week points
e.prototype._getLinePointsOfOneWeek=function(t,e,n){for(var i=t.coordinateSystem,r=i.getDateInfo(e),o=[],a=0;a<7;a++){var s=i.getNextNDay(r.time,a),l=i.dataToRect([s.time],!1);o[2*s.day]=l.tl,o[2*s.day+1]=l["horizontal"===n?"bl":"tr"]}return o},e.prototype._formatterLabel=function(t,e){return H(t)&&t?(n=t,R(e,(function(t,e){n=n.replace("{"+e+"}",i?qt(t):t)})),n):W(t)?t(e):e.nameMap;var n,i},e.prototype._yearTextPositionControl=function(t,e,n,i,r){var o=e[0],a=e[1],s=["center","bottom"];"bottom"===i?(a+=r,s=["center","top"]):"left"===i?o-=r:"right"===i?(o+=r,s=["center","top"]):// top
a-=r;var l=0;return"left"!==i&&"right"!==i||(l=Math.PI/2),{rotation:l,x:o,y:a,style:{align:s[0],verticalAlign:s[1]}}},// render year
e.prototype._renderYearText=function(t,e,n,i){var r=t.getModel("yearLabel");if(r.get("show")){var o=r.get("margin"),a=r.get("position");a||(a="horizontal"!==n?"top":"left");var s=[this._tlpoints[this._tlpoints.length-1],this._blpoints[0]],l=(s[0][0]+s[1][0])/2,u=(s[0][1]+s[1][1])/2,h="horizontal"===n?0:1,c={top:[l,s[h][1]],bottom:[l,s[1-h][1]],left:[s[1-h][0],u],right:[s[h][0],u]},p=e.start.y;+e.end.y>+e.start.y&&(p=p+"-"+e.end.y);var d=r.get("formatter"),f={start:e.start.y,end:e.end.y,nameMap:p},g=this._formatterLabel(d,f),y=new Zs({z2:30,style:lc(r,{text:g})});y.attr(this._yearTextPositionControl(y,c[a],n,a,o)),i.add(y)}},e.prototype._monthTextPositionControl=function(t,e,n,i,r){var o="left",a="top",s=t[0],l=t[1];return"horizontal"===n?(l+=r,e&&(o="center"),"start"===i&&(a="bottom")):(s+=r,e&&(a="middle"),"start"===i&&(o="right")),{x:s,y:l,align:o,verticalAlign:a}},// render month and year text
e.prototype._renderMonthText=function(t,e,n,i){var r=t.getModel("monthLabel");if(r.get("show")){var o=r.get("nameMap"),a=r.get("margin"),s=r.get("position"),l=r.get("align"),u=[this._tlpoints,this._blpoints];o&&!H(o)||(o&&(// case-sensitive
e=Hc(o)||e),// PENDING
// for ZH locale, original form is `` but current form is `1`
o=e.get(["time","monthAbbr"])||[]);var h="start"===s?0:1,c="horizontal"===n?0:1;a="start"===s?-a:a;for(var p="center"===l,d=0;d<u[h].length-1;d++){var f=u[h][d].slice(),g=this._firstDayOfMonth[d];if(p){var y=this._firstDayPoints[d];f[c]=(y[c]+u[0][d+1][c])/2}var v=r.get("formatter"),m=o[+g.m-1],x={yyyy:g.y,yy:(g.y+"").slice(2),MM:g.m,M:+g.m,nameMap:m},_=this._formatterLabel(v,x),b=new Zs({z2:30,style:A(lc(r,{text:_}),this._monthTextPositionControl(f,p,n,s,a))});i.add(b)}}},e.prototype._weekTextPositionControl=function(t,e,n,i,r){var o="center",a="middle",s=t[0],l=t[1],u="start"===n;return"horizontal"===e?(s=s+i+(u?1:-1)*r[0]/2,o=u?"right":"left"):(l=l+i+(u?1:-1)*r[1]/2,a=u?"bottom":"top"),{x:s,y:l,align:o,verticalAlign:a}},// render weeks
e.prototype._renderWeekText=function(t,e,n,i,r){var o=t.getModel("dayLabel");if(o.get("show")){var a=t.coordinateSystem,s=o.get("position"),l=o.get("nameMap"),u=o.get("margin"),h=a.getFirstDayOfWeek();l&&!H(l)||(l&&(// case-sensitive
e=Hc(l)||e),l=e.get(["time","dayOfWeekShort"])||N(e.get(["time","dayOfWeekAbbr"]),(function(t){return t[0]})));var c=a.getNextNDay(n.end.time,7-n.lweek).time,p=[a.getCellWidth(),a.getCellHeight()];u=Vr(u,Math.min(p[1],p[0])),"start"===s&&(c=a.getNextNDay(n.start.time,-(7+n.fweek)).time,u=-u);for(var d=0;d<7;d++){var f,g=a.getNextNDay(c,d),y=a.dataToRect([g.time],!1).center;f=Math.abs((d+h)%7);var v=new Zs({z2:30,style:A(lc(o,{text:l[f]}),this._weekTextPositionControl(y,i,s,u,p))});r.add(v)}}},e.type="calendar",e}(Bg);const NV=RV;var EV=864e5,zV=/** @class */function(){function t(e,n,i){this.type="calendar",this.dimensions=t.dimensions,// Required in createListFromData
this.getDimensionsInfo=t.getDimensionsInfo,this._model=e}return t.getDimensionsInfo=function(){return[{name:"time",type:"time"},"value"]},t.prototype.getRangeInfo=function(){return this._rangeInfo},t.prototype.getModel=function(){return this._model},t.prototype.getRect=function(){return this._rect},t.prototype.getCellWidth=function(){return this._sw},t.prototype.getCellHeight=function(){return this._sh},t.prototype.getOrient=function(){return this._orient},
/**
               * getFirstDayOfWeek
               *
               * @example
               *     0 : start at Sunday
               *     1 : start at Monday
               *
               * @return {number}
               */
t.prototype.getFirstDayOfWeek=function(){return this._firstDayOfWeek},
/**
               * get date info
               * }
               */
t.prototype.getDateInfo=function(t){var e=(t=jr(t)).getFullYear(),n=t.getMonth()+1,i=n<10?"0"+n:""+n,r=t.getDate(),o=r<10?"0"+r:""+r,a=t.getDay();return{y:e+"",m:i,d:o,day:a=Math.abs((a+7-this.getFirstDayOfWeek())%7),time:t.getTime(),formatedDate:e+"-"+i+"-"+o,date:t}},t.prototype.getNextNDay=function(t,e){return 0===(e=e||0)||(t=new Date(this.getDateInfo(t).time)).setDate(t.getDate()+e),this.getDateInfo(t)},t.prototype.update=function(t,e){this._firstDayOfWeek=+this._model.getModel("dayLabel").get("firstDay"),this._orient=this._model.get("orient"),this._lineWidth=this._model.getModel("itemStyle").getItemStyle().lineWidth||0,this._rangeInfo=this._getRangeInfo(this._initRangeOption());var n=this._rangeInfo.weeks||1,i=["width","height"],r=this._model.getCellSize().slice(),o=this._model.getBoxLayoutParams(),a="horizontal"===this._orient?[n,7]:[7,n];R([0,1],(function(t){u(r,t)&&(o[i[t]]=r[t]*a[t])}));var s={width:e.getWidth(),height:e.getHeight()},l=this._rect=Rp(o,s);function u(t,e){return null!=t[e]&&"auto"!==t[e]}// Has been calculated out number.
R([0,1],(function(t){u(r,t)||(r[t]=l[i[t]]/a[t])})),this._sw=r[0],this._sh=r[1]},
/**
               * Convert a time data(time, value) item to (x, y) point.
               */
// TODO Clamp of calendar is not same with cartesian coordinate systems.
// It will return NaN if data exceeds.
t.prototype.dataToPoint=function(t,e){G(t)&&(t=t[0]),null==e&&(e=!0);var n=this.getDateInfo(t),i=this._rangeInfo,r=n.formatedDate;// if not in range return [NaN, NaN]
if(e&&!(n.time>=i.start.time&&n.time<i.end.time+EV))return[NaN,NaN];var o=n.day,a=this._getRangeInfo([i.start.time,r]).nthWeek;return"vertical"===this._orient?[this._rect.x+o*this._sw+this._sw/2,this._rect.y+a*this._sh+this._sh/2]:[this._rect.x+a*this._sw+this._sw/2,this._rect.y+o*this._sh+this._sh/2]},
/**
               * Convert a (x, y) point to time data
               */
t.prototype.pointToData=function(t){var e=this.pointToDate(t);return e&&e.time},
/**
               * Convert a time date item to (x, y) four point.
               */
t.prototype.dataToRect=function(t,e){var n=this.dataToPoint(t,e);return{contentShape:{x:n[0]-(this._sw-this._lineWidth)/2,y:n[1]-(this._sh-this._lineWidth)/2,width:this._sw-this._lineWidth,height:this._sh-this._lineWidth},center:n,tl:[n[0]-this._sw/2,n[1]-this._sh/2],tr:[n[0]+this._sw/2,n[1]-this._sh/2],br:[n[0]+this._sw/2,n[1]+this._sh/2],bl:[n[0]-this._sw/2,n[1]+this._sh/2]}},
/**
               * Convert a (x, y) point to time date
               *
               * @param  {Array} point point
               * @return {Object}       date
               */
t.prototype.pointToDate=function(t){var e=Math.floor((t[0]-this._rect.x)/this._sw)+1,n=Math.floor((t[1]-this._rect.y)/this._sh)+1,i=this._rangeInfo.range;return"vertical"===this._orient?this._getDateByWeeksAndDay(n,e-1,i):this._getDateByWeeksAndDay(e,n-1,i)},t.prototype.convertToPixel=function(t,e,n){var i=VV(e);return i===this?i.dataToPoint(n):null},t.prototype.convertFromPixel=function(t,e,n){var i=VV(e);return i===this?i.pointToData(n):null},t.prototype.containPoint=function(t){return!1},
/**
               * initRange
               * Normalize to an [start, end] array
               */
t.prototype._initRangeOption=function(){var t,e=this._model.get("range");if(// Convert [1990] to 1990
G(e)&&1===e.length&&(e=e[0]),G(e))t=e;else{var n=e.toString();// One year.
// One month
if(/^\d{4}$/.test(n)&&(t=[n+"-01-01",n+"-12-31"]),/^\d{4}[\/|-]\d{1,2}$/.test(n)){var i=this.getDateInfo(n),r=i.date;r.setMonth(r.getMonth()+1);var o=this.getNextNDay(r,-1);t=[i.formatedDate,o.formatedDate]}// One day
/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n)&&(t=[n,n])}if(!t)return e;var a=this._getRangeInfo(t);return a.start.time>a.end.time&&t.reverse(),t},
/**
               * range info
               *
               * @private
               * @param  {Array} range range ['2017-01-01', '2017-07-08']
               *  If range[0] > range[1], they will not be reversed.
               * @return {Object}       obj
               */
t.prototype._getRangeInfo=function(t){var e,n=[this.getDateInfo(t[0]),this.getDateInfo(t[1])];n[0].time>n[1].time&&(e=!0,n.reverse());var i=Math.floor(n[1].time/EV)-Math.floor(n[0].time/EV)+1,r=new Date(n[0].time),o=r.getDate(),a=n[1].date.getDate();// Consider case1 (#11677 #10430):
// Set the system timezone as "UK", set the range to `['2016-07-01', '2016-12-31']`
// Consider case2:
// Firstly set system timezone as "Time Zone: America/Toronto",
// ```
// let first = new Date(1478412000000 - 3600 * 1000 * 2.5);
// let second = new Date(1478412000000);
// let allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;
// ```
// will get wrong result because of DST. So we should fix it.
r.setDate(o+i-1);// The bias can not over a month, so just compare date.
var s=r.getDate();if(s!==a)for(var l=r.getTime()-n[1].time>0?1:-1;(s=r.getDate())!==a&&(r.getTime()-n[1].time)*l>0;)i-=l,r.setDate(s-l);var u=Math.floor((i+n[0].day+6)/7),h=e?1-u:u-1;return e&&n.reverse(),{range:[n[0].formatedDate,n[1].formatedDate],start:n[0],end:n[1],allDay:i,weeks:u,// From 0.
nthWeek:h,fweek:n[0].day,lweek:n[1].day}},
/**
               * get date by nthWeeks and week day in range
               *
               * @private
               * @param  {number} nthWeek the week
               * @param  {number} day   the week day
               * @param  {Array} range [d1, d2]
               * @return {Object}
               */
t.prototype._getDateByWeeksAndDay=function(t,e,n){var i=this._getRangeInfo(n);if(t>i.weeks||0===t&&e<i.fweek||t===i.weeks&&e>i.lweek)return null;var r=7*(t-1)-i.fweek+e,o=new Date(i.start.time);return o.setDate(+i.start.d+r),this.getDateInfo(o)},t.create=function(e,n){var i=[];return e.eachComponent("calendar",(function(e){var n=new t(e);i.push(n),e.coordinateSystem=n})),e.eachSeries((function(t){"calendar"===t.get("coordinateSystem")&&(// Inject coordinate system
t.coordinateSystem=i[t.get("calendarIndex")||0])})),i},t.dimensions=["time","value"],t}();function VV(t){var e=t.calendarModel,n=t.seriesModel;return e?e.coordinateSystem:n?n.coordinateSystem:null}const BV=zV;function FV(t,e){var n;return R(e,(function(e){null!=t[e]&&"auto"!==t[e]&&(n=!0)})),n}var GV=["transition","enterFrom","leaveTo"],WV=GV.concat(["enterAnimation","updateAnimation","leaveAnimation"]);function HV(t,e,n){if(n&&(!t[n]&&e[n]&&(// TODO avoid creating this empty object when there is no transition configuration.
t[n]={}),t=t[n],e=e[n]),t&&e)for(var i=n?GV:WV,r=0;r<i.length;r++){var o=i[r];null==t[o]&&null!=e[o]&&(t[o]=e[o])}}var YV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.preventAutoZ=!0,n}return n(e,t),e.prototype.mergeOption=function(e,n){// Prevent default merge to elements
var i=this.option.elements;this.option.elements=null,t.prototype.mergeOption.call(this,e,n),this.option.elements=i},e.prototype.optionUpdated=function(t,e){var n=this.option,i=(e?n:t).elements,r=n.elements=e?[]:n.elements,o=[];this._flatten(i,o,null);var a=fo(r,o,"normalMerge"),s=this._elOptionsToUpdate=[];// Clear elOptionsToUpdate
R(a,(function(t,e){var n=t.newOption;n&&(s.push(n),function(t,e){var n=t.existing;// Set id and type after id assigned.
// Set parent id if not specified
if(e.id=t.keyInfo.id,!e.type&&n&&(e.type=n.type),null==e.parentId){var i=e.parentOption;i?e.parentId=i.id:n&&(e.parentId=n.parentId)}// Clear
e.parentOption=null}(t,n),function(t,e,n){// Update existing options, for `getOption` feature.
var i=A({},n),r=t[e],o=n.$action||"merge";"merge"===o?r?(// the same object, so `merge` will not change newElOptCopy.
C(r,i,!0),// Rigid body, use ignoreSize.
zp(r,i,{ignoreSize:!0}),// Will be used in render.
Bp(n,r),// Copy transition info to new option so it can be used in the transition.
// DO IT AFTER merge
HV(n,r),HV(n,r,"shape"),HV(n,r,"style"),HV(n,r,"extra"),// Copy clipPath
n.clipPath=r.clipPath):t[e]=i:"replace"===o?t[e]=i:"remove"===o&&// null will be cleaned later.
r&&(t[e]=null)}(r,e,n),function(t,e){if(t&&(t.hv=e.hv=[// Rigid body, don't care about `width`.
FV(e,["left","right"]),// Rigid body, don't care about `height`.
FV(e,["top","bottom"])],"group"===t.type)){var n=t,i=e;null==n.width&&(n.width=i.width=0),null==n.height&&(n.height=i.height=0)}}(r[e],n))}),this),// Clean
n.elements=z(r,(function(t){// $action should be volatile, otherwise option gotten from
// `getOption` will contain unexpected $action.
return t&&delete t.$action,null!=t}))},
/**
               * Convert
               * [{
               *  type: 'group',
               *  id: 'xx',
               *  children: [{type: 'circle'}, {type: 'polygon'}]
               * }]
               * to
               * [
               *  {type: 'group', id: 'xx'},
               *  {type: 'circle', parentId: 'xx'},
               *  {type: 'polygon', parentId: 'xx'}
               * ]
               */
e.prototype._flatten=function(t,e,n){R(t,(function(t){if(t){n&&(t.parentOption=n),e.push(t);var i=t.children;// here we don't judge if option.type is `group`
// when new option doesn't provide `type`, it will cause that the children can't be updated.
i&&i.length&&this._flatten(i,e,t),// Deleting for JSON output, and for not affecting group creation.
delete t.children}}),this)},// FIXME
// Pass to view using payload? setOption has a payload?
e.prototype.useElOptionsToUpdate=function(){var t=this._elOptionsToUpdate;// Clear to avoid render duplicately when zooming.
return this._elOptionsToUpdate=null,t},e.type="graphic",e.defaultOption={elements:[]},e}(Wp),XV={// Reserved but not supported in graphic component.
path:null,compoundPath:null,// Supported in graphic component.
group:Lr,image:Ss,text:Zs},UV=bo(),ZV=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(){this._elMap=ct()},e.prototype.render=function(t,e,n){// Having leveraged between use cases and algorithm complexity, a very
// simple layout mechanism is used:
// The size(width/height) can be determined by itself or its parent (not
// implemented yet), but can not by its children. (Top-down travel)
// The location(x/y) can be determined by the bounding rect of itself
// (can including its descendants or not) and the size of its parent.
// (Bottom-up travel)
// When `chart.clear()` or `chart.setOption({...}, true)` with the same id,
// view will be reused.
t!==this._lastGraphicModel&&this._clear(),this._lastGraphicModel=t,this._updateElements(t),this._relocate(t,n)},
/**
               * Update graphic elements.
               */
e.prototype._updateElements=function(t){var e=t.useElOptionsToUpdate();if(e){var n=this._elMap,i=this.group,r=t.get("z"),o=t.get("zlevel");// Top-down tranverse to assign graphic settings to each elements.
R(e,(function(e){var a=vo(e.id,null),s=null!=a?n.get(a):null,l=vo(e.parentId,null),u=null!=l?n.get(l):i,h=e.type,c=e.style;"text"===h&&c&&e.hv&&e.hv[1]&&(c.textVerticalAlign=c.textBaseline=c.verticalAlign=c.align=null);var p=e.textContent,d=e.textConfig;if(c&&NN(c,h,!!d,!!p)){var f=EN(c,h,!0);!d&&f.textConfig&&(d=e.textConfig=f.textConfig),!p&&f.textContent&&(p=f.textContent)}// Remove unnecessary props to avoid potential problems.
var g=// Remove unnecessary props to avoid potential problems.
function(t){return t=A({},t),R(["id","parentId","$action","hv","bounding","textContent","clipPath"].concat(kp),(function(e){delete t[e]})),t}(e),y=e.$action||"merge",v="merge"===y,m="replace"===y;// For simple, do not support parent change, otherwise reorder is needed.
if(v){var x=s;(T=!s)?x=qV(a,u,e.type,n):(x&&(UV(x).isNew=!1),// Stop and restore before update any other attributes.
iE(x)),x&&(XN(x,g,t,{isInit:T}),$V(x,e,r,o))}else if(m){KV(s,e,n,t);var _=qV(a,u,e.type,n);_&&(XN(_,g,t,{isInit:!0}),$V(_,e,r,o))}else"remove"===y&&(UN(s,e),KV(s,e,n,t));var b=n.get(a);if(b&&p)if(v){var w=b.getTextContent();w?w.attr(p):b.setTextContent(new Zs(p))}else m&&b.setTextContent(new Zs(p));if(b){var S=e.clipPath;if(S){var M=S.type,I=void 0,T=!1;if(v){var C=b.getClipPath();I=(T=!C||UV(C).type!==M)?jV(M):C}else m&&(T=!0,I=jV(M));b.setClipPath(I),XN(I,S,t,{isInit:T}),rE(I,S.keyframeAnimation,t)}var D=UV(b);b.setTextConfig(d),D.option=e,function(t,e,n){var i=js(t).eventData;// Simple optimize for large amount of elements that no need event.
t.silent||t.ignore||i||(i=js(t).eventData={componentType:"graphic",componentIndex:e.componentIndex,name:t.name}),// `elOption.info` enables user to mount some info on
// elements and use them in event handlers.
i&&(i.info=n.info)}(b,t,e),Qh({el:b,componentModel:t,itemName:b.name,itemTooltipOption:e.tooltip}),rE(b,e.keyframeAnimation,t)}}))}},
/**
               * Locate graphic elements.
               */
e.prototype._relocate=function(t,e){// Top-down to calculate percentage width/height of group
for(var n=t.option.elements,i=this.group,r=this._elMap,o=e.getWidth(),a=e.getHeight(),s=["x","y"],l=0;l<n.length;l++)if((f=null!=(d=vo((p=n[l]).id,null))?r.get(d):null)&&f.isGroup){var u=(g=f.parent)===i,h=UV(f),c=UV(g);h.width=Vr(h.option.width,u?o:c.width)||0,h.height=Vr(h.option.height,u?a:c.height)||0}// Bottom-up tranvese all elements (consider ec resize) to locate elements.
for(l=n.length-1;l>=0;l--){var p,d,f;if(f=null!=(d=vo((p=n[l]).id,null))?r.get(d):null){var g=f.parent,y=(c=UV(g),{}),v=Np(f,p,g===i?{width:o,height:a}:{width:c.width,height:c.height},null,{hv:p.hv,boundingMode:p.bounding},y);if(!UV(f).isNew&&v){for(var m=p.transition,x={},_=0;_<s.length;_++){var b=s[_],w=y[b];m&&(jN(m)||L(m,b)>=0)?x[b]=w:f[b]=w}Sh(f,x,t,0)}else f.attr(y)}}},
/**
               * Clear all elements.
               */
e.prototype._clear=function(){var t=this,e=this._elMap;e.each((function(n){KV(n,UV(n).option,e,t._lastGraphicModel)})),this._elMap=ct()},e.prototype.dispose=function(){this._clear()},e.type="graphic",e}(Bg);function jV(t){var e=new(gt(XV,t)?XV[t]:Nh(t))({});return UV(e).type=t,e}function qV(t,e,n,i){var r=jV(n);return e.add(r),i.set(t,r),UV(r).id=t,UV(r).isNew=!0,r}function KV(t,e,n,i){t&&t.parent&&("group"===t.type&&t.traverse((function(t){KV(t,e,n,i)})),ZN(t,e,i),n.removeKey(UV(t).id))}function $V(t,e,n,i){t.isGroup||R([["cursor",fa.prototype.cursor],// We should not support configure z and zlevel in the element level.
// But seems we didn't limit it previously. So here still use it to avoid breaking.
["zlevel",i||0],["z",n||0],// z2 must not be null/undefined, otherwise sort error may occur.
["z2",0]],(function(n){var i=n[0];gt(e,i)?t[i]=Q(e[i],n[1]):null==t[i]&&(t[i]=n[1])})),R(V(e),(function(n){// Assign event handlers.
// PENDING: should enumerate all event names or use pattern matching?
if(0===n.indexOf("on")){var i=e[n];t[n]=W(i)?i:null}})),gt(e,"draggable")&&(t.draggable=e.draggable),// Other attributes
null!=e.name&&(t.name=e.name),null!=e.id&&(t.id=e.id)}var JV=["x","y","radius","angle","single"],QV=["cartesian2d","polar","singleAxis"];// Supported coords.
// FIXME: polar has been broken (but rarely used).
function tB(t){return t+"Axis"}
/**
             * If two dataZoomModels has the same axis controlled, we say that they are 'linked'.
             * This function finds all linked dataZoomModels start from the given payload.
             */function eB(t,e){// Key: `DataZoomAxisDimension`
var n,i=ct(),r=[],o=ct();// Find the dataZooms specified by payload.
t.eachComponent({mainType:"dataZoom",query:e},(function(t){o.get(t.uid)||s(t)}));do{n=!1,t.eachComponent("dataZoom",a)}while(n);function a(t){!o.get(t.uid)&&function(t){var e=!1;return t.eachTargetAxis((function(t,n){var r=i.get(t);r&&r[n]&&(e=!0)})),e}(t)&&(s(t),n=!0)}function s(t){o.set(t.uid,!0),r.push(t),t.eachTargetAxis((function(t,e){(i.get(t)||i.set(t,[]))[e]=!0}))}return r}
/**
             * Find the first target coordinate system.
             * Available after model built.
             *
             * @return Like {
             *                  grid: [
             *                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
             *                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
             *                      ...
             *                  ],  // cartesians must not be null/undefined.
             *                  polar: [
             *                      {model: coord0, axisModels: [axis4], coordIndex: 0},
             *                      ...
             *                  ],  // polars must not be null/undefined.
             *                  singleAxis: [
             *                      {model: coord0, axisModels: [], coordIndex: 0}
             *                  ]
             *              }
             */function nB(t){var e=t.ecModel,n={infoList:[],infoMap:ct()};return t.eachTargetAxis((function(t,i){var r=e.getComponent(tB(t),i);if(r){var o=r.getCoordSysModel();if(o){var a=o.uid,s=n.infoMap.get(a);s||(s={model:o,axisModels:[]},n.infoList.push(s),n.infoMap.set(a,s)),s.axisModels.push(r)}}})),n}var iB=/** @class */function(){function t(){this.indexList=[],this.indexMap=[]}return t.prototype.add=function(t){// Remove duplication.
this.indexMap[t]||(this.indexList.push(t),this.indexMap[t]=!0)},t}(),rB=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._autoThrottle=!0,n._noTarget=!0,
/**
                 * It is `[rangeModeForMin, rangeModeForMax]`.
                 * The optional values for `rangeMode`:
                 * + `'value'` mode: the axis extent will always be determined by
                 *     `dataZoom.startValue` and `dataZoom.endValue`, despite
                 *     how data like and how `axis.min` and `axis.max` are.
                 * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,
                 *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,
                 *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.
                 *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.
                 *
                 * For example, when users are using dynamic data (update data periodically via `setOption`),
                 * if in `'value`' mode, the window will be kept in a fixed value range despite how
                 * data are appended, while if in `'percent'` mode, whe window range will be changed alone with
                 * the appended data (suppose `axis.min` and `axis.max` are not specified).
                 */
n._rangePropMode=["percent","percent"],n}return n(e,t),e.prototype.init=function(t,e,n){var i=oB(t);
/**
                 * Suppose a "main process" start at the point that model prepared (that is,
                 * model initialized or merged or method called in `action`).
                 * We should keep the `main process` idempotent, that is, given a set of values
                 * on `option`, we get the same result.
                 *
                 * But sometimes, values on `option` will be updated for providing users
                 * a "final calculated value" (`dataZoomProcessor` will do that). Those value
                 * should not be the base/input of the `main process`.
                 *
                 * So in that case we should save and keep the input of the `main process`
                 * separately, called `settledOption`.
                 *
                 * For example, consider the case:
                 * (Step_1) brush zoom the grid by `toolbox.dataZoom`,
                 *     where the original input `option.startValue`, `option.endValue` are earsed by
                 *     calculated value.
                 * (Step)2) click the legend to hide and show a series,
                 *     where the new range is calculated by the earsed `startValue` and `endValue`,
                 *     which brings incorrect result.
                 */this.settledOption=i,this.mergeDefaultAndTheme(t,n),this._doInit(i)},e.prototype.mergeOption=function(t){var e=oB(t);// FIX #2591
C(this.option,t,!0),C(this.settledOption,e,!0),this._doInit(e)},e.prototype._doInit=function(t){var e=this.option;this._setDefaultThrottle(t),this._updateRangeUse(t);var n=this.settledOption;R([["start","startValue"],["end","endValue"]],(function(t,i){// start/end has higher priority over startValue/endValue if they
// both set, but we should make chart.setOption({endValue: 1000})
// effective, rather than chart.setOption({endValue: 1000, end: null}).
"value"===this._rangePropMode[i]&&(e[t[0]]=n[t[0]]=null);// Otherwise do nothing and use the merge result.
}),this),this._resetTarget()},e.prototype._resetTarget=function(){var t=this.get("orient",!0),e=this._targetAxisInfoMap=ct();this._fillSpecifiedTargetAxis(e)?this._orient=t||this._makeAutoOrientByTargetAxis():(this._orient=t||"horizontal",this._fillAutoTargetAxisByOrient(e,this._orient)),this._noTarget=!0,e.each((function(t){t.indexList.length&&(this._noTarget=!1)}),this)},e.prototype._fillSpecifiedTargetAxis=function(t){var e=!1;return R(JV,(function(n){var i=this.getReferringComponents(tB(n),To);// When user set axisIndex as a empty array, we think that user specify axisIndex
// but do not want use auto mode. Because empty array may be encountered when
// some error occurred.
if(i.specified){e=!0;var r=new iB;R(i.models,(function(t){r.add(t.componentIndex)})),t.set(n,r)}}),this),e},e.prototype._fillAutoTargetAxisByOrient=function(t,e){var n=this.ecModel,i=!0;// Find axis that parallel to dataZoom as default.
if(i){var r="vertical"===e?"y":"x";o(n.findComponents({mainType:r+"Axis"}),r)}// Find axis that parallel to dataZoom as default.
function o(e,n){// At least use the first parallel axis as the target axis.
var r=e[0];if(r){var o=new iB;// Find parallel axes in the same grid.
if(o.add(r.componentIndex),t.set(n,o),i=!1,"x"===n||"y"===n){var a=r.getReferringComponents("grid",Io).models[0];a&&R(e,(function(t){r.componentIndex!==t.componentIndex&&a===t.getReferringComponents("grid",Io).models[0]&&o.add(t.componentIndex)}))}}}i&&o(n.findComponents({mainType:"singleAxis",filter:function(t){return t.get("orient",!0)===e}}),"single"),i&&// If no parallel axis, find the first category axis as default. (Also consider polar).
R(JV,(function(e){if(i){var r=n.findComponents({mainType:tB(e),filter:function(t){return"category"===t.get("type",!0)}});if(r[0]){var o=new iB;o.add(r[0].componentIndex),t.set(e,o),i=!1}}}),this)},e.prototype._makeAutoOrientByTargetAxis=function(){var t;// Find the first axis
return this.eachTargetAxis((function(e){!t&&(t=e)}),this),"y"===t?"vertical":"horizontal"},e.prototype._setDefaultThrottle=function(t){if(// When first time user set throttle, auto throttle ends.
t.hasOwnProperty("throttle")&&(this._autoThrottle=!1),this._autoThrottle){var e=this.ecModel.option;this.option.throttle=e.animation&&e.animationDurationUpdate>0?100:20}},e.prototype._updateRangeUse=function(t){var e=this._rangePropMode,n=this.get("rangeMode");R([["start","startValue"],["end","endValue"]],(function(i,r){var o=null!=t[i[0]],a=null!=t[i[1]];o&&!a?e[r]="percent":!o&&a?e[r]="value":n?e[r]=n[r]:o&&(// percentSpecified && valueSpecified
e[r]="percent");// else remain its original setting.
}))},e.prototype.noTarget=function(){return this._noTarget},e.prototype.getFirstTargetAxisModel=function(){var t;return this.eachTargetAxis((function(e,n){null==t&&(t=this.ecModel.getComponent(tB(e),n))}),this),t},
/**
               * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
               */
e.prototype.eachTargetAxis=function(t,e){this._targetAxisInfoMap.each((function(n,i){R(n.indexList,(function(n){t.call(e,i,n)}))}))},
/**
               * @return If not found, return null/undefined.
               */
e.prototype.getAxisProxy=function(t,e){var n=this.getAxisModel(t,e);if(n)return n.__dzAxisProxy},
/**
               * @return If not found, return null/undefined.
               */
e.prototype.getAxisModel=function(t,e){var n=this._targetAxisInfoMap.get(t);if(n&&n.indexMap[e])return this.ecModel.getComponent(tB(t),e)},
/**
               * If not specified, set to undefined.
               */
e.prototype.setRawRange=function(t){var e=this.option,n=this.settledOption;R([["start","startValue"],["end","endValue"]],(function(i){// Consider the pair <start, startValue>:
// If one has value and the other one is `null/undefined`, we both set them
// to `settledOption`. This strategy enables the feature to clear the original
// value in `settledOption` to `null/undefined`.
// But if both of them are `null/undefined`, we do not set them to `settledOption`
// and keep `settledOption` with the original value. This strategy enables users to
// only set <end or endValue> but not set <start or startValue> when calling
// `dispatchAction`.
// The pair <end, endValue> is treated in the same way.
null==t[i[0]]&&null==t[i[1]]||(e[i[0]]=n[i[0]]=t[i[0]],e[i[1]]=n[i[1]]=t[i[1]])}),this),this._updateRangeUse(t)},e.prototype.setCalculatedRange=function(t){var e=this.option;R(["start","startValue","end","endValue"],(function(n){e[n]=t[n]}))},e.prototype.getPercentRange=function(){var t=this.findRepresentativeAxisProxy();if(t)return t.getDataPercentWindow()},
/**
               * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
               *
               * @return [startValue, endValue] value can only be '-' or finite number.
               */
e.prototype.getValueRange=function(t,e){if(null!=t||null!=e)return this.getAxisProxy(t,e).getDataValueWindow();var n=this.findRepresentativeAxisProxy();return n?n.getDataValueWindow():void 0},
/**
               * @param axisModel If axisModel given, find axisProxy
               *      corresponding to the axisModel
               */
e.prototype.findRepresentativeAxisProxy=function(t){if(t)return t.__dzAxisProxy;// Find the first hosted axisProxy
for(var e,n=this._targetAxisInfoMap.keys(),i=0;i<n.length;i++)for(var r=n[i],o=this._targetAxisInfoMap.get(r),a=0;a<o.indexList.length;a++){var s=this.getAxisProxy(r,o.indexList[a]);if(s.hostedBy(this))return s;e||(e=s)}// If no hosted proxy found, still need to return a proxy.
// This case always happens in toolbox dataZoom, where axes are all hosted by
// other dataZooms.
return e},e.prototype.getRangePropMode=function(){return this._rangePropMode.slice()},e.prototype.getOrient=function(){return this._orient},e.type="dataZoom",e.dependencies=["xAxis","yAxis","radiusAxis","angleAxis","singleAxis","series","toolbox"],e.defaultOption={// zlevel: 0,
z:4,filterMode:"filter",start:0,end:100},e}(Wp);
/**
             * Retrieve those raw params from option, which will be cached separately,
             * because they will be overwritten by normalized/calculated values in the main
             * process.
             */
function oB(t){var e={};return R(["start","end","startValue","endValue","throttle"],(function(n){t.hasOwnProperty(n)&&(e[n]=t[n])})),e}const aB=rB;var sB=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="dataZoom.select",e}(aB);const lB=sB;var uB=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n,i){this.dataZoomModel=t,this.ecModel=e,this.api=n},e.type="dataZoom",e}(Bg);const hB=uB;var cB=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="dataZoom.select",e}(hB);const pB=cB;var dB=R,fB=Fr,gB=/** @class */function(){function t(t,e,n,i){this._dimName=t,this._axisIndex=e,this.ecModel=i,this._dataZoomModel=n}
/**
               * Whether the axisProxy is hosted by dataZoomModel.
               */return t.prototype.hostedBy=function(t){return this._dataZoomModel===t},
/**
               * @return Value can only be NaN or finite value.
               */
t.prototype.getDataValueWindow=function(){return this._valueWindow.slice()},
/**
               * @return {Array.<number>}
               */
t.prototype.getDataPercentWindow=function(){return this._percentWindow.slice()},t.prototype.getTargetSeriesModels=function(){var t=[];return this.ecModel.eachSeries((function(e){if(function(t){var e=t.get("coordinateSystem");return L(QV,e)>=0}(e)){var n=tB(this._dimName),i=e.getReferringComponents(n,Io).models[0];i&&this._axisIndex===i.componentIndex&&t.push(e)}}),this),t},t.prototype.getAxisModel=function(){return this.ecModel.getComponent(this._dimName+"Axis",this._axisIndex)},t.prototype.getMinMaxSpan=function(){return T(this._minMaxSpan)},
/**
               * Only calculate by given range and this._dataExtent, do not change anything.
               */
t.prototype.calculateDataWindow=function(t){var e,n=this._dataExtent,i=this.getAxisModel().axis.scale,r=this._dataZoomModel.getRangePropMode(),o=[0,100],a=[],s=[];dB(["start","end"],(function(l,u){var h=t[l],c=t[l+"Value"];// Notice: dataZoom is based either on `percentProp` ('start', 'end') or
// on `valueProp` ('startValue', 'endValue'). (They are based on the data extent
// but not min/max of axis, which will be calculated by data window then).
// The former one is suitable for cases that a dataZoom component controls multiple
// axes with different unit or extent, and the latter one is suitable for accurate
// zoom by pixel (e.g., in dataZoomSelect).
// we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated
// only when setOption or dispatchAction, otherwise it remains its original value.
// (Why not only record `percentProp` and always map to `valueProp`? Because
// the map `valueProp` -> `percentProp` -> `valueProp` probably not the original
// `valueProp`. consider two axes constrolled by one dataZoom. They have different
// data extent. All of values that are overflow the `dataExtent` will be calculated
// to percent '100%').
"percent"===r[u]?(null==h&&(h=o[u]),// Use scale.parse to math round for category or time axis.
c=i.parse(zr(h,o,n))):(e=!0,// Calculating `percent` from `value` may be not accurate, because
// This calculation can not be inversed, because all of values that
// are overflow the `dataExtent` will be calculated to percent '100%'
h=zr(c=null==c?n[u]:i.parse(c),n,o)),// valueWindow[idx] = round(boundValue);
// percentWindow[idx] = round(boundPercent);
// fallback to extent start/end when parsed value or percent is invalid
s[u]=null==c||isNaN(c)?n[u]:c,a[u]=null==h||isNaN(h)?o[u]:h})),fB(s),fB(a);// The windows from user calling of `dispatchAction` might be out of the extent,
// or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we don't restrict window
// by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,
// where API is able to initialize/modify the window size even though `zoomLock`
// specified.
var l=this._minMaxSpan;function u(t,e,n,r,o){var a=o?"Span":"ValueSpan";BL(0,t,n,"all",l["min"+a],l["max"+a]);for(var s=0;s<2;s++)e[s]=zr(t[s],n,r,!0),o&&(e[s]=i.parse(e[s]))}return e?u(s,a,n,o,!1):u(a,s,o,n,!0),{valueWindow:s,percentWindow:a}},
/**
               * Notice: reset should not be called before series.restoreData() is called,
               * so it is recommended to be called in "process stage" but not "model init
               * stage".
               */
t.prototype.reset=function(t){if(t===this._dataZoomModel){var e=this.getTargetSeriesModels();// Culculate data window and data extent, and record them.
this._dataExtent=function(t,e,n){var i=[1/0,-1/0];dB(n,(function(t){!function(t,e,n){e&&R(B_(e,n),(function(n){var i=e.getApproximateExtent(n);i[0]<t[0]&&(t[0]=i[0]),i[1]>t[1]&&(t[1]=i[1])}))}(i,t.getData(),e)}));// It is important to get "consistent" extent when more then one axes is
// controlled by a `dataZoom`, otherwise those axes will not be synchronized
// when zooming. But it is difficult to know what is "consistent", considering
// axes have different type or even different meanings (For example, two
// time axes are used to compare data of the same date in different years).
// So basically dataZoom just obtains extent by series.data (in category axis
// extent can be obtained from axis.data).
// Nevertheless, user can set min/max/scale on axes to make extent of axes
// consistent.
var r=t.getAxisModel(),o=A_(r.axis.scale,r,i).calculate();return[o.min,o.max]}(this,this._dimName,e),// `calculateDataWindow` uses min/maxSpan.
this._updateMinMaxSpan();var n=this.calculateDataWindow(t.settledOption);this._valueWindow=n.valueWindow,this._percentWindow=n.percentWindow,// Update axis setting then.
this._setAxisModel()}},t.prototype.filterData=function(t,e){if(t===this._dataZoomModel){var n=this._dimName,i=this.getTargetSeriesModels(),r=t.get("filterMode"),o=this._valueWindow;"none"!==r&&// FIXME
// Toolbox may has dataZoom injected. And if there are stacked bar chart
// with NaN data, NaN will be filtered and stack will be wrong.
// So we need to force the mode to be set empty.
// In fect, it is not a big deal that do not support filterMode-'filter'
// when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
// selection" some day, which might need "adapt to data extent on the
// otherAxis", which is disabled by filterMode-'empty'.
// But currently, stack has been fixed to based on value but not index,
// so this is not an issue any more.
// let otherAxisModel = this.getOtherAxisModel();
// if (dataZoomModel.get('$fromToolbox')
//     && otherAxisModel
//     && otherAxisModel.hasSeriesStacked
// ) {
//     filterMode = 'empty';
// }
// TODO
// filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.
dB(i,(function(t){var e=t.getData(),i=e.mapDimensionsAll(n);if(i.length){if("weakFilter"===r){var a=e.getStore(),s=N(i,(function(t){return e.getDimensionIndex(t)}),e);e.filterSelf((function(t){for(var e,n,r,l=0;l<i.length;l++){var u=a.get(s[l],t),h=!isNaN(u),c=u<o[0],p=u>o[1];if(h&&!c&&!p)return!0;h&&(r=!0),c&&(e=!0),p&&(n=!0)}// If both left out and right out, do not filter.
return r&&e&&n}))}else dB(i,(function(n){if("empty"===r)t.setData(e=e.map(n,(function(t){return function(t){return t>=o[0]&&t<=o[1]}(t)?t:NaN})));else{var i={};i[n]=o,// console.time('select');
e.selectRange(i)}}));dB(i,(function(t){e.setApproximateExtent(o,t)}))}}))}},t.prototype._updateMinMaxSpan=function(){var t=this._minMaxSpan={},e=this._dataZoomModel,n=this._dataExtent;dB(["min","max"],(function(i){var r=e.get(i+"Span"),o=e.get(i+"ValueSpan");null!=o&&(o=this.getAxisModel().axis.scale.parse(o)),// minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan
null!=o?r=zr(n[0]+o,n,[0,100],!0):null!=r&&(o=zr(r,[0,100],n,!0)-n[0]),t[i+"Span"]=r,t[i+"ValueSpan"]=o}),this)},t.prototype._setAxisModel=function(){var t=this.getAxisModel(),e=this._percentWindow,n=this._valueWindow;if(e){// [0, 500]: arbitrary value, guess axis extent.
var i=Wr(n,[0,500]);i=Math.min(i,20);// For value axis, if min/max/scale are not set, we just use the extent obtained
// by series data, which may be a little different from the extent calculated by
// `axisHelper.getScaleExtent`. But the different just affects the experience a
// little when zooming. So it will not be fixed until some users require it strongly.
var r=t.axis.scale.rawExtentInfo;0!==e[0]&&r.setDeterminedMinMax("min",+n[0].toFixed(i)),100!==e[1]&&r.setDeterminedMinMax("max",+n[1].toFixed(i)),r.freeze()}},t}();const yB=gB,vB={// `dataZoomProcessor` will only be performed in needed series. Consider if
// there is a line series and a pie series, it is better not to update the
// line series if only pie series is needed to be updated.
getTargetSeries:function(t){function e(e){t.eachComponent("dataZoom",(function(n){n.eachTargetAxis((function(i,r){var o=t.getComponent(tB(i),r);e(i,r,o,n)}))}))}// FIXME: it brings side-effect to `getTargetSeries`.
// Prepare axis proxies.
e((function(t,e,n,i){// dispose all last axis proxy, in case that some axis are deleted.
n.__dzAxisProxy=null}));var n=[];e((function(e,i,r,o){// Different dataZooms may constrol the same axis. In that case,
// an axisProxy serves both of them.
r.__dzAxisProxy||(// Use the first dataZoomModel as the main model of axisProxy.
r.__dzAxisProxy=new yB(e,i,o,t),n.push(r.__dzAxisProxy))}));var i=ct();return R(n,(function(t){R(t.getTargetSeriesModels(),(function(t){i.set(t.uid,t)}))})),i},// Consider appendData, where filter should be performed. Because data process is
// in block mode currently, it is not need to worry about that the overallProgress
// execute every frame.
overallReset:function(t,e){t.eachComponent("dataZoom",(function(t){// We calculate window and reset axis here but not in model
// init stage and not after action dispatch handler, because
// reset should be called after seriesData.restoreData.
t.eachTargetAxis((function(e,n){t.getAxisProxy(e,n).reset(t)})),// Caution: data zoom filtering is order sensitive when using
// percent range and no min/max/scale set on axis.
// For example, we have dataZoom definition:
// [
//      {xAxisIndex: 0, start: 30, end: 70},
//      {yAxisIndex: 0, start: 20, end: 80}
// ]
// In this case, [20, 80] of y-dataZoom should be based on data
// that have filtered by x-dataZoom using range of [30, 70],
// but should not be based on full raw data. Thus sliding
// x-dataZoom will change both ranges of xAxis and yAxis,
// while sliding y-dataZoom will only change the range of yAxis.
// So we should filter x-axis after reset x-axis immediately,
// and then reset y-axis and filter y-axis.
t.eachTargetAxis((function(n,i){t.getAxisProxy(n,i).filterData(t,e)}))})),t.eachComponent("dataZoom",(function(t){// Fullfill all of the range props so that user
// is able to get them from chart.getOption().
var e=t.findRepresentativeAxisProxy();if(e){var n=e.getDataPercentWindow(),i=e.getDataValueWindow();t.setCalculatedRange({start:n[0],end:n[1],startValue:i[0],endValue:i[1]})}}))}};var mB=!1;function xB(t){mB||(mB=!0,t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER,vB),function(t){t.registerAction("dataZoom",(function(t,e){R(eB(e,t),(function(e){e.setRawRange({start:t.start,end:t.end,startValue:t.startValue,endValue:t.endValue})}))}))}(t),t.registerSubTypeDefaulter("dataZoom",(function(){// Default 'slider' when no type specified.
return"slider"})))}function _B(t){t.registerComponentModel(lB),t.registerComponentView(pB),xB(t)}
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */var bB=function(){},wB={};function SB(t,e){wB[t]=e}function MB(t){return wB[t]}var IB=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.optionUpdated=function(){t.prototype.optionUpdated.apply(this,arguments);var e=this.ecModel;R(this.option.feature,(function(t,n){var i=MB(n);i&&(i.getDefaultOption&&(i.defaultOption=i.getDefaultOption(e)),C(t,i.defaultOption))}))},e.type="toolbox",e.layoutMode={type:"box",ignoreSize:!0},e.defaultOption={show:!0,z:6,// zlevel: 0,
orient:"horizontal",left:"right",top:"top",// right
// bottom
backgroundColor:"transparent",borderColor:"#ccc",borderRadius:0,borderWidth:0,padding:5,itemSize:15,itemGap:8,showTitle:!0,iconStyle:{borderColor:"#666",color:"none"},emphasis:{iconStyle:{borderColor:"#3E98C5"}},// textStyle: {},
// feature
tooltip:{show:!1,position:"bottom"}},e}(Wp);const TB=IB;
/**
             * Layout list like component.
             * It will box layout each items in group of component and then position the whole group in the viewport
             * @param {module:zrender/group/Group} group
             * @param {module:echarts/model/Component} componentModel
             * @param {module:echarts/ExtensionAPI}
             */function CB(t,e){var n=wp(e.get("padding")),i=e.getItemStyle(["color","opacity"]);// FIXME
// `subPixelOptimizeRect` may bring some gap between edge of viewpart
// and background rect when setting like `left: 0`, `top: 0`.
// graphic.subPixelOptimizeRect(rect);
return i.fill=e.get("backgroundColor"),t=new Ls({shape:{x:t.x-n[3],y:t.y-n[0],width:t.width+n[1]+n[3],height:t.height+n[0]+n[2],r:e.get("borderRadius")},style:i,silent:!0,z2:-1})}var DB=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.render=function(t,e,n,i){var r=this.group;if(r.removeAll(),t.get("show")){var o=+t.get("itemSize"),a="vertical"===t.get("orient"),s=t.get("feature")||{},l=this._features||(this._features={}),u=[];R(s,(function(t,e){u.push(e)})),new Um(this._featureNames||[],u).add(h).update(h).remove(F(h,null)).execute(),// Keep for diff.
this._featureNames=u,function(t,e,n){var i=e.getBoxLayoutParams(),r=e.get("padding"),o={width:n.getWidth(),height:n.getHeight()},a=Rp(i,o,r);Op(e.get("orient"),t,e.get("itemGap"),a.width,a.height),Np(t,i,o,r)}(r,t,n),// Render background after group is layout
// FIXME
r.add(CB(r.getBoundingRect(),t)),// Adjust icon title positions to avoid them out of screen
a||r.eachChild((function(t){var e=t.__title,i=t.ensureState("emphasis"),a=i.textConfig||(i.textConfig={}),s=t.getTextContent(),l=s&&s.ensureState("emphasis");// const hoverStyle = icon.hoverStyle;
// TODO simplify code?
// May be background element
if(l&&!W(l)&&e){var u=l.style||(l.style={}),h=dr(e,Zs.makeFont(u)),c=t.x+r.x,p=!1;t.y+r.y+o+h.height>n.getHeight()&&(a.position="top",p=!0);var d=p?-5-h.height:o+10;c+h.width/2>n.getWidth()?(a.position=["100%",d],u.align="right"):c-h.width/2<0&&(a.position=[0,d],u.align="left")}}))}function h(h,c){var p,d=u[h],f=u[c],g=s[d],y=new Pc(g,t,t.ecModel);if(// FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?
i&&null!=i.newTitle&&i.featureName===d&&(g.title=i.newTitle),d&&!f){// Create
if(function(t){return 0===t.indexOf("my")}(d))p={onclick:y.option.onclick,featureName:d};else{var v=MB(d);if(!v)return;p=new v}l[d]=p}else// If feature does not exsit.
if(!(p=l[f]))return;p.uid=Rc("toolbox-feature"),p.model=y,p.ecModel=e,p.api=n;var m=p instanceof bB;d||!f?!y.get("show")||m&&p.unusable?m&&p.remove&&p.remove(e,n):(function(i,s,l){var u,h,c=i.getModel("iconStyle"),p=i.getModel(["emphasis","iconStyle"]),d=s instanceof bB&&s.getIcons?s.getIcons():i.get("icon"),f=i.get("title")||{};H(d)?(u={})[l]=d:u=d,H(f)?(h={})[l]=f:h=f;var g=i.iconPaths={};R(u,(function(l,u){var d=qh(l,{},{x:-o/2,y:-o/2,width:o,height:o});// TODO handling image
d.setStyle(c.getItemStyle()),d.ensureState("emphasis").style=p.getItemStyle();// Text position calculation
var f=new Zs({style:{text:h[u],align:p.get("textAlign"),borderRadius:p.get("textBorderRadius"),padding:p.get("textPadding"),fill:null},ignore:!0});d.setTextContent(f),Qh({el:d,componentModel:t,itemName:u,formatterParamsExtra:{title:h[u]}}),d.__title=h[u],d.on("mouseover",(function(){// Should not reuse above hoverStyle, which might be modified.
var e=p.getItemStyle(),i=a?null==t.get("right")&&"right"!==t.get("left")?"right":"left":null==t.get("bottom")&&"bottom"!==t.get("top")?"bottom":"top";f.setStyle({fill:p.get("textFill")||e.fill||e.stroke||"#000",backgroundColor:p.get("textBackgroundColor")}),d.setTextConfig({position:p.get("textPosition")||i}),f.ignore=!t.get("showTitle"),// Use enterEmphasis and leaveEmphasis provide by ec.
// There are flags managed by the echarts.
n.enterEmphasis(this)})).on("mouseout",(function(){"emphasis"!==i.get(["iconStatus",u])&&n.leaveEmphasis(this),f.hide()})),("emphasis"===i.get(["iconStatus",u])?Il:Tl)(d),r.add(d),d.on("click",B(s.onclick,s,e,n,u)),g[u]=d}))}(y,p,d),y.setIconStatus=function(t,e){var n=this.option,i=this.iconPaths;n.iconStatus=n.iconStatus||{},n.iconStatus[t]=e,i[t]&&("emphasis"===e?Il:Tl)(i[t])},p instanceof bB&&p.render&&p.render(y,e,n,i)):m&&p.dispose&&p.dispose(e,n)}},e.prototype.updateView=function(t,e,n,i){R(this._features,(function(t){t instanceof bB&&t.updateView&&t.updateView(t.model,e,n,i)}))},// updateLayout(toolboxModel, ecModel, api, payload) {
//     zrUtil.each(this._features, function (feature) {
//         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
//     });
// },
e.prototype.remove=function(t,e){R(this._features,(function(n){n instanceof bB&&n.remove&&n.remove(t,e)})),this.group.removeAll()},e.prototype.dispose=function(t,e){R(this._features,(function(n){n instanceof bB&&n.dispose&&n.dispose(t,e)}))},e.type="toolbox",e}(Bg);const AB=DB;/* global window, document */var kB=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.onclick=function(t,e){var n=this.model,i=n.get("name")||t.get("title.0.text")||"echarts",r="svg"===e.getZr().painter.getType(),a=r?"svg":n.get("type",!0)||"png",s=e.getConnectedDataURL({type:a,backgroundColor:n.get("backgroundColor",!0)||t.get("backgroundColor")||"#fff",connectedBackgroundColor:n.get("connectedBackgroundColor"),excludeComponents:n.get("excludeComponents"),pixelRatio:n.get("pixelRatio")}),l=o.browser;// Chrome, Firefox, New Edge
if(W(MouseEvent)&&(l.newEdge||!l.ie&&!l.edge)){var u=document.createElement("a");u.download=i+"."+a,u.target="_blank",u.href=s;var h=new MouseEvent("click",{// some micro front-end framework window maybe is a Proxy
view:document.defaultView,bubbles:!0,cancelable:!1});u.dispatchEvent(h)}// IE or old Edge
else// @ts-ignore
if(window.navigator.msSaveOrOpenBlob||r){var c=s.split(","),p=c[0].indexOf("base64")>-1,d=r?decodeURIComponent(c[1]):c[1];// data:[<mime type>][;charset=<charset>][;base64],<encoded data>
// only `atob` when the data uri is encoded with base64
// otherwise, like `svg` data uri exported by zrender,
// there will be an error, for it's not encoded with base64.
// (just a url-encoded string through `encodeURIComponent`)
p&&(d=window.atob(d));var f=i+"."+a;// @ts-ignore
if(window.navigator.msSaveOrOpenBlob){for(var g=d.length,y=new Uint8Array(g);g--;)y[g]=d.charCodeAt(g);var v=new Blob([y]);// @ts-ignore
window.navigator.msSaveOrOpenBlob(v,f)}else{var m=document.createElement("iframe");document.body.appendChild(m);var x=m.contentWindow,_=x.document;_.open("image/svg+xml","replace"),_.write(d),_.close(),x.focus(),_.execCommand("SaveAs",!0,f),document.body.removeChild(m)}}else{var b=n.get("lang"),w='<body style="margin:0;"><img src="'+s+'" style="max-width:100%;" title="'+(b&&b[0]||"")+'" /></body>',S=window.open();S.document.write(w),S.document.title=i}},e.getDefaultOption=function(t){return{show:!0,icon:"M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",title:t.getLocaleModel().get(["toolbox","saveAsImage","title"]),type:"png",// Default use option.backgroundColor
// backgroundColor: '#fff',
connectedBackgroundColor:"#fff",name:"",excludeComponents:["toolbox"],// use current pixel ratio of device by default
// pixelRatio: 1,
lang:t.getLocaleModel().get(["toolbox","saveAsImage","lang"])}},e}(bB);const LB=kB;var PB="__ec_magicType_stack__",OB=[["line","bar"],["stack"]],RB=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.getIcons=function(){var t=this.model,e=t.get("icon"),n={};return R(t.get("type"),(function(t){e[t]&&(n[t]=e[t])})),n},e.getDefaultOption=function(t){return{show:!0,type:[],// Icon group
icon:{line:"M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",bar:"M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",// eslint-disable-next-line
stack:"M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"},// `line`, `bar`, `stack`, `tiled`
title:t.getLocaleModel().get(["toolbox","magicType","title"]),option:{},seriesIndex:{}}},e.prototype.onclick=function(t,e,n){var i=this.model,r=i.get(["seriesIndex",n]);// Not supported magicType
if(NB[n]){var o,a={series:[]};R(OB,(function(t){L(t,n)>=0&&R(t,(function(t){i.setIconStatus(t,"normal")}))})),i.setIconStatus(n,"emphasis"),t.eachComponent({mainType:"series",query:null==r?null:{seriesIndex:r}},(function(t){var e=t.subType,r=t.id,o=NB[n](e,r,t,i);o&&(// PENDING If merge original option?
k(o,t.option),a.series.push(o));// Modify boundaryGap
var s=t.coordinateSystem;if(s&&"cartesian2d"===s.type&&("line"===n||"bar"===n)){var l=s.getAxesByScale("ordinal")[0];if(l){var u=l.dim+"Axis",h=t.getReferringComponents(u,Io).models[0].componentIndex;a[u]=a[u]||[];for(var c=0;c<=h;c++)a[u][h]=a[u][h]||{};a[u][h].boundaryGap="bar"===n}}}));var s=n;// Change title of stack
"stack"===n&&(// use titles in model instead of ecModel
// as stack and tiled appears in pair, just flip them
// no need of checking stack state
o=C({stack:i.option.title.tiled,tiled:i.option.title.stack},i.option.title),"emphasis"!==i.get(["iconStatus",n])&&(s="tiled")),e.dispatchAction({type:"changeMagicType",currentType:s,newOption:a,newTitle:o,featureName:"magicType"})}},e}(bB),NB={line:function(t,e,n,i){if("bar"===t)return C({id:e,type:"line",// Preserve data related option
data:n.get("data"),stack:n.get("stack"),markPoint:n.get("markPoint"),markLine:n.get("markLine")},i.get(["option","line"])||{},!0)},bar:function(t,e,n,i){if("line"===t)return C({id:e,type:"bar",// Preserve data related option
data:n.get("data"),stack:n.get("stack"),markPoint:n.get("markPoint"),markLine:n.get("markLine")},i.get(["option","bar"])||{},!0)},stack:function(t,e,n,i){var r=n.get("stack")===PB;if("line"===t||"bar"===t)return i.setIconStatus("stack",r?"normal":"emphasis"),C({id:e,stack:r?"":PB},i.get(["option","stack"])||{},!0)}};// TODO: SELF REGISTERED.
Om({type:"changeMagicType",event:"magicTypeChanged",update:"prepareAndUpdate"},(function(t,e){e.mergeOption(t.newOption)}));const EB=RB;/* global document */var zB=new Array(60).join("-"),VB="\t";function BB(t){return t.replace(/^\s\s*/,"").replace(/\s\s*$/,"")}
/**
             * If a block is tsv format
             */var FB=new RegExp("[\t]+","g");
/**
             * @param {string} tsv
             * @return {Object}
             */function GB(t,e){var n=t.split(new RegExp("\n*"+zB+"\n*","g")),i={series:[]};return R(n,(function(t,n){if(function(t){if(t.slice(0,t.indexOf("\n")).indexOf(VB)>=0)return!0}(t)){var r=function(t){for(var e=t.split(/\n+/g),n=[],i=N(BB(e.shift()).split(FB),(function(t){return{name:t,data:[]}})),r=0;r<e.length;r++){var o=BB(e[r]).split(FB);n.push(o.shift());for(var a=0;a<o.length;a++)i[a]&&(i[a].data[r]=o[a])}return{series:i,categories:n}}(t),o=e[n],a=o.axisDim+"Axis";o&&(i[a]=i[a]||[],i[a][o.axisIndex]={data:r.categories},i.series=i.series.concat(r.series))}else r=function(t){for(var e=t.split(/\n+/g),n=BB(e.shift()),i=[],r=0;r<e.length;r++){// if line is empty, ignore it.
// there is a case that a user forgot to delete `\n`.
var o=BB(e[r]);if(o){var a=o.split(FB),s="",l=void 0,u=!1;isNaN(a[0])?(// First item is name
u=!0,s=a[0],a=a.slice(1),i[r]={name:s,value:[]},l=i[r].value):l=i[r]=[];for(var h=0;h<a.length;h++)l.push(+a[h]);1===l.length&&(u?i[r].value=l[0]:i[r]=l[0])}}return{name:n,data:i}}(t),i.series.push(r)})),i}var WB=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.onclick=function(t,e){// FIXME: better way?
setTimeout((function(){e.dispatchAction({type:"hideTip"})}));var n=e.getDom(),i=this.model;this._dom&&n.removeChild(this._dom);var r=document.createElement("div");// use padding to avoid 5px whitespace
r.style.cssText="position:absolute;top:0;bottom:0;left:0;right:0;padding:5px",r.style.backgroundColor=i.get("backgroundColor")||"#fff";// Create elements
var o=document.createElement("h4"),a=i.get("lang")||[];o.innerHTML=a[0]||i.get("title"),o.style.cssText="margin:10px 20px",o.style.color=i.get("textColor");var s=document.createElement("div"),l=document.createElement("textarea");s.style.cssText="overflow:auto";var u=i.get("optionToContent"),h=i.get("contentToOption"),c=function(t){var e,n,i,r=
/**
             * Group series into two types
             *  1. on category axis, like line, bar
             *  2. others, like scatter, pie
             */
function(t){var e={},n=[],i=[];return t.eachRawSeries((function(t){var r=t.coordinateSystem;if(!r||"cartesian2d"!==r.type&&"polar"!==r.type)n.push(t);else{// TODO: TYPE Consider polar? Include polar may increase unecessary bundle size.
var o=r.getBaseAxis();if("category"===o.type){var a=o.dim+"_"+o.index;e[a]||(e[a]={categoryAxis:o,valueAxis:r.getOtherAxis(o),series:[]},i.push({axisDim:o.dim,axisIndex:o.index})),e[a].series.push(t)}else n.push(t)}})),{seriesGroupByCategoryAxis:e,other:n,meta:i}}
/**
             * Assemble content of series on cateogory axis
             * @inner
             */(t);return{value:z([(n=r.seriesGroupByCategoryAxis,i=[],R(n,(function(t,e){var n=t.categoryAxis,r=t.valueAxis.dim,o=[" "].concat(N(t.series,(function(t){return t.name}))),a=[n.model.getCategories()];R(t.series,(function(t){var e=t.getRawData();a.push(t.getRawData().mapArray(e.mapDimension(r),(function(t){return t})))}));for(// Assemble table content
var s=[o.join(VB)],l=0;l<a[0].length;l++){for(var u=[],h=0;h<a.length;h++)u.push(a[h][l]);s.push(u.join(VB))}i.push(s.join("\n"))})),i.join("\n\n"+zB+"\n\n")),(e=r.other,N(e,(function(t){var e=t.getRawData(),n=[t.name],i=[];return e.each(e.dimensions,(function(){for(var t=arguments.length,r=arguments[t-1],o=e.getName(r),a=0;a<t-1;a++)i[a]=arguments[a];n.push((o?o+VB:"")+i.join(VB))})),n.join("\n")})).join("\n\n"+zB+"\n\n"))],(function(t){return!!t.replace(/[\n\t\s]/g,"")})).join("\n\n"+zB+"\n\n"),meta:r.meta}}(t);if(W(u)){var p=u(e.getOption());H(p)?s.innerHTML=p:q(p)&&s.appendChild(p)}else{// Use default textarea
l.readOnly=i.get("readOnly");var d=l.style;// eslint-disable-next-line max-len
d.cssText="display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none",d.color=i.get("textColor"),d.borderColor=i.get("textareaBorderColor"),d.backgroundColor=i.get("textareaColor"),l.value=c.value,s.appendChild(l)}var f=c.meta,g=document.createElement("div");g.style.cssText="position:absolute;bottom:5px;left:0;right:0";// eslint-disable-next-line max-len
var y="float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",v=document.createElement("div"),m=document.createElement("div");y+=";background-color:"+i.get("buttonColor"),y+=";color:"+i.get("buttonTextColor");var x=this;function _(){n.removeChild(r),x._dom=null}ie(v,"click",_),ie(m,"click",(function(){if(null==h&&null!=u||null!=h&&null==u)_();else{var t;try{t=W(h)?h(s,e.getOption()):GB(l.value,f)}catch(ku){throw _(),new Error("Data view format error "+ku)}t&&e.dispatchAction({type:"changeDataView",newOption:t}),_()}})),v.innerHTML=a[1],m.innerHTML=a[2],m.style.cssText=v.style.cssText=y,!i.get("readOnly")&&g.appendChild(m),g.appendChild(v),r.appendChild(o),r.appendChild(s),r.appendChild(g),s.style.height=n.clientHeight-80+"px",n.appendChild(r),this._dom=r},e.prototype.remove=function(t,e){this._dom&&e.getDom().removeChild(this._dom)},e.prototype.dispose=function(t,e){this.remove(t,e)},e.getDefaultOption=function(t){return{show:!0,readOnly:!1,optionToContent:null,contentToOption:null,// eslint-disable-next-line
icon:"M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",title:t.getLocaleModel().get(["toolbox","dataView","title"]),lang:t.getLocaleModel().get(["toolbox","dataView","lang"]),backgroundColor:"#fff",textColor:"#000",textareaColor:"#fff",textareaBorderColor:"#333",buttonColor:"#c23531",buttonTextColor:"#fff"}},e}(bB);
/**
             * @inner
             */function HB(t,e){return N(t,(function(t,n){var i=e&&e[n];if(U(i)&&!G(i)){U(t)&&!G(t)||(t={value:t});// original data has name but new data has no name
var r=null!=i.name&&null==t.name;// Original data has option
return t=k(t,i),r&&delete t.name,t}return t}))}// TODO: SELF REGISTERED.
Om({type:"changeDataView",event:"dataViewChanged",update:"prepareAndUpdate"},(function(t,e){var n=[];R(t.newOption.series,(function(t){var i=e.getSeriesByName(t.name)[0];if(i){var r=i.get("data");n.push({name:t.name,data:HB(t.data,r)})}else// New created series
// Geuss the series type
n.push(A({// Default is scatter
type:"scatter"},t))})),e.mergeOption(k({series:n},t.newOption))}));const YB=WB;var XB=R,UB=bo();
/**
             * History length of each dataZoom may be different.
             * this._history[0] is used to store origin range.
             */
function ZB(t){var e=UB(t);return e.snapshots||(e.snapshots=[{}]),e.snapshots}var jB=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.onclick=function(t,e){!function(t){UB(t).snapshots=null}(t),e.dispatchAction({type:"restore",from:this.uid})},e.getDefaultOption=function(t){return{show:!0,// eslint-disable-next-line
icon:"M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",title:t.getLocaleModel().get(["toolbox","restore","title"])}},e}(bB);// TODO: SELF REGISTERED.
Om({type:"restore",event:"restore",update:"prepareAndUpdate"},(function(t,e){e.resetOption("recreate")}));const qB=jB;// how to genarialize to more coordinate systems.
var KB=["grid","xAxis","yAxis","geo","graph","polar","radiusAxis","angleAxis","bmap"],$B=/** @class */function(){
/**
               * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid
               *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
               * @param opt.include include coordinate system types.
               */
function t(t,e,n){var i=this;this._targetInfoList=[];var r=QB(e,t);R(tF,(function(t,e){(!n||!n.include||L(n.include,e)>=0)&&t(r,i._targetInfoList)}))}return t.prototype.setOutputRanges=function(t,e){return this.matchOutputRanges(t,e,(function(t,e,n){// area.coordRange is the first of area.coordRanges
if((t.coordRanges||(t.coordRanges=[])).push(e),!t.coordRange){t.coordRange=e;// In 'category' axis, coord to pixel is not reversible, so we can not
// rebuild range by coordRange accrately, which may bring trouble when
// brushing only one item. So we use __rangeOffset to rebuilding range
// by coordRange. And this it only used in brush component so it is no
// need to be adapted to coordRanges.
var i=iF[t.brushType](0,n,e);t.__rangeOffset={offset:oF[t.brushType](i.values,t.range,[1,1]),xyMinMax:i.xyMinMax}}})),t},t.prototype.matchOutputRanges=function(t,e,n){R(t,(function(t){var i=this.findTargetInfo(t,e);i&&!0!==i&&R(i.coordSyses,(function(i){var r=iF[t.brushType](1,i,t.range,!0);n(t,r.values,i,e)}))}),this)},
/**
               * the `areas` is `BrushModel.areas`.
               * Called in layout stage.
               * convert `area.coordRange` to global range and set panelId to `area.range`.
               */
t.prototype.setInputRanges=function(t,e){R(t,(function(t){var n,i,r,o,a,s=this.findTargetInfo(t,e);// convert coordRange to global range and set panelId.
if(t.range=t.range||[],s&&!0!==s){t.panelId=s.panelId;// (1) area.range shoule always be calculate from coordRange but does
// not keep its original value, for the sake of the dataZoom scenario,
// where area.coordRange remains unchanged but area.range may be changed.
// (2) Only support converting one coordRange to pixel range in brush
// component. So do not consider `coordRanges`.
// (3) About __rangeOffset, see comment above.
var l=iF[t.brushType](0,s.coordSys,t.coordRange),u=t.__rangeOffset;t.range=u?oF[t.brushType](l.values,u.offset,(n=l.xyMinMax,i=u.xyMinMax,r=sF(n),o=sF(i),a=[r[0]/o[0],r[1]/o[1]],isNaN(a[0])&&(a[0]=1),isNaN(a[1])&&(a[1]=1),a)):l.values}}),this)},t.prototype.makePanelOpts=function(t,e){return N(this._targetInfoList,(function(n){var i=n.getPanelRect();return{panelId:n.panelId,defaultBrushType:e?e(n):null,clipPath:YP(i),isTargetByCursor:UP(i,t,n.coordSysModel),getLinearBrushOtherExtent:XP(i)}}))},t.prototype.controlSeries=function(t,e,n){// Check whether area is bound in coord, and series do not belong to that coord.
// If do not do this check, some brush (like lineX) will controll all axes.
var i=this.findTargetInfo(t,n);return!0===i||i&&L(i.coordSyses,e.coordinateSystem)>=0},
/**
               * If return Object, a coord found.
               * If reutrn true, global found.
               * Otherwise nothing found.
               */
t.prototype.findTargetInfo=function(t,e){for(var n=this._targetInfoList,i=QB(e,t),r=0;r<n.length;r++){var o=n[r],a=t.panelId;if(a){if(o.panelId===a)return o}else for(var s=0;s<eF.length;s++)if(eF[s](i,o))return o}return!0},t}();function JB(t){return t[0]>t[1]&&t.reverse(),t}function QB(t,e){return So(t,e,{includeMainTypes:KB})}var tF={grid:function(t,e){var n=t.xAxisModels,i=t.yAxisModels,r=t.gridModels,o=ct(),a={},s={};(n||i||r)&&(R(n,(function(t){var e=t.axis.grid.model;o.set(e.id,e),a[e.id]=!0})),R(i,(function(t){var e=t.axis.grid.model;o.set(e.id,e),s[e.id]=!0})),R(r,(function(t){o.set(t.id,t),a[t.id]=!0,s[t.id]=!0})),o.each((function(t){var r=t.coordinateSystem,o=[];R(r.getCartesians(),(function(t,e){(L(n,t.getAxis("x").model)>=0||L(i,t.getAxis("y").model)>=0)&&o.push(t)})),e.push({panelId:"grid--"+t.id,gridModel:t,coordSysModel:t,// Use the first one as the representitive coordSys.
coordSys:o[0],coordSyses:o,getPanelRect:nF.grid,xAxisDeclared:a[t.id],yAxisDeclared:s[t.id]})})))},geo:function(t,e){R(t.geoModels,(function(t){var n=t.coordinateSystem;e.push({panelId:"geo--"+t.id,geoModel:t,coordSysModel:t,coordSys:n,coordSyses:[n],getPanelRect:nF.geo})}))}},eF=[// grid
function(t,e){var n=t.xAxisModel,i=t.yAxisModel,r=t.gridModel;return!r&&n&&(r=n.axis.grid.model),!r&&i&&(r=i.axis.grid.model),r&&r===e.gridModel},// geo
function(t,e){var n=t.geoModel;return n&&n===e.geoModel}],nF={grid:function(){// grid is not Transformable.
return this.coordSys.master.getRect().clone()},geo:function(){var t=this.coordSys,e=t.getBoundingRect().clone();// geo roam and zoom transform
return e.applyTransform(Hh(t)),e}},iF={lineX:F(rF,0),lineY:F(rF,1),rect:function(t,e,n,i){var r=t?e.pointToData([n[0][0],n[1][0]],i):e.dataToPoint([n[0][0],n[1][0]],i),o=t?e.pointToData([n[0][1],n[1][1]],i):e.dataToPoint([n[0][1],n[1][1]],i),a=[JB([r[0],o[0]]),JB([r[1],o[1]])];return{values:a,xyMinMax:a}},polygon:function(t,e,n,i){var r=[[1/0,-1/0],[1/0,-1/0]];return{values:N(n,(function(n){var o=t?e.pointToData(n,i):e.dataToPoint(n,i);return r[0][0]=Math.min(r[0][0],o[0]),r[1][0]=Math.min(r[1][0],o[1]),r[0][1]=Math.max(r[0][1],o[0]),r[1][1]=Math.max(r[1][1],o[1]),o})),xyMinMax:r}}};function rF(t,e,n,i){var r=n.getAxis(["x","y"][t]),o=JB(N([0,1],(function(t){return e?r.coordToData(r.toLocalCoord(i[t]),!0):r.toGlobalCoord(r.dataToCoord(i[t]))}))),a=[];return a[t]=o,a[1-t]=[NaN,NaN],{values:o,xyMinMax:a}}var oF={lineX:F(aF,0),lineY:F(aF,1),rect:function(t,e,n){return[[t[0][0]-n[0]*e[0][0],t[0][1]-n[0]*e[0][1]],[t[1][0]-n[1]*e[1][0],t[1][1]-n[1]*e[1][1]]]},polygon:function(t,e,n){return N(t,(function(t,i){return[t[0]-n[0]*e[i][0],t[1]-n[1]*e[i][1]]}))}};function aF(t,e,n,i){return[e[0]-i[t]*n[0],e[1]-i[t]*n[1]]}// We have to process scale caused by dataZoom manually,
// although it might be not accurate.
// Return [0~1, 0~1]
function sF(t){return t?[t[0][1]-t[0][0],t[1][1]-t[1][0]]:[NaN,NaN]}const lF=$B;var uF,hF,cF=R,pF=so+"toolbox-dataZoom_",dF=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.render=function(t,e,n,i){this._brushController||(this._brushController=new HP(n.getZr()),this._brushController.on("brush",B(this._onBrush,this)).mount()),function(t,e,n,i,r){var o=n._isZoomActive;i&&"takeGlobalCursor"===i.type&&(o="dataZoomSelect"===i.key&&i.dataZoomSelectActive),n._isZoomActive=o,t.setIconStatus("zoom",o?"emphasis":"normal");var a=new lF(gF(t),e,{include:["grid"]}),s=a.makePanelOpts(r,(function(t){return t.xAxisDeclared&&!t.yAxisDeclared?"lineX":!t.xAxisDeclared&&t.yAxisDeclared?"lineY":"rect"}));n._brushController.setPanels(s).enableBrush(!(!o||!s.length)&&{brushType:"auto",brushStyle:t.getModel("brushStyle").getItemStyle()})}(t,e,this,i,n),function(t,e){t.setIconStatus("back",function(t){return ZB(t).length}(e)>1?"emphasis":"normal")}(t,e)},e.prototype.onclick=function(t,e,n){fF[n].call(this)},e.prototype.remove=function(t,e){this._brushController&&this._brushController.unmount()},e.prototype.dispose=function(t,e){this._brushController&&this._brushController.dispose()},e.prototype._onBrush=function(t){var e=t.areas;if(t.isEnd&&e.length){var n={},i=this.ecModel;this._brushController.updateCovers([]),new lF(gF(this.model),i,{include:["grid"]}).matchOutputRanges(e,i,(function(t,e,n){if("cartesian2d"===n.type){var i=t.brushType;"rect"===i?(r("x",n,e[0]),r("y",n,e[1])):r({lineX:"x",lineY:"y"}[i],n,e)}})),
/**
             * @param ecModel
             * @param newSnapshot key is dataZoomId
             */
function(t,e){var n=ZB(t);// If previous dataZoom can not be found,
// complete an range with current range.
XB(e,(function(e,i){for(var r=n.length-1;r>=0&&!n[r][i];r--);if(r<0){// No origin range set, create one by current range.
var o=t.queryComponents({mainType:"dataZoom",subType:"select",id:i})[0];if(o){var a=o.getPercentRange();n[0][i]={dataZoomId:i,start:a[0],end:a[1]}}}})),n.push(e)}(i,n),this._dispatchZoomAction(n)}function r(t,e,r){var o=e.getAxis(t),a=o.model,s=function(t,e,n){var i;return n.eachComponent({mainType:"dataZoom",subType:"select"},(function(n){n.getAxisModel(t,e.componentIndex)&&(i=n)})),i}(t,a,i),l=s.findRepresentativeAxisProxy(a).getMinMaxSpan();null==l.minValueSpan&&null==l.maxValueSpan||(r=BL(0,r.slice(),o.scale.getExtent(),0,l.minValueSpan,l.maxValueSpan)),s&&(n[s.id]={dataZoomId:s.id,startValue:r[0],endValue:r[1]})}},e.prototype._dispatchZoomAction=function(t){var e=[];// Convert from hash map to array.
cF(t,(function(t,n){e.push(T(t))})),e.length&&this.api.dispatchAction({type:"dataZoom",from:this.uid,batch:e})},e.getDefaultOption=function(t){return{show:!0,filterMode:"filter",// Icon group
icon:{zoom:"M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",back:"M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"},// `zoom`, `back`
title:t.getLocaleModel().get(["toolbox","dataZoom","title"]),brushStyle:{borderWidth:0,color:"rgba(210,219,238,0.2)"}}},e}(bB),fF={zoom:function(){var t=!this._isZoomActive;this.api.dispatchAction({type:"takeGlobalCursor",key:"dataZoomSelect",dataZoomSelectActive:t})},back:function(){this._dispatchZoomAction(function(t){var e=ZB(t),n=e[e.length-1];e.length>1&&e.pop();// Find top for all dataZoom.
var i={};return XB(n,(function(t,n){for(var r=e.length-1;r>=0;r--)if(t=e[r][n]){i[n]=t;break}})),i}(this.ecModel))}};function gF(t){var e={xAxisIndex:t.get("xAxisIndex",!0),yAxisIndex:t.get("yAxisIndex",!0),xAxisId:t.get("xAxisId",!0),yAxisId:t.get("yAxisId",!0)};// If both `xAxisIndex` `xAxisId` not set, it means 'all'.
// If both `yAxisIndex` `yAxisId` not set, it means 'all'.
// Some old cases set like this below to close yAxis control but leave xAxis control:
// `{ feature: { dataZoom: { yAxisIndex: false } }`.
return null==e.xAxisIndex&&null==e.xAxisId&&(e.xAxisIndex="all"),null==e.yAxisIndex&&null==e.yAxisId&&(e.yAxisIndex="all"),e}uF="dataZoom",hF=function(t){var e=t.getComponent("toolbox",0),n=["feature","dataZoom"];if(e&&null!=e.get(n)){var i=e.getModel(n),r=[],o=So(t,gF(i));return cF(o.xAxisModels,(function(t){return a(t,"xAxis","xAxisIndex")})),cF(o.yAxisModels,(function(t){return a(t,"yAxis","yAxisIndex")})),r}function a(t,e,n){var o=t.componentIndex,a={type:"select",$fromToolbox:!0,// Default to be filter
filterMode:i.get("filterMode",!0)||"filter",// Id for merge mapping.
id:pF+e+o};a[n]=o,r.push(a)}},it(null==dd.get(uF)&&hF),dd.set(uF,hF);const yF=dF;var vF=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="tooltip",e.dependencies=["axisPointer"],e.defaultOption={// zlevel: 0,
z:60,show:!0,// tooltip main content
showContent:!0,// 'trigger' only works on coordinate system.
// 'item' | 'axis' | 'none'
trigger:"item",// 'click' | 'mousemove' | 'none'
triggerOn:"mousemove|click",alwaysShowContent:!1,displayMode:"single",renderMode:"auto",// whether restraint content inside viewRect.
// If renderMode: 'richText', default true.
// If renderMode: 'html', defaut false (for backward compat).
confine:null,showDelay:0,hideDelay:100,// Animation transition time, unit is second
transitionDuration:.4,enterable:!1,backgroundColor:"#fff",// box shadow
shadowBlur:10,shadowColor:"rgba(0, 0, 0, .2)",shadowOffsetX:1,shadowOffsetY:2,// tooltip border radius, unit is px, default is 4
borderRadius:4,// tooltip border width, unit is px, default is 0 (no border)
borderWidth:1,// Tooltip inside padding, default is 5 for all direction
// Array is allowed to set up, right, bottom, left, same with css
// The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
padding:null,// Extra css text
extraCssText:"",// axis indicator, trigger by axis
axisPointer:{// default is line
// legal values: 'line' | 'shadow' | 'cross'
type:"line",// Valid when type is line, appoint tooltip line locate on which line. Optional
// legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
// default is 'auto', chose the axis which type is category.
// for multiply y axis, cartesian coord chose x axis, polar chose angle axis
axis:"auto",animation:"auto",animationDurationUpdate:200,animationEasingUpdate:"exponentialOut",crossStyle:{color:"#999",width:1,type:"dashed",// TODO formatter
textStyle:{}}},textStyle:{color:"#666",fontSize:14}},e}(Wp);const mF=vF;/* global document */function xF(t){var e=t.get("confine");return null!=e?!!e:"richText"===t.get("renderMode")}function _F(t){if(o.domSupported)for(var e=document.documentElement.style,n=0,i=t.length;n<i;n++)if(t[n]in e)return t[n]}var bF=_F(["transform","webkitTransform","OTransform","MozTransform","msTransform"]);function wF(t,e){if(!t)return e;e=bp(e,!0);var n=t.indexOf(e);return(t=-1===n?e:"-"+t.slice(0,n)+"-"+e).toLowerCase()}/* global document, window */var SF=wF(_F(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),"transition"),MF=wF(bF,"transform"),IF="position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;"+(o.transform3dSupported?"will-change:transform;":"");function TF(t,e,n){// If using float on style, the final width of the dom might
// keep changing slightly while mouse move. So `toFixed(0)` them.
var i=t.toFixed(0)+"px",r=e.toFixed(0)+"px";// not support transform, use `left` and `top` instead.
if(!o.transformSupported)return n?"top:"+r+";left:"+i+";":[["top",r],["left",i]];// support transform
var a=o.transform3dSupported,s="translate"+(a?"3d":"")+"("+i+","+r+(a?",0":"")+")";return n?"top:0;left:0;"+MF+":"+s+";":[["top",0],["left",0],[bF,s]]}
/**
             * @param {Object} textStyle
             * @return {string}
             * @inner
             */function CF(t,e,n){var i=[],r=t.get("transitionDuration"),a=t.get("backgroundColor"),s=t.get("shadowBlur"),l=t.get("shadowColor"),u=t.get("shadowOffsetX"),h=t.get("shadowOffsetY"),c=t.getModel("textStyle"),p=Sg(t,"html"),d=u+"px "+h+"px "+s+"px "+l;return i.push("box-shadow:"+d),// Animation transition. Do not animate when transitionDuration is 0.
e&&r&&i.push(function(t,e){var n="cubic-bezier(0.23,1,0.32,1)",i=" "+t/2+"s "+n,r="opacity"+i+",visibility"+i;return e||(i=" "+t+"s "+n,r+=o.transformSupported?","+MF+i:",left"+i+",top"+i),SF+":"+r}(r,n)),a&&i.push("background-color:"+a),// Border style
R(["width","color","radius"],(function(e){var n="border-"+e,r=bp(n),o=t.get(r);null!=o&&i.push(n+":"+o+("color"===e?"":"px"))})),// Text style
i.push(function(t){var e=[],n=t.get("fontSize"),i=t.getTextColor();i&&e.push("color:"+i),e.push("font:"+t.getFont()),n&&e.push("line-height:"+Math.round(3*n/2)+"px");var r=t.get("textShadowColor"),o=t.get("textShadowBlur")||0,a=t.get("textShadowOffsetX")||0,s=t.get("textShadowOffsetY")||0;return r&&o&&e.push("text-shadow:"+a+"px "+s+"px "+o+"px "+r),R(["decoration","align"],(function(n){var i=t.get(n);i&&e.push("text-"+n+":"+i)})),e.join(";")}(c)),// Padding
null!=p&&i.push("padding:"+wp(p).join("px ")+"px"),i.join(";")+";"}// If not able to make, do not modify the input `out`.
function DF(t,e,n,i,r){var o=e&&e.painter;if(n){var a=o&&o.getViewportRoot();a&&// Some APPs might use scale on body, so we support CSS transform here.
function(t,e,n,i,r){Xt(Yt,e,i,r,!0)&&Xt(t,n,Yt[0],Yt[1])}(t,a,document.body,i,r)}else{t[0]=i,t[1]=r;// xy should be based on canvas root. But tooltipContent is
// the sibling of canvas root. So padding of ec container
// should be considered here.
var s=o&&o.getViewportRootOffset();s&&(t[0]+=s.offsetLeft,t[1]+=s.offsetTop)}t[2]=t[0]/e.getWidth(),t[3]=t[1]/e.getHeight()}var AF=/** @class */function(){function t(t,e,n){if(this._show=!1,this._styleCoord=[0,0,0,0],this._enterable=!0,this._firstShow=!0,this._longHide=!0,o.wxa)return null;var i=document.createElement("div");// TODO: TYPE
i.domBelongToZr=!0,this.el=i;var r=this._zr=e.getZr(),a=this._appendToBody=n&&n.appendToBody;DF(this._styleCoord,r,a,e.getWidth()/2,e.getHeight()/2),a?document.body.appendChild(i):t.appendChild(i),this._container=t;// FIXME
// Is it needed to trigger zr event manually if
// the browser do not support `pointer-events: none`.
var s=this;i.onmouseenter=function(){// clear the timeout in hideLater and keep showing tooltip
s._enterable&&(clearTimeout(s._hideTimeout),s._show=!0),s._inContent=!0},i.onmousemove=function(t){if(t=t||window.event,!s._enterable){// `pointer-events: none` is set to tooltip content div
// if `enterable` is set as `false`, and `el.onmousemove`
// can not be triggered. But in browser that do not
// support `pointer-events`, we need to do this:
// Try trigger zrender event to avoid mouse
// in and out shape too frequently
var e=r.handler;ne(r.painter.getViewportRoot(),t,!0),e.dispatch("mousemove",t)}},i.onmouseleave=function(){// set `_inContent` to `false` before `hideLater`
s._inContent=!1,s._enterable&&s._show&&s.hideLater(s._hideDelay)}}
/**
               * Update when tooltip is rendered
               */return t.prototype.update=function(t){// FIXME
// Move this logic to ec main?
var e,n,i,r=this._container,o=(n="position",(i=(e=r).currentStyle||document.defaultView&&document.defaultView.getComputedStyle(e))?n?i[n]:i:null),a=r.style;"absolute"!==a.position&&"absolute"!==o&&(a.position="relative"),t.get("alwaysShowContent")&&this._moveIfResized(),// update className
this.el.className=t.get("className")||"";// move tooltip if chart resized
},t.prototype.show=function(t,e){clearTimeout(this._hideTimeout),clearTimeout(this._longHideTimeout);var n=this.el,i=n.style,r=this._styleCoord;n.innerHTML?i.cssText=IF+CF(t,!this._firstShow,this._longHide)+TF(r[0],r[1],!0)+"border-color:"+Cp(e)+";"+(t.get("extraCssText")||"")+";pointer-events:"+(this._enterable?"auto":"none"):i.display="none",this._show=!0,this._firstShow=!1,this._longHide=!1},t.prototype.setContent=function(t,e,n,i,r){var o=this.el;if(null!=t){var a="";if(H(r)&&"item"===n.get("trigger")&&!xF(n)&&(a=function(t,e,n){if(!H(n)||"inside"===n)return"";var i=t.get("backgroundColor"),r=t.get("borderWidth");e=Cp(e);var o,a,s="left"===(o=n)?"right":"right"===o?"left":"top"===o?"bottom":"top",l=Math.max(1.5*Math.round(r),6),u="",h=MF+":";L(["left","right"],s)>-1?(u+="top:50%",h+="translateY(-50%) rotate("+(a="left"===s?-225:-45)+"deg)"):(u+="left:50%",h+="translateX(-50%) rotate("+(a="top"===s?225:45)+"deg)");var c=a*Math.PI/180,p=l+r,d=p*Math.abs(Math.cos(c))+p*Math.abs(Math.sin(c)),f=e+" solid "+r+"px;";return'<div style="'+["position:absolute;width:"+l+"px;height:"+l+"px;z-index:-1;",(u+=";"+s+":-"+Math.round(100*((d-Math.SQRT2*r)/2+Math.SQRT2*r-(d-p)/2))/100+"px")+";"+h+";","border-bottom:"+f,"border-right:"+f,"background-color:"+i+";"].join("")+'"></div>'}(n,i,r)),H(t))o.innerHTML=t+a;else if(t){// Clear previous
o.innerHTML="",G(t)||(t=[t]);for(var s=0;s<t.length;s++)q(t[s])&&t[s].parentNode!==o&&o.appendChild(t[s]);// no arrow if empty
if(a&&o.childNodes.length){// no need to create a new parent element, but it's not supported by IE 10 and older.
// const arrowEl = document.createRange().createContextualFragment(arrow);
var l=document.createElement("div");l.innerHTML=a,o.appendChild(l)}}}else o.innerHTML=""},t.prototype.setEnterable=function(t){this._enterable=t},t.prototype.getSize=function(){var t=this.el;return[t.offsetWidth,t.offsetHeight]},t.prototype.moveTo=function(t,e){var n=this._styleCoord;if(DF(n,this._zr,this._appendToBody,t,e),null!=n[0]&&null!=n[1]){var i=this.el.style;R(TF(n[0],n[1]),(function(t){i[t[0]]=t[1]}))}},
/**
               * when `alwaysShowContent` is true,
               * move the tooltip after chart resized
               */
t.prototype._moveIfResized=function(){// The ratio of left to width
var t=this._styleCoord[2],e=this._styleCoord[3];// The ratio of top to height
this.moveTo(t*this._zr.getWidth(),e*this._zr.getHeight())},t.prototype.hide=function(){var t=this,e=this.el.style;e.visibility="hidden",e.opacity="0",o.transform3dSupported&&(e.willChange=""),this._show=!1,this._longHideTimeout=setTimeout((function(){return t._longHide=!0}),500)},t.prototype.hideLater=function(t){!this._show||this._inContent&&this._enterable||(t?(this._hideDelay=t,// Set show false to avoid invoke hideLater multiple times
this._show=!1,this._hideTimeout=setTimeout(B(this.hide,this),t)):this.hide())},t.prototype.isShow=function(){return this._show},t.prototype.dispose=function(){this.el.parentNode.removeChild(this.el)},t}();const kF=AF;function LF(t){return Math.max(0,t)}function PF(t){var e=LF(t.shadowBlur||0),n=LF(t.shadowOffsetX||0),i=LF(t.shadowOffsetY||0);return{left:LF(e-n),right:LF(e+n),top:LF(e-i),bottom:LF(e+i)}}function OF(t,e,n,i){t[0]=n,t[1]=i,t[2]=t[0]/e.getWidth(),t[3]=t[1]/e.getHeight()}const RF=/** @class */function(){function t(t){this._show=!1,this._styleCoord=[0,0,0,0],this._enterable=!0,this._zr=t.getZr(),OF(this._styleCoord,this._zr,t.getWidth()/2,t.getHeight()/2)}
/**
               * Update when tooltip is rendered
               */return t.prototype.update=function(t){t.get("alwaysShowContent")&&this._moveIfResized()},t.prototype.show=function(){this._hideTimeout&&clearTimeout(this._hideTimeout),this.el.show(),this._show=!0},
/**
               * Set tooltip content
               */
t.prototype.setContent=function(t,e,n,i,r){var o=this;U(t)&&ro(""),this.el&&this._zr.remove(this.el);var a=n.getModel("textStyle");this.el=new Zs({style:{rich:e.richTextStyles,text:t,lineHeight:22,borderWidth:1,borderColor:i,textShadowColor:a.get("textShadowColor"),fill:n.get(["textStyle","color"]),padding:Sg(n,"richText"),verticalAlign:"top",align:"left"},z:n.get("z")}),R(["backgroundColor","borderRadius","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY"],(function(t){o.el.style[t]=n.get(t)})),R(["textShadowBlur","textShadowOffsetX","textShadowOffsetY"],(function(t){o.el.style[t]=a.get(t)||0})),this._zr.add(this.el);var s=this;this.el.on("mouseover",(function(){// clear the timeout in hideLater and keep showing tooltip
s._enterable&&(clearTimeout(s._hideTimeout),s._show=!0),s._inContent=!0})),this.el.on("mouseout",(function(){s._enterable&&s._show&&s.hideLater(s._hideDelay),s._inContent=!1}))},t.prototype.setEnterable=function(t){this._enterable=t},t.prototype.getSize=function(){var t=this.el,e=this.el.getBoundingRect(),n=PF(t.style);return[e.width+n.left+n.right,e.height+n.top+n.bottom]},t.prototype.moveTo=function(t,e){var n=this.el;if(n){var i=this._styleCoord;OF(i,this._zr,t,e),t=i[0],e=i[1];var r=n.style,o=LF(r.borderWidth||0),a=PF(r);// rich text x, y do not include border.
n.x=t+o+a.left,n.y=e+o+a.top,n.markRedraw()}},
/**
               * when `alwaysShowContent` is true,
               * move the tooltip after chart resized
               */
t.prototype._moveIfResized=function(){// The ratio of left to width
var t=this._styleCoord[2],e=this._styleCoord[3];// The ratio of top to height
this.moveTo(t*this._zr.getWidth(),e*this._zr.getHeight())},t.prototype.hide=function(){this.el&&this.el.hide(),this._show=!1},t.prototype.hideLater=function(t){!this._show||this._inContent&&this._enterable||(t?(this._hideDelay=t,// Set show false to avoid invoke hideLater multiple times
this._show=!1,this._hideTimeout=setTimeout(B(this.hide,this),t)):this.hide())},t.prototype.isShow=function(){return this._show},t.prototype.dispose=function(){this._zr.remove(this.el)},t}();var NF=new Ls({shape:{x:-1,y:-1,width:2,height:2}}),EF=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(t,e){if(!o.node&&e.getDom()){var n,i=t.getComponent("tooltip"),r=this._renderMode="auto"===(n=i.get("renderMode"))?o.domSupported?"html":"richText":n||"html";this._tooltipContent="richText"===r?new RF(e):new kF(e.getDom(),e,{appendToBody:i.get("appendToBody",!0)})}},e.prototype.render=function(t,e,n){if(!o.node&&n.getDom()){// Reset
this.group.removeAll(),this._tooltipModel=t,this._ecModel=e,this._api=n,
/**
                 * @private
                 * @type {boolean}
                 */
this._alwaysShowContent=t.get("alwaysShowContent");var i=this._tooltipContent;i.update(t),i.setEnterable(t.get("enterable")),this._initGlobalListener(),this._keepShow(),// PENDING
// `mousemove` event will be triggered very frequently when the mouse moves fast,
// which causes that the `updatePosition` function was also called frequently.
// In Chrome with devtools open and Firefox, tooltip looks laggy and shakes. See #14695 #16101
// To avoid frequent triggering,
// consider throttling it in 50ms when transition is enabled
"richText"!==this._renderMode&&t.get("transitionDuration")?ty(this,"_updatePosition",50,"fixRate"):ey(this,"_updatePosition")}},e.prototype._initGlobalListener=function(){var t=this._tooltipModel.get("triggerOn");uz("itemTooltip",this._api,B((function(e,n,i){// If 'none', it is not controlled by mouse totally.
"none"!==t&&(t.indexOf(e)>=0?this._tryShow(n,i):"leave"===e&&this._hide(i))}),this))},e.prototype._keepShow=function(){var t=this._tooltipModel,e=this._ecModel,n=this._api,i=t.get("triggerOn");// Try to keep the tooltip show when refreshing
if(null!=this._lastX&&null!=this._lastY&&"none"!==i&&"click"!==i){var r=this;clearTimeout(this._refreshUpdateTimeout),this._refreshUpdateTimeout=setTimeout((function(){// Show tip next tick after other charts are rendered
// In case highlight action has wrong result
// FIXME
!n.isDisposed()&&r.manuallyShowTip(t,e,n,{x:r._lastX,y:r._lastY,dataByCoordSys:r._lastDataByCoordSys})}))}},
/**
               * Show tip manually by
               * dispatchAction({
               *     type: 'showTip',
               *     x: 10,
               *     y: 10
               * });
               * Or
               * dispatchAction({
               *      type: 'showTip',
               *      seriesIndex: 0,
               *      dataIndex or dataIndexInside or name
               * });
               *
               *  TODO Batch
               */
e.prototype.manuallyShowTip=function(t,e,n,i){if(i.from!==this.uid&&!o.node&&n.getDom()){var r=VF(i,n);// Reset ticket
this._ticket="";// When triggered from axisPointer.
var a=i.dataByCoordSys,s=
/**
             * Find target component by payload like:
             * ```js
             * { legendId: 'some_id', name: 'xxx' }
             * { toolboxIndex: 1, name: 'xxx' }
             * { geoName: 'some_name', name: 'xxx' }
             * ```
             * PENDING: at present only
             *
             * If not found, return null/undefined.
             */
function(t,e,n){var i=Mo(t).queryOptionMap,r=i.keys()[0];if(r&&"series"!==r){var o=Co(e,r,i.get(r),{useDefault:!1,enableAll:!1,enableNone:!1}),a=o.models[0];if(a){var s,l=n.getViewOfComponentModel(a);return l.group.traverse((function(e){var n=js(e).tooltipConfig;if(n&&n.name===t.name)return s=e,!0;// stop
})),s?{componentMainType:r,componentIndex:a.componentIndex,el:s}:void 0}}}(i,e,n);if(s){var l=s.el.getBoundingRect().clone();l.applyTransform(s.el.transform),this._tryShow({offsetX:l.x+l.width/2,offsetY:l.y+l.height/2,target:s.el,position:i.position,// When manully trigger, the mouse is not on the el, so we'd better to
// position tooltip on the bottom of the el and display arrow is possible.
positionDefault:"bottom"},r)}else if(i.tooltip&&null!=i.x&&null!=i.y){var u=NF;u.x=i.x,u.y=i.y,u.update(),js(u).tooltipConfig={name:null,option:i.tooltip},// Manually show tooltip while view is not using zrender elements.
this._tryShow({offsetX:i.x,offsetY:i.y,target:u},r)}else if(a)this._tryShow({offsetX:i.x,offsetY:i.y,position:i.position,dataByCoordSys:a,tooltipOption:i.tooltipOption},r);else if(null!=i.seriesIndex){if(this._manuallyAxisShowTip(t,e,n,i))return;var h=gz(i,e),c=h.point[0],p=h.point[1];null!=c&&null!=p&&this._tryShow({offsetX:c,offsetY:p,target:h.el,position:i.position,// When manully trigger, the mouse is not on the el, so we'd better to
// position tooltip on the bottom of the el and display arrow is possible.
positionDefault:"bottom"},r)}else null!=i.x&&null!=i.y&&(// FIXME
// should wrap dispatchAction like `axisPointer/globalListener` ?
n.dispatchAction({type:"updateAxisPointer",x:i.x,y:i.y}),this._tryShow({offsetX:i.x,offsetY:i.y,position:i.position,target:n.getZr().findHover(i.x,i.y).target},r))}},e.prototype.manuallyHideTip=function(t,e,n,i){var r=this._tooltipContent;!this._alwaysShowContent&&this._tooltipModel&&r.hideLater(this._tooltipModel.get("hideDelay")),this._lastX=this._lastY=this._lastDataByCoordSys=null,i.from!==this.uid&&this._hide(VF(i,n))},// Be compatible with previous design, that is, when tooltip.type is 'axis' and
// dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
// and tooltip.
e.prototype._manuallyAxisShowTip=function(t,e,n,i){var r=i.seriesIndex,o=i.dataIndex,a=e.getComponent("axisPointer").coordSysAxesInfo;if(null!=r&&null!=o&&null!=a){var s=e.getSeriesByIndex(r);if(s&&"axis"===zF([s.getData().getItemModel(o),s,(s.coordinateSystem||{}).model],this._tooltipModel).get("trigger"))return n.dispatchAction({type:"updateAxisPointer",seriesIndex:r,dataIndex:o,position:i.position}),!0}},e.prototype._tryShow=function(t,e){var n=t.target;if(this._tooltipModel){// Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
this._lastX=t.offsetX,this._lastY=t.offsetY;var i=t.dataByCoordSys;if(i&&i.length)this._showAxisTooltip(i,t);else if(n){var r,o;this._lastDataByCoordSys=null,Uy(n,(function(t){// Always show item tooltip if mouse is on the element with dataIndex
return null!=js(t).dataIndex?(r=t,!0):// Tooltip provided directly. Like legend.
null!=js(t).tooltipConfig?(o=t,!0):void 0}),!0),r?this._showSeriesItemTooltip(t,r,e):o?this._showComponentItemTooltip(t,o,e):this._hide(e)}else this._lastDataByCoordSys=null,this._hide(e)}},e.prototype._showOrMove=function(t,e){// showDelay is used in this case: tooltip.enterable is set
// as true. User intent to move mouse into tooltip and click
// something. `showDelay` makes it easier to enter the content
// but tooltip do not move immediately.
var n=t.get("showDelay");e=B(e,this),clearTimeout(this._showTimout),n>0?this._showTimout=setTimeout(e,n):e()},e.prototype._showAxisTooltip=function(t,e){var n=this._ecModel,i=this._tooltipModel,r=[e.offsetX,e.offsetY],o=zF([e.tooltipOption],i),a=this._renderMode,s=[],l=dg("section",{blocks:[],noHeader:!0}),u=[],h=new Mg;R(t,(function(t){R(t.dataByAxis,(function(t){var e=n.getComponent(t.axisDim+"Axis",t.axisIndex),r=t.value;if(e&&null!=r){var o=jE(r,e.axis,n,t.seriesDataIndices,t.valueLabelOpt),c=dg("section",{header:o,noHeader:!rt(o),sortBlocks:!0,blocks:[]});l.blocks.push(c),R(t.seriesDataIndices,(function(l){var p=n.getSeriesByIndex(l.seriesIndex),d=l.dataIndexInside,f=p.getDataParams(d);// Can't find data.
if(!(f.dataIndex<0)){f.axisDim=t.axisDim,f.axisIndex=t.axisIndex,f.axisType=t.axisType,f.axisId=t.axisId,f.axisValue=N_(e.axis,{value:r}),f.axisValueLabel=o,// Pre-create marker style for makers. Users can assemble richText
// text in `formatter` callback and use those markers style.
f.marker=h.makeTooltipMarker("item",Cp(f.color),a);var g=Af(p.formatTooltip(d,!0,null)),y=g.frag;if(y){var v=zF([p],i).get("valueFormatter");c.blocks.push(v?A({valueFormatter:v},y):y)}g.text&&u.push(g.text),s.push(f)}}))}}))})),// In most cases, the second axis is displays upper on the first one.
// So we reverse it to look better.
l.blocks.reverse(),u.reverse();var c=e.position,p=o.get("order"),d=xg(l,h,a,p,n.get("useUTC"),o.get("textStyle"));d&&u.unshift(d);var f="richText"===a?"\n\n":"<br/>",g=u.join(f);this._showOrMove(o,(function(){this._updateContentNotChangedOnAxis(t,s)?this._updatePosition(o,c,r[0],r[1],this._tooltipContent,s):this._showTooltipContent(o,g,s,Math.random()+"",r[0],r[1],c,null,h)}))},e.prototype._showSeriesItemTooltip=function(t,e,n){var i=this._ecModel,r=js(e),o=r.seriesIndex,a=i.getSeriesByIndex(o),s=r.dataModel||a,l=r.dataIndex,u=r.dataType,h=s.getData(u),c=this._renderMode,p=t.positionDefault,d=zF([h.getItemModel(l),s,a&&(a.coordinateSystem||{}).model],this._tooltipModel,p?{position:p}:null),f=d.get("trigger");if(null==f||"item"===f){var g=s.getDataParams(l,u),y=new Mg;// Pre-create marker style for makers. Users can assemble richText
// text in `formatter` callback and use those markers style.
g.marker=y.makeTooltipMarker("item",Cp(g.color),c);var v=Af(s.formatTooltip(l,!1,u)),m=d.get("order"),x=d.get("valueFormatter"),_=v.frag,b=_?xg(x?A({valueFormatter:x},_):_,y,c,m,i.get("useUTC"),d.get("textStyle")):v.text,w="item_"+s.name+"_"+l;this._showOrMove(d,(function(){this._showTooltipContent(d,b,g,w,t.offsetX,t.offsetY,t.position,t.target,y)})),// FIXME
// duplicated showtip if manuallyShowTip is called from dispatchAction.
n({type:"showTip",dataIndexInside:l,dataIndex:h.getRawIndex(l),seriesIndex:o,from:this.uid})}},e.prototype._showComponentItemTooltip=function(t,e,n){var i=js(e),r=i.tooltipConfig.option||{};H(r)&&(r={content:r,// Fixed formatter
formatter:r});var o=[r],a=this._ecModel.getComponent(i.componentMainType,i.componentIndex);a&&o.push(a),// In most cases, component tooltip formatter has different params with series tooltip formatter,
// so that they can not share the same formatter. Since the global tooltip formatter is used for series
// by convension, we do not use it as the default formatter for component.
o.push({formatter:r.content});var s=t.positionDefault,l=zF(o,this._tooltipModel,s?{position:s}:null),u=l.get("content"),h=Math.random()+"",c=new Mg;// Do not check whether `trigger` is 'none' here, because `trigger`
// only works on coordinate system. In fact, we have not found case
// that requires setting `trigger` nothing on component yet.
this._showOrMove(l,(function(){// Use formatterParams from element defined in component
// Avoid users modify it.
var n=T(l.get("formatterParams")||{});this._showTooltipContent(l,u,n,h,t.offsetX,t.offsetY,t.position,e,c)})),// If not dispatch showTip, tip may be hide triggered by axis.
n({type:"showTip",from:this.uid})},e.prototype._showTooltipContent=function(// Use Model<TooltipOption> insteadof TooltipModel because this model may be from series or other options.
// Instead of top level tooltip.
t,e,n,i,r,o,a,s,l){if(// Reset ticket
this._ticket="",t.get("showContent")&&t.get("show")){var u=this._tooltipContent;u.setEnterable(t.get("enterable"));var h=t.get("formatter");a=a||t.get("position");var c=e,p=this._getNearestPoint([r,o],n,t.get("trigger"),t.get("borderColor")).color;if(h)if(H(h)){var d=t.ecModel.get("useUTC"),f=G(n)?n[0]:n;c=h,f&&f.axisType&&f.axisType.indexOf("time")>=0&&(c=ip(f.axisValue,c,d)),c=Tp(c,n,!0)}else if(W(h)){var g=B((function(e,i){e===this._ticket&&(u.setContent(i,l,t,p,a),this._updatePosition(t,a,r,o,u,n,s))}),this);this._ticket=i,c=h(n,i,g)}else c=h;u.setContent(c,l,t,p,a),u.show(t,p),this._updatePosition(t,a,r,o,u,n,s)}},e.prototype._getNearestPoint=function(t,e,n,i){return"axis"===n||G(e)?{color:i||("html"===this._renderMode?"#fff":"none")}:G(e)?void 0:{color:i||e.color||e.borderColor}},e.prototype._updatePosition=function(t,e,n,// Mouse x
i,// Mouse y
r,o,a){var s=this._api.getWidth(),l=this._api.getHeight();e=e||t.get("position");var u=r.getSize(),h=t.get("align"),c=t.get("verticalAlign"),p=a&&a.getBoundingRect().clone();if(a&&p.applyTransform(a.transform),W(e)&&(// Callback of position can be an array or a string specify the position
e=e([n,i],o,r.el,p,{viewSize:[s,l],contentSize:u.slice()})),G(e))n=Vr(e[0],s),i=Vr(e[1],l);else if(U(e)){var d=e;d.width=u[0],d.height=u[1];var f=Rp(d,{width:s,height:l});n=f.x,i=f.y,h=null,// When positionExpr is left/top/right/bottom,
// align and verticalAlign will not work.
c=null}// Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
else if(H(e)&&a){var g=function(t,e,n,i){var r=n[0],o=n[1],a=Math.ceil(Math.SQRT2*i)+8,s=0,l=0,u=e.width,h=e.height;switch(t){case"inside":s=e.x+u/2-r/2,l=e.y+h/2-o/2;break;case"top":s=e.x+u/2-r/2,l=e.y-o-a;break;case"bottom":s=e.x+u/2-r/2,l=e.y+h+a;break;case"left":s=e.x-r-a,l=e.y+h/2-o/2;break;case"right":s=e.x+u+a,l=e.y+h/2-o/2}return[s,l]}(e,p,u,t.get("borderWidth"));n=g[0],i=g[1]}else g=function(t,e,n,i,r,o,a){var s=n.getSize(),l=s[0],u=s[1];return null!=o&&(// Add extra 2 pixels for this case:
// At present the "values" in defaut tooltip are using CSS `float: right`.
// When the right edge of the tooltip box is on the right side of the
// viewport, the `float` layout might push the "values" to the second line.
t+l+o+2>i?t-=l+o:t+=o),null!=a&&(e+u+a>r?e-=u+a:e+=a),[t,e]}(n,i,r,s,l,h?null:20,c?null:20),n=g[0],i=g[1];h&&(n-=BF(h)?u[0]/2:"right"===h?u[0]:0),c&&(i-=BF(c)?u[1]/2:"bottom"===c?u[1]:0),xF(t)&&(g=function(t,e,n,i,r){var o=n.getSize(),a=o[0],s=o[1];return t=Math.min(t+a,i)-a,e=Math.min(e+s,r)-s,t=Math.max(t,0),e=Math.max(e,0),[t,e]}(n,i,r,s,l),n=g[0],i=g[1]),r.moveTo(n,i)},// FIXME
// Should we remove this but leave this to user?
e.prototype._updateContentNotChangedOnAxis=function(t,e){var n=this._lastDataByCoordSys,i=this._cbParamsList,r=!!n&&n.length===t.length;return r&&R(n,(function(n,o){var a=n.dataByAxis||[],s=(t[o]||{}).dataByAxis||[];(r=r&&a.length===s.length)&&R(a,(function(t,n){var o=s[n]||{},a=t.seriesDataIndices||[],l=o.seriesDataIndices||[];(r=r&&t.value===o.value&&t.axisType===o.axisType&&t.axisId===o.axisId&&a.length===l.length)&&R(a,(function(t,e){var n=l[e];r=r&&t.seriesIndex===n.seriesIndex&&t.dataIndex===n.dataIndex})),// check is cbParams data value changed
i&&R(t.seriesDataIndices,(function(t){var n=t.seriesIndex,o=e[n],a=i[n];o&&a&&a.data!==o.data&&(r=!1)}))}))})),this._lastDataByCoordSys=t,this._cbParamsList=e,!!r},e.prototype._hide=function(t){// Do not directly hideLater here, because this behavior may be prevented
// in dispatchAction when showTip is dispatched.
// FIXME
// duplicated hideTip if manuallyHideTip is called from dispatchAction.
this._lastDataByCoordSys=null,t({type:"hideTip",from:this.uid})},e.prototype.dispose=function(t,e){!o.node&&e.getDom()&&(ey(this,"_updatePosition"),this._tooltipContent.dispose(),pz("itemTooltip",e))},e.type="tooltip",e}(Bg);
/**
             * From top to bottom. (the last one should be globalTooltipModel);
             */
function zF(t,e,n){// Last is always tooltip model.
var i,r=e.ecModel;n?(i=new Pc(n,r,r),i=new Pc(e.option,i,r)):i=e;for(var o=t.length-1;o>=0;o--){var a=t[o];a&&(a instanceof Pc&&(a=a.get("tooltip",!0)),// In each data item tooltip can be simply write:
// {
//  value: 10,
//  tooltip: 'Something you need to know'
// }
H(a)&&(a={formatter:a}),a&&(i=new Pc(a,i,r)))}return i}function VF(t,e){return t.dispatchAction||B(e.dispatchAction,e)}function BF(t){return"center"===t||"middle"===t}const FF=EF;var GF=["rect","polygon","keep","clear"];function WF(t,e){var n=lo(t?t.brush:[]);if(n.length){var i=[];R(n,(function(t){var e=t.hasOwnProperty("toolbox")?t.toolbox:[];e instanceof Array&&(i=i.concat(e))}));var r=t&&t.toolbox;G(r)&&(r=r[0]),r||(r={feature:{}},t.toolbox=[r]);var o=r.feature||(r.feature={}),a=o.brush||(o.brush={}),s=a.type||(a.type=[]);s.push.apply(s,i),function(t){var e={};R(t,(function(t){e[t]=1})),t.length=0,R(e,(function(e,n){t.push(n)}))}(s),e&&!s.length&&s.push.apply(s,GF)}}var HF=R;function YF(t){if(t)for(var e in t)if(t.hasOwnProperty(e))return!0}function XF(t,e,n){var i={};return HF(e,(function(e){var r,o=i[e]=(// Make sure hidden fields will not be visited by
// object iteration (with hasOwnProperty checking).
(r=function(){}).prototype.__hidden=r.prototype,new r);HF(t[e],(function(t,i){if(kA.isValidType(i)){var r={type:i,visual:t};n&&n(r,e),o[i]=new kA(r),// Prepare a alpha for opacity, for some case that opacity
// is not supported, such as rendering using gradient color.
"opacity"===i&&((r=T(r)).type="colorAlpha",o.__hidden.__alphaForOpacity=new kA(r))}}))})),i}function UF(t,e,n){// Visual attributes merge is not supported, otherwise it
// brings overcomplicated merge logic. See #2853. So if
// newOption has anyone of these keys, all of these keys
// will be reset. Otherwise, all keys remain.
var i;R(n,(function(t){e.hasOwnProperty(t)&&YF(e[t])&&(i=!0)})),i&&R(n,(function(n){e.hasOwnProperty(n)&&YF(e[n])?t[n]=T(e[n]):delete t[n]}))}
/**
             * @param stateList
             * @param visualMappings
             * @param list
             * @param getValueState param: valueOrIndex, return: state.
             * @param scope Scope for getValueState
             * @param dimension Concrete dimension, if used.
             */
// ???! handle brush?
var ZF={lineX:jF(0),lineY:jF(1),rect:{point:function(t,e,n){return t&&n.boundingRect.contain(t[0],t[1])},rect:function(t,e,n){return t&&n.boundingRect.intersect(t)}},polygon:{point:function(t,e,n){return t&&n.boundingRect.contain(t[0],t[1])&&W_(n.range,t[0],t[1])},rect:function(t,e,n){var i=n.range;if(!t||i.length<=1)return!1;var r=t.x,o=t.y,a=t.width,s=t.height,l=i[0];return!!(W_(i,r,o)||W_(i,r+a,o)||W_(i,r,o+s)||W_(i,r+a,o+s)||Ce.create(t).contain(l[0],l[1])||Kh(r,o,r+a,o,i)||Kh(r,o,r,o+s,i)||Kh(r+a,o,r+a,o+s,i)||Kh(r,o+s,r+a,o+s,i))||void 0}}};function jF(t){var e=["x","y"],n=["width","height"];return{point:function(e,n,i){if(e){var r=i.range;return qF(e[t],r)}},rect:function(i,r,o){if(i){var a=o.range,s=[i[e[t]],i[e[t]]+i[n[t]]];return s[1]<s[0]&&s.reverse(),qF(s[0],a)||qF(s[1],a)||qF(a[0],s)||qF(a[1],s)}}}}function qF(t,e){return e[0]<=t&&t<=e[1]}var KF=["inBrush","outOfBrush"],$F="__ecBrushSelect",JF="__ecInBrushSelectEvent";function QF(t){t.eachComponent({mainType:"brush"},(function(e){(e.brushTargetManager=new lF(e.option,t)).setInputRanges(e.areas,t)}))}
/**
             * Register the visual encoding if this modules required.
             */function tG(t,e,n){var i,r,o=[];t.eachComponent({mainType:"brush"},(function(t){n&&"takeGlobalCursor"===n.type&&t.setBrushOption("brush"===n.key?n.brushOption:{brushType:!1})})),QF(t),t.eachComponent({mainType:"brush"},(function(e,n){var a={brushId:e.id,brushIndex:n,brushName:e.name,areas:T(e.areas),selected:[]};// Every brush component exists in event params, convenient
// for user to find by index.
o.push(a);var s=e.option,l=s.brushLink,u=[],h=[],c=[],p=!1;n||(// Only the first throttle setting works.
i=s.throttleType,r=s.throttleDelay);// Add boundingRect and selectors to range.
var d=N(e.areas,(function(t){var e=iG[t.brushType],n=k({boundingRect:e?e(t):void 0},t);return n.selectors=function(t){var e=t.brushType,n={point:function(i){return ZF[e].point(i,n,t)},rect:function(i){return ZF[e].rect(i,n,t)}};// Do not use function binding or curry for performance.
return n}(n),n})),f=XF(e.option,KF,(function(t){t.mappingMethod="fixed"}));function g(t){return"all"===l||!!u[t]}// If no supported brush or no brush on the series,
// all visuals should be in original state.
function y(t){return!!t.length}
/**
                 * Logic for each series: (If the logic has to be modified one day, do it carefully!)
                 *
                 * ( brushed  && hasBrushExist  && linkOthers  ) => StepA: record,  StepB: visualByRecord.
                 *   !brushed    hasBrushExist                             nothing,        visualByRecord.
                 *                !hasBrushExist                                              nothing.
                 * ( !brushed  && hasBrushExist  && linkOthers  ) => StepA:  nothing,  StepB: visualByRecord.
                 *                !hasBrushExist                                              nothing.
                 * ( brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB: visualByCheck.
                 *   !brushed                                                                  nothing.
                 * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
                 */
// Step A
G(l)&&R(l,(function(t){u[t]=1})),t.eachSeries((function(n,i){var r=c[i]=[];"parallel"===n.subType?function(t,e){var n=t.coordinateSystem;p=p||n.hasAxisBrushed(),g(e)&&n.eachActiveState(t.getData(),(function(t,e){"active"===t&&(h[e]=1)}))}(n,i):function(n,i,r){if(n.brushSelector&&!function(t,e){var n=t.option.seriesIndex;return null!=n&&"all"!==n&&(G(n)?L(n,e)<0:e!==n)}(e,i)&&(R(d,(function(i){e.brushTargetManager.controlSeries(i,n,t)&&r.push(i),p=p||y(r)})),g(i)&&y(r))){var o=n.getData();o.each((function(t){nG(n,r,o,t)&&(h[t]=1)}))}}// Step B
(n,i,r)})),t.eachSeries((function(t,e){var n={seriesId:t.id,seriesIndex:e,seriesName:t.name,dataIndex:[]};// Every series exists in event params, convenient
// for user to find series by seriesIndex.
a.selected.push(n);var i=c[e],r=t.getData(),o=g(e)?function(t){return h[t]?(n.dataIndex.push(r.getRawIndex(t)),"inBrush"):"outOfBrush"}:function(e){return nG(t,i,r,e)?(n.dataIndex.push(r.getRawIndex(e)),"inBrush"):"outOfBrush"};// If no supported brush or no brush, all visuals are in original state.
(g(e)?p:y(i))&&function(t,e,n,i,r,o){var a,s={};function l(t){return Gy(n,a,t)}function u(t,e){Hy(n,a,t,e)}function h(t,h){a=null==o?t:h;var c=n.getRawDataItem(a);// Consider performance
// @ts-ignore
if(!c||!1!==c.visualMap)for(var p=i.call(r,t),d=e[p],f=s[p],g=0,y=f.length;g<y;g++){var v=f[g];d[v]&&d[v].applyVisual(t,l,u)}}R(t,(function(t){var n=kA.prepareVisualTypes(e[t]);s[t]=n})),null==o?n.each(h):n.each([o],h)}
/**
             * @param data
             * @param stateList
             * @param visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
             * @param getValueState param: valueOrIndex, return: state.
             * @param dim dimension or dimension index.
             */(KF,f,r,o)}))})),function(t,e,n,i,r){// This event will not be triggered when `setOpion`, otherwise dead lock may
// triggered when do `setOption` in event listener, which we do not find
// satisfactory way to solve yet. Some considered resolutions:
// (a) Diff with prevoius selected data ant only trigger event when changed.
// But store previous data and diff precisely (i.e., not only by dataIndex, but
// also detect value changes in selected data) might bring complexity or fragility.
// (b) Use spectial param like `silent` to suppress event triggering.
// But such kind of volatile param may be weird in `setOption`.
if(r){var o=t.getZr();if(!o[JF]){o[$F]||(o[$F]=eG);var a=ty(o,$F,n,e);a(t,i)}}}(e,i,r,o,n)}function eG(t,e){if(!t.isDisposed()){var n=t.getZr();n[JF]=!0,t.dispatchAction({type:"brushSelect",batch:e}),n[JF]=!1}}function nG(t,e,n,i){for(var r=0,o=e.length;r<o;r++){var a=e[r];if(t.brushSelector(i,n,a.selectors,a))return!0}}var iG={rect:function(t){return rG(t.range)},polygon:function(t){for(var e,n=t.range,i=0,r=n.length;i<r;i++){e=e||[[1/0,-1/0],[1/0,-1/0]];var o=n[i];o[0]<e[0][0]&&(e[0][0]=o[0]),o[0]>e[0][1]&&(e[0][1]=o[0]),o[1]<e[1][0]&&(e[1][0]=o[1]),o[1]>e[1][1]&&(e[1][1]=o[1])}return e&&rG(e)}};function rG(t){return new Ce(t[0][0],t[1][0],t[0][1]-t[0][0],t[1][1]-t[1][0])}var oG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(t,e){this.ecModel=t,this.api=e,this.model,(this._brushController=new HP(e.getZr())).on("brush",B(this._onBrush,this)).mount()},e.prototype.render=function(t,e,n,i){this.model=t,this._updateController(t,e,n,i)},e.prototype.updateTransform=function(t,e,n,i){// PENDING: `updateTransform` is a little tricky, whose layout need
// to be calculate mandatorily and other stages will not be performed.
// Take care the correctness of the logic. See #11754 .
QF(e),this._updateController(t,e,n,i)},e.prototype.updateVisual=function(t,e,n,i){this.updateTransform(t,e,n,i)},e.prototype.updateView=function(t,e,n,i){this._updateController(t,e,n,i)},e.prototype._updateController=function(t,e,n,i){// Do not update controller when drawing.
(!i||i.$from!==t.id)&&this._brushController.setPanels(t.brushTargetManager.makePanelOpts(n)).enableBrush(t.brushOption).updateCovers(t.areas.slice())},// updateLayout: updateController,
// updateVisual: updateController,
e.prototype.dispose=function(){this._brushController.dispose()},e.prototype._onBrush=function(t){var e=this.model.id,n=this.model.brushTargetManager.setOutputRanges(t.areas,this.ecModel);// Action is not dispatched on drag end, because the drag end
// emits the same params with the last drag move event, and
// may have some delay when using touch pad, which makes
// animation not smooth (when using debounce).
(!t.isEnd||t.removeOnClick)&&this.api.dispatchAction({type:"brush",brushId:e,areas:T(n),$from:e}),t.isEnd&&this.api.dispatchAction({type:"brushEnd",brushId:e,areas:T(n),$from:e})},e.type="brush",e}(Bg);const aG=oG;var sG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,
/**
                 * @readOnly
                 */
n.areas=[],
/**
                 * Current brush painting area settings.
                 * @readOnly
                 */
n.brushOption={},n}return n(e,t),e.prototype.optionUpdated=function(t,e){var n=this.option;!e&&UF(n,t,["inBrush","outOfBrush"]);var i=n.inBrush=n.inBrush||{};// Always give default visual, consider setOption at the second time.
n.outOfBrush=n.outOfBrush||{color:"#ddd"},i.hasOwnProperty("liftZ")||(// Bigger than the highlight z lift, otherwise it will
// be effected by the highlight z when brush.
i.liftZ=5)},
/**
               * If `areas` is null/undefined, range state remain.
               */
e.prototype.setAreas=function(t){// This helps user to dispatchAction({type: 'brush'}) with no areas
// set but just want to get the current brush select info from a `brush` event.
t&&(this.areas=N(t,(function(t){return lG(this.option,t)}),this))},
/**
               * Set the current painting brush option.
               */
e.prototype.setBrushOption=function(t){this.brushOption=lG(this.option,t),this.brushType=this.brushOption.brushType},e.type="brush",e.dependencies=["geo","grid","xAxis","yAxis","parallel","series"],e.defaultOption={seriesIndex:"all",brushType:"rect",brushMode:"single",transformable:!0,brushStyle:{borderWidth:1,color:"rgba(210,219,238,0.3)",borderColor:"#D2DBEE"},throttleType:"fixRate",throttleDelay:0,removeOnClick:!0,z:1e4},e}(Wp);function lG(t,e){return C({brushType:t.brushType,brushMode:t.brushMode,transformable:t.transformable,brushStyle:new Pc(t.brushStyle).getItemStyle(),removeOnClick:t.removeOnClick,z:t.z},e,!0)}const uG=sG;var hG=["rect","polygon","lineX","lineY","keep","clear"],cG=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.render=function(t,e,n){var i,r,o;e.eachComponent({mainType:"brush"},(function(t){i=t.brushType,r=t.brushOption.brushMode||"single",o=o||!!t.areas.length})),this._brushType=i,this._brushMode=r,R(t.get("type",!0),(function(e){t.setIconStatus(e,("keep"===e?"multiple"===r:"clear"===e?o:e===i)?"emphasis":"normal")}))},e.prototype.updateView=function(t,e,n){this.render(t,e,n)},e.prototype.getIcons=function(){var t=this.model,e=t.get("icon",!0),n={};return R(t.get("type",!0),(function(t){e[t]&&(n[t]=e[t])})),n},e.prototype.onclick=function(t,e,n){var i=this._brushType,r=this._brushMode;"clear"===n?(// Trigger parallel action firstly
e.dispatchAction({type:"axisAreaSelect",intervals:[]}),e.dispatchAction({type:"brush",command:"clear",// Clear all areas of all brush components.
areas:[]})):e.dispatchAction({type:"takeGlobalCursor",key:"brush",brushOption:{brushType:"keep"===n?i:i!==n&&n,brushMode:"keep"===n?"multiple"===r?"single":"multiple":r}})},e.getDefaultOption=function(t){return{show:!0,type:hG.slice(),icon:{/* eslint-disable */rect:"M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",polygon:"M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",lineX:"M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",lineY:"M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",keep:"M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",clear:"M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"},// `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
title:t.getLocaleModel().get(["toolbox","brush","title"])}},e}(bB);const pG=cG;var dG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.layoutMode={type:"box",ignoreSize:!0},n}return n(e,t),e.type="title",e.defaultOption={// zlevel: 0,
z:6,show:!0,text:"",target:"blank",subtext:"",subtarget:"blank",left:0,top:0,backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderWidth:0,padding:5,itemGap:10,textStyle:{fontSize:18,fontWeight:"bold",color:"#464646"},subtextStyle:{fontSize:12,color:"#6E7079"}},e}(Wp),fG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.render=function(t,e,n){if(this.group.removeAll(),t.get("show")){var i=this.group,r=t.getModel("textStyle"),o=t.getModel("subtextStyle"),a=t.get("textAlign"),s=Q(t.get("textBaseline"),t.get("textVerticalAlign")),l=new Zs({style:lc(r,{text:t.get("text"),fill:r.getTextColor()},{disableBox:!0}),z2:10}),u=l.getBoundingRect(),h=t.get("subtext"),c=new Zs({style:lc(o,{text:h,fill:o.getTextColor(),y:u.height+t.get("itemGap"),verticalAlign:"top"},{disableBox:!0}),z2:10}),p=t.get("link"),d=t.get("sublink"),f=t.get("triggerEvent",!0);l.silent=!p&&!f,c.silent=!d&&!f,p&&l.on("click",(function(){Dp(p,"_"+t.get("target"))})),d&&c.on("click",(function(){Dp(d,"_"+t.get("subtarget"))})),js(l).eventData=js(c).eventData=f?{componentType:"title",componentIndex:t.componentIndex}:null,i.add(l),h&&i.add(c);// If no subText, but add subTextEl, there will be an empty line.
var g=i.getBoundingRect(),y=t.getBoxLayoutParams();y.width=g.width,y.height=g.height;var v=Rp(y,{width:n.getWidth(),height:n.getHeight()},t.get("padding"));// Adjust text align based on position
a||(// Align left if title is on the left. center and right is same
// @ts-ignore
"middle"===(a=t.get("left")||t.get("right"))&&(a="center"),// Adjust layout by text align
"right"===a?v.x+=v.width:"center"===a&&(v.x+=v.width/2)),s||(// @ts-ignore
"center"===(s=t.get("top")||t.get("bottom"))&&(s="middle"),"bottom"===s?v.y+=v.height:"middle"===s&&(v.y+=v.height/2),s=s||"top"),i.x=v.x,i.y=v.y,i.markRedraw();var m={align:a,verticalAlign:s};l.setStyle(m),c.setStyle(m),// Render background
// Get groupRect again because textAlign has been changed
g=i.getBoundingRect();var x=v.margin,_=t.getItemStyle(["color","opacity"]);_.fill=t.get("backgroundColor");var b=new Ls({shape:{x:g.x-x[3],y:g.y-x[0],width:g.width+x[1]+x[3],height:g.height+x[0]+x[2],r:t.get("borderRadius")},style:_,subPixelOptimize:!0,silent:!0});i.add(b)}},e.type="title",e}(Bg),gG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.layoutMode="box",n}
/**
               * @override
               */return n(e,t),e.prototype.init=function(t,e,n){this.mergeDefaultAndTheme(t,n),this._initData()},
/**
               * @override
               */
e.prototype.mergeOption=function(e){t.prototype.mergeOption.apply(this,arguments),this._initData()},e.prototype.setCurrentIndex=function(t){null==t&&(t=this.option.currentIndex);var e=this._data.count();this.option.loop?t=(t%e+e)%e:(t>=e&&(t=e-1),t<0&&(t=0)),this.option.currentIndex=t},
/**
               * @return {number} currentIndex
               */
e.prototype.getCurrentIndex=function(){return this.option.currentIndex},
/**
               * @return {boolean}
               */
e.prototype.isIndexMax=function(){return this.getCurrentIndex()>=this._data.count()-1},
/**
               * @param {boolean} state true: play, false: stop
               */
e.prototype.setPlayState=function(t){this.option.autoPlay=!!t},
/**
               * @return {boolean} true: play, false: stop
               */
e.prototype.getPlayState=function(){return!!this.option.autoPlay},
/**
               * @private
               */
e.prototype._initData=function(){var t,e=this.option,n=e.data||[],i=e.axisType,r=this._names=[];"category"===i?(t=[],R(n,(function(e,n){var i,o=vo(co(e),"");U(e)?(i=T(e)).value=n:i=n,t.push(i),r.push(o)}))):t=n;var o={category:"ordinal",time:"time",value:"number"}[i]||"number";(this._data=new vx([{name:"value",type:o}],this)).initData(t,r)},e.prototype.getData=function(){return this._data},
/**
               * @public
               * @return {Array.<string>} categoreis
               */
e.prototype.getCategories=function(){if("category"===this.get("axisType"))return this._names.slice()},e.type="timeline",
/**
               * @protected
               */
e.defaultOption={// zlevel: 0,                  // 
z:4,show:!0,axisType:"time",realtime:!0,left:"20%",top:null,right:"20%",bottom:0,width:null,height:40,padding:5,controlPosition:"left",autoPlay:!1,rewind:!1,loop:!0,playInterval:2e3,currentIndex:0,itemStyle:{},label:{color:"#000"},data:[]},e}(Wp);// View
const yG=gG;var vG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="timeline.slider",
/**
               * @protected
               */
e.defaultOption=Nc(yG.defaultOption,{backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderWidth:0,orient:"horizontal",inverse:!1,tooltip:{trigger:"item"},symbol:"circle",symbolSize:12,lineStyle:{show:!0,width:2,color:"#DAE1F5"},label:{position:"auto",// When using number, label position is not
// restricted by viewRect.
// positive: right/bottom, negative: left/top
show:!0,interval:"auto",rotate:0,// formatter: null,
// TEXTSTYLE
color:"#A4B1D7"},itemStyle:{color:"#A4B1D7",borderWidth:1},checkpointStyle:{symbol:"circle",symbolSize:15,color:"#316bf3",borderColor:"#fff",borderWidth:2,shadowBlur:2,shadowOffsetX:1,shadowOffsetY:1,shadowColor:"rgba(0, 0, 0, 0.3)",// borderColor: 'rgba(194,53,49, 0.5)',
animation:!0,animationDuration:300,animationEasing:"quinticInOut"},controlStyle:{show:!0,showPlayBtn:!0,showPrevBtn:!0,showNextBtn:!0,itemSize:24,itemGap:12,position:"left",playIcon:"path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",stopIcon:"path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",// eslint-disable-next-line max-len
nextIcon:"M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",// eslint-disable-next-line max-len
prevIcon:"M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",prevBtnSize:18,nextBtnSize:18,color:"#A4B1D7",borderColor:"#A4B1D7",borderWidth:1},emphasis:{label:{show:!0,// TEXTSTYLE
color:"#6f778d"},itemStyle:{color:"#316BF3"},controlStyle:{color:"#316BF3",borderColor:"#316BF3",borderWidth:2}},progress:{lineStyle:{color:"#316BF3"},itemStyle:{color:"#316BF3"},label:{color:"#6f778d"}},data:[]}),e}(yG);P(vG,Df.prototype);const mG=vG;var xG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="timeline",e}(Bg);const _G=xG;
/**
             * Extend axis 2d
             */var bG=/** @class */function(t){function e(e,n,i,r){var o=t.call(this,e,n,i)||this;return o.type=r||"value",o}
/**
               * @override
               */return n(e,t),e.prototype.getLabelModel=function(){// Force override
return this.model.getModel("label")},
/**
               * @override
               */
e.prototype.isHorizontal=function(){return"horizontal"===this.model.get("orient")},e}(pb);const wG=bG;var SG=Math.PI,MG=bo(),IG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(t,e){this.api=e},
/**
               * @override
               */
e.prototype.render=function(t,e,n){if(this.model=t,this.api=n,this.ecModel=e,this.group.removeAll(),t.get("show",!0)){var i=this._layout(t,n),r=this._createGroup("_mainGroup"),o=this._createGroup("_labelGroup"),a=this._axis=this._createAxis(i,t);t.formatTooltip=function(t){return dg("nameValue",{noName:!0,value:a.scale.getLabel({value:t})})},R(["AxisLine","AxisTick","Control","CurrentPointer"],(function(e){this["_render"+e](i,r,a,t)}),this),this._renderAxisLabel(i,o,a,t),this._position(i,t)}this._doPlayStop(),this._updateTicksStatus()},
/**
               * @override
               */
e.prototype.remove=function(){this._clearTimer(),this.group.removeAll()},
/**
               * @override
               */
e.prototype.dispose=function(){this._clearTimer()},e.prototype._layout=function(t,e){var n,i,r,o,a=t.get(["label","position"]),s=t.get("orient"),l=function(t,e){return Rp(t.getBoxLayoutParams(),{width:e.getWidth(),height:e.getHeight()},t.get("padding"))}(t,e),u={horizontal:"center",vertical:(// Auto label offset.
n=null==a||"auto"===a?"horizontal"===s?l.y+l.height/2<e.getHeight()/2?"-":"+":l.x+l.width/2<e.getWidth()/2?"+":"-":H(a)?{horizontal:{top:"-",bottom:"+"},vertical:{left:"-",right:"+"}}[s][a]:a)>=0||"+"===n?"left":"right"},h={horizontal:n>=0||"+"===n?"top":"bottom",vertical:"middle"},c={horizontal:0,vertical:SG/2},p="vertical"===s?l.height:l.width,d=t.getModel("controlStyle"),f=d.get("show",!0),g=f?d.get("itemSize"):0,y=f?d.get("itemGap"):0,v=g+y,m=t.get(["label","rotate"])||0;m=m*SG/180;var x=d.get("position",!0),_=f&&d.get("showPlayBtn",!0),b=f&&d.get("showPrevBtn",!0),w=f&&d.get("showNextBtn",!0),S=0,M=p;// position[0] means left, position[1] means middle.
"left"===x||"bottom"===x?(_&&(i=[0,0],S+=v),b&&(r=[S,0],S+=v),w&&(o=[M-g,0],M-=v)):(// 'top' 'right'
_&&(i=[M-g,0],M-=v),b&&(r=[0,0],S+=v),w&&(o=[M-g,0],M-=v));var I=[S,M];return t.get("inverse")&&I.reverse(),{viewRect:l,mainLength:p,orient:s,rotation:c[s],labelRotation:m,labelPosOpt:n,labelAlign:t.get(["label","align"])||u[s],labelBaseline:t.get(["label","verticalAlign"])||t.get(["label","baseline"])||h[s],// Based on mainGroup.
playPosition:i,prevBtnPosition:r,nextBtnPosition:o,axisExtent:I,controlSize:g,controlGap:y}},e.prototype._position=function(t,e){// Position is be called finally, because bounding rect is needed for
// adapt content to fill viewRect (auto adapt offset).
// Timeline may be not all in the viewRect when 'offset' is specified
// as a number, because it is more appropriate that label aligns at
// 'offset' but not the other edge defined by viewRect.
var n=this._mainGroup,i=this._labelGroup,r=t.viewRect;if("vertical"===t.orient){// transform to horizontal, inverse rotate by left-top point.
var o=[1,0,0,1,0,0],a=r.x,s=r.y+r.height;pe(o,o,[-a,-s]),de(o,o,-SG/2),pe(o,o,[a,s]),(r=r.clone()).applyTransform(o)}var l=y(r),u=y(n.getBoundingRect()),h=y(i.getBoundingRect()),c=[n.x,n.y],p=[i.x,i.y];p[0]=c[0]=l[0][0];var d,f=t.labelPosOpt;function g(t){t.originX=l[0][0]-t.x,t.originY=l[1][0]-t.y}function y(t){// [[xmin, xmax], [ymin, ymax]]
return[[t.x,t.x+t.width],[t.y,t.y+t.height]]}function v(t,e,n,i,r){t[i]+=n[i][r]-e[i][r]}null==f||H(f)?(v(c,u,l,1,d="+"===f?0:1),v(p,h,l,1,1-d)):(v(c,u,l,1,d=f>=0?0:1),p[1]=c[1]+f),n.setPosition(c),i.setPosition(p),n.rotation=i.rotation=t.rotation,g(n),g(i)},e.prototype._createAxis=function(t,e){var n=e.getData(),i=e.get("axisType"),r=function(t,e){if(e=e||t.get("type"))switch(e){// Buildin scale
case"category":return new Hx({ordinalMeta:t.getCategories(),extent:[1/0,-1/0]});case"time":return new f_({locale:t.ecModel.getLocaleModel(),useUTC:t.ecModel.get("useUTC")});default:// default to be value
return new Ux}}(e,i);// Customize scale. The `tickValue` is `dataIndex`.
r.getTicks=function(){return n.mapArray(["value"],(function(t){return{value:t}}))};var o=n.getDataExtent("value");r.setExtent(o[0],o[1]),r.calcNiceTicks();var a=new wG("value",r,t.axisExtent,i);return a.model=e,a},e.prototype._createGroup=function(t){var e=this[t]=new Lr;return this.group.add(e),e},e.prototype._renderAxisLine=function(t,e,n,i){var r=n.getExtent();if(i.get(["lineStyle","show"])){var o=new qu({shape:{x1:r[0],y1:0,x2:r[1],y2:0},style:A({lineCap:"round"},i.getModel("lineStyle").getLineStyle()),silent:!0,z2:1});e.add(o);var a=this._progressLine=new qu({shape:{x1:r[0],x2:this._currentPointer?this._currentPointer.x:r[0],y1:0,y2:0},style:k({lineCap:"round",lineWidth:o.style.lineWidth},i.getModel(["progress","lineStyle"]).getLineStyle()),silent:!0,z2:1});e.add(a)}},e.prototype._renderAxisTick=function(t,e,n,i){var r=this,o=i.getData(),a=n.scale.getTicks();this._tickSymbols=[],// The value is dataIndex, see the customized scale.
R(a,(function(t){var a=n.dataToCoord(t.value),s=o.getItemModel(t.value),l=s.getModel("itemStyle"),u=s.getModel(["emphasis","itemStyle"]),h=s.getModel(["progress","itemStyle"]),c={x:a,y:0,onclick:B(r._changeTimeline,r,t.value)},p=TG(s,l,e,c);p.ensureState("emphasis").style=u.getItemStyle(),p.ensureState("progress").style=h.getItemStyle(),Vl(p);var d=js(p);s.get("tooltip")?(d.dataIndex=t.value,d.dataModel=i):d.dataIndex=d.dataModel=null,r._tickSymbols.push(p)}))},e.prototype._renderAxisLabel=function(t,e,n,i){var r=this;if(n.getLabelModel().get("show")){var o=i.getData(),a=n.getViewLabels();this._tickLabels=[],R(a,(function(i){// The tickValue is dataIndex, see the customized scale.
var a=i.tickValue,s=o.getItemModel(a),l=s.getModel("label"),u=s.getModel(["emphasis","label"]),h=s.getModel(["progress","label"]),c=n.dataToCoord(i.tickValue),p=new Zs({x:c,y:0,rotation:t.labelRotation-t.rotation,onclick:B(r._changeTimeline,r,a),silent:!1,style:lc(l,{text:i.formattedLabel,align:t.labelAlign,verticalAlign:t.labelBaseline})});p.ensureState("emphasis").style=lc(u),p.ensureState("progress").style=lc(h),e.add(p),Vl(p),MG(p).dataIndex=a,r._tickLabels.push(p)}))}},e.prototype._renderControl=function(t,e,n,i){var r=t.controlSize,o=t.rotation,a=i.getModel("controlStyle").getItemStyle(),s=i.getModel(["emphasis","controlStyle"]).getItemStyle(),l=i.getPlayState(),u=i.get("inverse",!0);function h(t,n,l,u){if(t){var h=vr(Q(i.get(["controlStyle",n+"BtnSize"]),r),r),c=function(t,e,n,i){var r=i.style,o=qh(t.get(["controlStyle",e]),i||{},new Ce(n[0],n[1],n[2],n[3]));// TODO createIcon won't use style in opt.
return r&&o.setStyle(r),o}
/**
             * Create symbol or update symbol
             * opt: basic position and event handlers
             */(i,n+"Icon",[0,-h/2,h,h],{x:t[0],y:t[1],originX:r/2,originY:0,rotation:u?-o:0,rectHover:!0,style:a,onclick:l});c.ensureState("emphasis").style=s,e.add(c),Vl(c)}}h(t.nextBtnPosition,"next",B(this._changeTimeline,this,u?"-":"+")),h(t.prevBtnPosition,"prev",B(this._changeTimeline,this,u?"+":"-")),h(t.playPosition,l?"stop":"play",B(this._handlePlayClick,this,!l),!0)},e.prototype._renderCurrentPointer=function(t,e,n,i){var r=i.getData(),o=i.getCurrentIndex(),a=r.getItemModel(o).getModel("checkpointStyle"),s=this,l={onCreate:function(t){t.draggable=!0,t.drift=B(s._handlePointerDrag,s),t.ondragend=B(s._handlePointerDragend,s),CG(t,s._progressLine,o,n,i,!0)},onUpdate:function(t){CG(t,s._progressLine,o,n,i)}};// Reuse when exists, for animation and drag.
this._currentPointer=TG(a,a,this._mainGroup,{},this._currentPointer,l)},e.prototype._handlePlayClick=function(t){this._clearTimer(),this.api.dispatchAction({type:"timelinePlayChange",playState:t,from:this.uid})},e.prototype._handlePointerDrag=function(t,e,n){this._clearTimer(),this._pointerChangeTimeline([n.offsetX,n.offsetY])},e.prototype._handlePointerDragend=function(t){this._pointerChangeTimeline([t.offsetX,t.offsetY],!0)},e.prototype._pointerChangeTimeline=function(t,e){var n=this._toAxisCoord(t)[0],i=Fr(this._axis.getExtent().slice());n>i[1]&&(n=i[1]),n<i[0]&&(n=i[0]),this._currentPointer.x=n,this._currentPointer.markRedraw();var r=this._progressLine;r&&(r.shape.x2=n,r.dirty());var o=this._findNearestTick(n),a=this.model;(e||o!==a.getCurrentIndex()&&a.get("realtime"))&&this._changeTimeline(o)},e.prototype._doPlayStop=function(){var t=this;this._clearTimer(),this.model.getPlayState()&&(this._timer=setTimeout((function(){// Do not cache
var e=t.model;t._changeTimeline(e.getCurrentIndex()+(e.get("rewind",!0)?-1:1))}),this.model.get("playInterval")))},e.prototype._toAxisCoord=function(t){return Yh(t,this._mainGroup.getLocalTransform(),!0)},e.prototype._findNearestTick=function(t){var e,n=this.model.getData(),i=1/0,r=this._axis;return n.each(["value"],(function(n,o){var a=r.dataToCoord(n),s=Math.abs(a-t);s<i&&(i=s,e=o)})),e},e.prototype._clearTimer=function(){this._timer&&(clearTimeout(this._timer),this._timer=null)},e.prototype._changeTimeline=function(t){var e=this.model.getCurrentIndex();"+"===t?t=e+1:"-"===t&&(t=e-1),this.api.dispatchAction({type:"timelineChange",currentIndex:t,from:this.uid})},e.prototype._updateTicksStatus=function(){var t=this.model.getCurrentIndex(),e=this._tickSymbols,n=this._tickLabels;if(e)for(var i=0;i<e.length;i++)e&&e[i]&&e[i].toggleState("progress",i<t);if(n)for(i=0;i<n.length;i++)n&&n[i]&&n[i].toggleState("progress",MG(n[i]).dataIndex<=t)},e.type="timeline.slider",e}(_G);function TG(t,e,n,i,r,o){var a=e.get("color");r?(r.setColor(a),n.add(r),// Group may be new, also need to add.
o&&o.onUpdate(r)):((r=ov(t.get("symbol"),-1,-1,2,2,a)).setStyle("strokeNoScale",!0),n.add(r),o&&o.onCreate(r));// Style
var s=e.getItemStyle(["color"]);r.setStyle(s),// Transform and events.
i=C({rectHover:!0,z2:100},i,!0);var l=av(t.get("symbolSize"));i.scaleX=l[0]/2,i.scaleY=l[1]/2;var u=sv(t.get("symbolOffset"),l);u&&(i.x=(i.x||0)+u[0],i.y=(i.y||0)+u[1]);var h=t.get("symbolRotate");return i.rotation=(h||0)*Math.PI/180||0,r.attr(i),// FIXME
// (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,
// getBoundingRect will return wrong result.
// (This is supposed to be resolved in zrender, but it is a little difficult to
// leverage performance and auto updateTransform)
// (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.
r.updateTransform(),r}function CG(t,e,n,i,r,o){if(!t.dragging){var a=r.getModel("checkpointStyle"),s=i.dataToCoord(r.getData().get("value",n));if(o||!a.get("animation",!0))t.attr({x:s,y:0}),e&&e.attr({shape:{x2:s}});else{var l={duration:a.get("animationDuration",!0),easing:a.get("animationEasing",!0)};t.stopAnimation(null,!0),t.animateTo({x:s,y:0},l),e&&e.animateTo({shape:{x2:s}},l)}}}const DG=IG;function AG(t){var e=t&&t.timeline;G(e)||(e=e?[e]:[]),R(e,(function(t){t&&function(t){var e=t.type,n={number:"value",time:"time"};if(// Compatible with ec2
n[e]&&(t.axisType=n[e],delete t.type),kG(t),LG(t,"controlPosition")){var i=t.controlStyle||(t.controlStyle={});LG(i,"position")||(i.position=t.controlPosition),"none"!==i.position||LG(i,"show")||(i.show=!1,delete i.position),delete t.controlPosition}R(t.data||[],(function(t){U(t)&&!G(t)&&(!LG(t,"value")&&LG(t,"name")&&(// In ec2, using name as value.
t.value=t.name),kG(t))}))}(t)}))}function kG(t){var e=t.itemStyle||(t.itemStyle={}),n=e.emphasis||(e.emphasis={}),i=t.label||t.label||{},r=i.normal||(i.normal={}),o={normal:1,emphasis:1};R(i,(function(t,e){o[e]||LG(r,e)||(r[e]=t)})),n.label&&!LG(i,"emphasis")&&(i.emphasis=n.label,delete n.label)}function LG(t,e){return t.hasOwnProperty(e)}function PG(t,e){if(!t)return!1;for(var n=G(t)?t:[t],i=0;i<n.length;i++)if(n[i]&&n[i][e])return!0;return!1}function OG(t){uo(t,"label",["show"])}// { [componentType]: MarkerModel }
var RG=bo(),NG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,
/**
                 * If marker model is created by self from series
                 */
n.createdBySelf=!1,n}
/**
               * @overrite
               */return n(e,t),e.prototype.init=function(t,e,n){this.mergeDefaultAndTheme(t,n),this._mergeOption(t,n,!1,!0)},e.prototype.isAnimationEnabled=function(){if(o.node)return!1;var t=this.__hostSeries;return this.getShallow("animation")&&t&&t.isAnimationEnabled()},
/**
               * @overrite
               */
e.prototype.mergeOption=function(t,e){this._mergeOption(t,e,!1,!1)},e.prototype._mergeOption=function(t,e,n,i){var r=this.mainType;n||e.eachSeries((function(t){// mainType can be markPoint, markLine, markArea
var n=t.get(this.mainType,!0),o=RG(t)[r];n&&n.data?(o?o._mergeOption(n,e,!0):(i&&// Default label emphasis `position` and `show`
OG(n),R(n.data,(function(t){// FIXME Overwrite fillLabel method ?
t instanceof Array?(OG(t[0]),OG(t[1])):OG(t)})),// markerModel = new ImplementedMarkerModel(
//     markerOpt, this, ecModel
// );
A(o=this.createMarkerModelFromSeries(n,this,e),{mainType:this.mainType,// Use the same series index and name
seriesIndex:t.seriesIndex,name:t.name,createdBySelf:!0}),o.__hostSeries=t),RG(t)[r]=o):RG(t)[r]=null}),this)},e.prototype.formatTooltip=function(t,e,n){var i=this.getData(),r=this.getRawValue(t),o=i.getName(t);return dg("section",{header:this.name,blocks:[dg("nameValue",{name:o,value:r,noName:!o,noValue:null==r})]})},e.prototype.getData=function(){return this._data},e.prototype.setData=function(t){this._data=t},e.getMarkerModelFromSeries=function(t,// Support three types of markers. Strict check.
e){return RG(t)[e]},e.type="marker",e.dependencies=["series","grid","polar","geo"],e}(Wp);P(NG,Df.prototype);const EG=NG;var zG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.createMarkerModelFromSeries=function(t,n,i){return new e(t,n,i)},e.type="markPoint",e.defaultOption={// zlevel: 0,
z:5,symbol:"pin",symbolSize:50,// symbolRotate: 0,
// symbolOffset: [0, 0]
tooltip:{trigger:"item"},label:{show:!0,position:"inside"},itemStyle:{borderWidth:2},emphasis:{label:{show:!0}}},e}(EG);const VG=zG;function BG(t){return!(isNaN(parseFloat(t.x))&&isNaN(parseFloat(t.y)))}function FG(t,e,n,i,r,o){var a=[],s=Ix(e,i/* , otherDataDim */)?e.getCalculationInfo("stackResultDimension"):i,l=UG(e,s,t),u=e.indicesOfNearest(s,l)[0];a[r]=e.get(n,u),a[o]=e.get(s,u);var h=e.get(i,u),c=Gr(e.get(i,u));// Make it simple, do not visit all stacked value to count precision.
return(c=Math.min(c,20))>=0&&(a[o]=+a[o].toFixed(c)),[a,h]}// TODO Specified percent
var GG={min:F(FG,"min"),max:F(FG,"max"),average:F(FG,"average"),median:F(FG,"median")};
/**
             * Transform markPoint data item to format used in List by do the following
             * 1. Calculate statistic like `max`, `min`, `average`
             * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
             */function WG(t,e){if(e){var n=t.getData(),i=t.coordinateSystem,r=i.dimensions;// 1. If not specify the position with pixel directly
// 2. If `coord` is not a data array. Which uses `xAxis`,
// `yAxis` to specify the coord on each dimension
// parseFloat first because item.x and item.y can be percent string like '20%'
if(!function(t){return!isNaN(parseFloat(t.x))&&!isNaN(parseFloat(t.y))}(e)&&!G(e.coord)&&i){var o=HG(e,n,i,t);// Clone the option
// Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value
if((e=T(e)).type&&GG[e.type]&&o.baseAxis&&o.valueAxis){var a=L(r,o.baseAxis.dim),s=L(r,o.valueAxis.dim),l=GG[e.type](n,o.baseDataDim,o.valueDataDim,a,s);e.coord=l[0],// Force to use the value of calculated value.
// let item use the value without stack.
e.value=l[1]}else// FIXME Only has one of xAxis and yAxis.
e.coord=[null!=e.xAxis?e.xAxis:e.radiusAxis,null!=e.yAxis?e.yAxis:e.angleAxis]}// x y is provided
if(null==e.coord)e.coord=[];else for(// Each coord support max, min, average
var u=e.coord,h=0;h<2;h++)GG[u[h]]&&(u[h]=UG(n,n.mapDimension(r[h]),u[h]));return e}}function HG(t,e,n,i){var r={};return null!=t.valueIndex||null!=t.valueDim?(r.valueDataDim=null!=t.valueIndex?e.getDimension(t.valueIndex):t.valueDim,r.valueAxis=n.getAxis(function(t,e){var n=t.getData().getDimensionInfo(e);return n&&n.coordDim}
/**
             * Filter data which is out of coordinateSystem range
             * [dataFilter description]
             */(i,r.valueDataDim)),r.baseAxis=n.getOtherAxis(r.valueAxis),r.baseDataDim=e.mapDimension(r.baseAxis.dim)):(r.baseAxis=i.getBaseAxis(),r.valueAxis=n.getOtherAxis(r.baseAxis),r.baseDataDim=e.mapDimension(r.baseAxis.dim),r.valueDataDim=e.mapDimension(r.valueAxis.dim)),r}function YG(// Currently only polar and cartesian has containData.
t,e){// Always return true if there is no coordSys
return!(t&&t.containData&&e.coord&&!BG(e))||t.containData(e.coord)}function XG(t,e){return t?function(t,n,i,r){return Of(r<2?t.coord&&t.coord[r]:t.value,e[r])}:function(t,n,i,r){return Of(t.value,e[r])}}function UG(t,e,n){if("average"===n){var i=0,r=0;return t.each(e,(function(t,e){isNaN(t)||(i+=t,r++)})),i/r}return"median"===n?t.getMedian(e):t.getDataExtent(e)["max"===n?1:0]}var ZG=bo(),jG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.init=function(){this.markerGroupMap=ct()},e.prototype.render=function(t,e,n){var i=this,r=this.markerGroupMap;r.each((function(t){ZG(t).keep=!1})),e.eachSeries((function(t){var r=EG.getMarkerModelFromSeries(t,i.type);r&&i.renderSeries(t,r,e,n)})),r.each((function(t){!ZG(t).keep&&i.group.remove(t.group)}))},e.prototype.markKeep=function(t){ZG(t).keep=!0},e.prototype.toggleBlurSeries=function(t,e){var n=this;R(t,(function(t){var i=EG.getMarkerModelFromSeries(t,n.type);i&&i.getData().eachItemGraphicEl((function(t){t&&(e?Cl(t):Dl(t))}))}))},e.type="marker",e}(Bg);const qG=jG;function KG(t,e,n){var i=e.coordinateSystem;t.each((function(r){var o,a=t.getItemModel(r),s=Vr(a.get("x"),n.getWidth()),l=Vr(a.get("y"),n.getHeight());if(isNaN(s)||isNaN(l)){if(e.getMarkerPosition)// Use the getMarkerPosition
o=e.getMarkerPosition(t.getValues(t.dimensions,r));else if(i){var u=t.get(i.dimensions[0],r),h=t.get(i.dimensions[1],r);o=i.dataToPoint([u,h])}// Use x, y if has any
}else o=[s,l];isNaN(s)||(o[0]=s),isNaN(l)||(o[1]=l),t.setItemLayout(r,o)}))}var $G=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.updateTransform=function(t,e,n){e.eachSeries((function(t){var e=EG.getMarkerModelFromSeries(t,"markPoint");e&&(KG(e.getData(),t,n),this.markerGroupMap.get(t.id).updateLayout())}),this)},e.prototype.renderSeries=function(t,e,n,i){var r=t.coordinateSystem,o=t.id,a=t.getData(),s=this.markerGroupMap,l=s.get(o)||s.set(o,new TS),u=function(t,e,n){var i;i=t?N(t&&t.dimensions,(function(t){// In map series data don't have lng and lat dimension. Fallback to same with coordSys
return A(A({},e.getData().getDimensionInfo(e.getData().mapDimension(t))||{}),{name:t,// DON'T use ordinalMeta to parse and collect ordinal.
ordinalMeta:null})})):[{name:"value",type:"float"}];var r=new vx(i,n),o=N(n.get("data"),F(WG,e));t&&(o=z(o,F(YG,t)));var a=XG(!!t,i);return r.initData(o,null,a),r}(r,t,e);// FIXME
e.setData(u),KG(e.getData(),t,i),u.each((function(t){var n=u.getItemModel(t),i=n.getShallow("symbol"),r=n.getShallow("symbolSize"),o=n.getShallow("symbolRotate"),s=n.getShallow("symbolOffset"),l=n.getShallow("symbolKeepAspect");// TODO: refactor needed: single data item should not support callback function
if(W(i)||W(r)||W(o)||W(s)){var h=e.getRawValue(t),c=e.getDataParams(t);W(i)&&(i=i(h,c)),W(r)&&(// FIXME  ECharts 2.x2.x 
r=r(h,c)),W(o)&&(o=o(h,c)),W(s)&&(s=s(h,c))}var p=n.getModel("itemStyle").getItemStyle(),d=Wy(a,"color");p.fill||(p.fill=d),u.setItemVisual(t,{symbol:i,symbolSize:r,symbolRotate:o,symbolOffset:s,symbolKeepAspect:l,style:p})})),// TODO Text are wrong
l.updateData(u),this.group.add(l.group),// Set host model for tooltip
// FIXME
u.eachItemGraphicEl((function(t){t.traverse((function(t){js(t).dataModel=e}))})),this.markKeep(l),l.group.silent=e.get("silent")||t.get("silent")},e.type="markPoint",e}(qG);const JG=$G;var QG=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.createMarkerModelFromSeries=function(t,n,i){return new e(t,n,i)},e.type="markLine",e.defaultOption={// zlevel: 0,
z:5,symbol:["circle","arrow"],symbolSize:[8,16],// symbolRotate: 0,
symbolOffset:0,precision:2,tooltip:{trigger:"item"},label:{show:!0,position:"end",distance:5},lineStyle:{type:"dashed"},emphasis:{label:{show:!0},lineStyle:{width:3}},animationEasing:"linear"},e}(EG);const tW=QG;var eW=bo(),nW=function(t,e,n,i){var r,o=t.getData();if(G(i))r=i;else{// Special type markLine like 'min', 'max', 'average', 'median'
var a=i.type;if("min"===a||"max"===a||"average"===a||"median"===a||null!=i.xAxis||null!=i.yAxis){var s=void 0,l=void 0;if(null!=i.yAxis||null!=i.xAxis)s=e.getAxis(null!=i.yAxis?"y":"x"),l=J(i.yAxis,i.xAxis);else{var u=HG(i,o,e,t);s=u.valueAxis,l=UG(o,Tx(o,u.valueDataDim),a)}var h="x"===s.dim?0:1,c=1-h,p=T(i),d={coord:[]};p.type=null,p.coord=[],p.coord[c]=-1/0,d.coord[c]=1/0;var f=n.get("precision");f>=0&&X(l)&&(l=+l.toFixed(Math.min(f,20))),p.coord[h]=d.coord[h]=l,r=[p,d,{type:a,valueIndex:i.valueIndex,// Force to use the value of calculated value.
value:l}]}else r=[]}var g=[WG(t,r[0]),WG(t,r[1]),A({},r[2])];// Avoid line data type is extended by from(to) data type
return g[2].type=g[2].type||null,// Merge from option and to option into line option
C(g[2],g[0]),C(g[2],g[1]),g};function iW(t){return!isNaN(t)&&!isFinite(t)}// If a markLine has one dim
function rW(t,e,n,i){var r=1-t,o=i.dimensions[t];return iW(e[r])&&iW(n[r])&&e[t]===n[t]&&i.getAxis(o).containData(e[t])}function oW(t,e){if("cartesian2d"===t.type){var n=e[0].coord,i=e[1].coord;// In case
// {
//  markLine: {
//    data: [{ yAxis: 2 }]
//  }
// }
if(n&&i&&(rW(1,n,i,t)||rW(0,n,i,t)))return!0}return YG(t,e[0])&&YG(t,e[1])}function aW(t,e,n,i,r){var o,a=i.coordinateSystem,s=t.getItemModel(e),l=Vr(s.get("x"),r.getWidth()),u=Vr(s.get("y"),r.getHeight());if(isNaN(l)||isNaN(u)){// Chart like bar may have there own marker positioning logic
if(i.getMarkerPosition)// Use the getMarkerPosition
o=i.getMarkerPosition(t.getValues(t.dimensions,e));else{var h=a.dimensions,c=t.get(h[0],e),p=t.get(h[1],e);o=a.dataToPoint([c,p])}// Expand line to the edge of grid if value on one axis is Inifnity
// In case
//  markLine: {
//    data: [{
//      yAxis: 2
//      // or
//      type: 'average'
//    }]
//  }
if(FS(a,"cartesian2d")){// TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
var d=a.getAxis("x"),f=a.getAxis("y");h=a.dimensions,iW(t.get(h[0],e))?o[0]=d.toGlobalCoord(d.getExtent()[n?0:1]):iW(t.get(h[1],e))&&(o[1]=f.toGlobalCoord(f.getExtent()[n?0:1]))}// Use x, y if has any
isNaN(l)||(o[0]=l),isNaN(u)||(o[1]=u)}else o=[l,u];t.setItemLayout(e,o)}var sW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.updateTransform=function(t,e,n){e.eachSeries((function(t){var e=EG.getMarkerModelFromSeries(t,"markLine");if(e){var i=e.getData(),r=eW(e).from,o=eW(e).to;// Update visual and layout of from symbol and to symbol
r.each((function(e){aW(r,e,!0,t,n),aW(o,e,!1,t,n)})),// Update layout of line
i.each((function(t){i.setItemLayout(t,[r.getItemLayout(t),o.getItemLayout(t)])})),this.markerGroupMap.get(t.id).updateLayout()}}),this)},e.prototype.renderSeries=function(t,e,n,i){var r=t.coordinateSystem,o=t.id,a=t.getData(),s=this.markerGroupMap,l=s.get(o)||s.set(o,new Ek);this.group.add(l.group);var u=function(t,e,n){var i;i=t?N(t&&t.dimensions,(function(t){// In map series data don't have lng and lat dimension. Fallback to same with coordSys
return A(A({},e.getData().getDimensionInfo(e.getData().mapDimension(t))||{}),{name:t,// DON'T use ordinalMeta to parse and collect ordinal.
ordinalMeta:null})})):[{name:"value",type:"float"}];var r=new vx(i,n),o=new vx(i,n),a=new vx([],n),s=N(n.get("data"),F(nW,e,t,n));t&&(s=z(s,F(oW,t)));var l=XG(!!t,i);return r.initData(N(s,(function(t){return t[0]})),null,l),o.initData(N(s,(function(t){return t[1]})),null,l),a.initData(N(s,(function(t){return t[2]}))),a.hasItemOption=!0,{from:r,to:o,line:a}}(r,t,e),h=u.from,c=u.to,p=u.line;eW(e).from=h,eW(e).to=c,// Line data for tooltip and formatter
e.setData(p);// TODO
// Functionally, `symbolSize` & `symbolOffset` can also be 2D array now.
// But the related logic and type definition are not finished yet.
// Finish it if required
var d=e.get("symbol"),f=e.get("symbolSize"),g=e.get("symbolRotate"),y=e.get("symbolOffset");function v(e,n,r){var o=e.getItemModel(n);aW(e,n,r,t,i);var s=o.getModel("itemStyle").getItemStyle();null==s.fill&&(s.fill=Wy(a,"color")),e.setItemVisual(n,{symbolKeepAspect:o.get("symbolKeepAspect"),// `0` should be considered as a valid value, so use `retrieve2` instead of `||`
symbolOffset:Q(o.get("symbolOffset",!0),y[r?0:1]),symbolRotate:Q(o.get("symbolRotate",!0),g[r?0:1]),// TODO: when 2d array is supported, it should ignore parent
symbolSize:Q(o.get("symbolSize"),f[r?0:1]),symbol:Q(o.get("symbol",!0),d[r?0:1]),style:s})}// TODO: support callback function like markPoint
G(d)||(d=[d,d]),G(f)||(f=[f,f]),G(g)||(g=[g,g]),G(y)||(y=[y,y]),// Update visual and layout of from symbol and to symbol
u.from.each((function(t){v(h,t,!0),v(c,t,!1)})),// Update visual and layout of line
p.each((function(t){var e=p.getItemModel(t).getModel("lineStyle").getLineStyle();// lineData.setItemVisual(idx, {
//     color: lineColor || fromData.getItemVisual(idx, 'color')
// });
p.setItemLayout(t,[h.getItemLayout(t),c.getItemLayout(t)]),null==e.stroke&&(e.stroke=h.getItemVisual(t,"style").fill),p.setItemVisual(t,{fromSymbolKeepAspect:h.getItemVisual(t,"symbolKeepAspect"),fromSymbolOffset:h.getItemVisual(t,"symbolOffset"),fromSymbolRotate:h.getItemVisual(t,"symbolRotate"),fromSymbolSize:h.getItemVisual(t,"symbolSize"),fromSymbol:h.getItemVisual(t,"symbol"),toSymbolKeepAspect:c.getItemVisual(t,"symbolKeepAspect"),toSymbolOffset:c.getItemVisual(t,"symbolOffset"),toSymbolRotate:c.getItemVisual(t,"symbolRotate"),toSymbolSize:c.getItemVisual(t,"symbolSize"),toSymbol:c.getItemVisual(t,"symbol"),style:e})})),l.updateData(p),// Set host model for tooltip
// FIXME
u.line.eachItemGraphicEl((function(t){js(t).dataModel=e,t.traverse((function(t){js(t).dataModel=e}))})),this.markKeep(l),l.group.silent=e.get("silent")||t.get("silent")},e.type="markLine",e}(qG);const lW=sW;var uW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.createMarkerModelFromSeries=function(t,n,i){return new e(t,n,i)},e.type="markArea",e.defaultOption={// zlevel: 0,
// PENDING
z:1,tooltip:{trigger:"item"},// markArea should fixed on the coordinate system
animation:!1,label:{show:!0,position:"top"},itemStyle:{// color and borderColor default to use color from series
// color: 'auto'
// borderColor: 'auto'
borderWidth:0},emphasis:{label:{show:!0,position:"top"}}},e}(EG);const hW=uW;var cW=bo(),pW=function(t,e,n,i){// item may be null
var r=i[0],o=i[1];if(r&&o){var a=WG(t,r),s=WG(t,o),l=a.coord,u=s.coord;l[0]=J(l[0],-1/0),l[1]=J(l[1],-1/0),u[0]=J(u[0],1/0),u[1]=J(u[1],1/0);// Merge option into one
var h=D([{},a,s]);return h.coord=[a.coord,s.coord],h.x0=a.x,h.y0=a.y,h.x1=s.x,h.y1=s.y,h}};function dW(t){return!isNaN(t)&&!isFinite(t)}// If a markArea has one dim
function fW(t,e,n,i){var r=1-t;return dW(e[r])&&dW(n[r])}function gW(t,e){var n=e.coord[0],i=e.coord[1],r={coord:n,x:e.x0,y:e.y0},o={coord:i,x:e.x1,y:e.y1};return FS(t,"cartesian2d")?// In case
// {
//  markArea: {
//    data: [{ yAxis: 2 }]
//  }
// }
!(!n||!i||!fW(1,n,i)&&!fW(0,n,i))||function(// Currently only polar and cartesian has containData.
t,e,n){// Always return true if there is no coordSys
return!(t&&t.containZone&&e.coord&&n.coord&&!BG(e)&&!BG(n))||t.containZone(e.coord,n.coord)}(t,r,o):YG(t,r)||YG(t,o)}// dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']
function yW(t,e,n,i,r){var o,a=i.coordinateSystem,s=t.getItemModel(e),l=Vr(s.get(n[0]),r.getWidth()),u=Vr(s.get(n[1]),r.getHeight());if(isNaN(l)||isNaN(u)){// Chart like bar may have there own marker positioning logic
if(i.getMarkerPosition){// Consider the case that user input the right-bottom point first
// Pick the larger x and y as 'x1' and 'y1'
var h=t.getValues(["x0","y0"],e),c=t.getValues(["x1","y1"],e),p=a.clampData(h),d=a.clampData(c),f=[];"x0"===n[0]?f[0]=p[0]>d[0]?c[0]:h[0]:f[0]=p[0]>d[0]?h[0]:c[0],"y0"===n[1]?f[1]=p[1]>d[1]?c[1]:h[1]:f[1]=p[1]>d[1]?h[1]:c[1],// Use the getMarkerPosition
o=i.getMarkerPosition(f,n,!0)}else{var g=[m=t.get(n[0],e),x=t.get(n[1],e)];a.clampData&&a.clampData(g,g),o=a.dataToPoint(g,!0)}if(FS(a,"cartesian2d")){// TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
var y=a.getAxis("x"),v=a.getAxis("y"),m=t.get(n[0],e),x=t.get(n[1],e);dW(m)?o[0]=y.toGlobalCoord(y.getExtent()["x0"===n[0]?0:1]):dW(x)&&(o[1]=v.toGlobalCoord(v.getExtent()["y0"===n[1]?0:1]))}// Use x, y if has any
isNaN(l)||(o[0]=l),isNaN(u)||(o[1]=u)}else o=[l,u];return o}var vW=[["x0","y0"],["x1","y0"],["x1","y1"],["x0","y1"]],mW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.updateTransform=function(t,e,n){e.eachSeries((function(t){var e=EG.getMarkerModelFromSeries(t,"markArea");if(e){var i=e.getData();i.each((function(e){var r=N(vW,(function(r){return yW(i,e,r,t,n)}));// Layout
i.setItemLayout(e,r),i.getItemGraphicEl(e).setShape("points",r)}))}}),this)},e.prototype.renderSeries=function(t,e,n,i){var r=t.coordinateSystem,o=t.id,a=t.getData(),s=this.markerGroupMap,l=s.get(o)||s.set(o,{group:new Lr});this.group.add(l.group),this.markKeep(l);var u=function(t,e,n){var i,r,o=["x0","y0","x1","y1"];if(t){var a=N(t&&t.dimensions,(function(t){var n=e.getData();// In map series data don't have lng and lat dimension. Fallback to same with coordSys
return A(A({},n.getDimensionInfo(n.mapDimension(t))||{}),{name:t,// DON'T use ordinalMeta to parse and collect ordinal.
ordinalMeta:null})}));r=N(o,(function(t,e){return{name:t,type:a[e%2].type}})),i=new vx(r,n)}else i=new vx(r=[{name:"value",type:"float"}],n);var s=N(n.get("data"),F(pW,e,t,n));t&&(s=z(s,F(gW,t)));var l=t?function(t,e,n,i){return Of(t.coord[Math.floor(i/2)][i%2],r[i])}:function(t,e,n,i){return Of(t.value,r[i])};return i.initData(s,null,l),i.hasItemOption=!0,i}(r,t,e);// Line data for tooltip and formatter
e.setData(u),// Update visual and layout of line
u.each((function(e){// Layout
var n=N(vW,(function(n){return yW(u,e,n,t,i)})),o=r.getAxis("x").scale,s=r.getAxis("y").scale,l=o.getExtent(),h=s.getExtent(),c=[o.parse(u.get("x0",e)),o.parse(u.get("x1",e))],p=[s.parse(u.get("y0",e)),s.parse(u.get("y1",e))];Fr(c),Fr(p);var d=!!(l[0]>c[1]||l[1]<c[0]||h[0]>p[1]||h[1]<p[0]);// If none of the area is inside coordSys, allClipped is set to be true
// in layout so that label will not be displayed. See #12591
u.setItemLayout(e,{points:n,allClipped:d});var f=u.getItemModel(e).getModel("itemStyle").getItemStyle(),g=Wy(a,"color");f.fill||(f.fill=g,H(f.fill)&&(f.fill=jn(f.fill,.4))),f.stroke||(f.stroke=g),// Visual
u.setItemVisual(e,"style",f)})),u.diff(cW(l).data).add((function(t){var e=u.getItemLayout(t);if(!e.allClipped){var n=new Wu({shape:{points:e.points}});u.setItemGraphicEl(t,n),l.group.add(n)}})).update((function(t,n){var i=cW(l).data.getItemGraphicEl(n),r=u.getItemLayout(t);r.allClipped?i&&l.group.remove(i):(i?Sh(i,{shape:{points:r.points}},e,t):i=new Wu({shape:{points:r.points}}),u.setItemGraphicEl(t,i),l.group.add(i))})).remove((function(t){var e=cW(l).data.getItemGraphicEl(t);l.group.remove(e)})).execute(),u.eachItemGraphicEl((function(t,n){var i=u.getItemModel(n),r=u.getItemVisual(n,"style");t.useStyle(u.getItemVisual(n,"style")),ac(t,sc(i),{labelFetcher:e,labelDataIndex:n,defaultText:u.getName(n)||"",inheritColor:H(r.fill)?jn(r.fill,1):"#000"}),Hl(t,i),Bl(t,null,null,i.get(["emphasis","disabled"])),js(t).dataModel=e})),cW(l).data=u,l.group.silent=e.get("silent")||t.get("silent")},e.type="markArea",e}(qG);const xW=mW;var _W=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.layoutMode={type:"box",// legend.width/height are maxWidth/maxHeight actually,
// whereas real width/height is calculated by its content.
// (Setting {left: 10, right: 10} does not make sense).
// So consider the case:
// `setOption({legend: {left: 10});`
// then `setOption({legend: {right: 10});`
// The previous `left` should be cleared by setting `ignoreSize`.
ignoreSize:!0},n}return n(e,t),e.prototype.init=function(t,e,n){this.mergeDefaultAndTheme(t,n),t.selected=t.selected||{},this._updateSelector(t)},e.prototype.mergeOption=function(e,n){t.prototype.mergeOption.call(this,e,n),this._updateSelector(e)},e.prototype._updateSelector=function(t){var e=t.selector,n=this.ecModel;!0===e&&(e=t.selector=["all","inverse"]),G(e)&&R(e,(function(t,i){H(t)&&(t={type:t}),e[i]=C(t,function(t,e){return"all"===e?{type:"all",title:t.getLocaleModel().get(["legend","selector","all"])}:"inverse"===e?{type:"inverse",title:t.getLocaleModel().get(["legend","selector","inverse"])}:void 0}(n,t.type))}))},e.prototype.optionUpdated=function(){this._updateData(this.ecModel);var t=this._data;// If selectedMode is single, try to select one
if(t[0]&&"single"===this.get("selectedMode")){// If has any selected in option.selected
for(var e=!1,n=0;n<t.length;n++){var i=t[n].get("name");if(this.isSelected(i)){// Force to unselect others
this.select(i),e=!0;break}}// Try select the first if selectedMode is single
!e&&this.select(t[0].get("name"))}},e.prototype._updateData=function(t){var e=[],n=[];t.eachRawSeries((function(i){var r,o=i.name;if(n.push(o),i.legendVisualProvider){var a=i.legendVisualProvider.getAllNames();t.isSeriesFiltered(i)||(n=n.concat(a)),a.length?e=e.concat(a):r=!0}else r=!0;r&&mo(i)&&e.push(i.name)})),
/**
                 * @type {Array.<string>}
                 * @private
                 */
this._availableNames=n;// If legend.data is not specified in option, use availableNames as data,
// which is convenient for user preparing option.
var i=this.get("data")||e,r=ct(),o=N(i,(function(t){// Can be string or number
return(H(t)||X(t))&&(t={name:t}),r.get(t.name)?null:(r.set(t.name,!0),new Pc(t,this,this.ecModel))}),this);
/**
                 * @type {Array.<module:echarts/model/Model>}
                 * @private
                 */
this._data=z(o,(function(t){return!!t}))},e.prototype.getData=function(){return this._data},e.prototype.select=function(t){var e=this.option.selected;"single"===this.get("selectedMode")&&R(this._data,(function(t){e[t.get("name")]=!1})),e[t]=!0},e.prototype.unSelect=function(t){"single"!==this.get("selectedMode")&&(this.option.selected[t]=!1)},e.prototype.toggleSelected=function(t){var e=this.option.selected;// Default is true
e.hasOwnProperty(t)||(e[t]=!0),this[e[t]?"unSelect":"select"](t)},e.prototype.allSelect=function(){var t=this._data,e=this.option.selected;R(t,(function(t){e[t.get("name",!0)]=!0}))},e.prototype.inverseSelect=function(){var t=this._data,e=this.option.selected;R(t,(function(t){var n=t.get("name",!0);// Initially, default value is true
e.hasOwnProperty(n)||(e[n]=!0),e[n]=!e[n]}))},e.prototype.isSelected=function(t){var e=this.option.selected;return!(e.hasOwnProperty(t)&&!e[t])&&L(this._availableNames,t)>=0},e.prototype.getOrient=function(){return"vertical"===this.get("orient")?{index:1,name:"vertical"}:{index:0,name:"horizontal"}},e.type="legend.plain",e.dependencies=["series"],e.defaultOption={// zlevel: 0,
z:4,show:!0,orient:"horizontal",left:"center",// right: 'center',
top:0,// bottom: null,
align:"auto",backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",borderRadius:0,borderWidth:0,padding:5,itemGap:10,itemWidth:25,itemHeight:14,symbolRotate:"inherit",symbolKeepAspect:!0,inactiveColor:"#ccc",inactiveBorderColor:"#ccc",inactiveBorderWidth:"auto",itemStyle:{color:"inherit",opacity:"inherit",borderColor:"inherit",borderWidth:"auto",borderCap:"inherit",borderJoin:"inherit",borderDashOffset:"inherit",borderMiterLimit:"inherit"},lineStyle:{width:"auto",color:"inherit",inactiveColor:"#ccc",inactiveWidth:2,opacity:"inherit",type:"inherit",cap:"inherit",join:"inherit",dashOffset:"inherit",miterLimit:"inherit"},textStyle:{color:"#333"},selectedMode:!0,selector:!1,selectorLabel:{show:!0,borderRadius:10,padding:[3,5,3,5],fontSize:12,fontFamily:"sans-serif",color:"#666",borderWidth:1,borderColor:"#666"},emphasis:{selectorLabel:{show:!0,color:"#eee",backgroundColor:"#666"}},selectorPosition:"auto",selectorItemGap:7,selectorButtonGap:10,tooltip:{show:!1}},e}(Wp);const bW=_W;var wW=F,SW=R,MW=Lr,IW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.newlineDisabled=!1,n}return n(e,t),e.prototype.init=function(){this.group.add(this._contentGroup=new MW),this.group.add(this._selectorGroup=new MW),this._isFirstRender=!0},
/**
               * @protected
               */
e.prototype.getContentGroup=function(){return this._contentGroup},
/**
               * @protected
               */
e.prototype.getSelectorGroup=function(){return this._selectorGroup},
/**
               * @override
               */
e.prototype.render=function(t,e,n){var i=this._isFirstRender;if(this._isFirstRender=!1,this.resetInner(),t.get("show",!0)){var r=t.get("align"),o=t.get("orient");r&&"auto"!==r||(r="right"===t.get("left")&&"vertical"===o?"right":"left");// selector has been normalized to an array in model
var a=t.get("selector",!0),s=t.get("selectorPosition",!0);!a||s&&"auto"!==s||(s="horizontal"===o?"end":"start"),this.renderInner(r,t,e,n,a,o,s);// Perform layout.
var l=t.getBoxLayoutParams(),u={width:n.getWidth(),height:n.getHeight()},h=t.get("padding"),c=Rp(l,u,h),p=this.layoutInner(t,r,c,i,a,s),d=Rp(k({width:p.width,height:p.height},l),u,h);this.group.x=d.x-p.x,this.group.y=d.y-p.y,this.group.markRedraw(),// Render background after group is layout.
this.group.add(this._backgroundEl=CB(p,t))}},e.prototype.resetInner=function(){this.getContentGroup().removeAll(),this._backgroundEl&&this.group.remove(this._backgroundEl),this.getSelectorGroup().removeAll()},e.prototype.renderInner=function(t,e,n,i,r,o,a){var s=this.getContentGroup(),l=ct(),u=e.get("selectedMode"),h=[];n.eachRawSeries((function(t){!t.get("legendHoverLink")&&h.push(t.id)})),SW(e.getData(),(function(r,o){var a=r.get("name");// Use empty string or \n as a newline string
if(!this.newlineDisabled&&(""===a||"\n"===a)){var c=new MW;// @ts-ignore
return c.newline=!0,void s.add(c)}// Representitive series.
var p=n.getSeriesByName(a)[0];if(!l.get(a))// Legend to control series.
if(p){var d=p.getData(),f=d.getVisual("legendLineStyle")||{},g=d.getVisual("legendIcon"),y=d.getVisual("style");this._createItem(p,a,o,r,e,t,f,y,g,u,i).on("click",wW(TW,a,null,i,h)).on("mouseover",wW(DW,p.name,null,i,h)).on("mouseout",wW(AW,p.name,null,i,h)),l.set(a,!0)}else// Legend to control data. In pie and funnel.
n.eachRawSeries((function(n){// In case multiple series has same data name
if(!l.get(a)&&n.legendVisualProvider){var s=n.legendVisualProvider;if(!s.containName(a))return;var c=s.indexOfName(a),p=s.getItemVisual(c,"style"),d=s.getItemVisual(c,"legendIcon"),f=Hn(p.fill);// Color may be set to transparent in visualMap when data is out of range.
// Do not show nothing.
f&&0===f[3]&&(f[3]=.2,// TODO color is set to 0, 0, 0, 0. Should show correct RGBA
p=A(A({},p),{fill:qn(f,"rgba")})),// FIXME: consider different series has items with the same name.
this._createItem(n,a,o,r,e,t,{},p,d,u,i).on("click",wW(TW,null,a,i,h)).on("mouseover",wW(DW,null,a,i,h)).on("mouseout",wW(AW,null,a,i,h)),l.set(a,!0)}}),this)}),this),r&&this._createSelector(r,e,i,o,a)},e.prototype._createSelector=function(t,e,n,i,r){var o=this.getSelectorGroup();SW(t,(function(t){var i=t.type,r=new Zs({style:{x:0,y:0,align:"center",verticalAlign:"middle"},onclick:function(){n.dispatchAction({type:"all"===i?"legendAllSelect":"legendInverseSelect"})}});o.add(r),ac(r,{normal:e.getModel("selectorLabel"),emphasis:e.getModel(["emphasis","selectorLabel"])},{defaultText:t.title}),Vl(r)}))},e.prototype._createItem=function(t,e,n,i,r,o,a,s,l,u,h){var c,p,d,f=t.visualDrawType,g=r.get("itemWidth"),y=r.get("itemHeight"),v=r.isSelected(e),m=i.get("symbolRotate"),x=i.get("symbolKeepAspect"),_=i.get("icon"),b=function(t,e,n,i,r,o,a){
/**
               * Use series style if is inherit;
               * elsewise, use legend style
               */
function s(t,e){// If lineStyle.width is 'auto', it is set to be 2 if series has border
"auto"===t.lineWidth&&(t.lineWidth=e.lineWidth>0?2:0),SW(t,(function(n,i){"inherit"===t[i]&&(t[i]=e[i])}))}// itemStyle
var l=e.getModel("itemStyle"),u=l.getItemStyle(),h=0===t.lastIndexOf("empty",0)?"fill":"stroke",c=l.getShallow("decal");u.decal=c&&"inherit"!==c?Pv(c,a):i.decal,"inherit"===u.fill&&(
/**
                 * Series with visualDrawType as 'stroke' should have
                 * series stroke as legend fill
                 */
u.fill=i[r]),"inherit"===u.stroke&&(
/**
                 * icon type with "emptyXXX" should use fill color
                 * in visual style
                 */
u.stroke=i[h]),"inherit"===u.opacity&&(
/**
                 * Use lineStyle.opacity if drawType is stroke
                 */
u.opacity=("fill"===r?i:n).opacity),s(u,i);// lineStyle
var p=e.getModel("lineStyle"),d=p.getLineStyle();if(s(d,n),// Fix auto color to real color
"auto"===u.fill&&(u.fill=i.fill),"auto"===u.stroke&&(u.stroke=i.fill),"auto"===d.stroke&&(d.stroke=i.fill),!o){var f=e.get("inactiveBorderWidth"),g=u[h];
/**
                 * Since stroke is set to be inactiveBorderColor, it may occur that
                 * there is no border in series but border in legend, so we need to
                 * use border only when series has border if is set to be auto
                 */u.lineWidth="auto"===f?i.lineWidth>0&&g?2:0:u.lineWidth,u.fill=e.get("inactiveColor"),u.stroke=e.get("inactiveBorderColor"),d.stroke=p.get("inactiveColor"),d.lineWidth=p.get("inactiveWidth")}return{itemStyle:u,lineStyle:d}}(l=_||l||"roundRect",i,a,s,f,v,h),w=new MW,S=i.getModel("textStyle");if(!W(t.getLegendIcon)||_&&"inherit"!==_){// Use default legend icon policy for most series
var M="inherit"===_&&t.getData().getVisual("symbol")?"inherit"===m?t.getData().getVisual("symbolRotate"):m:0;// No rotation for no icon
w.add((c={itemWidth:g,itemHeight:y,icon:l,iconRotate:M,itemStyle:b.itemStyle,lineStyle:b.lineStyle,symbolKeepAspect:x},p=c.icon||"roundRect",(d=ov(p,0,0,c.itemWidth,c.itemHeight,c.itemStyle.fill,c.symbolKeepAspect)).setStyle(c.itemStyle),d.rotation=(c.iconRotate||0)*Math.PI/180,d.setOrigin([c.itemWidth/2,c.itemHeight/2]),p.indexOf("empty")>-1&&(d.style.stroke=d.style.fill,d.style.fill="#fff",d.style.lineWidth=2),d))}else// Series has specific way to define legend icon
w.add(t.getLegendIcon({itemWidth:g,itemHeight:y,icon:l,iconRotate:m,itemStyle:b.itemStyle,lineStyle:b.lineStyle,symbolKeepAspect:x}));var I="left"===o?g+5:-5,T=o,C=r.get("formatter"),D=e;H(C)&&C?D=C.replace("{name}",null!=e?e:""):W(C)&&(D=C(e));var A=i.get("inactiveColor");w.add(new Zs({style:lc(S,{text:D,x:I,y:y/2,fill:v?S.getTextColor():A,align:T,verticalAlign:"middle"})}));// Add a invisible rect to increase the area of mouse hover
var k=new Ls({shape:w.getBoundingRect(),invisible:!0}),L=i.getModel("tooltip");return L.get("show")&&Qh({el:k,componentModel:r,itemName:e,itemTooltipOption:L.option}),w.add(k),w.eachChild((function(t){t.silent=!0})),k.silent=!u,this.getContentGroup().add(w),Vl(w),// @ts-ignore
w.__legendDataIndex=n,w},e.prototype.layoutInner=function(t,e,n,i,r,o){var a=this.getContentGroup(),s=this.getSelectorGroup();// Place items in contentGroup.
Op(t.get("orient"),a,t.get("itemGap"),n.width,n.height);var l=a.getBoundingRect(),u=[-l.x,-l.y];if(s.markRedraw(),a.markRedraw(),r){// Place buttons in selectorGroup
Op(// Buttons in selectorGroup always layout horizontally
"horizontal",s,t.get("selectorItemGap",!0));var h=s.getBoundingRect(),c=[-h.x,-h.y],p=t.get("selectorButtonGap",!0),d=t.getOrient().index,f=0===d?"width":"height",g=0===d?"height":"width",y=0===d?"y":"x";"end"===o?c[d]+=l[f]+p:u[d]+=h[f]+p,// Always align selector to content as 'middle'
c[1-d]+=l[g]/2-h[g]/2,s.x=c[0],s.y=c[1],a.x=u[0],a.y=u[1];var v={x:0,y:0};return v[f]=l[f]+p+h[f],v[g]=Math.max(l[g],h[g]),v[y]=Math.min(0,h[y]+c[1-d]),v}return a.x=u[0],a.y=u[1],this.group.getBoundingRect()},
/**
               * @protected
               */
e.prototype.remove=function(){this.getContentGroup().removeAll(),this._isFirstRender=!0},e.type="legend.plain",e}(Bg);function TW(t,e,n,i){// downplay before unselect
AW(t,e,n,i),n.dispatchAction({type:"legendToggleSelect",name:null!=t?t:e}),// highlight after select
// TODO highlight immediately may cause animation loss.
DW(t,e,n,i)}function CW(t){for(var e,n=t.getZr().storage.getDisplayList(),i=0,r=n.length;i<r&&!(e=n[i].states.emphasis);)i++;return e&&e.hoverLayer}function DW(t,e,n,i){// If element hover will move to a hoverLayer.
CW(n)||n.dispatchAction({type:"highlight",seriesName:t,name:e,excludeSeriesId:i})}function AW(t,e,n,i){// If element hover will move to a hoverLayer.
CW(n)||n.dispatchAction({type:"downplay",seriesName:t,name:e,excludeSeriesId:i})}const kW=IW;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function LW(t){var e=t.findComponents({mainType:"legend"});e&&e.length&&t.filterSeries((function(t){// If in any legend component the status is not selected.
// Because in legend series is assumed selected when it is not in the legend data.
for(var n=0;n<e.length;n++)if(!e[n].isSelected(t.name))return!1;return!0}))}function PW(t,e,n){var i,r={},o="toggleSelected"===t;// Return the event explicitly
// Update all legend components
return n.eachComponent("legend",(function(n){o&&null!=i?// Force other legend has same selected status
// Or the first is toggled to true and other are toggled to false
// In the case one legend has some item unSelected in option. And if other legend
// doesn't has the item, they will assume it is selected.
n[i?"select":"unSelect"](e.name):"allSelect"===t||"inverseSelect"===t?n[t]():(n[t](e.name),i=n.isSelected(e.name)),R(n.getData(),(function(t){var e=t.get("name");// Wrap element
if("\n"!==e&&""!==e){var i=n.isSelected(e);r.hasOwnProperty(e)?// Unselected if any legend is unselected
r[e]=r[e]&&i:r[e]=i}}))})),"allSelect"===t||"inverseSelect"===t?{selected:r}:{name:e.name,selected:r}}function OW(t){t.registerComponentModel(bW),t.registerComponentView(kW),t.registerProcessor(t.PRIORITY.PROCESSOR.SERIES_FILTER,LW),t.registerSubTypeDefaulter("legend",(function(){return"plain"})),function(t){
/**
               * @event legendToggleSelect
               * @type {Object}
               * @property {string} type 'legendToggleSelect'
               * @property {string} [from]
               * @property {string} name Series name or data item name
               */
t.registerAction("legendToggleSelect","legendselectchanged",F(PW,"toggleSelected")),t.registerAction("legendAllSelect","legendselectall",F(PW,"allSelect")),t.registerAction("legendInverseSelect","legendinverseselect",F(PW,"inverseSelect")),
/**
               * @event legendSelect
               * @type {Object}
               * @property {string} type 'legendSelect'
               * @property {string} name Series name or data item name
               */
t.registerAction("legendSelect","legendselected",F(PW,"select")),
/**
               * @event legendUnSelect
               * @type {Object}
               * @property {string} type 'legendUnSelect'
               * @property {string} name Series name or data item name
               */
t.registerAction("legendUnSelect","legendunselected",F(PW,"unSelect"))}(t)}var RW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * @param {number} scrollDataIndex
               */return n(e,t),e.prototype.setScrollDataIndex=function(t){this.option.scrollDataIndex=t},e.prototype.init=function(e,n,i){var r=Vp(e);t.prototype.init.call(this,e,n,i),NW(this,e,r)},
/**
               * @override
               */
e.prototype.mergeOption=function(e,n){t.prototype.mergeOption.call(this,e,n),NW(this,this.option,e)},e.type="legend.scroll",e.defaultOption=Nc(bW.defaultOption,{scrollDataIndex:0,pageButtonItemGap:5,pageButtonGap:null,pageButtonPosition:"end",pageFormatter:"{current}/{total}",pageIcons:{horizontal:["M0,0L12,-10L12,10z","M0,0L-12,-10L-12,10z"],vertical:["M0,0L20,0L10,-20z","M0,0L20,0L10,20z"]},pageIconColor:"#2f4554",pageIconInactiveColor:"#aaa",pageIconSize:15,pageTextStyle:{color:"#333"},animationDurationUpdate:800}),e}(bW);function NW(t,e,n){var i=[1,1];i[t.getOrient().index]=0,zp(e,n,{type:"box",ignoreSize:!!i})}const EW=RW;var zW=Lr,VW=["width","height"],BW=["x","y"],FW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.newlineDisabled=!0,n._currentIndex=0,n}return n(e,t),e.prototype.init=function(){t.prototype.init.call(this),this.group.add(this._containerGroup=new zW),this._containerGroup.add(this.getContentGroup()),this.group.add(this._controllerGroup=new zW)},
/**
               * @override
               */
e.prototype.resetInner=function(){t.prototype.resetInner.call(this),this._controllerGroup.removeAll(),this._containerGroup.removeClipPath(),this._containerGroup.__rectSize=null},
/**
               * @override
               */
e.prototype.renderInner=function(e,n,i,r,o,a,s){var l=this;// Render content items.
t.prototype.renderInner.call(this,e,n,i,r,o,a,s);var u=this._controllerGroup,h=n.get("pageIconSize",!0),c=G(h)?h:[h,h];// FIXME: support be 'auto' adapt to size number text length,
// e.g., '3/12345' should not overlap with the control arrow button.
d("pagePrev",0);var p=n.getModel("pageTextStyle");function d(t,e){var i=t+"DataIndex",o=qh(n.get("pageIcons",!0)[n.getOrient().name][e],{// Buttons will be created in each render, so we do not need
// to worry about avoiding using legendModel kept in scope.
onclick:B(l._pageGo,l,i,n,r)},{x:-c[0]/2,y:-c[1]/2,width:c[0],height:c[1]});o.name=t,u.add(o)}u.add(new Zs({name:"pageText",style:{// Placeholder to calculate a proper layout.
text:"xx/xx",fill:p.getTextColor(),font:p.getFont(),verticalAlign:"middle",align:"center"},silent:!0})),d("pageNext",1)},
/**
               * @override
               */
e.prototype.layoutInner=function(t,e,n,i,r,o){var a=this.getSelectorGroup(),s=t.getOrient().index,l=VW[s],u=BW[s],h=VW[1-s],c=BW[1-s];r&&Op(// Buttons in selectorGroup always layout horizontally
"horizontal",a,t.get("selectorItemGap",!0));var p=t.get("selectorButtonGap",!0),d=a.getBoundingRect(),f=[-d.x,-d.y],g=T(n);r&&(g[l]=n[l]-d[l]-p);var y=this._layoutContentAndController(t,i,g,s,l,h,c,u);if(r){if("end"===o)f[s]+=y[l]+p;else{var v=d[l]+p;f[s]-=v,y[u]-=v}y[l]+=d[l]+p,f[1-s]+=y[c]+y[h]/2-d[h]/2,y[h]=Math.max(y[h],d[h]),y[c]=Math.min(y[c],d[c]+f[1-s]),a.x=f[0],a.y=f[1],a.markRedraw()}return y},e.prototype._layoutContentAndController=function(t,e,n,i,r,o,a,s){var l=this.getContentGroup(),u=this._containerGroup,h=this._controllerGroup;// Place items in contentGroup.
Op(t.get("orient"),l,t.get("itemGap"),i?n.width:null,i?null:n.height),Op(// Buttons in controller are layout always horizontally.
"horizontal",h,t.get("pageButtonItemGap",!0));var c=l.getBoundingRect(),p=h.getBoundingRect(),d=this._showController=c[r]>n[r],f=[-c.x,-c.y];// Remain contentPos when scroll animation perfroming.
// If first rendering, `contentGroup.position` is [0, 0], which
// does not make sense and may cause unexepcted animation if adopted.
e||(f[i]=l[s]);// Layout container group based on 0.
var g=[0,0],y=[-p.x,-p.y],v=Q(t.get("pageButtonGap",!0),t.get("itemGap",!0));// Place containerGroup and controllerGroup and contentGroup.
d&&(// controller is on the right / bottom.
"end"===t.get("pageButtonPosition",!0)?y[i]+=n[r]-p[r]:g[i]+=p[r]+v),// Always align controller to content as 'middle'.
y[1-i]+=c[o]/2-p[o]/2,l.setPosition(f),u.setPosition(g),h.setPosition(y);// Calculate `mainRect` and set `clipPath`.
// mainRect should not be calculated by `this.group.getBoundingRect()`
// for sake of the overflow.
var m={x:0,y:0};// Consider content may be overflow (should be clipped).
if(m[r]=d?n[r]:c[r],m[o]=Math.max(c[o],p[o]),// `containerRect[yx] + containerPos[1 - orientIdx]` is 0.
m[a]=Math.min(0,p[a]+y[1-i]),u.__rectSize=n[r],d){var x={x:0,y:0};x[r]=Math.max(n[r]-p[r]-v,0),x[o]=m[o],u.setClipPath(new Ls({shape:x})),// Consider content may be larger than container, container rect
// can not be obtained from `containerGroup.getBoundingRect()`.
u.__rectSize=x[r]}else// Do not remove or ignore controller. Keep them set as placeholders.
h.eachChild((function(t){t.attr({invisible:!0,silent:!0})}));// Content translate animation.
var _=this._getPageInfo(t);return null!=_.pageIndex&&Sh(l,{x:_.contentPosition[0],y:_.contentPosition[1]},// When switch from "show controller" to "not show controller", view should be
// updated immediately without animation, otherwise causes weird effect.
d?t:null),this._updatePageInfoView(t,_),m},e.prototype._pageGo=function(t,e,n){var i=this._getPageInfo(e)[t];null!=i&&n.dispatchAction({type:"legendScroll",scrollDataIndex:i,legendId:e.id})},e.prototype._updatePageInfoView=function(t,e){var n=this._controllerGroup;R(["pagePrev","pageNext"],(function(i){var r=null!=e[i+"DataIndex"],o=n.childOfName(i);o&&(o.setStyle("fill",r?t.get("pageIconColor",!0):t.get("pageIconInactiveColor",!0)),o.cursor=r?"pointer":"default")}));var i=n.childOfName("pageText"),r=t.get("pageFormatter"),o=e.pageIndex,a=null!=o?o+1:0,s=e.pageCount;i&&r&&i.setStyle("text",H(r)?r.replace("{current}",null==a?"":a+"").replace("{total}",null==s?"":s+""):r({current:a,total:s}))},
/**
               *  contentPosition: Array.<number>, null when data item not found.
               *  pageIndex: number, null when data item not found.
               *  pageCount: number, always be a number, can be 0.
               *  pagePrevDataIndex: number, null when no previous page.
               *  pageNextDataIndex: number, null when no next page.
               * }
               */
e.prototype._getPageInfo=function(t){var e=t.get("scrollDataIndex",!0),n=this.getContentGroup(),i=this._containerGroup.__rectSize,r=t.getOrient().index,o=VW[r],a=BW[r],s=this._findTargetItemIndex(e),l=n.children(),u=l[s],h=l.length,c=h?1:0,p={contentPosition:[n.x,n.y],pageCount:c,pageIndex:c-1,pagePrevDataIndex:null,pageNextDataIndex:null};if(!u)return p;var d=m(u);p.contentPosition[r]=-d.s;// Strategy:
// (1) Always align based on the left/top most item.
// (2) It is user-friendly that the last item shown in the
// current window is shown at the begining of next window.
// Otherwise if half of the last item is cut by the window,
// it will have no chance to display entirely.
// (3) Consider that item size probably be different, we
// have calculate pageIndex by size rather than item index,
// and we can not get page index directly by division.
// (4) The window is to narrow to contain more than
// one item, we should make sure that the page can be fliped.
for(var f=s+1,g=d,y=d,v=null;f<=h;++f)// Half of the last item is out of the window.
(!(v=m(l[f]))&&y.e>g.s+i||// If the current item does not intersect with the window, the new page
// can be started at the current item or the last item.
v&&!x(v,g.s))&&(g=y.i>g.i?y:v)&&(null==p.pageNextDataIndex&&(p.pageNextDataIndex=g.i),++p.pageCount),y=v;for(f=s-1,g=d,y=d,v=null;f>=-1;--f)// If the the end item does not intersect with the window started
// from the current item, a page can be settled.
(v=m(l[f]))&&x(y,v.s)||// e.g., when page size is smaller than item size.
!(g.i<y.i)||(y=g,null==p.pagePrevDataIndex&&(p.pagePrevDataIndex=g.i),++p.pageCount,++p.pageIndex),g=v;return p;function m(t){if(t){var e=t.getBoundingRect(),n=e[a]+t[a];return{s:n,e:n+e[o],i:t.__legendDataIndex}}}function x(t,e){return t.e>=e&&t.s<=e+i}},e.prototype._findTargetItemIndex=function(t){return this._showController?(this.getContentGroup().eachChild((function(i,r){var o=i.__legendDataIndex;// FIXME
// If the given targetDataIndex (from model) is illegal,
// we use defaultIndex. But the index on the legend model and
// action payload is still illegal. That case will not be
// changed until some scenario requires.
null==n&&null!=o&&(n=r),o===t&&(e=r)})),null!=e?e:n):0;var e,n},e.type="legend.scroll",e}(kW);const GW=FW;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */function WW(t){Wm(OW),t.registerComponentModel(EW),t.registerComponentView(GW),function(t){
/**
               * @event legendScroll
               * @type {Object}
               * @property {string} type 'legendScroll'
               * @property {string} scrollDataIndex
               */
t.registerAction("legendScroll","legendscroll",(function(t,e){var n=t.scrollDataIndex;null!=n&&e.eachComponent({mainType:"legend",subType:"scroll",query:t},(function(t){t.setScrollDataIndex(n)}))}))}(t)}var HW=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="dataZoom.inside",e.defaultOption=Nc(aB.defaultOption,{disabled:!1,zoomLock:!1,zoomOnMouseWheel:!0,moveOnMouseMove:!0,moveOnMouseWheel:!1,preventDefaultMouseMove:!0}),e}(aB);const YW=HW;var XW=bo();function UW(t,e,n){XW(t).coordSysRecordMap.each((function(t){var i=t.dataZoomInfoMap.get(e.uid);i&&(i.getRange=n)}))}function ZW(t,e){if(e){t.removeKey(e.model.uid);var n=e.controller;n&&n.dispose()}}
/**
             * This action will be throttled.
             */
function jW(t,e){t.isDisposed()||t.dispatchAction({type:"dataZoom",animation:{easing:"cubicOut",duration:100},batch:e})}function qW(t,e,n,i){return t.coordinateSystem.containPoint([n,i])}
/**
             * Merge roamController settings when multiple dataZooms share one roamController.
             */function KW(t){t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER,(function(t,e){var n=XW(e),i=n.coordSysRecordMap||(n.coordSysRecordMap=ct());i.each((function(t){// `coordSysRecordMap` always exists (because it holds the `roam controller`, which should
// better not re-create each time), but clear `dataZoomInfoMap` each round of the workflow.
t.dataZoomInfoMap=null})),t.eachComponent({mainType:"dataZoom",subType:"inside"},(function(t){R(nB(t).infoList,(function(n){var r=n.model.uid,o=i.get(r)||i.set(r,function(t,e){// These init props will never change after record created.
var n={model:e,containsPoint:F(qW,e),dispatchAction:F(jW,t),dataZoomInfoMap:null,controller:null},i=n.controller=new RT(t.getZr());// Must not do anything depends on coordSysRecord outside the event handler here,
// because coordSysRecord not completed yet.
return R(["pan","zoom","scrollMove"],(function(t){i.on(t,(function(e){var i=[];n.dataZoomInfoMap.each((function(r){// Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,
// moveOnMouseWheel, ...) enabled.
if(e.isAvailableBehavior(r.model.option)){var o=(r.getRange||{})[t],a=o&&o(r.dzReferCoordSysInfo,n.model.mainType,n.controller,e);!r.model.get("disabled",!0)&&a&&i.push({dataZoomId:r.model.id,start:a[0],end:a[1]})}})),i.length&&n.dispatchAction(i)}))})),n}(e,n.model));// Notice these props might be changed each time for a single dataZoomModel.
(o.dataZoomInfoMap||(o.dataZoomInfoMap=ct())).set(t.uid,{dzReferCoordSysInfo:n,model:t,getRange:null})}))})),// (1) Merge dataZoom settings for each coord sys and set to the roam controller.
// (2) Clear coord sys if not refered by any dataZoom.
i.each((function(t){var e,n=t.controller,r=t.dataZoomInfoMap;if(r){var o=r.keys()[0];null!=o&&(e=r.get(o))}if(e){var a=function(t){var e,n="type_",i={type_true:2,type_move:1,type_false:0,type_undefined:-1},r=!0;// DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated
// as string, it is probably revert to reserved word by compress tool. See #7411.
return t.each((function(t){var o=t.model,a=!o.get("disabled",!0)&&(!o.get("zoomLock",!0)||"move");i[n+a]>i[n+e]&&(e=a),// Prevent default move event by default. If one false, do not prevent. Otherwise
// users may be confused why it does not work when multiple insideZooms exist.
r=r&&o.get("preventDefaultMouseMove",!0)})),{controlType:e,opt:{// RoamController will enable all of these functionalities,
// and the final behavior is determined by its event listener
// provided by each inside zoom.
zoomOnMouseWheel:!0,moveOnMouseMove:!0,moveOnMouseWheel:!0,preventDefaultMouseMove:!!r}}}(r);n.enable(a.controlType,a.opt),n.setPointerChecker(t.containsPoint),ty(t,"dispatchAction",e.model.get("throttle",!0),"fixRate")}else ZW(i,t)}))}))}var $W=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="dataZoom.inside",e}return n(e,t),e.prototype.render=function(e,n,i){t.prototype.render.apply(this,arguments),e.noTarget()?this._clear():(// Hence the `throttle` util ensures to preserve command order,
// here simply updating range all the time will not cause missing
// any of the the roam change.
this.range=e.getPercentRange(),// Reset controllers.
UW(i,e,{pan:B(JW.pan,this),zoom:B(JW.zoom,this),scrollMove:B(JW.scrollMove,this)}))},e.prototype.dispose=function(){this._clear(),t.prototype.dispose.apply(this,arguments)},e.prototype._clear=function(){!function(t,e){for(var n=XW(t).coordSysRecordMap,i=n.keys(),r=0;r<i.length;r++){var o=i[r],a=n.get(o),s=a.dataZoomInfoMap;if(s){var l=e.uid;s.get(l)&&(s.removeKey(l),s.keys().length||ZW(n,a))}}}(this.api,this.dataZoomModel),this.range=null},e.type="dataZoom.inside",e}(hB),JW={zoom:function(t,e,n,i){var r=this.range,o=r.slice(),a=t.axisModels[0];if(a){var s=tH[e](null,[i.originX,i.originY],a,n,t),l=(s.signal>0?s.pixelStart+s.pixelLength-s.pixel:s.pixel-s.pixelStart)/s.pixelLength*(o[1]-o[0])+o[0],u=Math.max(1/i.scale,0);o[0]=(o[0]-l)*u+l,o[1]=(o[1]-l)*u+l;// Restrict range.
var h=this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();return BL(0,o,[0,100],0,h.minSpan,h.maxSpan),this.range=o,r[0]!==o[0]||r[1]!==o[1]?o:void 0}},pan:QW((function(t,e,n,i,r,o){var a=tH[i]([o.oldX,o.oldY],[o.newX,o.newY],e,r,n);return a.signal*(t[1]-t[0])*a.pixel/a.pixelLength})),scrollMove:QW((function(t,e,n,i,r,o){return tH[i]([0,0],[o.scrollDelta,o.scrollDelta],e,r,n).signal*(t[1]-t[0])*o.scrollDelta}))};function QW(t){return function(e,n,i,r){var o=this.range,a=o.slice(),s=e.axisModels[0];if(s)return BL(t(a,s,e,n,i,r),a,[0,100],"all"),this.range=a,o[0]!==a[0]||o[1]!==a[1]?a:void 0}}var tH={grid:function(t,e,n,i,r){var o=n.axis,a={},s=r.model.coordinateSystem.getRect();return t=t||[0,0],"x"===o.dim?(a.pixel=e[0]-t[0],a.pixelLength=s.width,a.pixelStart=s.x,a.signal=o.inverse?1:-1):(// axis.dim === 'y'
a.pixel=e[1]-t[1],a.pixelLength=s.height,a.pixelStart=s.y,a.signal=o.inverse?-1:1),a},polar:function(t,e,n,i,r){var o=n.axis,a={},s=r.model.coordinateSystem,l=s.getRadiusAxis().getExtent(),u=s.getAngleAxis().getExtent();return t=t?s.pointToCoord(t):[0,0],e=s.pointToCoord(e),"radiusAxis"===n.mainType?(a.pixel=e[0]-t[0],// ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
// ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);
a.pixelLength=l[1]-l[0],a.pixelStart=l[0],a.signal=o.inverse?1:-1):(// 'angleAxis'
a.pixel=e[1]-t[1],// ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
// ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);
a.pixelLength=u[1]-u[0],a.pixelStart=u[0],a.signal=o.inverse?-1:1),a},singleAxis:function(t,e,n,i,r){var o=n.axis,a=r.model.coordinateSystem.getRect(),s={};return t=t||[0,0],"horizontal"===o.orient?(s.pixel=e[0]-t[0],s.pixelLength=a.width,s.pixelStart=a.x,s.signal=o.inverse?1:-1):(// 'vertical'
s.pixel=e[1]-t[1],s.pixelLength=a.height,s.pixelStart=a.y,s.signal=o.inverse?-1:1),s}};const eH=$W;function nH(t){xB(t),t.registerComponentModel(YW),t.registerComponentView(eH),KW(t)}var iH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.type="dataZoom.slider",e.layoutMode="box",e.defaultOption=Nc(aB.defaultOption,{show:!0,// deault value can only be drived in view stage.
right:"ph",top:"ph",width:"ph",height:"ph",left:null,bottom:null,borderColor:"#d2dbee",borderRadius:3,backgroundColor:"rgba(47,69,84,0)",// dataBackgroundColor: '#ddd',
dataBackground:{lineStyle:{color:"#d2dbee",width:.5},areaStyle:{color:"#d2dbee",opacity:.2}},selectedDataBackground:{lineStyle:{color:"#8fb0f7",width:.5},areaStyle:{color:"#8fb0f7",opacity:.2}},// Color of selected window.
fillerColor:"rgba(135,175,274,0.2)",handleIcon:"path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",// Percent of the slider height
handleSize:"100%",handleStyle:{color:"#fff",borderColor:"#ACB8D1"},moveHandleSize:7,moveHandleIcon:"path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",moveHandleStyle:{color:"#D2DBEE",opacity:.7},showDetail:!0,showDataShadow:"auto",realtime:!0,zoomLock:!1,textStyle:{color:"#6E7079"},brushSelect:!0,brushStyle:{color:"rgba(135,175,274,0.15)"},emphasis:{handleStyle:{borderColor:"#8FB0F7"},moveHandleStyle:{color:"#8FB0F7"}}}),e}(aB);const rH=iH;var oH=Ls,aH="horizontal",sH="vertical",lH=["line","bar","candlestick","scatter"],uH={easing:"cubicOut",duration:100,delay:0},hH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._displayables={},n}return n(e,t),e.prototype.init=function(t,e){this.api=e,// A unique handler for each dataZoom component
this._onBrush=B(this._onBrush,this),this._onBrushEnd=B(this._onBrushEnd,this)},e.prototype.render=function(e,n,i,r){if(t.prototype.render.apply(this,arguments),ty(this,"_dispatchZoomAction",e.get("throttle"),"fixRate"),this._orient=e.getOrient(),!1!==e.get("show")){if(e.noTarget())return this._clear(),void this.group.removeAll();// Notice: this._resetInterval() should not be executed when payload.type
// is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
// or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,
r&&"dataZoom"===r.type&&r.from===this.uid||this._buildView(),this._updateView()}else this.group.removeAll()},e.prototype.dispose=function(){this._clear(),t.prototype.dispose.apply(this,arguments)},e.prototype._clear=function(){ey(this,"_dispatchZoomAction");var t=this.api.getZr();t.off("mousemove",this._onBrush),t.off("mouseup",this._onBrushEnd)},e.prototype._buildView=function(){var t=this.group;t.removeAll(),this._brushing=!1,this._displayables.brushRect=null,this._resetLocation(),this._resetInterval();var e=this._displayables.sliderGroup=new Lr;this._renderBackground(),this._renderHandle(),this._renderDataShadow(),t.add(e),this._positionGroup()},e.prototype._resetLocation=function(){var t=this.dataZoomModel,e=this.api,n=t.get("brushSelect")?7:0,i=this._findCoordRect(),r={width:e.getWidth(),height:e.getHeight()},o=this._orient===aH?{// Why using 'right', because right should be used in vertical,
// and it is better to be consistent for dealing with position param merge.
right:r.width-i.x-i.width,top:r.height-30-7-n,width:i.width,height:30}:{right:7,top:i.y,width:30,height:i.height},a=Vp(t.option);// Replace the placeholder value.
R(["right","top","width","height"],(function(t){"ph"===a[t]&&(a[t]=o[t])}));var s=Rp(a,r);this._location={x:s.x,y:s.y},this._size=[s.width,s.height],this._orient===sH&&this._size.reverse()},e.prototype._positionGroup=function(){var t=this.group,e=this._location,n=this._orient,i=this.dataZoomModel.getFirstTargetAxisModel(),r=i&&i.get("inverse"),o=this._displayables.sliderGroup,a=(this._dataShadowInfo||{}).otherAxisInverse;// Transform barGroup.
o.attr(n!==aH||r?n===aH&&r?{scaleY:a?1:-1,scaleX:-1}:n!==sH||r?{scaleY:a?-1:1,scaleX:-1,rotation:Math.PI/2}:{scaleY:a?-1:1,scaleX:1,rotation:Math.PI/2}:{scaleY:a?1:-1,scaleX:1});// Position barGroup
var s=t.getBoundingRect([o]);t.x=e.x-s.x,t.y=e.y-s.y,t.markRedraw()},e.prototype._getViewExtent=function(){return[0,this._size[0]]},e.prototype._renderBackground=function(){var t=this.dataZoomModel,e=this._size,n=this._displayables.sliderGroup,i=t.get("brushSelect");n.add(new oH({silent:!0,shape:{x:0,y:0,width:e[0],height:e[1]},style:{fill:t.get("backgroundColor")},z2:-40}));// Click panel, over shadow, below handles.
var r=new oH({shape:{x:0,y:0,width:e[0],height:e[1]},style:{fill:"transparent"},z2:0,onclick:B(this._onClickPanel,this)}),o=this.api.getZr();i?(r.on("mousedown",this._onBrushStart,this),r.cursor="crosshair",o.on("mousemove",this._onBrush),o.on("mouseup",this._onBrushEnd)):(o.off("mousemove",this._onBrush),o.off("mouseup",this._onBrushEnd)),n.add(r)},e.prototype._renderDataShadow=function(){var t=this._dataShadowInfo=this._prepareDataShadowInfo();if(this._displayables.dataShadowSegs=[],t){var e=this._size,n=this._shadowSize||[],i=t.series,r=i.getRawData(),o=i.getShadowDim&&i.getShadowDim(),a=o&&r.getDimensionInfo(o)?i.getShadowDim():t.otherDim;if(null!=a){var s=this._shadowPolygonPts,l=this._shadowPolylinePts;// Not re-render if data doesn't change.
if(r!==this._shadowData||a!==this._shadowDim||e[0]!==n[0]||e[1]!==n[1]){var u=r.getDataExtent(a),h=.3*(u[1]-u[0]);// Nice extent.
u=[u[0]-h,u[1]+h];var c,p=[0,e[1]],d=[0,e[0]],f=[[e[0],0],[0,0]],g=[],y=d[1]/(r.count()-1),v=0,m=Math.round(r.count()/e[0]);r.each([a],(function(t,e){if(m>0&&e%m)v+=y;else{// FIXME
// Should consider axis.min/axis.max when drawing dataShadow.
// FIXME
// list
var n=null==t||isNaN(t)||""===t,i=n?0:zr(t,u,p,!0);// See #4235.
// Attempt to draw data shadow precisely when there are empty value.
n&&!c&&e?(f.push([f[f.length-1][0],0]),g.push([g[g.length-1][0],0])):!n&&c&&(f.push([v,0]),g.push([v,0])),f.push([v,i]),g.push([v,i]),v+=y,c=n}})),s=this._shadowPolygonPts=f,l=this._shadowPolylinePts=g}this._shadowData=r,this._shadowDim=a,this._shadowSize=[e[0],e[1]];// let dataBackgroundModel = dataZoomModel.getModel('dataBackground');
for(var x=this.dataZoomModel,_=0;_<3;_++){var b=w(1===_);this._displayables.sliderGroup.add(b),this._displayables.dataShadowSegs.push(b)}}}function w(t){var e=x.getModel(t?"selectedDataBackground":"dataBackground"),n=new Lr,i=new Wu({shape:{points:s},segmentIgnoreThreshold:1,style:e.getModel("areaStyle").getAreaStyle(),silent:!0,z2:-20}),r=new Xu({shape:{points:l},segmentIgnoreThreshold:1,style:e.getModel("lineStyle").getLineStyle(),silent:!0,z2:-19});return n.add(i),n.add(r),n}},e.prototype._prepareDataShadowInfo=function(){var t=this.dataZoomModel,e=t.get("showDataShadow");if(!1!==e){// Find a representative series.
var n,i=this.ecModel;return t.eachTargetAxis((function(r,o){R(t.getAxisProxy(r,o).getTargetSeriesModels(),(function(t){if(!(n||!0!==e&&L(lH,t.get("type"))<0)){var a,s=i.getComponent(tB(r),o).axis,l=function(t){// FIXME
// getOtherAxis
var e={x:"y",y:"x",radius:"angle",angle:"radius"};return e[t]}(r),u=t.coordinateSystem;null!=l&&u.getOtherAxis&&(a=u.getOtherAxis(s).inverse),l=t.getData().mapDimension(l),n={thisAxis:s,series:t,thisDim:r,otherDim:l,otherAxisInverse:a}}}),this)}),this),n}},e.prototype._renderHandle=function(){var t=this.group,e=this._displayables,n=e.handles=[null,null],i=e.handleLabels=[null,null],r=this._displayables.sliderGroup,o=this._size,a=this.dataZoomModel,s=this.api,l=a.get("borderRadius")||0,u=a.get("brushSelect"),h=e.filler=new oH({silent:u,style:{fill:a.get("fillerColor")},textConfig:{position:"inside"}});r.add(h),// Frame border.
r.add(new oH({silent:!0,subPixelOptimize:!0,shape:{x:0,y:0,width:o[0],height:o[1],r:l},style:{// deprecated option
stroke:a.get("dataBackgroundColor")||a.get("borderColor"),lineWidth:1,fill:"rgba(0,0,0,0)"}})),// Left and right handle to resize
R([0,1],(function(e){var o=a.get("handleIcon");!nv[o]&&o.indexOf("path://")<0&&o.indexOf("image://")<0&&(// Compatitable with the old icon parsers. Which can use a path string without path://
o="path://"+o);var s=ov(o,-1,0,2,2,null,!0);s.attr({cursor:cH(this._orient),draggable:!0,drift:B(this._onDragMove,this,e),ondragend:B(this._onDragEnd,this),onmouseover:B(this._showDataInfo,this,!0),onmouseout:B(this._showDataInfo,this,!1),z2:5});var l=s.getBoundingRect(),u=a.get("handleSize");this._handleHeight=Vr(u,this._size[1]),this._handleWidth=l.width/l.height*this._handleHeight,s.setStyle(a.getModel("handleStyle").getItemStyle()),s.style.strokeNoScale=!0,s.rectHover=!0,s.ensureState("emphasis").style=a.getModel(["emphasis","handleStyle"]).getItemStyle(),Vl(s);var h=a.get("handleColor");// deprecated option
// Compatitable with previous version
null!=h&&(s.style.fill=h),r.add(n[e]=s);var c=a.getModel("textStyle");t.add(i[e]=new Zs({silent:!0,invisible:!0,style:lc(c,{x:0,y:0,text:"",verticalAlign:"middle",align:"center",fill:c.getTextColor(),font:c.getFont()}),z2:10}))}),this);// Handle to move. Only visible when brushSelect is set true.
var c=h;if(u){var p=Vr(a.get("moveHandleSize"),o[1]),d=e.moveHandle=new Ls({style:a.getModel("moveHandleStyle").getItemStyle(),silent:!0,shape:{r:[0,0,2,2],y:o[1]-.5,height:p}}),f=.8*p,g=e.moveHandleIcon=ov(a.get("moveHandleIcon"),-f/2,-f/2,f,f,"#fff",!0);g.silent=!0,g.y=o[1]+p/2-.5,d.ensureState("emphasis").style=a.getModel(["emphasis","moveHandleStyle"]).getItemStyle();var y=Math.min(o[1]/2,Math.max(p,10));(c=e.moveZone=new Ls({invisible:!0,shape:{y:o[1]-y,height:p+y}})).on("mouseover",(function(){s.enterEmphasis(d)})).on("mouseout",(function(){s.leaveEmphasis(d)})),r.add(d),r.add(g),r.add(c)}c.attr({draggable:!0,cursor:cH(this._orient),drift:B(this._onDragMove,this,"all"),ondragstart:B(this._showDataInfo,this,!0),ondragend:B(this._onDragEnd,this),onmouseover:B(this._showDataInfo,this,!0),onmouseout:B(this._showDataInfo,this,!1)})},e.prototype._resetInterval=function(){var t=this._range=this.dataZoomModel.getPercentRange(),e=this._getViewExtent();this._handleEnds=[zr(t[0],[0,100],e,!0),zr(t[1],[0,100],e,!0)]},e.prototype._updateInterval=function(t,e){var n=this.dataZoomModel,i=this._handleEnds,r=this._getViewExtent(),o=n.findRepresentativeAxisProxy().getMinMaxSpan(),a=[0,100];BL(e,i,r,n.get("zoomLock")?"all":t,null!=o.minSpan?zr(o.minSpan,a,r,!0):null,null!=o.maxSpan?zr(o.maxSpan,a,r,!0):null);var s=this._range,l=this._range=Fr([zr(i[0],r,a,!0),zr(i[1],r,a,!0)]);return!s||s[0]!==l[0]||s[1]!==l[1]},e.prototype._updateView=function(t){var e=this._displayables,n=this._handleEnds,i=Fr(n.slice()),r=this._size;R([0,1],(function(t){// Handles
var i=e.handles[t],o=this._handleHeight;i.attr({scaleX:o/2,scaleY:o/2,// This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
// NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
x:n[t]+(t?-1:1),y:r[1]/2-o/2})}),this),// Filler
e.filler.setShape({x:i[0],y:0,width:i[1]-i[0],height:r[1]});var o={x:i[0],width:i[1]-i[0]};// Move handle
e.moveHandle&&(e.moveHandle.setShape(o),e.moveZone.setShape(o),// Force update path on the invisible object
e.moveZone.getBoundingRect(),e.moveHandleIcon&&e.moveHandleIcon.attr("x",o.x+o.width/2));// update clip path of shadow.
for(var a=e.dataShadowSegs,s=[0,i[0],i[1],r[0]],l=0;l<a.length;l++){var u=a[l],h=u.getClipPath();h||(h=new Ls,u.setClipPath(h)),h.setShape({x:s[l],y:0,width:s[l+1]-s[l],height:r[1]})}this._updateDataInfo(t)},e.prototype._updateDataInfo=function(t){var e=this.dataZoomModel,n=this._displayables,i=n.handleLabels,r=this._orient,o=["",""];// FIXME
// dateformatterautoformatterec2 date.getAutoFormatter
if(e.get("showDetail")){var a=e.findRepresentativeAxisProxy();if(a){var s=a.getAxisModel().axis,l=this._range,u=t?a.calculateDataWindow({start:l[0],end:l[1]}).valueWindow:a.getDataValueWindow();o=[this._formatLabel(u[0],s),this._formatLabel(u[1],s)]}}var h=Fr(this._handleEnds.slice());function c(t){// Label
// Text should not transform by barGroup.
// Ignore handlers transform
var e=Hh(n.handles[t].parent,this.group),a=Xh(0===t?"right":"left",e),s=this._handleWidth/2+5,l=Yh([h[t]+(0===t?-s:s),this._size[1]/2],e);i[t].setStyle({x:l[0],y:l[1],verticalAlign:r===aH?"middle":a,align:r===aH?a:"center",text:o[t]})}c.call(this,0),c.call(this,1)},e.prototype._formatLabel=function(t,e){var n=this.dataZoomModel,i=n.get("labelFormatter"),r=n.get("labelPrecision");null!=r&&"auto"!==r||(r=e.getPixelPrecision());var o=null==t||isNaN(t)?"":"category"===e.type||"time"===e.type?e.scale.getLabel({value:Math.round(t)}):t.toFixed(Math.min(r,20));return W(i)?i(t,o):H(i)?i.replace("{value}",o):o},
/**
               * @param showOrHide true: show, false: hide
               */
e.prototype._showDataInfo=function(t){// Always show when drgging.
t=this._dragging||t;var e=this._displayables,n=e.handleLabels;n[0].attr("invisible",!t),n[1].attr("invisible",!t),// Highlight move handle
e.moveHandle&&this.api[t?"enterEmphasis":"leaveEmphasis"](e.moveHandle,1)},e.prototype._onDragMove=function(t,e,n,i){this._dragging=!0,// For mobile device, prevent screen slider on the button.
re(i.event);// Transform dx, dy to bar coordination.
var r=Yh([e,n],this._displayables.sliderGroup.getLocalTransform(),!0),o=this._updateInterval(t,r[0]),a=this.dataZoomModel.get("realtime");this._updateView(!a),// Avoid dispatch dataZoom repeatly but range not changed,
// which cause bad visual effect when progressive enabled.
o&&a&&this._dispatchZoomAction(!0)},e.prototype._onDragEnd=function(){this._dragging=!1,this._showDataInfo(!1),!this.dataZoomModel.get("realtime")&&this._dispatchZoomAction(!1)},e.prototype._onClickPanel=function(t){var e=this._size,n=this._displayables.sliderGroup.transformCoordToLocal(t.offsetX,t.offsetY);if(!(n[0]<0||n[0]>e[0]||n[1]<0||n[1]>e[1])){var i=this._handleEnds,r=(i[0]+i[1])/2,o=this._updateInterval("all",n[0]-r);this._updateView(),o&&this._dispatchZoomAction(!1)}},e.prototype._onBrushStart=function(t){var e=t.offsetX,n=t.offsetY;this._brushStart=new ve(e,n),this._brushing=!0,this._brushStartTime=+new Date},e.prototype._onBrushEnd=function(t){if(this._brushing){var e=this._displayables.brushRect;if(this._brushing=!1,e){e.attr("ignore",!0);var n=e.shape;// console.log(brushEndTime - this._brushStartTime);
if(!(+new Date-this._brushStartTime<200&&Math.abs(n.width)<5)){var i=this._getViewExtent(),r=[0,100];this._range=Fr([zr(n.x,i,r,!0),zr(n.x+n.width,i,r,!0)]),this._handleEnds=[n.x,n.x+n.width],this._updateView(),this._dispatchZoomAction(!1)}}}},e.prototype._onBrush=function(t){this._brushing&&(// For mobile device, prevent screen slider on the button.
re(t.event),this._updateBrushRect(t.offsetX,t.offsetY))},e.prototype._updateBrushRect=function(t,e){var n=this._displayables,i=this.dataZoomModel,r=n.brushRect;r||(r=n.brushRect=new oH({silent:!0,style:i.getModel("brushStyle").getItemStyle()}),n.sliderGroup.add(r)),r.attr("ignore",!1);var o=this._brushStart,a=this._displayables.sliderGroup,s=a.transformCoordToLocal(t,e),l=a.transformCoordToLocal(o.x,o.y),u=this._size;s[0]=Math.max(Math.min(u[0],s[0]),0),r.setShape({x:l[0],y:0,width:s[0]-l[0],height:u[1]})},
/**
               * This action will be throttled.
               */
e.prototype._dispatchZoomAction=function(t){var e=this._range;this.api.dispatchAction({type:"dataZoom",from:this.uid,dataZoomId:this.dataZoomModel.id,animation:t?uH:null,start:e[0],end:e[1]})},e.prototype._findCoordRect=function(){// Find the grid coresponding to the first axis referred by dataZoom.
var t,e=nB(this.dataZoomModel).infoList;if(!t&&e.length){var n=e[0].model.coordinateSystem;t=n.getRect&&n.getRect()}if(!t){var i=this.api.getWidth(),r=this.api.getHeight();t={x:.2*i,y:.2*r,width:.6*i,height:.6*r}}return t},e.type="dataZoom.slider",e}(hB);// Constants
function cH(t){return"vertical"===t?"ns-resize":"ew-resize"}const pH=hH;function dH(t){t.registerComponentModel(rH),t.registerComponentView(pH),xB(t)}var fH={
/**
               * @public
               */
get:function(t,e,n){var i=T((gH[t]||{})[e]);return n&&G(i)?i[i.length-1]:i}},gH={color:{active:["#006edd","#e0ffff"],inactive:["rgba(0,0,0,0)"]},colorHue:{active:[0,360],inactive:[0,0]},colorSaturation:{active:[.3,1],inactive:[0,0]},colorLightness:{active:[.9,.5],inactive:[0,0]},colorAlpha:{active:[.3,1],inactive:[0,0]},opacity:{active:[.3,1],inactive:[0,0]},symbol:{active:["circle","roundRect","diamond"],inactive:["none"]},symbolSize:{active:[10,50],inactive:[0,0]}};const yH=fH;var vH=kA.mapVisual,mH=kA.eachVisual,xH=G,_H=R,bH=Fr,wH=zr,SH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.stateList=["inRange","outOfRange"],n.replacableOptionKeys=["inRange","outOfRange","target","controller","color"],n.layoutMode={type:"box",ignoreSize:!0},
/**
                 * [lowerBound, upperBound]
                 */
n.dataBound=[-1/0,1/0],n.targetVisuals={},n.controllerVisuals={},n}return n(e,t),e.prototype.init=function(t,e,n){this.mergeDefaultAndTheme(t,n)},
/**
               * @protected
               */
e.prototype.optionUpdated=function(t,e){var n=this.option;!e&&UF(n,t,this.replacableOptionKeys),this.textStyleModel=this.getModel("textStyle"),this.resetItemSize(),this.completeVisualOption()},
/**
               * @protected
               */
e.prototype.resetVisual=function(t){var e=this.stateList;t=B(t,this),this.controllerVisuals=XF(this.option.controller,e,t),this.targetVisuals=XF(this.option.target,e,t)},
/**
               * @public
               */
e.prototype.getItemSymbol=function(){return null},
/**
               * @protected
               * @return {Array.<number>} An array of series indices.
               */
e.prototype.getTargetSeriesIndices=function(){var t=this.option.seriesIndex,e=[];return null==t||"all"===t?this.ecModel.eachSeries((function(t,n){e.push(n)})):e=lo(t),e},
/**
               * @public
               */
e.prototype.eachTargetSeries=function(t,e){R(this.getTargetSeriesIndices(),(function(n){var i=this.ecModel.getSeriesByIndex(n);i&&t.call(e,i)}),this)},
/**
               * @pubilc
               */
e.prototype.isTargetSeries=function(t){var e=!1;return this.eachTargetSeries((function(n){n===t&&(e=!0)})),e},
/**
               * @example
               * this.formatValueText(someVal); // format single numeric value to text.
               * this.formatValueText(someVal, true); // format single category value to text.
               * this.formatValueText([min, max]); // format numeric min-max to text.
               * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
               * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
               *
               * @param value Real value, or this.dataBound[0 or 1].
               * @param isCategory Only available when value is number.
               * @param edgeSymbols Open-close symbol when value is interval.
               * @protected
               */
e.prototype.formatValueText=function(t,e,n){var i,r=this.option,o=r.precision,a=this.dataBound,s=r.formatter;n=n||["<",">"],G(t)&&(t=t.slice(),i=!0);var l=e?t:i?[u(t[0]),u(t[1])]:u(t);return H(s)?s.replace("{value}",i?l[0]:l).replace("{value2}",i?l[1]:l):W(s)?i?s(t[0],t[1]):s(t):i?t[0]===a[0]?n[0]+" "+l[1]:t[1]===a[1]?n[1]+" "+l[0]:l[0]+" - "+l[1]:l;function u(t){return t===a[0]?"min":t===a[1]?"max":(+t).toFixed(Math.min(o,20))}},
/**
               * @protected
               */
e.prototype.resetExtent=function(){var t=this.option,e=bH([t.min,t.max]);// Can not calculate data extent by data here.
// Because series and data may be modified in processing stage.
// So we do not support the feature "auto min/max".
this._dataExtent=e},
/**
               * PENDING:
               * delete this method if no outer usage.
               *
               * Return  Concrete dimention. If return null/undefined, no dimension used.
               */
// getDataDimension(data: SeriesData) {
//     const optDim = this.option.dimension;
//     if (optDim != null) {
//         return data.getDimension(optDim);
//     }
//     const dimNames = data.dimensions;
//     for (let i = dimNames.length - 1; i >= 0; i--) {
//         const dimName = dimNames[i];
//         const dimInfo = data.getDimensionInfo(dimName);
//         if (!dimInfo.isCalculationCoord) {
//             return dimName;
//         }
//     }
// }
e.prototype.getDataDimensionIndex=function(t){var e=this.option.dimension;if(null!=e)return t.getDimensionIndex(e);for(var n=t.dimensions,i=n.length-1;i>=0;i--){var r=n[i],o=t.getDimensionInfo(r);if(!o.isCalculationCoord)return o.storeDimIndex}},e.prototype.getExtent=function(){return this._dataExtent.slice()},e.prototype.completeVisualOption=function(){var t=this.ecModel,e=this.option,n={inRange:e.inRange,outOfRange:e.outOfRange},i=e.target||(e.target={}),r=e.controller||(e.controller={});C(i,n),// Do not override
C(r,n);// Do not override
var o=this.isCategory();function a(n){// Compatible with ec2 dataRange.color.
// The mapping order of dataRange.color is: [high value, ..., low value]
// whereas inRange.color and outOfRange.color is [low value, ..., high value]
// Notice: ec2 has no inverse.
xH(e.color)&&!n.inRange&&(n.inRange={color:e.color.slice().reverse()}),// Compatible with previous logic, always give a defautl color, otherwise
// simple config with no inRange and outOfRange will not work.
// Originally we use visualMap.color as the default color, but setOption at
// the second time the default color will be erased. So we change to use
// constant DEFAULT_COLOR.
// If user do not want the default color, set inRange: {color: null}.
n.inRange=n.inRange||{color:t.get("gradientColor")}}a.call(this,i),a.call(this,r),function(t,e,n){var i=t[e],r=t[n];i&&!r&&(r=t[n]={},_H(i,(function(t,e){if(kA.isValidType(e)){var n=yH.get(e,"inactive",o);null!=n&&(r[e]=n,// Compatibable with ec2:
// Only inactive color to rgba(0,0,0,0) can not
// make label transparent, so use opacity also.
"color"!==e||r.hasOwnProperty("opacity")||r.hasOwnProperty("colorAlpha")||(r.opacity=[0,0]))}})))}.call(this,i,"inRange","outOfRange"),// completeInactive.call(this, target, 'outOfRange', 'inRange');
function(t){var e=(t.inRange||{}).symbol||(t.outOfRange||{}).symbol,n=(t.inRange||{}).symbolSize||(t.outOfRange||{}).symbolSize,i=this.get("inactiveColor"),r=this.getItemSymbol()||"roundRect";_H(this.stateList,(function(a){var s=this.itemSize,l=t[a];// Set inactive color for controller if no other color
// attr (like colorAlpha) specified.
l||(l=t[a]={color:o?i:[i]}),// Consistent symbol and symbolSize if not specified.
null==l.symbol&&(l.symbol=e&&T(e)||(o?r:[r])),null==l.symbolSize&&(l.symbolSize=n&&T(n)||(o?s[0]:[s[0],s[0]])),// Filter none
l.symbol=vH(l.symbol,(function(t){return"none"===t?r:t}));// Normalize symbolSize
var u=l.symbolSize;if(null!=u){var h=-1/0;// symbolSize can be object when categories defined.
mH(u,(function(t){t>h&&(h=t)})),l.symbolSize=vH(u,(function(t){return wH(t,[0,h],[0,s[0]],!0)}))}}),this)}.call(this,r)},e.prototype.resetItemSize=function(){this.itemSize=[parseFloat(this.get("itemWidth")),parseFloat(this.get("itemHeight"))]},e.prototype.isCategory=function(){return!!this.option.categories},
/**
               * @public
               * @abstract
               */
e.prototype.setSelected=function(t){},e.prototype.getSelected=function(){return null},
/**
               * @public
               * @abstract
               */
e.prototype.getValueState=function(t){return null},
/**
               * FIXME
               * Do not publish to thirt-part-dev temporarily
               * util the interface is stable. (Should it return
               * a function but not visual meta?)
               *
               * @pubilc
               * @abstract
               * @param getColorVisual
               *        params: value, valueState
               *        return: color
               * @return {Object} visualMeta
               *        should includes {stops, outerColors}
               *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
               */
e.prototype.getVisualMeta=function(t){return null},e.type="visualMap",e.dependencies=["series"],e.defaultOption={show:!0,// zlevel: 0,
z:4,seriesIndex:"all",min:0,max:200,left:0,right:null,top:null,bottom:0,itemWidth:null,itemHeight:null,inverse:!1,orient:"vertical",backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",contentColor:"#5793f3",inactiveColor:"#aaa",borderWidth:0,padding:5,// css
textGap:10,precision:0,textStyle:{color:"#333"}},e}(Wp);const MH=SH;var IH=[20,140],TH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}
/**
               * @override
               */return n(e,t),e.prototype.optionUpdated=function(e,n){t.prototype.optionUpdated.apply(this,arguments),this.resetExtent(),this.resetVisual((function(t){t.mappingMethod="linear",t.dataExtent=this.getExtent()})),this._resetRange()},
/**
               * @protected
               * @override
               */
e.prototype.resetItemSize=function(){t.prototype.resetItemSize.apply(this,arguments);var e=this.itemSize;(null==e[0]||isNaN(e[0]))&&(e[0]=IH[0]),(null==e[1]||isNaN(e[1]))&&(e[1]=IH[1])},
/**
               * @private
               */
e.prototype._resetRange=function(){var t=this.getExtent(),e=this.option.range;!e||e.auto?(// `range` should always be array (so we dont use other
// value like 'auto') for user-friend. (consider getOption).
t.auto=1,this.option.range=t):G(e)&&(e[0]>e[1]&&e.reverse(),e[0]=Math.max(e[0],t[0]),e[1]=Math.min(e[1],t[1]))},
/**
               * @protected
               * @override
               */
e.prototype.completeVisualOption=function(){t.prototype.completeVisualOption.apply(this,arguments),R(this.stateList,(function(t){var e=this.option.controller[t].symbolSize;e&&e[0]!==e[1]&&(e[0]=e[1]/3)}),this)},
/**
               * @override
               */
e.prototype.setSelected=function(t){this.option.range=t.slice(),this._resetRange()},
/**
               * @public
               */
e.prototype.getSelected=function(){var t=this.getExtent(),e=Fr((this.get("range")||[]).slice());// Clamp
return e[0]>t[1]&&(e[0]=t[1]),e[1]>t[1]&&(e[1]=t[1]),e[0]<t[0]&&(e[0]=t[0]),e[1]<t[0]&&(e[1]=t[0]),e},
/**
               * @override
               */
e.prototype.getValueState=function(t){var e=this.option.range,n=this.getExtent();// When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
// range[1] is processed likewise.
return(e[0]<=n[0]||e[0]<=t)&&(e[1]>=n[1]||t<=e[1])?"inRange":"outOfRange"},e.prototype.findTargetDataIndices=function(t){var e=[];return this.eachTargetSeries((function(n){var i=[],r=n.getData();r.each(this.getDataDimensionIndex(r),(function(e,n){t[0]<=e&&e<=t[1]&&i.push(n)}),this),e.push({seriesId:n.id,dataIndex:i})}),this),e},
/**
               * @implement
               */
e.prototype.getVisualMeta=function(t){var e=CH(0,0,this.getExtent()),n=CH(0,0,this.option.range.slice()),i=[];function r(e,n){i.push({value:e,color:t(e,n)})}// Format to: outOfRange -- inRange -- outOfRange.
for(var o=0,a=0,s=n.length,l=e.length;a<l&&(!n.length||e[a]<=n[0]);a++)// If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
e[a]<n[o]&&r(e[a],"outOfRange");for(var u=1;o<s;o++,u=0)// If range is full, value beyond min, max will be clamped.
// make a singularity
u&&i.length&&r(n[o],"outOfRange"),r(n[o],"inRange");for(u=1;a<l;a++)(!n.length||n[n.length-1]<e[a])&&(// make a singularity
u&&(i.length&&r(i[i.length-1].value,"outOfRange"),u=0),r(e[a],"outOfRange"));var h=i.length;return{stops:i,outerColors:[h?i[0].color:"transparent",h?i[h-1].color:"transparent"]}},e.type="visualMap.continuous",e.defaultOption=Nc(MH.defaultOption,{align:"auto",calculable:!1,hoverLink:!0,realtime:!0,handleIcon:"path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",handleSize:"120%",handleStyle:{borderColor:"#fff",borderWidth:1},indicatorIcon:"circle",indicatorSize:"50%",indicatorStyle:{borderColor:"#fff",borderWidth:2,shadowBlur:2,shadowOffsetX:1,shadowOffsetY:1,shadowColor:"rgba(0,0,0,0.2)"}}),e}(MH);function CH(t,e,n){if(n[0]===n[1])return n.slice();// When using colorHue mapping, it is not linear color any more.
// Moreover, canvas gradient seems not to be accurate linear.
// FIXME
// Should be arbitrary value 100? or based on pixel size?
for(var i=(n[1]-n[0])/200,r=n[0],o=[],a=0;a<=200&&r<n[1];a++)o.push(r),r+=i;return o.push(n[1]),o}const DH=TH;var AH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n.autoPositionValues={left:1,right:1,top:1,bottom:1},n}return n(e,t),e.prototype.init=function(t,e){this.ecModel=t,this.api=e},
/**
               * @protected
               */
e.prototype.render=function(t,e,n,i){this.visualMapModel=t,!1!==t.get("show")?this.doRender(t,e,n,i):this.group.removeAll()},
/**
               * @protected
               */
e.prototype.renderBackground=function(t){var e=this.visualMapModel,n=wp(e.get("padding")||0),i=t.getBoundingRect();t.add(new Ls({z2:-1,silent:!0,shape:{x:i.x-n[3],y:i.y-n[0],width:i.width+n[3]+n[1],height:i.height+n[0]+n[2]},style:{fill:e.get("backgroundColor"),stroke:e.get("borderColor"),lineWidth:e.get("borderWidth")}}))},
/**
               * @protected
               * @param targetValue can be Infinity or -Infinity
               * @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
               * @param opts
               * @param opts.forceState Specify state, instead of using getValueState method.
               * @param opts.convertOpacityToAlpha For color gradient in controller widget.
               * @return {*} Visual value.
               */
e.prototype.getControllerVisual=function(t,e,n){var i=(n=n||{}).forceState,r=this.visualMapModel,o={};// Default values.
if("color"===e){var a=r.get("contentColor");o.color=a}function s(t){return o[t]}function l(t,e){o[t]=e}var u=r.controllerVisuals[i||r.getValueState(t)];return R(kA.prepareVisualTypes(u),(function(i){var r=u[i];n.convertOpacityToAlpha&&"opacity"===i&&(i="colorAlpha",r=u.__alphaForOpacity),kA.dependsOn(i,e)&&r&&r.applyVisual(t,s,l)})),o[e]},e.prototype.positionGroup=function(t){var e=this.visualMapModel,n=this.api;Np(t,e.getBoxLayoutParams(),{width:n.getWidth(),height:n.getHeight()})},e.prototype.doRender=function(t,e,n,i){},e.type="visualMap",e}(Bg);const kH=AH;var LH=[["left","right","width"],["top","bottom","height"]];
/**
             * @param visualMapModel
             * @param api
             * @param itemSize always [short, long]
             * @return {string} 'left' or 'right' or 'top' or 'bottom'
             */function PH(t,e,n){var i=t.option,r=i.align;if(null!=r&&"auto"!==r)return r;// Auto decision align.
for(var o={width:e.getWidth(),height:e.getHeight()},a="horizontal"===i.orient?1:0,s=LH[a],l=[0,null,10],u={},h=0;h<3;h++)u[LH[1-a][h]]=l[h],u[s[h]]=2===h?n[0]:i[s[h]];var c=[["x","width",3],["y","height",0]][a],p=Rp(u,o,i.padding);return s[(p.margin[c[2]]||0)+p[c[0]]+.5*p[c[1]]<.5*o[c[1]]?0:1]}
/**
             * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
             * dataIndexInside means filtered index.
             */
// TODO: TYPE more specified payload types.
function OH(t,e){return R(t||[],(function(t){null!=t.dataIndex&&(t.dataIndexInside=t.dataIndex,t.dataIndex=null),t.highlightKey="visualMap"+(e?e.componentIndex:"")})),t}var RH=zr,NH=R,EH=Math.min,zH=Math.max,VH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n._shapes={},n._dataInterval=[],n._handleEnds=[],n._hoverLinkDataIndices=[],n}return n(e,t),e.prototype.doRender=function(t,e,n,i){this._api=n,i&&"selectDataRange"===i.type&&i.from===this.uid||this._buildView()},e.prototype._buildView=function(){this.group.removeAll();var t=this.visualMapModel,e=this.group;this._orient=t.get("orient"),this._useHandle=t.get("calculable"),this._resetInterval(),this._renderBar(e);var n=t.get("text");this._renderEndsText(e,n,0),this._renderEndsText(e,n,1),// Do this for background size calculation.
this._updateView(!0),// After updating view, inner shapes is built completely,
// and then background can be rendered.
this.renderBackground(e),// Real update view
this._updateView(),this._enableHoverLinkToSeries(),this._enableHoverLinkFromSeries(),this.positionGroup(e)},e.prototype._renderEndsText=function(t,e,n){if(e){// Compatible with ec2, text[0] map to high value, text[1] map low value.
var i=e[1-n];i=null!=i?i+"":"";var r=this.visualMapModel,o=r.get("textGap"),a=r.itemSize,s=this._shapes.mainGroup,l=this._applyTransform([a[0]/2,0===n?-o:a[1]+o],s),u=this._applyTransform(0===n?"bottom":"top",s),h=this._orient,c=this.visualMapModel.textStyleModel;this.group.add(new Zs({style:lc(c,{x:l[0],y:l[1],verticalAlign:"horizontal"===h?"middle":u,align:"horizontal"===h?u:"center",text:i})}))}},e.prototype._renderBar=function(t){var e=this.visualMapModel,n=this._shapes,i=e.itemSize,r=this._orient,o=this._useHandle,a=PH(e,this.api,i),s=n.mainGroup=this._createBarGroup(a),l=new Lr;s.add(l),// Bar
l.add(n.outOfRange=BH()),l.add(n.inRange=BH(null,o?GH(this._orient):null,B(this._dragHandle,this,"all",!1),B(this._dragHandle,this,"all",!0))),// A border radius clip.
l.setClipPath(new Ls({shape:{x:0,y:0,width:i[0],height:i[1],r:3}}));var u=e.textStyleModel.getTextRect(""),h=zH(u.width,u.height);// Handle
o&&(n.handleThumbs=[],n.handleLabels=[],n.handleLabelPoints=[],this._createHandle(e,s,0,i,h,r),this._createHandle(e,s,1,i,h,r)),this._createIndicator(e,s,i,h,r),t.add(s)},e.prototype._createHandle=function(t,e,n,i,r,o){var a=B(this._dragHandle,this,n,!1),s=B(this._dragHandle,this,n,!0),l=vr(t.get("handleSize"),i[0]),u=ov(t.get("handleIcon"),-l/2,-l/2,l,l,null,!0),h=GH(this._orient);u.attr({cursor:h,draggable:!0,drift:a,ondragend:s,onmousemove:function(t){re(t.event)}}),u.x=i[0]/2,u.useStyle(t.getModel("handleStyle").getItemStyle()),u.setStyle({strokeNoScale:!0,strokeFirst:!0}),u.style.lineWidth*=2,u.ensureState("emphasis").style=t.getModel(["emphasis","handleStyle"]).getItemStyle(),Yl(u,!0),e.add(u);// Text is always horizontal layout but should not be effected by
// transform (orient/inverse). So label is built separately but not
// use zrender/graphic/helper/RectText, and is located based on view
// group (according to handleLabelPoint) but not barGroup.
var c=this.visualMapModel.textStyleModel,p=new Zs({cursor:h,draggable:!0,drift:a,onmousemove:function(t){// Fot mobile devicem, prevent screen slider on the button.
re(t.event)},ondragend:s,style:lc(c,{x:0,y:0,text:""})});p.ensureState("blur").style={opacity:.1},p.stateTransition={duration:200},this.group.add(p);var d=[l,0],f=this._shapes;f.handleThumbs[n]=u,f.handleLabelPoints[n]=d,f.handleLabels[n]=p},e.prototype._createIndicator=function(t,e,n,i,r){var o=vr(t.get("indicatorSize"),n[0]),a=ov(t.get("indicatorIcon"),-o/2,-o/2,o,o,null,!0);a.attr({cursor:"move",invisible:!0,silent:!0,x:n[0]/2});var s=t.getModel("indicatorStyle").getItemStyle();if(a instanceof Ss){var l=a.style;a.useStyle(A({// TODO other properties like x, y ?
image:l.image,x:l.x,y:l.y,width:l.width,height:l.height},s))}else a.useStyle(s);e.add(a);var u=this.visualMapModel.textStyleModel,h=new Zs({silent:!0,invisible:!0,style:lc(u,{x:0,y:0,text:""})});this.group.add(h);var c=[("horizontal"===r?i/2:6)+n[0]/2,0],p=this._shapes;p.indicator=a,p.indicatorLabel=h,p.indicatorLabelPoint=c,this._firstShowIndicator=!0},e.prototype._dragHandle=function(t,e,// dx is event from ondragend if isEnd is true. It's not used
n,i){if(this._useHandle){if(this._dragging=!e,!e){// Transform dx, dy to bar coordination.
var r=this._applyTransform([n,i],this._shapes.mainGroup,!0);this._updateInterval(t,r[1]),this._hideIndicator(),// Considering realtime, update view should be executed
// before dispatch action.
this._updateView()}// dragEnd do not dispatch action when realtime.
e===!this.visualMapModel.get("realtime")&&// jshint ignore:line
this.api.dispatchAction({type:"selectDataRange",from:this.uid,visualMapId:this.visualMapModel.id,selected:this._dataInterval.slice()}),e?!this._hovering&&this._clearHoverLinkToSeries():FH(this.visualMapModel)&&this._doHoverLinkToSeries(this._handleEnds[t],!1)}},e.prototype._resetInterval=function(){var t=this.visualMapModel,e=this._dataInterval=t.getSelected(),n=t.getExtent(),i=[0,t.itemSize[1]];this._handleEnds=[RH(e[0],n,i,!0),RH(e[1],n,i,!0)]},
/**
               * @private
               * @param {(number|string)} handleIndex 0 or 1 or 'all'
               * @param {number} dx
               * @param {number} dy
               */
e.prototype._updateInterval=function(t,e){e=e||0;var n=this.visualMapModel,i=this._handleEnds,r=[0,n.itemSize[1]];BL(e,i,r,t,// cross is forbiden
0);var o=n.getExtent();// Update data interval.
this._dataInterval=[RH(i[0],r,o,!0),RH(i[1],r,o,!0)]},e.prototype._updateView=function(t){var e=this.visualMapModel,n=e.getExtent(),i=this._shapes,r=[0,e.itemSize[1]],o=t?r:this._handleEnds,a=this._createBarVisual(this._dataInterval,n,o,"inRange"),s=this._createBarVisual(n,n,r,"outOfRange");i.inRange.setStyle({fill:a.barColor}).setShape("points",a.barPoints),i.outOfRange.setStyle({fill:s.barColor}).setShape("points",s.barPoints),this._updateHandle(o,a)},e.prototype._createBarVisual=function(t,e,n,i){var r={forceState:i,convertOpacityToAlpha:!0},o=this._makeColorGradient(t,r),a=[this.getControllerVisual(t[0],"symbolSize",r),this.getControllerVisual(t[1],"symbolSize",r)],s=this._createBarPoints(n,a);return{barColor:new lh(0,0,0,1,o),barPoints:s,handlesColor:[o[0].color,o[o.length-1].color]}},e.prototype._makeColorGradient=function(t,e){// Considering colorHue, which is not linear, so we have to sample
// to calculate gradient color stops, but not only caculate head
// and tail.
var n=[],i=(t[1]-t[0])/100;// Arbitrary value.
n.push({color:this.getControllerVisual(t[0],"color",e),offset:0});for(var r=1;r<100;r++){var o=t[0]+i*r;if(o>t[1])break;n.push({color:this.getControllerVisual(o,"color",e),offset:r/100})}return n.push({color:this.getControllerVisual(t[1],"color",e),offset:1}),n},e.prototype._createBarPoints=function(t,e){var n=this.visualMapModel.itemSize;return[[n[0]-e[0],t[0]],[n[0],t[0]],[n[0],t[1]],[n[0]-e[1],t[1]]]},e.prototype._createBarGroup=function(t){var e=this._orient,n=this.visualMapModel.get("inverse");return new Lr("horizontal"!==e||n?"horizontal"===e&&n?{scaleX:"bottom"===t?-1:1,rotation:-Math.PI/2}:"vertical"!==e||n?{scaleX:"left"===t?1:-1}:{scaleX:"left"===t?1:-1,scaleY:-1}:{scaleX:"bottom"===t?1:-1,rotation:Math.PI/2})},e.prototype._updateHandle=function(t,e){if(this._useHandle){var n=this._shapes,i=this.visualMapModel,r=n.handleThumbs,o=n.handleLabels,a=i.itemSize,s=i.getExtent();NH([0,1],(function(l){var u=r[l];u.setStyle("fill",e.handlesColor[l]),u.y=t[l];var h=RH(t[l],[0,a[1]],s,!0),c=this.getControllerVisual(h,"symbolSize");u.scaleX=u.scaleY=c/a[0],u.x=a[0]-c/2;// Update handle label position.
var p=Yh(n.handleLabelPoints[l],Hh(u,this.group));o[l].setStyle({x:p[0],y:p[1],text:i.formatValueText(this._dataInterval[l]),verticalAlign:"middle",align:"vertical"===this._orient?this._applyTransform("left",n.mainGroup):"center"})}),this)}},e.prototype._showIndicator=function(t,e,n,i){var r=this.visualMapModel,o=r.getExtent(),a=r.itemSize,s=[0,a[1]],l=this._shapes,u=l.indicator;if(u){u.attr("invisible",!1);var h=this.getControllerVisual(t,"color",{convertOpacityToAlpha:!0}),c=this.getControllerVisual(t,"symbolSize"),p=RH(t,o,s,!0),d=a[0]-c/2,f={x:u.x,y:u.y};// Update handle label position.
u.y=p,u.x=d;var g=Yh(l.indicatorLabelPoint,Hh(u,this.group)),y=l.indicatorLabel;y.attr("invisible",!1);var v=this._applyTransform("left",l.mainGroup),m="horizontal"===this._orient;y.setStyle({text:(n||"")+r.formatValueText(e),verticalAlign:m?v:"middle",align:m?"center":v});var x={x:d,y:p,style:{fill:h}},_={style:{x:g[0],y:g[1]}};if(r.ecModel.isAnimationEnabled()&&!this._firstShowIndicator){var b={duration:100,easing:"cubicInOut",additive:!0};u.x=f.x,u.y=f.y,u.animateTo(x,b),y.animateTo(_,b)}else u.attr(x),y.attr(_);this._firstShowIndicator=!1;var w=this._shapes.handleLabels;if(w)for(var S=0;S<w.length;S++)// Fade out handle labels.
// NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
this._api.enterBlur(w[S])}},e.prototype._enableHoverLinkToSeries=function(){var t=this;this._shapes.mainGroup.on("mousemove",(function(e){if(t._hovering=!0,!t._dragging){var n=t.visualMapModel.itemSize,i=t._applyTransform([e.offsetX,e.offsetY],t._shapes.mainGroup,!0,!0);// For hover link show when hover handle, which might be
// below or upper than sizeExtent.
i[1]=EH(zH(0,i[1]),n[1]),t._doHoverLinkToSeries(i[1],0<=i[0]&&i[0]<=n[0])}})).on("mouseout",(function(){// When mouse is out of handle, hoverLink still need
// to be displayed when realtime is set as false.
t._hovering=!1,!t._dragging&&t._clearHoverLinkToSeries()}))},e.prototype._enableHoverLinkFromSeries=function(){var t=this.api.getZr();this.visualMapModel.option.hoverLink?(t.on("mouseover",this._hoverLinkFromSeriesMouseOver,this),t.on("mouseout",this._hideIndicator,this)):this._clearHoverLinkFromSeries()},e.prototype._doHoverLinkToSeries=function(t,e){var n=this.visualMapModel,i=n.itemSize;if(n.option.hoverLink){var r=[0,i[1]],o=n.getExtent();// For hover link show when hover handle, which might be below or upper than sizeExtent.
t=EH(zH(r[0],t),r[1]);var a=function(t,e,n){var i=6,r=t.get("hoverLinkDataSize");return r&&(i=RH(r,e,n,!0)/2),i}(n,o,r),s=[t-a,t+a],l=RH(t,r,o,!0),u=[RH(s[0],r,o,!0),RH(s[1],r,o,!0)];// Consider data range is out of visualMap range, see test/visualMap-continuous.html,
// where china and india has very large population.
s[0]<r[0]&&(u[0]=-1/0),s[1]>r[1]&&(u[1]=1/0),// Do not show indicator when mouse is over handle,
// otherwise labels overlap, especially when dragging.
e&&(u[0]===-1/0?this._showIndicator(l,u[1],"< ",a):u[1]===1/0?this._showIndicator(l,u[0],"> ",a):this._showIndicator(l,l," ",a));// When realtime is set as false, handles, which are in barGroup,
// also trigger hoverLink, which help user to realize where they
// focus on when dragging. (see test/heatmap-large.html)
// When realtime is set as true, highlight will not show when hover
// handle, because the label on handle, which displays a exact value
// but not range, might mislead users.
var h=this._hoverLinkDataIndices,c=[];(e||FH(n))&&(c=this._hoverLinkDataIndices=n.findTargetDataIndices(u));var p=function(t,e){var n={},i={};return r(t||[],n),r(e||[],i,n),[o(n),o(i)];function r(t,e,n){for(var i=0,r=t.length;i<r;i++){var o=vo(t[i].seriesId,null);if(null==o)return;for(var a=lo(t[i].dataIndex),s=n&&n[o],l=0,u=a.length;l<u;l++){var h=a[l];s&&s[h]?s[h]=null:(e[o]||(e[o]={}))[h]=1}}}function o(t,e){var n=[];for(var i in t)if(t.hasOwnProperty(i)&&null!=t[i])if(e)n.push(+i);else{var r=o(t[i],!0);r.length&&n.push({seriesId:i,dataIndex:r})}return n}}(h,c);this._dispatchHighDown("downplay",OH(p[0],n)),this._dispatchHighDown("highlight",OH(p[1],n))}},e.prototype._hoverLinkFromSeriesMouseOver=function(t){var e;if(Uy(t.target,(function(t){var n=js(t);if(null!=n.dataIndex)return e=n,!0}),!0),e){var n=this.ecModel.getSeriesByIndex(e.seriesIndex),i=this.visualMapModel;if(i.isTargetSeries(n)){var r=n.getData(e.dataType),o=r.getStore().get(i.getDataDimensionIndex(r),e.dataIndex);isNaN(o)||this._showIndicator(o,o)}}},e.prototype._hideIndicator=function(){var t=this._shapes;t.indicator&&t.indicator.attr("invisible",!0),t.indicatorLabel&&t.indicatorLabel.attr("invisible",!0);var e=this._shapes.handleLabels;if(e)for(var n=0;n<e.length;n++)// Fade out handle labels.
// NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
this._api.leaveBlur(e[n])},e.prototype._clearHoverLinkToSeries=function(){this._hideIndicator();var t=this._hoverLinkDataIndices;this._dispatchHighDown("downplay",OH(t,this.visualMapModel)),t.length=0},e.prototype._clearHoverLinkFromSeries=function(){this._hideIndicator();var t=this.api.getZr();t.off("mouseover",this._hoverLinkFromSeriesMouseOver),t.off("mouseout",this._hideIndicator)},e.prototype._applyTransform=function(t,e,n,i){var r=Hh(e,i?null:this.group);return G(t)?Yh(t,r,n):Xh(t,r,n)},// TODO: TYPE more specified payload types.
e.prototype._dispatchHighDown=function(t,e){e&&e.length&&this.api.dispatchAction({type:t,batch:e})},
/**
               * @override
               */
e.prototype.dispose=function(){this._clearHoverLinkFromSeries(),this._clearHoverLinkToSeries()},
/**
               * @override
               */
e.prototype.remove=function(){this._clearHoverLinkFromSeries(),this._clearHoverLinkToSeries()},e.type="visualMap.continuous",e}(kH);function BH(t,e,n,i){return new Wu({shape:{points:t},draggable:!!n,cursor:e,drift:n,onmousemove:function(t){// Fot mobile devicem, prevent screen slider on the button.
re(t.event)},ondragend:i})}function FH(t){var e=t.get("hoverLinkOnHandle");return!!(null==e?t.get("realtime"):e)}function GH(t){return"vertical"===t?"ns-resize":"ew-resize"}const WH=VH;
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */
/**
             * AUTO-GENERATED FILE. DO NOT MODIFY.
             */
/*
            * Licensed to the Apache Software Foundation (ASF) under one
            * or more contributor license agreements.  See the NOTICE file
            * distributed with this work for additional information
            * regarding copyright ownership.  The ASF licenses this file
            * to you under the Apache License, Version 2.0 (the
            * "License"); you may not use this file except in compliance
            * with the License.  You may obtain a copy of the License at
            *
            *   http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing,
            * software distributed under the License is distributed on an
            * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            * KIND, either express or implied.  See the License for the
            * specific language governing permissions and limitations
            * under the License.
            */var HH={type:"selectDataRange",event:"dataRangeSelected",// FIXME use updateView appears wrong
update:"update"},YH=function(t,e){e.eachComponent({mainType:"visualMap",query:t},(function(e){e.setSelected(t.selected)}))},XH=[{createOnAllSeries:!0,reset:function(t,e){var n=[];return e.eachComponent("visualMap",(function(e){var i,r,o,a,s,l=t.pipelineContext;!e.isTargetSeries(t)||l&&l.large||n.push((i=e.stateList,r=e.targetVisuals,o=B(e.getValueState,e),a=e.getDataDimensionIndex(t.getData()),s={},R(i,(function(t){var e=kA.prepareVisualTypes(r[t]);s[t]=e})),{progress:function(t,e){var n,i;function l(t){return Gy(e,i,t)}function u(t,n){Hy(e,i,t,n)}null!=a&&(n=e.getDimensionIndex(a));for(var h=e.getStore();null!=(i=t.next());){var c=e.getRawDataItem(i);// Consider performance
// @ts-ignore
if(!c||!1!==c.visualMap)for(var p=null!=a?h.get(n,i):i,d=o(p),f=r[d],g=s[d],y=0,v=g.length;y<v;y++){var m=g[y];f[m]&&f[m].applyVisual(p,l,u)}}}}))})),n}},// Only support color.
{createOnAllSeries:!0,reset:function(t,e){var n=t.getData(),i=[];e.eachComponent("visualMap",(function(e){if(e.isTargetSeries(t)){var r=e.getVisualMeta(B(UH,null,t,e))||{stops:[],outerColors:[]},o=e.getDataDimensionIndex(n);o>=0&&(// visualMeta.dimension should be dimension index, but not concrete dimension.
r.dimension=o,i.push(r))}})),// console.log(JSON.stringify(visualMetaList.map(a => a.stops)));
t.getData().setVisual("visualMeta",i)}}];// FIXME
// performance and export for heatmap?
// value can be Infinity or -Infinity
function UH(t,e,n,i){for(var r=e.targetVisuals[i],o=kA.prepareVisualTypes(r),a={color:Wy(t.getData(),"color")},s=0,l=o.length;s<l;s++){var u=o[s],h=r["opacity"===u?"__alphaForOpacity":u];h&&h.applyVisual(n,c,p)}return a.color;function c(t){return a[t]}function p(t,e){a[t]=e}}var ZH=R;function jH(t){var e=t&&t.visualMap;G(e)||(e=e?[e]:[]),ZH(e,(function(t){if(t){// rename splitList to pieces
qH(t,"splitList")&&!qH(t,"pieces")&&(t.pieces=t.splitList,delete t.splitList);var e=t.pieces;e&&G(e)&&ZH(e,(function(t){U(t)&&(qH(t,"start")&&!qH(t,"min")&&(t.min=t.start),qH(t,"end")&&!qH(t,"max")&&(t.max=t.end))}))}}))}function qH(t,e){return t&&t.hasOwnProperty&&t.hasOwnProperty(e)}var KH=!1;function $H(t){KH||(KH=!0,t.registerSubTypeDefaulter("visualMap",(function(t){// Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
return t.categories||(t.pieces?t.pieces.length>0:t.splitNumber>0)&&!t.calculable?"piecewise":"continuous"})),t.registerAction(HH,YH),R(XH,(function(e){t.registerVisual(t.PRIORITY.VISUAL.COMPONENT,e)})),t.registerPreprocessor(jH))}function JH(t){t.registerComponentModel(DH),t.registerComponentView(WH),$H(t)}var QH=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,
/**
                 * The order is always [low, ..., high].
                 * [{text: string, interval: Array.<number>}, ...]
                 */
n._pieceList=[],n}return n(e,t),e.prototype.optionUpdated=function(e,n){t.prototype.optionUpdated.apply(this,arguments),this.resetExtent();var i=this._mode=this._determineMode();this._pieceList=[],tY[this._mode].call(this,this._pieceList),this._resetSelected(e,n);var r=this.option.categories;this.resetVisual((function(t,e){"categories"===i?(t.mappingMethod="category",t.categories=T(r)):(t.dataExtent=this.getExtent(),t.mappingMethod="piecewise",t.pieceList=N(this._pieceList,(function(t){return t=T(t),"inRange"!==e&&(// FIXME
// outOfRange do not support special visual in pieces.
t.visual=null),t})))}))},
/**
               * @protected
               * @override
               */
e.prototype.completeVisualOption=function(){// Consider this case:
// visualMap: {
//      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
// }
// where no inRange/outOfRange set but only pieces. So we should make
// default inRange/outOfRange for this case, otherwise visuals that only
// appear in `pieces` will not be taken into account in visual encoding.
var e=this.option,n={},i=kA.listVisualTypes(),r=this.isCategory();function o(t,e,n){return t&&t[e]&&t[e].hasOwnProperty(n)}R(e.pieces,(function(t){R(i,(function(e){t.hasOwnProperty(e)&&(n[e]=1)}))})),R(n,(function(t,n){var i=!1;R(this.stateList,(function(t){i=i||o(e,t,n)||o(e.target,t,n)}),this),!i&&R(this.stateList,(function(t){(e[t]||(e[t]={}))[n]=yH.get(n,"inRange"===t?"active":"inactive",r)}))}),this),t.prototype.completeVisualOption.apply(this,arguments)},e.prototype._resetSelected=function(t,e){var n=this.option,i=this._pieceList,r=(e?n:t).selected||{};if(n.selected=r,// Consider 'not specified' means true.
R(i,(function(t,e){var n=this.getSelectedMapKey(t);r.hasOwnProperty(n)||(r[n]=!0)}),this),"single"===n.selectedMode){// Ensure there is only one selected.
var o=!1;R(i,(function(t,e){var n=this.getSelectedMapKey(t);r[n]&&(o?r[n]=!1:o=!0)}),this)}// thisOption.selectedMode === 'multiple', default: all selected.
},
/**
               * @public
               */
e.prototype.getItemSymbol=function(){return this.get("itemSymbol")},
/**
               * @public
               */
e.prototype.getSelectedMapKey=function(t){return"categories"===this._mode?t.value+"":t.index+""},
/**
               * @public
               */
e.prototype.getPieceList=function(){return this._pieceList},
/**
               * @return {string}
               */
e.prototype._determineMode=function(){var t=this.option;return t.pieces&&t.pieces.length>0?"pieces":this.option.categories?"categories":"splitNumber"},
/**
               * @override
               */
e.prototype.setSelected=function(t){this.option.selected=T(t)},
/**
               * @override
               */
e.prototype.getValueState=function(t){var e=kA.findPieceIndex(t,this._pieceList);return null!=e&&this.option.selected[this.getSelectedMapKey(this._pieceList[e])]?"inRange":"outOfRange"},
/**
               * @public
               * @param pieceIndex piece index in visualMapModel.getPieceList()
               */
e.prototype.findTargetDataIndices=function(t){var e=[],n=this._pieceList;return this.eachTargetSeries((function(i){var r=[],o=i.getData();o.each(this.getDataDimensionIndex(o),(function(e,i){kA.findPieceIndex(e,n)===t&&r.push(i)}),this),e.push({seriesId:i.id,dataIndex:r})}),this),e},
/**
               * @private
               * @param piece piece.value or piece.interval is required.
               * @return  Can be Infinity or -Infinity
               */
e.prototype.getRepresentValue=function(t){var e;if(this.isCategory())e=t.value;else if(null!=t.value)e=t.value;else{var n=t.interval||[];e=n[0]===-1/0&&n[1]===1/0?0:(n[0]+n[1])/2}return e},e.prototype.getVisualMeta=function(t){// Do not support category. (category axis is ordinal, numerical)
if(!this.isCategory()){var e=[],n=["",""],i=this,r=this._pieceList.slice();if(r.length){var o=r[0].interval[0];o!==-1/0&&r.unshift({interval:[-1/0,o]}),(o=r[r.length-1].interval[1])!==1/0&&r.push({interval:[o,1/0]})}else r.push({interval:[-1/0,1/0]});var a=-1/0;return R(r,(function(t){var e=t.interval;e&&(// Fulfill gap.
e[0]>a&&s([a,e[0]],"outOfRange"),s(e.slice()),a=e[1])}),this),{stops:e,outerColors:n}}function s(r,o){var a=i.getRepresentValue({interval:r});// Not category
o||(o=i.getValueState(a));var s=t(a,o);r[0]===-1/0?n[0]=s:r[1]===1/0?n[1]=s:e.push({value:r[0],color:s},{value:r[1],color:s})}// Suplement
},e.type="visualMap.piecewise",e.defaultOption=Nc(MH.defaultOption,{selected:null,minOpen:!1,maxOpen:!1,align:"auto",itemWidth:20,itemHeight:14,itemSymbol:"roundRect",pieces:null,categories:null,splitNumber:5,selectedMode:"multiple",itemGap:10,hoverLink:!0}),e}(MH),tY={splitNumber:function(t){var e=this.option,n=Math.min(e.precision,20),i=this.getExtent(),r=e.splitNumber;r=Math.max(parseInt(r,10),1),e.splitNumber=r;// Precision auto-adaption
for(var o=(i[1]-i[0])/r;+o.toFixed(n)!==o&&n<5;)n++;e.precision=n,o=+o.toFixed(n),e.minOpen&&t.push({interval:[-1/0,i[0]],close:[0,0]});for(var a=0,s=i[0];a<r;s+=o,a++){var l=a===r-1?i[1]:s+o;t.push({interval:[s,l],close:[1,1]})}e.maxOpen&&t.push({interval:[i[1],1/0],close:[0,0]}),Jr(t),R(t,(function(t,e){t.index=e,t.text=this.formatValueText(t.interval)}),this)},categories:function(t){var e=this.option;R(e.categories,(function(e){// FIXME categorypieceListvisualMappingpieceList
// 
t.push({text:this.formatValueText(e,!0),value:e})}),this),// See "Order Rule".
eY(e,t)},pieces:function(t){var e=this.option;R(e.pieces,(function(e,n){U(e)||(e={value:e});var i={text:"",index:n};if(null!=e.label&&(i.text=e.label),e.hasOwnProperty("value")){var r=i.value=e.value;i.interval=[r,r],i.close=[1,1]}else{for(// `min` `max` is legacy option.
// `lt` `gt` `lte` `gte` is recommanded.
var o=i.interval=[],a=i.close=[0,0],s=[1,0,1],l=[-1/0,1/0],u=[],h=0;h<2;h++){for(var c=[["gte","gt","min"],["lte","lt","max"]][h],p=0;p<3&&null==o[h];p++)o[h]=e[c[p]],a[h]=s[p],u[h]=2===p;null==o[h]&&(o[h]=l[h])}u[0]&&o[1]===1/0&&(a[0]=0),u[1]&&o[0]===-1/0&&(a[1]=0),o[0]===o[1]&&a[0]&&a[1]&&(// Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
// we use value to lift the priority when min === max
i.value=o[0])}i.visual=kA.retrieveVisuals(e),t.push(i)}),this),// See "Order Rule".
eY(e,t),// Only pieces
Jr(t),R(t,(function(t){var e=t.close,n=[["<",""][e[1]],[">",""][e[0]]];t.text=t.text||this.formatValueText(null!=t.value?t.value:t.interval,!1,n)}),this)}};
/**
             * Key is this._mode
             * @type {Object}
             * @this {module:echarts/component/viusalMap/PiecewiseMode}
             */function eY(t,e){var n=t.inverse;("vertical"===t.orient?!n:n)&&e.reverse()}const nY=QH;var iY=/** @class */function(t){function e(){var n=null!==t&&t.apply(this,arguments)||this;return n.type=e.type,n}return n(e,t),e.prototype.doRender=function(){var t=this.group;t.removeAll();var e=this.visualMapModel,n=e.get("textGap"),i=e.textStyleModel,r=i.getFont(),o=i.getTextColor(),a=this._getItemAlign(),s=e.itemSize,l=this._getViewData(),u=l.endsText,h=J(e.get("showLabel",!0),!u);u&&this._renderEndsText(t,u[0],s,h,a),R(l.viewPieceList,(function(i){var l=i.piece,u=new Lr;u.onclick=B(this._onItemClick,this,l),this._enableHoverLink(u,i.indexInModelPieceList);// TODO Category
var c=e.getRepresentValue(l);if(this._createItemSymbol(u,c,[0,0,s[0],s[1]]),h){var p=this.visualMapModel.getValueState(c);u.add(new Zs({style:{x:"right"===a?-n:s[0]+n,y:s[1]/2,text:l.text,verticalAlign:"middle",align:a,font:r,fill:o,opacity:"outOfRange"===p?.5:1}}))}t.add(u)}),this),u&&this._renderEndsText(t,u[1],s,h,a),Op(e.get("orient"),t,e.get("itemGap")),this.renderBackground(t),this.positionGroup(t)},e.prototype._enableHoverLink=function(t,e){var n=this;t.on("mouseover",(function(){return i("highlight")})).on("mouseout",(function(){return i("downplay")}));var i=function(t){var i=n.visualMapModel;// TODO: TYPE More detailed action types
i.option.hoverLink&&n.api.dispatchAction({type:t,batch:OH(i.findTargetDataIndices(e),i)})}},e.prototype._getItemAlign=function(){var t=this.visualMapModel,e=t.option;if("vertical"===e.orient)return PH(t,this.api,t.itemSize);// horizontal, most case left unless specifying right.
var n=e.align;return n&&"auto"!==n||(n="left"),n},e.prototype._renderEndsText=function(t,e,n,i,r){if(e){var o=new Lr,a=this.visualMapModel.textStyleModel;o.add(new Zs({style:lc(a,{x:i?"right"===r?n[0]:0:n[0]/2,y:n[1]/2,verticalAlign:"middle",align:i?r:"center",text:e})})),t.add(o)}},
/**
               * @private
               * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
               */
e.prototype._getViewData=function(){var t=this.visualMapModel,e=N(t.getPieceList(),(function(t,e){return{piece:t,indexInModelPieceList:e}})),n=t.get("text"),i=t.get("orient"),r=t.get("inverse");// Order of model pieceList is always [low, ..., high]
return("horizontal"===i?r:!r)?e.reverse():n&&(n=n.slice().reverse()),{viewPieceList:e,endsText:n}},e.prototype._createItemSymbol=function(t,e,n){t.add(ov(// symbol will be string
this.getControllerVisual(e,"symbol"),n[0],n[1],n[2],n[3],// color will be string
this.getControllerVisual(e,"color")))},e.prototype._onItemClick=function(t){var e=this.visualMapModel,n=e.option,i=n.selectedMode;if(i){var r=T(n.selected),o=e.getSelectedMapKey(t);"single"===i||!0===i?(r[o]=!0,R(r,(function(t,e){r[e]=e===o}))):r[o]=!r[o],this.api.dispatchAction({type:"selectDataRange",from:this.uid,visualMapId:this.visualMapModel.id,selected:r})}},e.type="visualMap.piecewise",e}(kH);const rY=iY;function oY(t){t.registerComponentModel(nY),t.registerComponentView(rY),$H(t)}var aY={label:{enabled:!0},decal:{show:!1}},sY=bo(),lY={};function uY(t,e){var n=t.getModel("aria");// See "area enabled" detection code in `GlobalModel.ts`.
if(n.get("enabled")){var i=T(aY);C(i.label,t.getLocaleModel().get("aria"),!1),C(n.option,i,!1),function(){if(n.getModel("decal").get("show")){// Each type of series use one scope.
// Pie and funnel are using different scopes.
var e=ct();t.eachSeries((function(t){if(!t.isColorBySeries()){var n=e.get(t.type);n||(n={},e.set(t.type,n)),sY(t).scope=n}})),t.eachRawSeries((function(e){if(!t.isSeriesFiltered(e))if(W(e.enableAriaDecal))// Let series define how to use decal palette on data
e.enableAriaDecal();else{var n=e.getData();if(e.isColorBySeries()){var i=vd(e.ecModel,e.name,lY,t.getSeriesCount()),r=n.getVisual("decal");n.setVisual("decal",u(r,i))}else{var o=e.getRawData(),a={},s=sY(e).scope;n.each((function(t){var e=n.getRawIndex(t);a[e]=t}));var l=o.count();o.each((function(t){var i=a[t],r=o.getName(t)||t+"",h=vd(e.ecModel,r,s,l),c=n.getItemVisual(i,"decal");n.setItemVisual(i,"decal",u(c,h))}))}}function u(t,e){// Merge decal from palette to decal from itemStyle.
// User do not need to specify all of the decal props.
var n=t?A(A({},e),t):e;return n.dirty=!0,n}}))}}(),function(){var i=t.getLocaleModel().get("aria"),o=n.getModel("label");if(o.option=k(o.option,i),o.get("enabled")){var a=e.getZr().dom;if(o.get("description"))a.setAttribute("aria-label",o.get("description"));else{var s,l=t.getSeriesCount(),u=o.get(["data","maxCount"])||10,h=o.get(["series","maxCount"])||10,c=Math.min(l,h);if(!(l<1)){var p=function(){var e=t.get("title");return e&&e.length&&(e=e[0]),e&&e.text}();s=p?r(o.get(["general","withTitle"]),{title:p}):o.get(["general","withoutTitle"]);var d=[];s+=r(l>1?o.get(["series","multiple","prefix"]):o.get(["series","single","prefix"]),{seriesCount:l}),t.eachSeries((function(e,n){if(n<c){var i=void 0,a=e.get("name")?"withName":"withoutName";i=r(i=l>1?o.get(["series","multiple",a]):o.get(["series","single",a]),{seriesId:e.seriesIndex,seriesName:e.get("name"),seriesType:(x=e.subType,t.getLocaleModel().get(["series","typeNames"])[x]||"")});var s=e.getData();s.count()>u?i+=r(o.get(["data","partialData"]),{displayCnt:u}):i+=o.get(["data","allData"]);for(var h=o.get(["data","separator","middle"]),p=o.get(["data","separator","end"]),f=[],g=0;g<s.count();g++)if(g<u){var y=s.getName(g),v=s.getValues(g),m=o.get(["data",y?"withName":"withoutName"]);f.push(r(m,{name:y,value:v.join(h)}))}i+=f.join(h)+p,d.push(i)}var x}));var f=o.getModel(["series","multiple","separator"]),g=f.get("middle"),y=f.get("end");s+=d.join(g)+y,a.setAttribute("aria-label",s)}}}}()}function r(t,e){if(!H(t))return t;var n=t;return R(e,(function(t,e){n=n.replace(new RegExp("\\{\\s*"+e+"\\s*\\}","g"),t)})),n}}function hY(t){if(t&&t.aria){var e=t.aria;// aria.show is deprecated and should use aria.enabled instead
null!=e.show&&(e.enabled=e.show),e.label=e.label||{},// move description, general, series, data to be under aria.label
R(["description","general","series","data"],(function(t){null!=e[t]&&(e.label[t]=e[t])}))}}var cY={value:"eq",// PENDING: not good for literal semantic?
"<":"lt","<=":"lte",">":"gt",">=":"gte","=":"eq","!=":"ne","<>":"ne"},pY=/** @class */function(){function t(t){// Support condVal: RegExp | string
var e;null==(this._condVal=H(t)?new RegExp(t):(e=t,"[object RegExp]"===f.call(e)?t:null))&&ro("")}return t.prototype.evaluate=function(t){var e=typeof t;return H(e)?this._condVal.test(t):!!X(e)&&this._condVal.test(t+"")},t}(),dY=/** @class */function(){function t(){}return t.prototype.evaluate=function(){return this.value},t}(),fY=/** @class */function(){function t(){}return t.prototype.evaluate=function(){for(var t=this.children,e=0;e<t.length;e++)if(!t[e].evaluate())return!1;return!0},t}(),gY=/** @class */function(){function t(){}return t.prototype.evaluate=function(){for(var t=this.children,e=0;e<t.length;e++)if(t[e].evaluate())return!0;return!1},t}(),yY=/** @class */function(){function t(){}return t.prototype.evaluate=function(){return!this.child.evaluate()},t}(),vY=/** @class */function(){function t(){}return t.prototype.evaluate=function(){// Relational cond follow "and" logic internally.
for(var t=!!this.valueParser,e=(0,this.getValue)(this.valueGetterParam),n=t?this.valueParser(e):null,i=0// Call getValue with no `this`.
;i<this.subCondList.length;i++)if(!this.subCondList[i].evaluate(t?n:e))return!1;return!0},t}();// type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;
function mY(t,e){if(!0===t||!1===t){var n=new dY;return n.value=t,n}return _Y(t)||ro(""),t.and?xY("and",t,e):t.or?xY("or",t,e):t.not?function(t,e){var n=t.not,i="";_Y(n)||ro(i);var r=new yY;return r.child=mY(n,e),r.child||ro(i),r}(t,e):function(t,e){for(var n="",i=e.prepareGetValue(t),r=[],o=V(t),a=t.parser,s=a?Nf(a):null,l=0;l<o.length;l++){var u=o[l];if("parser"!==u&&!e.valueGetterAttrMap.get(u)){var h=gt(cY,u)?cY[u]:u,c=t[u],p=s?s(c):c,d=Ff(h,p)||"reg"===h&&new pY(p);d||ro(n),r.push(d)}}r.length||ro(n);var f=new vY;return f.valueGetterParam=i,f.valueParser=s,f.getValue=e.getValue,f.subCondList=r,f}(t,e)}function xY(t,e,n){var i=e[t];G(i)||ro(""),i.length||ro("");var r="and"===t?new fY:new gY;return r.children=N(i,(function(t){return mY(t,n)})),r.children.length||ro(""),r}function _Y(t){return U(t)&&!O(t)}var bY=/** @class */function(){function t(t,e){this._cond=mY(t,e)}return t.prototype.evaluate=function(){return this._cond.evaluate()},t}(),wY={type:"echarts:filter",// PEDING: enhance to filter by index rather than create new data
transform:function(t){for(// [Caveat] Fail-Fast:
// Do not return the whole dataset unless user config indicate it explicitly.
// For example, if no condition specified by mistake, return an empty result
// is better than return the entire raw soruce for user to find the mistake.
var e,n,i,r=t.upstream,o=(n=t.config,i={valueGetterAttrMap:ct({dimension:!0}),prepareGetValue:function(t){var e=t.dimension;gt(t,"dimension")||ro("");var n=r.getDimensionInfo(e);return n||ro(""),{dimIdx:n.index}},getValue:function(t){return r.retrieveValueFromItem(e,t.dimIdx)}},new bY(n,i)),a=[],s=0,l=r.count();s<l;s++)e=r.getRawDataItem(s),o.evaluate()&&a.push(e);return{data:a}}},SY={type:"echarts:sort",transform:function(t){var e=t.upstream,n=t.config,i="",r=lo(n);r.length||ro(i);var o=[];R(r,(function(t){var n=t.dimension,r=t.order,a=t.parser,s=t.incomparable;null==n&&ro(i),"asc"!==r&&"desc"!==r&&ro(i),s&&"min"!==s&&"max"!==s&&ro(""),"asc"!==r&&"desc"!==r&&ro("");var l=e.getDimensionInfo(n);l||ro(i);var u=a?Nf(a):null;a&&!u&&ro(i),o.push({dimIdx:l.index,parser:u,comparator:new Vf(r,s)})}));// TODO: support it?
var a=e.sourceFormat;a!==jp&&a!==qp&&ro(i);// Other upstream format are all array.
for(var s=[],l=0,u=e.count();l<u;l++)s.push(e.getRawDataItem(l));return s.sort((function(t,n){for(var i=0;i<o.length;i++){var r=o[i],a=e.retrieveValueFromItem(t,r.dimIdx),s=e.retrieveValueFromItem(n,r.dimIdx);r.parser&&(a=r.parser(a),s=r.parser(s));var l=r.comparator.evaluate(a,s);if(0!==l)return l}return 0})),{data:s}}},MY=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="dataset",e}return n(e,t),e.prototype.init=function(e,n,i){t.prototype.init.call(this,e,n,i),this._sourceManager=new og(this),ag(this)},e.prototype.mergeOption=function(e,n){t.prototype.mergeOption.call(this,e,n),ag(this)},e.prototype.optionUpdated=function(){this._sourceManager.dirty()},e.prototype.getSourceManager=function(){return this._sourceManager},e.type="dataset",e.defaultOption={seriesLayoutBy:Qp},e}(Wp),IY=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.type="dataset",e}return n(e,t),e.type="dataset",e}(Bg),TY=qa.CMD;function CY(t,e){return Math.abs(t-e)<1e-5}function DY(t){var e,n,i,r,o,a=t.data,s=t.len(),l=[],u=0,h=0,c=0,p=0;function d(t,n){e&&e.length>2&&l.push(e),e=[t,n]}function f(t,n,i,r){CY(t,i)&&CY(n,r)||e.push(t,n,i,r,i,r)}function g(t,n,i,r,o,a){var s=Math.abs(n-t),l=4*Math.tan(s/4)/3,u=n<t?-1:1,h=Math.cos(t),c=Math.sin(t),p=Math.cos(n),d=Math.sin(n),f=h*o+i,g=c*a+r,y=p*o+i,v=d*a+r,m=o*l*u,x=a*l*u;e.push(f-m*c,g+x*h,y+m*d,v-x*p,y,v)}for(var y=0;y<s;){var v=a[y++],m=1===y;switch(m&&(c=u=a[y],p=h=a[y+1],v!==TY.L&&v!==TY.C&&v!==TY.Q||(e=[c,p])),v){case TY.M:u=c=a[y++],h=p=a[y++],d(c,p);break;case TY.L:f(u,h,n=a[y++],i=a[y++]),u=n,h=i;break;case TY.C:e.push(a[y++],a[y++],a[y++],a[y++],u=a[y++],h=a[y++]);break;case TY.Q:n=a[y++],i=a[y++],r=a[y++],o=a[y++],e.push(u+2/3*(n-u),h+2/3*(i-h),r+2/3*(n-r),o+2/3*(i-o),r,o),u=r,h=o;break;case TY.A:var x=a[y++],_=a[y++],b=a[y++],w=a[y++],S=a[y++],M=a[y++]+S;y+=1;var I=!a[y++];n=Math.cos(S)*b+x,i=Math.sin(S)*w+_,m?d(c=n,p=i):f(u,h,n,i),u=Math.cos(M)*b+x,h=Math.sin(M)*w+_;for(var T=(I?-1:1)*Math.PI/2,C=S;I?C>M:C<M;C+=T)g(C,I?Math.max(C+T,M):Math.min(C+T,M),x,_,b,w);break;case TY.R:c=u=a[y++],p=h=a[y++],n=c+a[y++],i=p+a[y++],d(n,p),f(n,p,n,i),f(n,i,c,i),f(c,i,c,p),f(c,p,n,p);break;case TY.Z:e&&f(u,h,c,p),u=c,h=p}}return e&&e.length>2&&l.push(e),l}function AY(t,e,n,i,r,o,a,s,l,u){if(CY(t,n)&&CY(e,i)&&CY(r,a)&&CY(o,s))l.push(a,s);else{var h=2/u,c=h*h,p=a-t,d=s-e,f=Math.sqrt(p*p+d*d);p/=f,d/=f;var g=n-t,y=i-e,v=r-a,m=o-s,x=g*g+y*y,_=v*v+m*m;if(x<c&&_<c)l.push(a,s);else{var b=p*g+d*y,w=-p*v-d*m;if(x-b*b<c&&b>=0&&_-w*w<c&&w>=0)l.push(a,s);else{var S=[],M=[];gn(t,n,r,a,.5,S),gn(e,i,o,s,.5,M),AY(S[0],M[0],S[1],M[1],S[2],M[2],S[3],M[3],l,u),AY(S[4],M[4],S[5],M[5],S[6],M[6],S[7],M[7],l,u)}}}}function kY(t,e,n){var i=t[e],r=t[1-e],o=Math.abs(i/r),a=Math.ceil(Math.sqrt(o*n)),s=Math.floor(n/a);0===s&&(s=1,a=n);for(var l=[],u=0;u<a;u++)l.push(s);var h=n-a*s;if(h>0)for(u=0;u<h;u++)l[u%a]+=1;return l}function LY(t,e,n){for(var i=t.r0,r=t.r,o=t.startAngle,a=t.endAngle,s=Math.abs(a-o),l=s*r,u=r-i,h=l>Math.abs(u),c=kY([l,u],h?0:1,e),p=(h?s:u)/c.length,d=0;d<c.length;d++)for(var f=(h?u:s)/c[d],g=0;g<c[d];g++){var y={};h?(y.startAngle=o+p*d,y.endAngle=o+p*(d+1),y.r0=i+f*g,y.r=i+f*(g+1)):(y.startAngle=o+f*g,y.endAngle=o+f*(g+1),y.r0=i+p*d,y.r=i+p*(d+1)),y.clockwise=t.clockwise,y.cx=t.cx,y.cy=t.cy,n.push(y)}}function PY(t,e,n,i){return t*i-n*e}function OY(t,e,n,i,r,o,a,s){var l=n-t,u=i-e,h=a-r,c=s-o,p=PY(h,c,l,u);if(Math.abs(p)<1e-6)return null;var d=PY(t-r,e-o,h,c)/p;return d<0||d>1?null:new ve(d*l+t,d*u+e)}function RY(t,e,n){var i=new ve;ve.sub(i,n,e),i.normalize();var r=new ve;return ve.sub(r,t,e),r.dot(i)}function NY(t,e){var n=t[t.length-1];n&&n[0]===e[0]&&n[1]===e[1]||t.push(e)}function EY(t){var e=t.points,n=[],i=[];Sa(e,n,i);var r=new Ce(n[0],n[1],i[0]-n[0],i[1]-n[1]),o=r.width,a=r.height,s=r.x,l=r.y,u=new ve,h=new ve;return o>a?(u.x=h.x=s+o/2,u.y=l,h.y=l+a):(u.y=h.y=l+a/2,u.x=s,h.x=s+o),function(t,e,n){for(var i=t.length,r=[],o=0;o<i;o++){var a=t[o],s=t[(o+1)%i],l=OY(a[0],a[1],s[0],s[1],e.x,e.y,n.x,n.y);l&&r.push({projPt:RY(l,e,n),pt:l,idx:o})}if(r.length<2)return[{points:t},{points:t}];r.sort((function(t,e){return t.projPt-e.projPt}));var u=r[0],h=r[r.length-1];if(h.idx<u.idx){var c=u;u=h,h=c}var p=[u.pt.x,u.pt.y],d=[h.pt.x,h.pt.y],f=[p],g=[d];for(o=u.idx+1;o<=h.idx;o++)NY(f,t[o].slice());for(NY(f,d),NY(f,p),o=h.idx+1;o<=u.idx+i;o++)NY(g,t[o%i].slice());return NY(g,p),NY(g,d),[{points:f},{points:g}]}(e,u,h)}function zY(t,e,n,i){if(1===n)i.push(e);else{var r=Math.floor(n/2),o=t(e);zY(t,o[0],r,i),zY(t,o[1],n-r,i)}return i}function VY(t,e){e.setStyle(t.style),e.z=t.z,e.z2=t.z2,e.zlevel=t.zlevel}function BY(t,e){var n,i=[],r=t.shape;switch(t.type){case"rect":!function(t,e,n){for(var i=t.width,r=t.height,o=i>r,a=kY([i,r],o?0:1,e),s=o?"width":"height",l=o?"height":"width",u=o?"x":"y",h=o?"y":"x",c=t[s]/a.length,p=0;p<a.length;p++)for(var d=t[l]/a[p],f=0;f<a[p];f++){var g={};g[u]=p*c,g[h]=f*d,g[s]=c,g[l]=d,g.x+=t.x,g.y+=t.y,n.push(g)}}(r,e,i),n=Ls;break;case"sector":LY(r,e,i),n=Nu;break;case"circle":LY({r0:0,r:r.r,startAngle:0,endAngle:2*Math.PI,cx:r.cx,cy:r.cy},e,i),n=Nu;break;default:var o=t.getComputedTransform(),a=o?Math.sqrt(Math.max(o[0]*o[0]+o[1]*o[1],o[2]*o[2]+o[3]*o[3])):1,s=N(function(t,e){var n=DY(t),i=[];e=e||1;for(var r=0;r<n.length;r++){var o=n[r],a=[],s=o[0],l=o[1];a.push(s,l);for(var u=2;u<o.length;){var h=o[u++],c=o[u++],p=o[u++],d=o[u++],f=o[u++],g=o[u++];AY(s,l,h,c,p,d,f,g,a,e),s=f,l=g}i.push(a)}return i}(t.getUpdatedPathProxy(),a),(function(t){return function(t){for(var e=[],n=0;n<t.length;)e.push([t[n++],t[n++]]);return e}(t)})),l=s.length;if(0===l)zY(EY,{points:s[0]},e,i);else if(l===e)for(var u=0;u<l;u++)i.push({points:s[u]});else{var h=0,c=N(s,(function(t){var e=[],n=[];Sa(t,e,n);var i=(n[1]-e[1])*(n[0]-e[0]);return h+=i,{poly:t,area:i}}));c.sort((function(t,e){return e.area-t.area}));var p=e;for(u=0;u<l;u++){var d=c[u];if(p<=0)break;var f=u===l-1?p:Math.ceil(d.area/h*e);f<0||(zY(EY,{points:d.poly},f,i),p-=f)}}n=Wu}if(!n)return function(t,e){for(var n=[],i=0;i<e;i++)n.push(du(t));return n}(t,e);var g=[];for(u=0;u<i.length;u++){var y=new n;y.setShape(i[u]),VY(t,y),g.push(y)}return g}function FY(t,e){var n=t.length,i=e.length;if(n===i)return[t,e];for(var r=[],o=[],a=n<i?t:e,s=Math.min(n,i),l=Math.abs(i-n)/6,u=(s-2)/6,h=Math.ceil(l/u)+1,c=[a[0],a[1]],p=l,d=2;d<s;){var f=a[d-2],g=a[d-1],y=a[d++],v=a[d++],m=a[d++],x=a[d++],_=a[d++],b=a[d++];if(p<=0)c.push(y,v,m,x,_,b);else{for(var w=Math.min(p,h-1)+1,S=1;S<=w;S++){var M=S/w;gn(f,y,m,_,M,r),gn(g,v,x,b,M,o),f=r[3],g=o[3],c.push(r[1],o[1],r[2],o[2],f,g),y=r[5],v=o[5],m=r[6],x=o[6]}p-=w-1}}return a===t?[c,e]:[t,c]}function GY(t,e){for(var n=t.length,i=t[n-2],r=t[n-1],o=[],a=0;a<e.length;)o[a++]=i,o[a++]=r;return o}function WY(t){for(var e=0,n=0,i=0,r=t.length,o=0,a=r-2;o<r;a=o,o+=2){var s=t[a],l=t[a+1],u=t[o],h=t[o+1],c=s*h-u*l;e+=c,n+=(s+u)*c,i+=(l+h)*c}return 0===e?[t[0]||0,t[1]||0]:[n/e/3,i/e/3,e]}function HY(t,e,n,i){for(var r=(t.length-2)/6,o=1/0,a=0,s=t.length,l=s-2,u=0;u<r;u++){for(var h=6*u,c=0,p=0;p<s;p+=2){var d=0===p?h:(h+p-2)%l+2,f=t[d]-n[0],g=t[d+1]-n[1],y=e[p]-i[0]-f,v=e[p+1]-i[1]-g;c+=y*y+v*v}c<o&&(o=c,a=u)}return a}function YY(t){for(var e=[],n=t.length,i=0;i<n;i+=2)e[i]=t[n-i-2],e[i+1]=t[n-i-1];return e}function XY(t){return t.__isCombineMorphing}var UY="__mOriginal_";function ZY(t,e,n){var i=UY+e,r=t[i]||t[e];t[i]||(t[i]=t[e]);var o=n.replace,a=n.after,s=n.before;t[e]=function(){var t,e=arguments;return s&&s.apply(this,e),t=o?o.apply(this,e):r.apply(this,e),a&&a.apply(this,e),t}}function jY(t,e){var n=UY+e;t[n]&&(t[e]=t[n],t[n]=null)}function qY(t,e){for(var n=0;n<t.length;n++)for(var i=t[n],r=0;r<i.length;){var o=i[r],a=i[r+1];i[r++]=e[0]*o+e[2]*a+e[4],i[r++]=e[1]*o+e[3]*a+e[5]}}function KY(t,e){var n=t.getUpdatedPathProxy(),i=e.getUpdatedPathProxy(),r=function(t,e){for(var n,i,r,o=[],a=[],s=0;s<Math.max(t.length,e.length);s++){var l=t[s],u=e[s],h=void 0,c=void 0;l?u?(i=h=(n=FY(l,u))[0],r=c=n[1]):(c=GY(r||l,l),h=l):(h=GY(i||u,u),c=u),o.push(h),a.push(c)}return[o,a]}(DY(n),DY(i)),o=r[0],a=r[1],s=t.getComputedTransform(),l=e.getComputedTransform();s&&qY(o,s),l&&qY(a,l),ZY(e,"updateTransform",{replace:function(){this.transform=null}}),e.transform=null;var u=function(t,e,n,i){for(var r,o=[],a=0;a<t.length;a++){var s=t[a],l=e[a],u=WY(s),h=WY(l);null==r&&(r=u[2]<0!=h[2]<0);var c=[],p=[],d=0,f=1/0,g=[],y=s.length;r&&(s=YY(s));for(var v=6*HY(s,l,u,h),m=y-2,x=0;x<m;x+=2){var _=(v+x)%m+2;c[x+2]=s[_]-u[0],c[x+3]=s[_+1]-u[1]}if(c[0]=s[v]-u[0],c[1]=s[v+1]-u[1],n>0)for(var b=i/n,w=-i/2;w<=i/2;w+=b){var S=Math.sin(w),M=Math.cos(w),I=0;for(x=0;x<s.length;x+=2){var T=c[x],C=c[x+1],D=l[x]-h[0],A=l[x+1]-h[1],k=D*M-A*S,L=D*S+A*M;g[x]=k,g[x+1]=L;var P=k-T,O=L-C;I+=P*P+O*O}if(I<f){f=I,d=w;for(var R=0;R<g.length;R++)p[R]=g[R]}}else for(var N=0;N<y;N+=2)p[N]=l[N]-h[0],p[N+1]=l[N+1]-h[1];o.push({from:c,to:p,fromCp:u,toCp:h,rotation:-d})}return o}(o,a,10,Math.PI),h=[];ZY(e,"buildPath",{replace:function(t){for(var n=e.__morphT,i=1-n,r=[],o=0;o<u.length;o++){var a=u[o],s=a.from,l=a.to,c=a.rotation*n,p=a.fromCp,d=a.toCp,f=Math.sin(c),g=Math.cos(c);Lt(r,p,d,n);for(var y=0;y<s.length;y+=2){var v=s[y],m=s[y+1],x=v*i+(S=l[y])*n,_=m*i+(M=l[y+1])*n;h[y]=x*g-_*f+r[0],h[y+1]=x*f+_*g+r[1]}var b=h[0],w=h[1];for(t.moveTo(b,w),y=2;y<s.length;){var S=h[y++],M=h[y++],I=h[y++],T=h[y++],C=h[y++],D=h[y++];b===S&&w===M&&I===C&&T===D?t.lineTo(C,D):t.bezierCurveTo(S,M,I,T,C,D),b=C,w=D}}}})}function $Y(t,e,n){if(!t||!e)return e;var i=n.done,r=n.during;return KY(t,e),e.__morphT=0,e.animateTo({__morphT:1},k({during:function(t){e.dirtyShape(),r&&r(t)},done:function(){jY(e,"buildPath"),jY(e,"updateTransform"),e.__morphT=-1,e.createPathProxy(),e.dirtyShape(),i&&i()}},n)),e}function JY(t,e,n,i,r,o){t=r===n?0:Math.round(32767*(t-n)/(r-n)),e=o===i?0:Math.round(32767*(e-i)/(o-i));for(var a,s=0,l=32768;l>0;l/=2){var u=0,h=0;(t&l)>0&&(u=1),(e&l)>0&&(h=1),s+=l*l*(3*u^h),0===h&&(1===u&&(t=l-1-t,e=l-1-e),a=t,t=e,e=a)}return s}function QY(t){var e=1/0,n=1/0,i=-1/0,r=-1/0,o=N(t,(function(t){var o=t.getBoundingRect(),a=t.getComputedTransform(),s=o.x+o.width/2+(a?a[4]:0),l=o.y+o.height/2+(a?a[5]:0);return e=Math.min(s,e),n=Math.min(l,n),i=Math.max(s,i),r=Math.max(l,r),[s,l]}));return N(o,(function(o,a){return{cp:o,z:JY(o[0],o[1],e,n,i,r),path:t[a]}})).sort((function(t,e){return t.z-e.z})).map((function(t){return t.path}))}function tX(t){return BY(t.path,t.count)}function eX(t){return G(t[0])}function nX(t,e){for(var n=[],i=t.length,r=0;r<i;r++)n.push({one:t[r],many:[]});for(r=0;r<e.length;r++){var o=e[r].length,a=void 0;for(a=0;a<o;a++)n[a%i].many.push(e[r][a])}var s=0;// If one has more paths than each one of many. average them.
for(r=i-1;r>=0;r--)if(!n[r].many.length){var l=n[s].many;if(l.length<=1){// Not enough
// Start from the first one.
if(!s)return n;s=0}o=l.length;var u=Math.ceil(o/2);n[r].many=l.slice(u,o),n[s].many=l.slice(0,u),s++}return n}var iX={clone:function(t){for(var e=[],n=1-Math.pow(1-t.path.style.opacity,1/t.count),i=0// Fitting the alpha
;i<t.count;i++){var r=du(t.path);r.setStyle("opacity",n),e.push(r)}return e},// Use the default divider
split:null};function rX(t,e,n,i,r,o){if(t.length&&e.length){var a=bh("update",i,r);if(a&&a.duration>0){var s,l,u=i.getModel("universalTransition").get("delay"),h=Object.assign({// Need to setToFinal so the further calculation based on the style can be correct.
// Like emphasis color.
setToFinal:!0},a);eX(t)&&(// manyToOne
s=t,l=e),eX(e)&&(// oneToMany
s=e,l=t);for(var c=s?s===t:t.length>e.length,p=s?nX(l,s):nX(c?e:t,[c?t:e]),d=0,f=0;f<p.length;f++)d+=p[f].many.length;var g=0;for(f=0;f<p.length;f++)y(p[f],c,g,d),g+=p[f].many.length}}function y(t,e,i,r,a){var s=t.many,l=t.one;if(1!==s.length||a)for(var c=k({dividePath:iX[n],individualDelay:u&&function(t,e,n,o){return u(t+i,r)}},h),p=e?function(t,e,n){var i=[];!function t(e){for(var n=0;n<e.length;n++){var r=e[n];XY(r)?t(r.childrenRef()):r instanceof ys&&i.push(r)}}(t);var r=i.length;if(!r)return{fromIndividuals:[],toIndividuals:[],count:0};var o=(n.dividePath||tX)({path:e,count:r});if(o.length!==r)return{fromIndividuals:[],toIndividuals:[],count:0};i=QY(i),o=QY(o);for(var a=n.done,s=n.during,l=n.individualDelay,u=new sr,h=0;h<r;h++){var c=i[h],p=o[h];p.parent=e,p.copyTransform(u),l||KY(c,p)}function d(t){for(var e=0;e<o.length;e++)o[e].addSelfToZr(t)}function f(){e.__isCombineMorphing=!1,e.__morphT=-1,e.childrenRef=null,jY(e,"addSelfToZr"),jY(e,"removeSelfFromZr")}e.__isCombineMorphing=!0,e.childrenRef=function(){return o},ZY(e,"addSelfToZr",{after:function(t){d(t)}}),ZY(e,"removeSelfFromZr",{after:function(t){for(var e=0;e<o.length;e++)o[e].removeSelfFromZr(t)}});var g=o.length;if(l){var y=g,v=function(){0==--y&&(f(),a&&a())};for(h=0;h<g;h++){var m=l?k({delay:(n.delay||0)+l(h,g,i[h],o[h]),done:v},n):n;$Y(i[h],o[h],m)}}else e.__morphT=0,e.animateTo({__morphT:1},k({during:function(t){for(var n=0;n<g;n++){var i=o[n];i.__morphT=e.__morphT,i.dirtyShape()}s&&s(t)},done:function(){f();for(var e=0;e<t.length;e++)jY(t[e],"updateTransform");a&&a()}},n));return e.__zr&&d(e.__zr),{fromIndividuals:i,toIndividuals:o,count:g}}(s,l,c):function(t,e,n){var i=e.length,r=[],o=n.dividePath||tX;if(XY(t)){!function t(e){for(var n=0;n<e.length;n++){var i=e[n];XY(i)?t(i.childrenRef()):i instanceof ys&&r.push(i)}}(t.childrenRef());var a=r.length;if(a<i)for(var s=0,l=a;l<i;l++)r.push(du(r[s++%a]));r.length=i}else{r=o({path:t,count:i});var u=t.getComputedTransform();for(l=0;l<r.length;l++)r[l].setLocalTransform(u);if(r.length!==i)return{fromIndividuals:[],toIndividuals:[],count:0}}r=QY(r),e=QY(e);var h=n.individualDelay;for(l=0;l<i;l++){var c=h?k({delay:(n.delay||0)+h(l,i,r[l],e[l])},n):n;$Y(r[l],e[l],c)}return{fromIndividuals:r,toIndividuals:e,count:e.length}}(l,s,c),d=p.fromIndividuals,f=p.toIndividuals,g=d.length,v=0;v<g;v++)m=u?k({delay:u(v,g)},h):h,o(d[v],f[v],e?s[v]:t.one,e?t.one:s[v],m);else{// Is one to one
var m,x=e?s[0]:l,_=e?l:s[0];XY(x)?// Keep doing combine animation.
y({many:[x],one:_},!0,i,r,!0):($Y(x,_,m=u?k({delay:u(i,r)},h):h),o(x,_,x,_,m))}}}function oX(t){if(!t)return[];if(G(t)){for(var e=[],n=0;n<t.length;n++)e.push(oX(t[n]));return e}var i=[];return t.traverse((function(t){t instanceof ys&&!t.disableMorphing&&!t.invisible&&!t.ignore&&i.push(t)})),i}var aX=bo();function sX(t){var e=[];return R(t,(function(t){var n=t.data;if(!(n.count()>1e4))for(var i=n.getIndices(),r=function(t){for(var e=t.dimensions,n=0;n<e.length;n++){var i=t.getDimensionInfo(e[n]);if(i&&0===i.otherDims.itemGroupId)return e[n]}}(n),o=0;o<i.length;o++)e.push({dataGroupId:t.dataGroupId,data:n,dim:t.dim||r,divide:t.divide,dataIndex:o})})),e}function lX(t,e,n){t.traverse((function(t){t instanceof ys&&// TODO use fade in animation for target element.
Mh(t,{style:{opacity:0}},e,{dataIndex:n,isFrom:!0})}))}function uX(t){if(t.parent){// Bake parent transform to element.
// So it can still have proper transform to transition after it's removed.
var e=t.getComputedTransform();t.setLocalTransform(e),t.parent.remove(t)}}function hX(t){t.stopAnimation(),t.isGroup&&t.traverse((function(t){t.stopAnimation()}))}function cX(t,e,n){var i=bh("update",n,e);i&&t.traverse((function(t){if(t instanceof fa){var e=function(t){return _h(t).oldStyle}(t);e&&t.animateFrom({style:e},i)}}))}function pX(t,e,n){var i=sX(t),r=sX(e);function o(t,e,n,i,r){(n||t)&&e.animateFrom({style:n&&n!==t?// dividingMethod like clone may override the style(opacity)
// So extend it to raw style.
A(A({},n.style),t.style):t.style},r)}function a(t){for(var e=0;e<t.length;e++)if(t[e].dim)return t[e].dim}var s=a(i),l=a(r),u=!1;function h(t,e){return function(n){var i=n.data,r=n.dataIndex;// TODO if specified dim
if(e)return i.getId(r);// Use group id as transition key by default.
// So we can achieve multiple to multiple animation like drilldown / up naturally.
// If group id not exits. Use id instead. If so, only one to one transition will be applied.
var o=n.dataGroupId,a=t?s||l:l||s,u=a&&i.getDimensionInfo(a),h=u&&u.ordinalMeta;// If specified key dimension(itemGroupId by default). Use this same dimension from other data.
// PENDING: If only use key dimension of newData.
if(u){// Get from encode.itemGroupId.
var c=i.get(u.name,r);return h&&h.categories[c]||c+""}// Get groupId from raw item. { groupId: '' }
var p=i.getRawDataItem(r);return p&&p.groupId?p.groupId+"":o||i.getId(r)}}// Use id if it's very likely to be an one to one animation
// It's more robust than groupId
// TODO Check if key dimension is specified.
var c=function(t,e){var n=t.length;if(n!==e.length)return!1;for(var i=0;i<n;i++){var r=t[i],o=e[i];if(r.data.getId(r.dataIndex)!==o.data.getId(o.dataIndex))return!1}return!0}(i,r),p={};if(!c)// We may have different diff strategy with basicTransition if we use other dimension as key.
// If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.
// We can't use the elements that already being morphed. Let it keep it's original basic transition.
for(var d=0;d<r.length;d++){var f=r[d],g=f.data.getItemGraphicEl(f.dataIndex);g&&(p[g.id]=!0)}function y(t,e){var n=i[e],a=r[t],s=a.data.hostModel,l=n.data.getItemGraphicEl(n.dataIndex),h=a.data.getItemGraphicEl(a.dataIndex);// Can't handle same elements.
l!==h?// We can't use the elements that already being morphed
l&&p[l.id]||h&&(// TODO: If keep animating the group in case
// some of the elements don't want to be morphed.
// TODO Label?
hX(h),l?(hX(l),// If old element is doing leaving animation. stop it and remove it immediately.
uX(l),u=!0,rX(oX(l),oX(h),a.divide,s,t,o)):lX(h,s,t)):h&&cX(h,a.dataIndex,s)}new Um(i,r,h(!0,c),h(!1,c),null,"multiple").update(y).updateManyToOne((function(t,e){var n=r[t],a=n.data,s=a.hostModel,l=a.getItemGraphicEl(n.dataIndex),h=z(N(e,(function(t){return i[t].data.getItemGraphicEl(i[t].dataIndex)})),(function(t){return t&&t!==l&&!p[t.id]}));l&&(hX(l),h.length?(// If old element is doing leaving animation. stop it and remove it immediately.
R(h,(function(t){hX(t),uX(t)})),u=!0,rX(oX(h),oX(l),n.divide,s,t,o)):lX(l,s,n.dataIndex));// else keep oldEl leaving animation.
})).updateOneToMany((function(t,e){var n=i[e],a=n.data.getItemGraphicEl(n.dataIndex);// We can't use the elements that already being morphed
if(!a||!p[a.id]){var s=z(N(t,(function(t){return r[t].data.getItemGraphicEl(r[t].dataIndex)})),(function(t){return t&&t!==a})),l=r[t[0]].data.hostModel;s.length&&(R(s,(function(t){return hX(t)})),a?(hX(a),// If old element is doing leaving animation. stop it and remove it immediately.
uX(a),u=!0,rX(oX(a),oX(s),n.divide,// Use divide on old.
l,t[0],o)):R(s,(function(e){return lX(e,l,t[0])})));// else keep oldEl leaving animation.
}})).updateManyToMany((function(t,e){// If two data are same and both have groupId.
// Normally they should be diff by id.
new Um(e,t,(function(t){return i[t].data.getId(i[t].dataIndex)}),(function(t){return r[t].data.getId(r[t].dataIndex)})).update((function(n,i){// Use the original index
y(t[n],e[i])})).execute()})).execute(),u&&R(e,(function(t){var e=t.data.hostModel,i=e&&n.getViewOfSeriesModel(e),r=bh("update",e,0);// use 0 index.
i&&e.isAnimationEnabled()&&r&&r.duration>0&&i.group.traverse((function(t){t instanceof ys&&!t.animators.length&&// We can't accept there still exists element that has no animation
// if universalTransition is enabled
t.animateFrom({style:{opacity:0}},r)}))}))}function dX(t){var e=t.getModel("universalTransition").get("seriesKey");return e||t.id}function fX(t){return G(t)?t.sort().join(","):t}function gX(t){if(t.hostModel)return t.hostModel.getModel("universalTransition").get("divideShape")}function yX(t,e){for(var n=0;n<t.length;n++)if(null!=e.seriesIndex&&e.seriesIndex===t[n].seriesIndex||null!=e.seriesId&&e.seriesId===t[n].id)return n}// Render engines
// -----------------
// Render via Canvas.
// echarts.init(dom, null, { renderer: 'canvas' })
Wm([function(t){t.registerPainter("canvas",fS)}]),// Render via SVG.
// echarts.init(dom, null, { renderer: 'svg' })
Wm([function(t){t.registerPainter("svg",aS)}]),// ----------------
// Charts (series)
// ----------------
// All of the series types, for example:
// chart.setOption({
//     series: [{
//         type: 'line' // or 'bar', 'pie', ...
//     }]
// });
Wm([function(t){t.registerChartView(JS),t.registerSeriesModel(yS),t.registerLayout(QS("line",!0)),t.registerVisual({seriesType:"line",reset:function(t){var e=t.getData(),n=t.getModel("lineStyle").getLineStyle();// Visual coding for legend
n&&!n.stroke&&(// Fill in visual should be palette color if
// has color callback
n.stroke=e.getVisual("style").fill),e.setVisual("legendLineStyle",n)}}),// Down sample after filter
t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC,nM("line"))},function(t){t.registerChartView(kM),t.registerSeriesModel(aM),t.registerLayout(t.PRIORITY.VISUAL.LAYOUT,F(n_,"bar")),// Do layout after other overall layout, which can prepare some information.
t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT,i_("bar")),// Down sample after filter
t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC,nM("bar")),
/**
               * @payload
               * @property {string} [componentType=series]
               * @property {number} [dx]
               * @property {number} [dy]
               * @property {number} [zoom]
               * @property {number} [originX]
               * @property {number} [originY]
               */
t.registerAction({type:"changeAxisOrder",event:"changeAxisOrder",update:"update"},(function(t,e){var n=t.componentType||"series";e.eachComponent({mainType:n,query:t},(function(e){t.sortInfo&&e.axis.setCategorySortInfo(t.sortInfo)}))}))},function(t){t.registerChartView(XM),t.registerSeriesModel($M),Yy("pie",t.registerAction),t.registerLayout(F(NM,"pie")),t.registerProcessor(EM("pie")),t.registerProcessor(function(t){return{seriesType:t,reset:function(t,e){var n=t.getData();n.filterSelf((function(t){// handle negative value condition
var e=n.mapDimension("value"),i=n.get(e,t);return!(X(i)&&!isNaN(i)&&i<0)}))}}}("pie"))},function(t){// In case developer forget to include grid component
Wm(aT),t.registerSeriesModel(QM),t.registerChartView(oI),t.registerLayout(QS("scatter"))},function(t){Wm(TT),t.registerChartView(pT),t.registerSeriesModel(fT),t.registerLayout(sT),t.registerProcessor(EM("radar")),t.registerPreprocessor(hT)},function(t){Wm(uD),t.registerChartView(BC),t.registerSeriesModel(GC),t.registerLayout(HC),t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC,WC),Yy("map",t.registerAction)},function(t){t.registerChartView(DD),t.registerSeriesModel(UD),t.registerLayout(jD),t.registerVisual(qD),function(t){t.registerAction({type:"treeExpandAndCollapse",event:"treeExpandAndCollapse",update:"update"},(function(t,e){e.eachComponent({mainType:"series",subType:"tree",query:t},(function(e){var n=t.dataIndex,i=e.getData().tree.getNodeByDataIndex(n);i.isExpand=!i.isExpand}))})),t.registerAction({type:"treeRoam",event:"treeRoam",// Here we set 'none' instead of 'update', because roam action
// just need to update the transform matrix without having to recalculate
// the layout. So don't need to go through the whole update process, such
// as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
update:"none"},(function(t,e,n){e.eachComponent({mainType:"series",subType:"tree",query:t},(function(e){var i=oD(e.coordinateSystem,t,void 0,n);e.setCenter&&e.setCenter(i.center),e.setZoom&&e.setZoom(i.zoom)}))}))}(t)},function(t){t.registerSeriesModel(tA),t.registerChartView(fA),t.registerVisual(PA),t.registerLayout(XA),function(t){for(var e=0;e<KD.length;e++)t.registerAction({type:KD[e],update:"updateView"},yt);t.registerAction({type:"treemapRootToNode",update:"updateView"},(function(t,e){e.eachComponent({mainType:"series",subType:"treemap",query:t},(function(e,n){var i=GD(t,["treemapZoomToNode","treemapRootToNode"],e);if(i){var r=e.getViewRoot();r&&(t.direction=HD(r,i.node)?"rollUp":"drillDown"),e.resetViewRoot(i.node)}}))}))}(t)},function(t){t.registerChartView(Zk),t.registerSeriesModel(nL),t.registerProcessor($A),t.registerVisual(JA),t.registerVisual(tk),t.registerLayout(hk),t.registerLayout(t.PRIORITY.VISUAL.POST_CHART_LAYOUT,mk),t.registerLayout(_k),t.registerCoordinateSystem("graphView",{dimensions:ZC.dimensions,create:bk}),// Register legacy focus actions
t.registerAction({type:"focusNodeAdjacency",event:"focusNodeAdjacency",update:"series:focusNodeAdjacency"},yt),t.registerAction({type:"unfocusNodeAdjacency",event:"unfocusNodeAdjacency",update:"series:unfocusNodeAdjacency"},yt),// Register roam action.
t.registerAction(iL,(function(t,e,n){e.eachComponent({mainType:"series",query:t},(function(e){var i=oD(e.coordinateSystem,t,void 0,n);e.setCenter&&e.setCenter(i.center),e.setZoom&&e.setZoom(i.zoom)}))}))},function(t){t.registerChartView(uL),t.registerSeriesModel(cL)},function(t){t.registerChartView(gL),t.registerSeriesModel(vL),t.registerLayout(mL),t.registerProcessor(EM("funnel"))},function(t){Wm(QP),t.registerChartView(ML),t.registerSeriesModel(CL),t.registerVisual(t.PRIORITY.VISUAL.BRUSH,AL)},function(t){t.registerChartView(iO),t.registerSeriesModel(oO),t.registerLayout(aO),t.registerVisual(mO),t.registerAction({type:"dragNode",event:"dragnode",// here can only use 'update' now, other value is not support in echarts.
update:"update"},(function(t,e){e.eachComponent({mainType:"series",subType:"sankey",query:t},(function(e){e.setNodePosition(t.dataIndex,[t.localX,t.localY])}))}))},function(t){t.registerSeriesModel(bO),t.registerChartView(DO),t.registerLayout(kO),t.registerTransform(LO)},function(t){t.registerChartView(YO),t.registerSeriesModel(UO),t.registerPreprocessor(ZO),t.registerVisual(QO),t.registerLayout(nR)},function(t){t.registerChartView(sR),t.registerSeriesModel(uR),t.registerLayout(QS("effectScatter"))},function(t){t.registerChartView(wR),t.registerSeriesModel(CR),t.registerLayout(_R),t.registerVisual(AR)},function(t){t.registerChartView(RR),t.registerSeriesModel(ER)},function(t){t.registerChartView(rN),t.registerSeriesModel(aN),t.registerLayout(t.PRIORITY.VISUAL.LAYOUT,F(n_,"pictorialBar")),// Do layout after other overall layout, which can prepare some information.
t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT,i_("pictorialBar"))},function(t){t.registerChartView(lN),t.registerSeriesModel(hN),t.registerLayout(cN),t.registerProcessor(EM("themeRiver"))},function(t){t.registerChartView(mN),t.registerSeriesModel(bN),t.registerLayout(F(SN,"sunburst")),t.registerProcessor(F(EM,"sunburst")),t.registerVisual(IN),function(t){t.registerAction({type:gN,update:"updateView"},(function(t,e){e.eachComponent({mainType:"series",subType:"sunburst",query:t},(function(e,n){var i=GD(t,[gN],e);if(i){var r=e.getViewRoot();r&&(t.direction=HD(r,i.node)?"rollUp":"drillDown"),e.resetViewRoot(i.node)}}))})),t.registerAction({type:yN,update:"none"},(function(t,e,n){// Clone
t=A({},t),e.eachComponent({mainType:"series",subType:"sunburst",query:t},(function(e){var n=GD(t,[yN],e);n&&(t.dataIndex=n.node.dataIndex)})),n.dispatchAction(A(t,{type:"highlight"}))})),t.registerAction({type:"sunburstUnhighlight",update:"updateView"},(function(t,e,n){t=A({},t),n.dispatchAction(A(t,{type:"downplay"}))}))}(t)},function(t){t.registerChartView(mE),t.registerSeriesModel(kN)}]),// -------------------
// Coordinate systems
// -------------------
// All of the axis modules have been included in the
// coordinate system module below, do not need to
// make extra import.
// `cartesian` coordinate system. For some historical
// reasons, it is named as grid, for example:
// chart.setOption({
//     grid: {...},
//     xAxis: {...},
//     yAxis: {...},
//     series: [{...}]
// });
Wm((function(t){Wm(aT),Wm(Sz)})),// `polar` coordinate system, for example:
// chart.setOption({
//     polar: {...},
//     radiusAxis: {...},
//     angleAxis: {...},
//     series: [{
//         coordinateSystem: 'polar'
//     }]
// });
Wm((function(t){Wm(Sz),jI.registerAxisPointerClass("PolarAxisPointer",Tz),t.registerCoordinateSystem("polar",Yz),t.registerComponentModel(Dz),t.registerComponentView(lV),// Model and view for angleAxis and radiusAxis
fI(t,"angle",kz,aV),fI(t,"radius",Lz,sV),t.registerComponentView($z),t.registerComponentView(nV),t.registerLayout(F(oV,"bar"))})),// `geo` coordinate system, for example:
// chart.setOption({
//     geo: {...},
//     series: [{
//         coordinateSystem: 'geo'
//     }]
// });
Wm(uD),// `singleAxis` coordinate system (notice, it is a coordinate system
// with only one axis, work for chart like theme river), for example:
// chart.setOption({
//     singleAxis: {...}
//     series: [{type: 'themeRiver', ...}]
// });
Wm((function(t){Wm(Sz),jI.registerAxisPointerClass("SingleAxisPointer",AV),t.registerComponentView(kV),// Axis
t.registerComponentView(fV),t.registerComponentModel(yV),fI(t,"single",yV,yV.defaultOption),t.registerCoordinateSystem("single",wV)})),// `parallel` coordinate system, only work for parallel series, for example:
// chart.setOption({
//     parallel: {...},
//     parallelAxis: [{...}, ...],
//     series: [{
//         type: 'parallel'
//     }]
// });
Wm(QP),// `calendar` coordinate system. for example,
// chart.setOptionp({
//     calendar: {...},
//     series: [{
//         coordinateSystem: 'calendar'
//     }]
// );
Wm((function(t){t.registerComponentModel(OV),t.registerComponentView(NV),t.registerCoordinateSystem("calendar",BV)})),// ------------------
// Other components
// ------------------
// `graphic` component, for example:
// chart.setOption({
//     graphic: {...}
// });
Wm((function(t){t.registerComponentModel(YV),t.registerComponentView(ZV),t.registerPreprocessor((function(t){var e=t.graphic;// Convert
// {graphic: [{left: 10, type: 'circle'}, ...]}
// or
// {graphic: {left: 10, type: 'circle'}}
// to
// {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}
G(e)?e[0]&&e[0].elements?// Only one graphic instance can be instantiated. (We don't
// want that too many views are created in echarts._viewMap.)
t.graphic=[t.graphic[0]]:t.graphic=[{elements:e}]:e&&!e.elements&&(t.graphic=[{elements:[e]}])}))})),// `toolbox` component, for example:
// chart.setOption({
//     toolbox: {...}
// });
Wm((function(t){t.registerComponentModel(TB),t.registerComponentView(AB),SB("saveAsImage",LB),SB("magicType",EB),SB("dataView",YB),SB("dataZoom",yF),SB("restore",qB),Wm(_B)})),// `tooltip` component, for example:
// chart.setOption({
//     tooltip: {...}
// });
Wm((function(t){Wm(Sz),t.registerComponentModel(mF),t.registerComponentView(FF),
/**
               * @action
               * @property {string} type
               * @property {number} seriesIndex
               * @property {number} dataIndex
               * @property {number} [x]
               * @property {number} [y]
               */
t.registerAction({type:"showTip",event:"showTip",update:"tooltip:manuallyShowTip"},yt),t.registerAction({type:"hideTip",event:"hideTip",update:"tooltip:manuallyHideTip"},yt)})),// `axisPointer` component, for example:
// chart.setOption({
//     tooltip: {axisPointer: {...}, ...}
// });
// Or
// chart.setOption({
//     axisPointer: {...}
// });
Wm(Sz),// `brush` component, for example:
// chart.setOption({
//     brush: {...}
// });
// Or
// chart.setOption({
//     tooltip: {feature: {brush: {...}}
// })
Wm((function(t){t.registerComponentView(aG),t.registerComponentModel(uG),t.registerPreprocessor(WF),t.registerVisual(t.PRIORITY.VISUAL.BRUSH,tG),t.registerAction({type:"brush",event:"brush",update:"updateVisual"},(function(t,e){e.eachComponent({mainType:"brush",query:t},(function(e){e.setAreas(t.areas)}))})),
/**
               * payload: {
               *      brushComponents: [
               *          {
               *              brushId,
               *              brushIndex,
               *              brushName,
               *              series: [
               *                  {
               *                      seriesId,
               *                      seriesIndex,
               *                      seriesName,
               *                      rawIndices: [21, 34, ...]
               *                  },
               *                  ...
               *              ]
               *          },
               *          ...
               *      ]
               * }
               */
t.registerAction({type:"brushSelect",event:"brushSelected",update:"none"},yt),t.registerAction({type:"brushEnd",event:"brushEnd",update:"none"},yt),SB("brush",pG)})),// `title` component, for example:
// chart.setOption({
//     title: {...}
// });
Wm((function(t){t.registerComponentModel(dG),t.registerComponentView(fG)})),// `timeline` component, for example:
// chart.setOption({
//     timeline: {...}
// });
Wm((function(t){t.registerComponentModel(mG),t.registerComponentView(DG),t.registerSubTypeDefaulter("timeline",(function(){// Only slider now.
return"slider"})),function(t){t.registerAction({type:"timelineChange",event:"timelineChanged",update:"prepareAndUpdate"},(function(t,e,n){var i=e.getComponent("timeline");return i&&null!=t.currentIndex&&(i.setCurrentIndex(t.currentIndex),!i.get("loop",!0)&&i.isIndexMax()&&i.getPlayState()&&(i.setPlayState(!1),// The timeline has played to the end, trigger event
n.dispatchAction({type:"timelinePlayChange",playState:!1,from:t.from}))),// Set normalized currentIndex to payload.
e.resetOption("timeline",{replaceMerge:i.get("replaceMerge",!0)}),k({currentIndex:i.option.currentIndex},t)})),t.registerAction({type:"timelinePlayChange",event:"timelinePlayChanged",update:"update"},(function(t,e){var n=e.getComponent("timeline");n&&null!=t.playState&&n.setPlayState(t.playState)}))}(t),t.registerPreprocessor(AG)})),// `markPoint` component, for example:
// chart.setOption({
//     series: [{markPoint: {...}}]
// });
Wm((function(t){t.registerComponentModel(VG),t.registerComponentView(JG),t.registerPreprocessor((function(t){PG(t.series,"markPoint")&&(// Make sure markPoint component is enabled
t.markPoint=t.markPoint||{})}))})),// `markLine` component, for example:
// chart.setOption({
//     series: [{markLine: {...}}]
// });
Wm((function(t){t.registerComponentModel(tW),t.registerComponentView(lW),t.registerPreprocessor((function(t){PG(t.series,"markLine")&&(// Make sure markLine component is enabled
t.markLine=t.markLine||{})}))})),// `markArea` component, for example:
// chart.setOption({
//     series: [{markArea: {...}}]
// });
Wm((function(t){t.registerComponentModel(hW),t.registerComponentView(xW),t.registerPreprocessor((function(t){PG(t.series,"markArea")&&(// Make sure markArea component is enabled
t.markArea=t.markArea||{})}))})),// `legend` component not scrollable. for example:
// chart.setOption({
//     legend: {...}
// });
Wm((function(t){Wm(OW),Wm(WW)})),// `dataZoom` component including both `dataZoomInside` and `dataZoomSlider`.
Wm((function(t){Wm(nH),Wm(dH)})),// `dataZoom` component providing drag, pinch, wheel behaviors
// inside coodinate system, for example:
// chart.setOption({
//     dataZoom: {type: 'inside'}
// });
Wm(nH),// `dataZoom` component providing a slider bar, for example:
// chart.setOption({
//     dataZoom: {type: 'slider'}
// });
Wm(dH),// `visualMap` component including both `visualMapContinuous` and `visualMapPiecewise`.
Wm((function(t){Wm(JH),Wm(oY)})),// `visualMap` component providing continuous bar, for example:
// chart.setOption({
//     visualMap: {type: 'continuous'}
// });
Wm(JH),// `visualMap` component providing pieces bar, for example:
// chart.setOption({
//     visualMap: {type: 'piecewise'}
// });
Wm(oY),// `aria` component providing aria, for example:
// chart.setOption({
//     aria: {...}
// });
Wm((function(t){t.registerPreprocessor(hY),t.registerVisual(t.PRIORITY.VISUAL.ARIA,uY)})),// dataset transform
// chart.setOption({
//     dataset: {
//          transform: []
//     }
// });
Wm((function(t){t.registerTransform(wY),t.registerTransform(SY)})),Wm((function(t){t.registerComponentModel(MY),t.registerComponentView(IY)})),// universal transition
// chart.setOption({
//     series: {
//         universalTransition: { enabled: true }
//     }
// })
Wm((function(t){t.registerUpdateLifecycle("series:beforeupdate",(function(t,e,n){R(lo(n.seriesTransition),(function(t){R(lo(t.to),(function(t){for(var e=n.updatedSeries,i=0;i<e.length;i++)(null!=t.seriesIndex&&t.seriesIndex===e[i].seriesIndex||null!=t.seriesId&&t.seriesId===e[i].id)&&(e[i][Dg]=!0)}))}))})),t.registerUpdateLifecycle("series:transition",(function(t,e,n){// TODO api provide an namespace that can save stuff per instance
var i=aX(e);// TODO multiple to multiple series.
if(i.oldSeries&&n.updatedSeries&&n.optionChanged){// Use give transition config if its' give;
var r=n.seriesTransition;if(r)R(lo(r),(function(t){!function(t,e,n,i){var r=[],o=[];R(lo(t.from),(function(t){var n=yX(e.oldSeries,t);n>=0&&r.push({dataGroupId:e.oldDataGroupIds[n],data:e.oldData[n],// TODO can specify divideShape in transition.
divide:gX(e.oldData[n]),dim:t.dimension})})),R(lo(t.to),(function(t){var i=yX(n.updatedSeries,t);if(i>=0){var r=n.updatedSeries[i].getData();o.push({dataGroupId:e.oldDataGroupIds[i],data:r,divide:gX(r),dim:t.dimension})}})),r.length>0&&o.length>0&&pX(r,o,i)}(t,i,n,e)}));else{// Else guess from series based on transition series key.
var o=function(t,e){var n=ct(),i=ct(),r=ct();return R(t.oldSeries,(function(e,n){var o=t.oldDataGroupIds[n],a=t.oldData[n],s=dX(e),l=fX(s);i.set(l,{dataGroupId:o,data:a}),G(s)&&// Same key can't in different array seriesKey.
R(s,(function(t){r.set(t,{key:l,dataGroupId:o,data:a})}))})),R(e.updatedSeries,(function(t){if(t.isUniversalTransitionEnabled()&&t.isAnimationEnabled()){var e=t.get("dataGroupId"),o=t.getData(),a=dX(t),s=fX(a),l=i.get(s);// string transition key is the best match.
if(l)n.set(s,{oldSeries:[{dataGroupId:l.dataGroupId,divide:gX(l.data),data:l.data}],newSeries:[{dataGroupId:e,divide:gX(o),data:o}]});else// Transition from multiple series.
if(G(a)){var u=[];R(a,(function(t){var e=i.get(t);e.data&&u.push({dataGroupId:e.dataGroupId,divide:gX(e.data),data:e.data})})),u.length&&n.set(s,{oldSeries:u,newSeries:[{dataGroupId:e,data:o,divide:gX(o)}]})}else{// Try transition to multiple series.
var h=r.get(a);if(h){var c=n.get(h.key);c||(c={oldSeries:[{dataGroupId:h.dataGroupId,data:h.data,divide:gX(h.data)}],newSeries:[]},n.set(h.key,c)),c.newSeries.push({dataGroupId:e,data:o,divide:gX(o)})}}}})),n}(i,n);R(o.keys(),(function(t){var n=o.get(t);pX(n.oldSeries,n.newSeries,e)}))}// Reset
R(n.updatedSeries,(function(t){// Reset;
t[Dg]&&(t[Dg]=!1)}))}// Save all series of current update. Not only the updated one.
for(var a=t.getSeries(),s=i.oldSeries=[],l=i.oldDataGroupIds=[],u=i.oldData=[],h=0;h<a.length;h++){var c=a[h].getData();// Only save the data that can have transition.
// Avoid large data costing too much extra memory
c.count()<1e4&&(s.push(a[h]),l.push(a[h].get("dataGroupId")),u.push(c))}}))})),// label layout
// chart.setOption({
//     series: {
//         labelLayout: { hideOverlap: true }
//     }
// })
Wm((function(t){t.registerUpdateLifecycle("series:beforeupdate",(function(t,e,n){// TODO api provide an namespace that can save stuff per instance
var i=$b(e).labelManager;i||(i=$b(e).labelManager=new Kb),i.clearLabels()})),t.registerUpdateLifecycle("series:layoutlabels",(function(t,e,n){var i=$b(e).labelManager;n.updatedSeries.forEach((function(t){i.addLabelsOfSeries(e.getViewOfSeriesModel(t))})),i.updateLayoutConfig(e),i.layout(e),i.processLabelsOverall()}))}))}}}));
